-- blurys net
game["Run Service"].RenderStepped:connect(function()
    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
    settings().Physics.AllowSleep = false
    setsimulationradius(math.huge*math.huge,math.huge*math.huge)
end)

spawn(function()
while true do
settings().Physics.AllowSleep = false
game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1/0)
sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", 1/0)
setsimulationradius(1/0)
game:GetService("RunService").Heartbeat:wait()
end
end)

game["Run Service"].RenderStepped:connect(function()
    settings().Physics.AllowSleep = false
    setsimulationradius(math.huge*math.huge,math.huge*math.huge)
end)
local Network = coroutine.create(function()
while true do
game:GetService("RunService").Heartbeat:Wait()
settings().Physics.AllowSleep = false
sethiddenproperty(game.Players.LocalPlayer,"MaximumSimulationRadius",(7.0000001355554e+31)*7.0000001355554e+31)
sethiddenproperty(game.Players.LocalPlayer,"SimulationRadius",(7.0000001355554e+31)*7.0000001355554e+31)
end
end)
local NetworkAccess = coroutine.create(function()
settings().Physics.AllowSleep = false
while true do game:GetService("RunService").RenderStepped:Wait()
for _,Players in next, game:GetService("Players"):GetChildren() do
if Players ~= game:GetService("Players").LocalPlayer then
Players.MaximumSimulationRadius = 0.1 Players.SimulationRadius = 0 end end
coroutine.resume(NetworkAccess)
_G.sim = {}
local set = setsimulationradius or set_simulation_radius

getgenv().setsim = function(maxsimvalue, simvalue)
	set(simvalue, maxsimvalue)
	local s = pcall(function()
		local maxsim = game.Players.LocalPlayer.MaximumSimulationRadius
		local sim = game.Players.LocalPlayer.SimulationRadius
	end)
	if s then
		table.insert(_G.sim, {game.Players.LocalPlayer, "MaximumSimulationRadius", 1000})
		table.insert(_G.sim, {game.Players.LocalPlayer, "SimulationRadius", 1000})
	end
end

getgenv().setothersim = function(maxsimvalue, simvalue)
	local Players = game.Players:GetChildren()
	for i,v in pairs(Players) do
		if v ~= game.Players.LocalPlayer then
		    setscriptable(v, "MaximumSimulationRadius", true)
	        setscriptable(v, "SimulationRadius", true)
	        v.MaximumSimulationRadius = maxsimvalue
	        v.SimulationRadius = simvalue
			local s = pcall(function()
				local maxsim = v.MaximumSimulationRadius
				local sim = v.SimulationRadius
			end)
			if s then
				table.insert(_G.sim, {v, "MaximumSimulationRadius", 1000})
				table.insert(_G.sim, {v, "SimulationRadius", 1000})
			end
		end
	end
end

getgenv().findwithintable = function(o, p)
	for i, v in pairs(_G.sim) do
		if table.find(v, o) and table.find(v, p) then
			return v
		end
	end
	return nil
end

local mt = getrawmetatable(game)
setreadonly(mt, false)
old = mt.__index

mt.__index = newcclosure(function(o, p)
	local t = findwithintable(o, p)
	if t ~= nil then
		return t[3]
	end
	
	return old(o, p)
end)

local NetworkAccess = coroutine.create(function()
	Frame_Speed=1/60;ArtificialHB=Instance.new("BindableEvent",workspace)ArtificialHB.Name="ArtificialHB"workspace:WaitForChild("ArtificialHB")frame=Frame_Speed;tf=0;allowframeloss=false;tossremainder=false;lastframe=tick()workspace.ArtificialHB:Fire()game:GetService("RunService").Heartbeat:connect(function(a,b)tf=tf+a;if tf>=frame then if allowframeloss then script.ArtificialHB:Fire()lastframe=tick()else for c=1,math.floor(tf/frame)do workspace.ArtificialHB:Fire()end;lastframe=tick()end;if tossremainder then tf=0 else tf=tf-frame*math.floor(tf/frame)end end end)function swait(d)if d==0 or d==nil then ArtificialHB.Event:wait()else for c=1,d do ArtificialHB.Event:wait(d)end end end
	local a=game.Players:GetChildren()for b,c in pairs(a)do if c~=game.Players.LocalPlayer then setscriptable(c,"MaximumSimulationRadius",true)setscriptable(c,"SimulationRadius",true)c.MaximumSimulationRadius=0.1;c.SimulationRadius=0 end end
	local set = setsimulationradius or set_simulation_radius
    setsim(math.huge, math.huge)
    setothersim(0.1, 0)
	spawn(function()
		while true do
			settings().Physics.AllowSleep = false
			game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
			swait()
		end
	end)
end)
coroutine.resume(NetworkAccess)

spawn(function()
while true do
settings().Physics.AllowSleep = false
game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1/0)
sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", 1/0)
setsimulationradius(1/0)
game:GetService("RunService").Heartbeat:wait()
end end) end end)
--[[
net by blurry ok 
]]--

if syn then
local mt = getrawmetatable(game)
make_writeable(mt)

local namecall = mt.namecall

mt.namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if method == "GetHttp" then
      return
    end
    return namecall(self, table.unpack(args))
end)

local mt = getrawmetatable(game)
make_writeable(mt)

local namecall = mt.namecall

mt.namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if method == "GetObjects" then
      return
    end
    return namecall(self, table.unpack(args))
end)
print("work")
else
print("http spy cant be disabled cuz you use some shitty exploit")
end


local ScreenGui = Instance.new("ScreenGui")
local Main = Instance.new("Frame")
local Title = Instance.new("TextLabel")
local HUB = Instance.new("TextLabel")
local FEVer = Instance.new("TextLabel")
local UnderlineTop = Instance.new("Frame")
local TabButtons = Instance.new("Frame")
local Hometab = Instance.new("TextButton")
local TabPadding = Instance.new("UIPadding")
local TabList = Instance.new("UIListLayout")
local ScriptsButton = Instance.new("TextButton")
local Credits = Instance.new("TextButton")
local Reanimate = Instance.new("TextButton")
local Exit = Instance.new("TextButton")
local FrameHolder = Instance.new("Frame")
local Scripts = Instance.new("ScrollingFrame")
local UIPadding = Instance.new("UIPadding")
local Button = Instance.new("TextButton")
local UnderlineButton = Instance.new("Frame")
local UIGridLayout = Instance.new("UIGridLayout")
local Button_2 = Instance.new("TextButton")
local UnderlineButton_2 = Instance.new("Frame")
local Button_3 = Instance.new("TextButton")
local UnderlineButton_3 = Instance.new("Frame")
local Button_4 = Instance.new("TextButton")
local UnderlineButton_4 = Instance.new("Frame")
local Button_5 = Instance.new("TextButton")
local UnderlineButton_5 = Instance.new("Frame")
local Button_6 = Instance.new("TextButton")
local UnderlineButton_6 = Instance.new("Frame")
local Button_7 = Instance.new("TextButton")
local UnderlineButton_7 = Instance.new("Frame")
local Button_8 = Instance.new("TextButton")
local UnderlineButton_8 = Instance.new("Frame")
local Button_9 = Instance.new("TextButton")
local UnderlineButton_9 = Instance.new("Frame")
local Button_10 = Instance.new("TextButton")
local UnderlineButton_10 = Instance.new("Frame")
local Button_11 = Instance.new("TextButton")
local UnderlineButton_11 = Instance.new("Frame")
local Button_12 = Instance.new("TextButton")
local UnderlineButton_12 = Instance.new("Frame")
local Button_13 = Instance.new("TextButton")
local UnderlineButton_13 = Instance.new("Frame")
local Button_14 = Instance.new("TextButton")
local UnderlineButton_14 = Instance.new("Frame")
local Button_15 = Instance.new("TextButton")
local UnderlineButton_15 = Instance.new("Frame")
local Button_16 = Instance.new("TextButton")
local UnderlineButton_16 = Instance.new("Frame")
local Button_17 = Instance.new("TextButton")
local UnderlineButton_17 = Instance.new("Frame")
local Button_18 = Instance.new("TextButton")
local UnderlineButton_18 = Instance.new("Frame")
local Button_19 = Instance.new("TextButton")
local UnderlineButton_19 = Instance.new("Frame")
local Home = Instance.new("Frame")
local Title2 = Instance.new("TextLabel")
local HUB2 = Instance.new("TextLabel")
local FEVer1 = Instance.new("TextLabel")
local FEVer1_2 = Instance.new("TextLabel")
local Credits_2 = Instance.new("Frame")
local TextLabel = Instance.new("TextLabel")
local TextLabel_2 = Instance.new("TextLabel")
local TextLabel_3 = Instance.new("TextLabel")
local TextLabel_4 = Instance.new("TextLabel")
local TextLabel_5 = Instance.new("TextLabel")


--Properties:

ScreenGui.Parent = game.CoreGui

ScreenGui.ResetOnSpawn = false

Main.Name = "Main"
Main.Parent = ScreenGui
Main.AnchorPoint = Vector2.new(0.5, 0.5)
Main.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
Main.BorderSizePixel = 0
Main.ClipsDescendants = true
Main.Position = UDim2.new(0.5, 0, 0.5, 0)
Main.Size = UDim2.new(0, 513, 0, 259)

Title.Name = "Title"
Title.Parent = Main
Title.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Title.BorderSizePixel = 0
Title.Size = UDim2.new(0, 514, 0, 26)
Title.Font = Enum.Font.Gotham
Title.Text = "  SEX"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 14.000
Title.TextXAlignment = Enum.TextXAlignment.Left

HUB.Name = "HUB"
HUB.Parent = Title
HUB.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
HUB.BackgroundTransparency = 1.000
HUB.Position = UDim2.new(0.00972762611, 0, -0.0145169776, 0)
HUB.Size = UDim2.new(0, 91, 0, 26)
HUB.Font = Enum.Font.Gotham
HUB.Text = "HUB"
HUB.TextColor3 = Color3.fromRGB(255, 170, 127)
HUB.TextSize = 14.000

FEVer.Name = "FEVer"
FEVer.Parent = Title
FEVer.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
FEVer.BackgroundTransparency = 1.000
FEVer.Size = UDim2.new(0, 514, 0, 26)
FEVer.Font = Enum.Font.Gotham
FEVer.Text = "FE Version"
FEVer.TextColor3 = Color3.fromRGB(255, 255, 255)
FEVer.TextSize = 14.000

UnderlineTop.Name = "UnderlineTop"
UnderlineTop.Parent = Title
UnderlineTop.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineTop.BorderSizePixel = 0
UnderlineTop.Position = UDim2.new(-5.93727201e-08, 0, 1, 0)
UnderlineTop.Size = UDim2.new(1.00000012, 0, 0, 1)

TabButtons.Name = "TabButtons"
TabButtons.Parent = Main
TabButtons.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
TabButtons.BackgroundTransparency = 0.800
TabButtons.BorderSizePixel = 0
TabButtons.Position = UDim2.new(0, 0, 0.104247101, 0)
TabButtons.Size = UDim2.new(0, 96, 0, 231)

Hometab.Name = "Hometab"
Hometab.Parent = TabButtons
Hometab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Hometab.BorderSizePixel = 0
Hometab.Position = UDim2.new(0.0495833308, 0, 0.0113960113, 0)
Hometab.Size = UDim2.new(0, 88, 0, 25)
Hometab.AutoButtonColor = false
Hometab.Font = Enum.Font.Gotham
Hometab.Text = "Home"
Hometab.TextColor3 = Color3.fromRGB(255, 255, 255)
Hometab.TextSize = 14.000
Hometab.MouseButton1Down:Connect(function()
	if Credits_2.Position == UDim2.new(0,0,0,0) then
		Credits_2:TweenPosition(UDim2.new(0,0,-1,0))
		wait(0.8)
		Home:TweenPosition(UDim2.new(0,0,0,0))
	elseif Scripts_2.Position == UDim2.new(0,0,0,0) then
		Scripts_2:TweenPosition(UDim2.new(0,0,-1,0))
		wait(0.8)
		Home:TweenPosition(UDim2.new(0,0,0,0))
	end
end)


TabPadding.Name = "TabPadding"
TabPadding.Parent = TabButtons
TabPadding.PaddingBottom = UDim.new(0, 5)
TabPadding.PaddingLeft = UDim.new(0, 5)
TabPadding.PaddingRight = UDim.new(0, 5)
TabPadding.PaddingTop = UDim.new(0, 5)

TabList.Name = "TabList"
TabList.Parent = TabButtons
TabList.SortOrder = Enum.SortOrder.LayoutOrder
TabList.Padding = UDim.new(0, 5)

ScriptsButton.Name = "ScriptsButton"
ScriptsButton.Parent = TabButtons
ScriptsButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
ScriptsButton.BorderSizePixel = 0
ScriptsButton.Position = UDim2.new(0.0495833308, 0, 0.0113960113, 0)
ScriptsButton.Size = UDim2.new(0, 88, 0, 25)
ScriptsButton.AutoButtonColor = false
ScriptsButton.Font = Enum.Font.Gotham
ScriptsButton.Text = "Scripts"
ScriptsButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ScriptsButton.TextSize = 14.000
ScriptsButton.MouseButton1Down:Connect(function()
	if Home.Position == UDim2.new(0,0,0,0) then
		Home:TweenPosition(UDim2.new(0,0,-1,0))
		wait(0.8)
		Scripts:TweenPosition(UDim2.new(0,0,0,0))
	elseif Credits_2.Position == UDim2.new(0,0,0,0) then
		Credits_2:TweenPosition(UDim2.new(0,0,-1,0))
		wait(0.8)
		Scripts:TweenPosition(UDim2.new(0,0,0,0))
	end
end)

Credits.Name = "Credits"
Credits.Parent = TabButtons
Credits.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Credits.BorderSizePixel = 0
Credits.Position = UDim2.new(0.0495833308, 0, 0.0113960113, 0)
Credits.Size = UDim2.new(0, 88, 0, 25)
Credits.AutoButtonColor = false
Credits.Font = Enum.Font.Gotham
Credits.Text = "Credits"
Credits.TextColor3 = Color3.fromRGB(255, 255, 255)
Credits.TextSize = 14.000
Credits.MouseButton1Down:Connect(function()
	if Scripts.Position == UDim2.new(0,0,0,0) then
		Scripts:TweenPosition(UDim2.new(0,0,-1,0))
		wait(0.8)
		Credits_2:TweenPosition(UDim2.new(0,0,0,0))
	elseif Home.Position == UDim2.new(0,0,0,0) then
		Home:TweenPosition(UDim2.new(0,0,-1,0))
		wait(0.8)
		Credits_2:TweenPosition(UDim2.new(0,0,0,0))
	end
end)

Reanimate.Name = "Reanimate"
Reanimate.Parent = TabButtons
Reanimate.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Reanimate.BorderSizePixel = 0
Reanimate.Position = UDim2.new(0.0495833308, 0, 0.0113960113, 0)
Reanimate.Size = UDim2.new(0, 88, 0, 25)
Reanimate.AutoButtonColor = false
Reanimate.Font = Enum.Font.Gotham
Reanimate.Text = "Reanimate"
Reanimate.TextColor3 = Color3.fromRGB(255, 255, 255)
Reanimate.TextSize = 14.000
Reanimate.MouseButton1Down:connect(function()

	if _G.homebrewbest ~= true then
		_G.homebrewbest = true
		coroutine.wrap(function()
			game["Run Service"].RenderStepped:connect(function()
				settings().Physics.AllowSleep = false
				setsimulationradius(math.huge*math.huge,math.huge*math.huge)
			end)
		end)()
	end



	local function nocloloop()
		if  game.Players.LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then
			for _, child in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
				if child:IsA("BasePart") and child.CanCollide == true then
					child.CanCollide = false
				end
			end
		end
	end
	Noclipping = game:GetService('RunService').Stepped:connect(nocloloop)




	local Player = game.Players.LocalPlayer
	local Character = Player.Character
	if Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then

		Character.RightUpperArm["RightShoulder"]:Destroy()
		Character.LeftUpperArm["LeftShoulder"]:Destroy()
		Character.LeftUpperLeg["LeftHip"]:Destroy()
		Character.RightUpperLeg["RightHip"]:Destroy()
	else
		Character.Torso["Right Shoulder"]:Destroy()
		Character.Torso["Left Shoulder"]:Destroy()
		Character.Torso["Right Hip"]:Destroy()
		Character.Torso["Left Hip"]:Destroy()
	end
	local Leftarm = Character:FindFirstChild("Left Arm") or Character:FindFirstChild("LeftUpperArm")
	local Rightarm = Character:FindFirstChild("Right Arm") or Character:FindFirstChild("RightUpperArm")
	local Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")
	local Leftleg = Character:FindFirstChild("Left Leg") or Character:FindFirstChild("LeftUpperLeg")
	local Rightleg = Character:FindFirstChild("Right Leg") or Character:FindFirstChild("RightUpperLeg")
	local rig = game:GetObjects("rbxassetid://5508993607")[1]

	rig.Parent = Character
	rig:MoveTo(game.Players.LocalPlayer.Character.HumanoidRootPart.Position)
	rig.Humanoid:Move(game.Players.LocalPlayer.Character.Humanoid.MoveDirection, false)
	rig.Torso.Anchored = false

	if Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then


		alignPosition = Instance.new("AlignPosition",Leftarm)
		alignPosition.RigidityEnabled = false
		alignPosition.ApplyAtCenterOfMass = false
		alignPosition.MaxForce = 9e9
		alignPosition.MaxVelocity = 9e99
		alignPosition.ReactionForceEnabled = false
		alignPosition.Responsiveness = 9e99
		--alignPosition.Parent = Leftarm
		alignOr = Instance.new("AlignOrientation",Leftarm)
		alignOr.MaxTorque = 9e99
		alignOr.MaxAngularVelocity = 9e99
		alignOr.PrimaryAxisOnly = false
		alignOr.ReactionTorqueEnabled = false
		alignOr.Responsiveness = 200
		alignOr.RigidityEnabled = false
		--alignOr.Parent = Leftarm
		--Rightarm
		alignPosition = Instance.new("AlignPosition",Rightarm)
		alignPosition.RigidityEnabled = false
		alignPosition.ApplyAtCenterOfMass = false
		alignPosition.MaxForce = 9e9
		alignPosition.MaxVelocity = 9e99
		alignPosition.ReactionForceEnabled = false
		alignPosition.Responsiveness = 9e99
		--alignPosition.Parent = Rightarm
		alignOr = Instance.new("AlignOrientation",Rightarm)
		alignOr.MaxTorque = 9e99
		alignOr.MaxAngularVelocity = 9e99
		alignOr.PrimaryAxisOnly = false
		alignOr.ReactionTorqueEnabled = false
		alignOr.Responsiveness = 200
		alignOr.RigidityEnabled = false
		--alignOr.Parent = Rightarm
		--Torso
		alignPosition = Instance.new("AlignPosition",Torso)
		alignPosition.RigidityEnabled = false
		alignPosition.ApplyAtCenterOfMass = false
		alignPosition.MaxForce = 9e9
		alignPosition.MaxVelocity = 9e99
		alignPosition.ReactionForceEnabled = false
		alignPosition.Responsiveness = 9e99
		--alignPosition.Parent = Torso
		alignOr = Instance.new("AlignOrientation",Torso)
		alignOr.MaxTorque = 9e99
		alignOr.MaxAngularVelocity = 9e99
		alignOr.PrimaryAxisOnly = false
		alignOr.ReactionTorqueEnabled = false
		alignOr.Responsiveness = 200
		alignOr.RigidityEnabled = false
		--alignOr.Parent = Torso
		--LeftLeg
		alignPosition = Instance.new("AlignPosition",Leftleg)
		alignPosition.RigidityEnabled = false
		alignPosition.ApplyAtCenterOfMass = false
		alignPosition.MaxForce = 9e9
		alignPosition.MaxVelocity = 9e99
		alignPosition.ReactionForceEnabled = false
		alignPosition.Responsiveness = 9e99
		alignPosition.Parent = Leftleg
		alignOr = Instance.new("AlignOrientation",Leftleg)
		alignOr.MaxTorque = 9e99
		alignOr.MaxAngularVelocity = 9e99
		alignOr.PrimaryAxisOnly = false
		alignOr.ReactionTorqueEnabled = false
		alignOr.Responsiveness = 200
		alignOr.RigidityEnabled = false
		--alignOr.Parent = Leftleg
		--Rightleg
		alignPosition = Instance.new("AlignPosition",Rightleg)
		alignPosition.RigidityEnabled = false
		alignPosition.ApplyAtCenterOfMass = false
		alignPosition.MaxForce = 9e9
		alignPosition.MaxVelocity = 9e99
		alignPosition.ReactionForceEnabled = false
		alignPosition.Responsiveness = 9e99
		alignPosition.Parent = Rightleg
		alignOr = Instance.new("AlignOrientation",Rightleg)
		alignOr.MaxTorque = 9e99
		alignOr.MaxAngularVelocity = 9e99
		alignOr.PrimaryAxisOnly = false
		alignOr.ReactionTorqueEnabled = false
		alignOr.Responsiveness = 200
		alignOr.RigidityEnabled = false
		--alignOr.Parent = Rightleg
		a0 = Instance.new("Attachment",Rightarm)
		a0.Position = Vector3.new(0, -0.4, 0)
		a1 = Instance.new("Attachment",rig["Right Arm"])
		a2 = Instance.new("Attachment",Rightarm)
		Rightarm.AlignPosition.Attachment0 = a0
		Rightarm.AlignPosition.Attachment1 = a1
		Rightarm.AlignOrientation.Attachment0 = a2
		Rightarm.AlignOrientation.Attachment1 = a1
		a0 = Instance.new("Attachment",Leftarm)
		a0.Position = Vector3.new(0, -0.4, 0)
		a1 = Instance.new("Attachment",rig["Left Arm"])
		a2 = Instance.new("Attachment",Leftarm)
		Leftarm.AlignPosition.Attachment0 = a0
		Leftarm.AlignPosition.Attachment1 = a1
		Leftarm.AlignOrientation.Attachment0 = a2
		Leftarm.AlignOrientation.Attachment1 = a1
		a0 = Instance.new("Attachment",Torso)
		a0.Position = Vector3.new(0, -0.2, 0)
		a1 = Instance.new("Attachment",rig["Torso"])
		a2 = Instance.new("Attachment",Torso)
		Torso.AlignPosition.Attachment0 = a0
		Torso.AlignPosition.Attachment1 = a1
		Torso.AlignOrientation.Attachment0 = a2
		Torso.AlignOrientation.Attachment1 = a1
		a0 = Instance.new("Attachment",Leftleg)
		a0.Position = Vector3.new(0, -0.5, 0)

		a1 = Instance.new("Attachment",rig["Left Leg"])
		a2 = Instance.new("Attachment",Leftleg)
		Leftleg.AlignPosition.Attachment0 = a0
		Leftleg.AlignPosition.Attachment1 = a1
		Leftleg.AlignOrientation.Attachment0 = a2
		Leftleg.AlignOrientation.Attachment1 = a1
		a0 = Instance.new("Attachment",Rightleg)
		a0.Position = Vector3.new(0, -0.5, 0)

		a1 = Instance.new("Attachment",rig["Right Leg"])
		a2 = Instance.new("Attachment",Rightleg)
		Rightleg.AlignPosition.Attachment0 = a0
		Rightleg.AlignPosition.Attachment1 = a1
		Rightleg.AlignOrientation.Attachment0 = a2
		Rightleg.AlignOrientation.Attachment1 = a1

	else 

		alignPosition = Instance.new("AlignPosition",Leftarm)
		alignPosition.RigidityEnabled = false
		alignPosition.ApplyAtCenterOfMass = false
		alignPosition.MaxForce = 9e9
		alignPosition.MaxVelocity = 9e99
		alignPosition.ReactionForceEnabled = false
		alignPosition.Responsiveness = 9e99
		--alignPosition.Parent = Leftarm
		alignOr = Instance.new("AlignOrientation",Leftarm)
		alignOr.MaxTorque = 9e99
		alignOr.MaxAngularVelocity = 9e99
		alignOr.PrimaryAxisOnly = false
		alignOr.ReactionTorqueEnabled = false
		alignOr.Responsiveness = 200
		alignOr.RigidityEnabled = false
		--alignOr.Parent = Leftarm
		--Rightarm
		alignPosition = Instance.new("AlignPosition",Rightarm)
		alignPosition.RigidityEnabled = false
		alignPosition.ApplyAtCenterOfMass = false
		alignPosition.MaxForce = 9e9
		alignPosition.MaxVelocity = 9e99
		alignPosition.ReactionForceEnabled = false
		alignPosition.Responsiveness = 9e99
		--alignPosition.Parent = Rightarm
		alignOr = Instance.new("AlignOrientation",Rightarm)
		alignOr.MaxTorque = 9e99
		alignOr.MaxAngularVelocity = 9e99
		alignOr.PrimaryAxisOnly = false
		alignOr.ReactionTorqueEnabled = false
		alignOr.Responsiveness = 200
		alignOr.RigidityEnabled = false
		--alignOr.Parent = Rightarm
		--Torso
		alignPosition = Instance.new("AlignPosition",Torso)
		alignPosition.RigidityEnabled = false
		alignPosition.ApplyAtCenterOfMass = false
		alignPosition.MaxForce = 9e9
		alignPosition.MaxVelocity = 9e99
		alignPosition.ReactionForceEnabled = false
		alignPosition.Responsiveness = 9e99
		--alignPosition.Parent = Torso
		alignOr = Instance.new("AlignOrientation",Torso)
		alignOr.MaxTorque = 9e99
		alignOr.MaxAngularVelocity = 9e99
		alignOr.PrimaryAxisOnly = false
		alignOr.ReactionTorqueEnabled = false
		alignOr.Responsiveness = 200
		alignOr.RigidityEnabled = false
		--alignOr.Parent = Torso
		--LeftLeg
		alignPosition = Instance.new("AlignPosition",Leftleg)
		alignPosition.RigidityEnabled = false
		alignPosition.ApplyAtCenterOfMass = false
		alignPosition.MaxForce = 9e9
		alignPosition.MaxVelocity = 9e99
		alignPosition.ReactionForceEnabled = false
		alignPosition.Responsiveness = 9e99
		alignPosition.Parent = Leftleg
		alignOr = Instance.new("AlignOrientation",Leftleg)
		alignOr.MaxTorque = 9e99
		alignOr.MaxAngularVelocity = 9e99
		alignOr.PrimaryAxisOnly = false
		alignOr.ReactionTorqueEnabled = false
		alignOr.Responsiveness = 200
		alignOr.RigidityEnabled = false
		--alignOr.Parent = Leftleg
		--Rightleg
		alignPosition = Instance.new("AlignPosition",Rightleg)
		alignPosition.RigidityEnabled = false
		alignPosition.ApplyAtCenterOfMass = false
		alignPosition.MaxForce = 9e9
		alignPosition.MaxVelocity = 9e99
		alignPosition.ReactionForceEnabled = false
		alignPosition.Responsiveness = 9e99
		alignPosition.Parent = Rightleg
		alignOr = Instance.new("AlignOrientation",Rightleg)
		alignOr.MaxTorque = 9e99
		alignOr.MaxAngularVelocity = 9e99
		alignOr.PrimaryAxisOnly = false
		alignOr.ReactionTorqueEnabled = false
		alignOr.Responsiveness = 200
		alignOr.RigidityEnabled = false
		--alignOr.Parent = Rightleg
		a0 = Instance.new("Attachment",Rightarm)
		a1 = Instance.new("Attachment",rig["Right Arm"])
		a2 = Instance.new("Attachment",Rightarm)
		Rightarm.AlignPosition.Attachment0 = a0
		Rightarm.AlignPosition.Attachment1 = a1
		Rightarm.AlignOrientation.Attachment0 = a2
		Rightarm.AlignOrientation.Attachment1 = a1
		a0 = Instance.new("Attachment",Leftarm)
		a1 = Instance.new("Attachment",rig["Left Arm"])
		a2 = Instance.new("Attachment",Leftarm)
		Leftarm.AlignPosition.Attachment0 = a0
		Leftarm.AlignPosition.Attachment1 = a1
		Leftarm.AlignOrientation.Attachment0 = a2
		Leftarm.AlignOrientation.Attachment1 = a1
		a0 = Instance.new("Attachment",Torso)
		a1 = Instance.new("Attachment",rig["Torso"])
		a2 = Instance.new("Attachment",Torso)
		Torso.AlignPosition.Attachment0 = a0
		Torso.AlignPosition.Attachment1 = a1
		Torso.AlignOrientation.Attachment0 = a2
		Torso.AlignOrientation.Attachment1 = a1
		a0 = Instance.new("Attachment",Leftleg)

		a1 = Instance.new("Attachment",rig["Left Leg"])
		a2 = Instance.new("Attachment",Leftleg)
		Leftleg.AlignPosition.Attachment0 = a0
		Leftleg.AlignPosition.Attachment1 = a1
		Leftleg.AlignOrientation.Attachment0 = a2
		Leftleg.AlignOrientation.Attachment1 = a1
		a0 = Instance.new("Attachment",Rightleg)

		a1 = Instance.new("Attachment",rig["Right Leg"])
		a2 = Instance.new("Attachment",Rightleg)
		Rightleg.AlignPosition.Attachment0 = a0
		Rightleg.AlignPosition.Attachment1 = a1
		Rightleg.AlignOrientation.Attachment0 = a2
		Rightleg.AlignOrientation.Attachment1 = a1
	end

	rig.HumanoidRootPart.Anchored = false
	spawn(function()
		while true do
			wait()
			if Character:FindFirstChild("Humanoid").Health == 0 then
				Character:BreakJoints()
				rig:BreakJoints()
			end
		end
	end)

	function nocol(same)
		for i,v in pairs(Character:GetDescendants()) do
			if v:IsA("BasePart") then
				HILOL=Instance.new("NoCollisionConstraint",v)
				HILOL.Part0 = v
				HILOL.Part1 = same
			end
		end
	end
	for i,v in pairs(rig:GetDescendants()) do
		if v:IsA("BasePart") then
			nocol(v)
		end
	end


	spawn(function()


		local Figure = rig.Animate.Parent
		local Torso = Figure:WaitForChild("Torso")
		local RightShoulder = Torso:WaitForChild("Right Shoulder")
		local LeftShoulder = Torso:WaitForChild("Left Shoulder")
		local RightHip = Torso:WaitForChild("Right Hip")
		local LeftHip = Torso:WaitForChild("Left Hip")
		local Neck = Torso:WaitForChild("Neck")
		local Humanoid = Figure:WaitForChild("Humanoid")
		local pose = "Standing"

		local currentAnim = ""
		local currentAnimInstance = nil
		local currentAnimTrack = nil
		local currentAnimKeyframeHandler = nil
		local currentAnimSpeed = 1.0
		local animTable = {}
		local animNames = { 
			idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
			walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
			run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
			jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
			fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
			climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
			sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
			toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
			toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
				--				{ id = "slash.xml", weight = 10 } 
			},
			toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
			wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
			point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
			dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
			dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
			dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
			laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
			cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
		}
		local dances = {"dance1", "dance2", "dance3"}

		-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
		local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

		function configureAnimationSet(name, fileList)
			if (animTable[name] ~= nil) then
				for _, connection in pairs(animTable[name].connections) do
					connection:disconnect()
				end
			end
			animTable[name] = {}
			animTable[name].count = 0
			animTable[name].totalWeight = 0	
			animTable[name].connections = {}

			-- check for config values
			local config = rig.Animate:FindFirstChild(name)
			if (config ~= nil) then
				--		print("Loading anims " .. name)
				table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
				local idx = 1
				for _, childPart in pairs(config:GetChildren()) do
					if (childPart:IsA("Animation")) then
						table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
						animTable[name][idx] = {}
						animTable[name][idx].anim = childPart
						local weightObject = childPart:FindFirstChild("Weight")
						if (weightObject == nil) then
							animTable[name][idx].weight = 1
						else
							animTable[name][idx].weight = weightObject.Value
						end
						animTable[name].count = animTable[name].count + 1
						animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
						--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
						idx = idx + 1
					end
				end
			end

			-- fallback to defaults
			if (animTable[name].count <= 0) then
				for idx, anim in pairs(fileList) do
					animTable[name][idx] = {}
					animTable[name][idx].anim = Instance.new("Animation")
					animTable[name][idx].anim.Name = name
					animTable[name][idx].anim.AnimationId = anim.id
					animTable[name][idx].weight = anim.weight
					animTable[name].count = animTable[name].count + 1
					animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
					--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
				end
			end
		end

		-- Setup animation objects
		function scriptChildModified(child)
			local fileList = animNames[child.Name]
			if (fileList ~= nil) then
				configureAnimationSet(child.Name, fileList)
			end	
		end

		rig.Animate.ChildAdded:connect(scriptChildModified)
		rig.Animate.ChildRemoved:connect(scriptChildModified)
		rig.HumanoidRootPart.Anchored = false

		for name, fileList in pairs(animNames) do 
			configureAnimationSet(name, fileList)
		end	

		-- ANIMATION

		-- declarations
		local toolAnim = "None"
		local toolAnimTime = 0

		local jumpAnimTime = 0
		local jumpAnimDuration = 0.3

		local toolTransitionTime = 0.1
		local fallTransitionTime = 0.3
		local jumpMaxLimbVelocity = 0.75

		-- functions

		function stopAllAnimations()
			local oldAnim = currentAnim

			-- return to idle if finishing an emote
			if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
				oldAnim = "idle"
			end

			currentAnim = ""
			currentAnimInstance = nil
			if (currentAnimKeyframeHandler ~= nil) then
				currentAnimKeyframeHandler:disconnect()
			end

			if (currentAnimTrack ~= nil) then
				currentAnimTrack:Stop()
				currentAnimTrack:Destroy()
				currentAnimTrack = nil
			end
			return oldAnim
		end

		function setAnimationSpeed(speed)
			if speed ~= currentAnimSpeed then
				currentAnimSpeed = speed
				currentAnimTrack:AdjustSpeed(currentAnimSpeed)
			end
		end

		function keyFrameReachedFunc(frameName)
			if (frameName == "End") then

				local repeatAnim = currentAnim
				-- return to idle if finishing an emote
				if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
					repeatAnim = "idle"
				end

				local animSpeed = currentAnimSpeed
				playAnimation(repeatAnim, 0.0, Humanoid)
				setAnimationSpeed(animSpeed)
			end
		end

		-- Preload animations
		function playAnimation(animName, transitionTime, humanoid) 

			local roll = math.random(1, animTable[animName].totalWeight) 
			local origRoll = roll
			local idx = 1
			while (roll > animTable[animName][idx].weight) do
				roll = roll - animTable[animName][idx].weight
				idx = idx + 1
			end
			--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
			local anim = animTable[animName][idx].anim

			-- switch animation		
			if (anim ~= currentAnimInstance) then

				if (currentAnimTrack ~= nil) then
					currentAnimTrack:Stop(transitionTime)
					currentAnimTrack:Destroy()
				end

				currentAnimSpeed = 1.0

				-- load it to the humanoid; get AnimationTrack
				currentAnimTrack = humanoid:LoadAnimation(anim)
				currentAnimTrack.Priority = Enum.AnimationPriority.Core

				-- play the animation
				currentAnimTrack:Play(transitionTime)
				currentAnim = animName
				currentAnimInstance = anim

				-- set up keyframe name triggers
				if (currentAnimKeyframeHandler ~= nil) then
					currentAnimKeyframeHandler:disconnect()
				end
				currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)

			end

		end

		-------------------------------------------------------------------------------------------
		-------------------------------------------------------------------------------------------

		local toolAnimName = ""
		local toolAnimTrack = nil
		local toolAnimInstance = nil
		local currentToolAnimKeyframeHandler = nil

		function toolKeyFrameReachedFunc(frameName)
			if (frameName == "End") then
				--		print("Keyframe : ".. frameName)	
				playToolAnimation(toolAnimName, 0.0, Humanoid)
			end
		end


		function playToolAnimation(animName, transitionTime, humanoid, priority)	 

			local roll = math.random(1, animTable[animName].totalWeight) 
			local origRoll = roll
			local idx = 1
			while (roll > animTable[animName][idx].weight) do
				roll = roll - animTable[animName][idx].weight
				idx = idx + 1
			end
			--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
			local anim = animTable[animName][idx].anim

			if (toolAnimInstance ~= anim) then

				if (toolAnimTrack ~= nil) then
					toolAnimTrack:Stop()
					toolAnimTrack:Destroy()
					transitionTime = 0
				end

				-- load it to the humanoid; get AnimationTrack
				toolAnimTrack = humanoid:LoadAnimation(anim)
				if priority then
					toolAnimTrack.Priority = priority
				end

				-- play the animation
				toolAnimTrack:Play(transitionTime)
				toolAnimName = animName
				toolAnimInstance = anim

				currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
			end
		end

		function stopToolAnimations()
			local oldAnim = toolAnimName

			if (currentToolAnimKeyframeHandler ~= nil) then
				currentToolAnimKeyframeHandler:disconnect()
			end

			toolAnimName = ""
			toolAnimInstance = nil
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				toolAnimTrack = nil
			end


			return oldAnim
		end

		-------------------------------------------------------------------------------------------
		-------------------------------------------------------------------------------------------


		function onRunning(speed)
			if speed > 0.01 then
				playAnimation("walk", 0.1, Humanoid)
				if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
					setAnimationSpeed(speed / 14.5)
				end
				pose = "Running"
			else
				if emoteNames[currentAnim] == nil then
					playAnimation("idle", 0.1, Humanoid)
					pose = "Standing"
				end
			end
		end

		function onDied()
			pose = "Dead"
		end

		function onJumping()
			playAnimation("jump", 0.1, Humanoid)
			jumpAnimTime = jumpAnimDuration
			pose = "Jumping"
		end

		function onClimbing(speed)
			playAnimation("climb", 0.1, Humanoid)
			setAnimationSpeed(speed / 12.0)
			pose = "Climbing"
		end

		function onGettingUp()
			pose = "GettingUp"
		end

		function onFreeFall()
			if (jumpAnimTime <= 0) then
				playAnimation("fall", fallTransitionTime, Humanoid)
			end
			pose = "FreeFall"
		end

		function onFallingDown()
			pose = "FallingDown"
		end

		function onSeated()
			pose = "Seated"
		end

		function onPlatformStanding()
			pose = "PlatformStanding"
		end

		function onSwimming(speed)
			if speed > 0 then
				pose = "Running"
			else
				pose = "Standing"
			end
		end

		function getTool()	
			for _, kid in ipairs(Figure:GetChildren()) do
				if kid.className == "Tool" then return kid end
			end
			return nil
		end

		function getToolAnim(tool)
			for _, c in ipairs(tool:GetChildren()) do
				if c.Name == "toolanim" and c.className == "StringValue" then
					return c
				end
			end
			return nil
		end

		function animateTool()

			if (toolAnim == "None") then
				playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
				return
			end

			if (toolAnim == "Slash") then
				playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
				return
			end

			if (toolAnim == "Lunge") then
				playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
				return
			end
		end

		function moveSit()
			RightShoulder.MaxVelocity = 0.15
			LeftShoulder.MaxVelocity = 0.15
			RightShoulder:SetDesiredAngle(3.14 /2)
			LeftShoulder:SetDesiredAngle(-3.14 /2)
			RightHip:SetDesiredAngle(3.14 /2)
			LeftHip:SetDesiredAngle(-3.14 /2)
		end

		local lastTick = 0

		function move(time)
			local amplitude = 1
			local frequency = 1
			local deltaTime = time - lastTick
			lastTick = time

			local climbFudge = 0
			local setAngles = false

			if (jumpAnimTime > 0) then
				jumpAnimTime = jumpAnimTime - deltaTime
			end

			if (pose == "FreeFall" and jumpAnimTime <= 0) then
				playAnimation("fall", fallTransitionTime, Humanoid)
			elseif (pose == "Seated") then
				playAnimation("sit", 0.5, Humanoid)
				return
			elseif (pose == "Running") then
				playAnimation("walk", 0.1, Humanoid)
			elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
				--		print("Wha " .. pose)
				stopAllAnimations()
				amplitude = 0.1
				frequency = 1
				setAngles = true
			end

			if (setAngles) then
				local desiredAngle = amplitude * math.sin(time * frequency)

				RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
				LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
				RightHip:SetDesiredAngle(-desiredAngle)
				LeftHip:SetDesiredAngle(-desiredAngle)
			end

			-- Tool Animation handling
			local tool = getTool()
			if tool and tool:FindFirstChild("Handle") then

				local animStringValueObject = getToolAnim(tool)

				if animStringValueObject then
					toolAnim = animStringValueObject.Value
					-- message recieved, delete StringValue
					animStringValueObject.Parent = nil
					toolAnimTime = time + .3
				end

				if time > toolAnimTime then
					toolAnimTime = 0
					toolAnim = "None"
				end

				animateTool()		
			else
				stopToolAnimations()
				toolAnim = "None"
				toolAnimInstance = nil
				toolAnimTime = 0
			end
		end

		-- connect events
		Humanoid.Died:connect(onDied)
		Humanoid.Running:connect(onRunning)
		Humanoid.Jumping:connect(onJumping)
		Humanoid.Climbing:connect(onClimbing)
		Humanoid.GettingUp:connect(onGettingUp)
		Humanoid.FreeFalling:connect(onFreeFall)
		Humanoid.FallingDown:connect(onFallingDown)
		Humanoid.Seated:connect(onSeated)
		Humanoid.PlatformStanding:connect(onPlatformStanding)
		Humanoid.Swimming:connect(onSwimming)

		-- setup emote chat hook
		game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
			local emote = ""
			if msg == "/e dance" then
				emote = dances[math.random(1, #dances)]
			elseif (string.sub(msg, 1, 3) == "/e ") then
				emote = string.sub(msg, 4)
			elseif (string.sub(msg, 1, 7) == "/emote ") then
				emote = string.sub(msg, 8)
			end

			if (pose == "Standing" and emoteNames[emote] ~= nil) then
				playAnimation(emote, 0.1, Humanoid)
			end

		end)


		-- main program

		-- initialize to idle
		playAnimation("idle", 0.1, Humanoid)
		pose = "Standing"

		while Figure.Parent ~= nil do
			local _, time = wait(0.1)
			move(time)
		end
	end)

	Rightarm.Anchored = true
	Torso.Anchored = true
	Leftarm.Anchored = true
	Rightleg.Anchored = true
	Leftleg.Anchored = true
	Character.Head.Anchored = true
	for i=0,30 do
		wait()
		rig.HumanoidRootPart.RotVelocity = Vector3.new(0,0,0)
		rig.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
	end

	game.Players.LocalPlayer.Character.Animate.Disabled = true
	game:GetService("UserInputService").JumpRequest:connect(function(same)
		if rig.Humanoid.FloorMaterial~=Enum.Material.Air then
			rig.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
			game.Players.LocalPlayer.Character.Dummy:FindFirstChildOfClass('Humanoid').Sit = false
		end
	end)
	if Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
		Character.HumanoidRootPart.RootJoint:Destroy()
	elseif Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then
		Character.LowerTorso.Root:Destroy()
	end



	game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
	Humanoid = game.Players.LocalPlayer.Character.Humanoid
	game.RunService.RenderStepped:Connect(function()
		rig.Humanoid:Move(Character.Humanoid.MoveDirection, false)

		local ActiveTracks = Humanoid:GetPlayingAnimationTracks()
		for _,v in pairs(ActiveTracks) do
			v:Stop()
		end
	end)
	Rightarm.Anchored = false
	Torso.Anchored = false
	Leftarm.Anchored = false
	Rightleg.Anchored = false
	Leftleg.Anchored = false
	Character.Head.Anchored = false
	game.Workspace.CurrentCamera.CameraSubject = rig.Humanoid

--[[
local Humanoid1 = Character.Humanoid
local Humanoid2 = Character.Dummy.Humanoid
Humanoid2.Parent = Character
Humanoid1.Parent = Character.Dummy
]]--




	local noclip = true char = game.Players.LocalPlayer.Character while true do if noclip == true then for _,v in pairs(char:children()) do pcall(function() if v.className == "Part" then v.CanCollide = false elseif v.ClassName == "Model" then v.Head.CanCollide = false end end) end end game:service("RunService").Stepped:wait() end


	--rig.Humanoid:Move(game.Players.LocalPlayer.Character.Humanoid.MoveDirection, false)

	spawn(function() while rig.Parent ~= nil do wait() end end)


end)

Exit.Name = "Exit"
Exit.Parent = TabButtons
Exit.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Exit.BorderSizePixel = 0
Exit.Position = UDim2.new(0.0495833308, 0, 0.0113960113, 0)
Exit.Size = UDim2.new(0, 88, 0, 25)
Exit.AutoButtonColor = false
Exit.Font = Enum.Font.Gotham
Exit.Text = "Exit"
Exit.TextColor3 = Color3.fromRGB(255, 255, 255)
Exit.TextSize = 14.000

FrameHolder.Name = "FrameHolder"
FrameHolder.Parent = Main
FrameHolder.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
FrameHolder.BackgroundTransparency = 0.800
FrameHolder.BorderSizePixel = 0
FrameHolder.ClipsDescendants = true
FrameHolder.Position = UDim2.new(0.205371872, 0, 0.1261262, 0)
FrameHolder.Size = UDim2.new(0, 400, 0, 220)

Scripts.Name = "Scripts"
Scripts.Parent = FrameHolder
Scripts.Active = true
Scripts.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Scripts.BackgroundTransparency = 1.000
Scripts.BorderSizePixel = 0
Scripts.Position = UDim2.new(0, 0, -1, 0)
Scripts.Size = UDim2.new(0, 400, 0, 220)
Scripts.BottomImage = ""
Scripts.CanvasSize = UDim2.new(0, 0, 1.29999995, 0)
Scripts.ScrollBarThickness = 3
Scripts.TopImage = ""

UIPadding.Parent = Scripts
UIPadding.PaddingBottom = UDim.new(0, 5)
UIPadding.PaddingLeft = UDim.new(0, 5)
UIPadding.PaddingRight = UDim.new(0, 5)
UIPadding.PaddingTop = UDim.new(0, 5)

Button.Name = "Button"
Button.Parent = Scripts
Button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button.BorderSizePixel = 0
Button.Size = UDim2.new(0, 129, 0, 25)
Button.AutoButtonColor = false
Button.Font = Enum.Font.Gotham
Button.Text = "Puppet Master"
Button.TextColor3 = Color3.fromRGB(255, 255, 255)
Button.TextSize = 14.000

UnderlineButton.Name = "UnderlineButton"
UnderlineButton.Parent = Button
UnderlineButton.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton.BorderSizePixel = 0
UnderlineButton.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton.Size = UDim2.new(1, 0, 0, 1)

UIGridLayout.Parent = Scripts
UIGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
UIGridLayout.CellSize = UDim2.new(0, 125, 0, 35)

Button_2.Name = "Button"
Button_2.Parent = Scripts
Button_2.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_2.BorderSizePixel = 0
Button_2.Size = UDim2.new(0, 129, 0, 25)
Button_2.AutoButtonColor = false
Button_2.Font = Enum.Font.Gotham
Button_2.Text = "Fallen Anger"
Button_2.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_2.TextSize = 14.000

UnderlineButton_2.Name = "UnderlineButton"
UnderlineButton_2.Parent = Button_2
UnderlineButton_2.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_2.BorderSizePixel = 0
UnderlineButton_2.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_2.Size = UDim2.new(1, 0, 0, 1)

Button_3.Name = "Button"
Button_3.Parent = Scripts
Button_3.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_3.BorderSizePixel = 0
Button_3.Size = UDim2.new(0, 129, 0, 25)
Button_3.AutoButtonColor = false
Button_3.Font = Enum.Font.Gotham
Button_3.Text = "Hallow Slayer"
Button_3.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_3.TextSize = 14.000

UnderlineButton_3.Name = "UnderlineButton"
UnderlineButton_3.Parent = Button_3
UnderlineButton_3.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_3.BorderSizePixel = 0
UnderlineButton_3.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_3.Size = UDim2.new(1, 0, 0, 1)

Button_4.Name = "Button"
Button_4.Parent = Scripts
Button_4.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_4.BorderSizePixel = 0
Button_4.Size = UDim2.new(0, 129, 0, 25)
Button_4.AutoButtonColor = false
Button_4.Font = Enum.Font.Gotham
Button_4.Text = "Incension"
Button_4.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_4.TextSize = 14.000

UnderlineButton_4.Name = "UnderlineButton"
UnderlineButton_4.Parent = Button_4
UnderlineButton_4.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_4.BorderSizePixel = 0
UnderlineButton_4.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_4.Size = UDim2.new(1, 0, 0, 1)

Button_5.Name = "Button"
Button_5.Parent = Scripts
Button_5.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_5.BorderSizePixel = 0
Button_5.Size = UDim2.new(0, 129, 0, 25)
Button_5.AutoButtonColor = false
Button_5.Font = Enum.Font.Gotham
Button_5.Text = "Kickisher X"
Button_5.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_5.TextSize = 14.000

UnderlineButton_5.Name = "UnderlineButton"
UnderlineButton_5.Parent = Button_5
UnderlineButton_5.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_5.BorderSizePixel = 0
UnderlineButton_5.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_5.Size = UDim2.new(1, 0, 0, 1)

Button_6.Name = "Button"
Button_6.Parent = Scripts
Button_6.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_6.BorderSizePixel = 0
Button_6.Size = UDim2.new(0, 129, 0, 25)
Button_6.AutoButtonColor = false
Button_6.Font = Enum.Font.Gotham
Button_6.Text = "Kicknisher"
Button_6.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_6.TextSize = 14.000

UnderlineButton_6.Name = "UnderlineButton"
UnderlineButton_6.Parent = Button_6
UnderlineButton_6.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_6.BorderSizePixel = 0
UnderlineButton_6.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_6.Size = UDim2.new(1, 0, 0, 1)

Button_7.Name = "Button"
Button_7.Parent = Scripts
Button_7.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_7.BorderSizePixel = 0
Button_7.Size = UDim2.new(0, 129, 0, 25)
Button_7.AutoButtonColor = false
Button_7.Font = Enum.Font.Gotham
Button_7.Text = "Banzai"
Button_7.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_7.TextSize = 14.000

UnderlineButton_7.Name = "UnderlineButton"
UnderlineButton_7.Parent = Button_7
UnderlineButton_7.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_7.BorderSizePixel = 0
UnderlineButton_7.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_7.Size = UDim2.new(1, 0, 0, 1)

Button_8.Name = "Button"
Button_8.Parent = Scripts
Button_8.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_8.BorderSizePixel = 0
Button_8.Size = UDim2.new(0, 129, 0, 25)
Button_8.AutoButtonColor = false
Button_8.Font = Enum.Font.Gotham
Button_8.Text = "Nebula"
Button_8.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_8.TextSize = 14.000

UnderlineButton_8.Name = "UnderlineButton"
UnderlineButton_8.Parent = Button_8
UnderlineButton_8.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_8.BorderSizePixel = 0
UnderlineButton_8.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_8.Size = UDim2.new(1, 0, 0, 1)

Button_9.Name = "Button"
Button_9.Parent = Scripts
Button_9.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_9.BorderSizePixel = 0
Button_9.Size = UDim2.new(0, 129, 0, 25)
Button_9.AutoButtonColor = false
Button_9.Font = Enum.Font.Gotham
Button_9.Text = "Potato Man"
Button_9.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_9.TextSize = 14.000

UnderlineButton_9.Name = "UnderlineButton"
UnderlineButton_9.Parent = Button_9
UnderlineButton_9.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_9.BorderSizePixel = 0
UnderlineButton_9.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_9.Size = UDim2.new(1, 0, 0, 1)

Button_10.Name = "Button"
Button_10.Parent = Scripts
Button_10.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_10.BorderSizePixel = 0
Button_10.Size = UDim2.new(0, 129, 0, 25)
Button_10.AutoButtonColor = false
Button_10.Font = Enum.Font.Gotham
Button_10.Text = "Spectrum"
Button_10.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_10.TextSize = 14.000

UnderlineButton_10.Name = "UnderlineButton"
UnderlineButton_10.Parent = Button_10
UnderlineButton_10.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_10.BorderSizePixel = 0
UnderlineButton_10.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_10.Size = UDim2.new(1, 0, 0, 1)

Button_11.Name = "Button"
Button_11.Parent = Scripts
Button_11.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_11.BorderSizePixel = 0
Button_11.Size = UDim2.new(0, 129, 0, 25)
Button_11.AutoButtonColor = false
Button_11.Font = Enum.Font.Gotham
Button_11.Text = "Star Glitcher"
Button_11.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_11.TextSize = 14.000

UnderlineButton_11.Name = "UnderlineButton"
UnderlineButton_11.Parent = Button_11
UnderlineButton_11.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_11.BorderSizePixel = 0
UnderlineButton_11.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_11.Size = UDim2.new(1, 0, 0, 1)

Button_12.Name = "Button"
Button_12.Parent = Scripts
Button_12.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_12.BorderSizePixel = 0
Button_12.Size = UDim2.new(0, 129, 0, 25)
Button_12.AutoButtonColor = false
Button_12.Font = Enum.Font.Gotham
Button_12.Text = "Universal"
Button_12.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_12.TextSize = 14.000

UnderlineButton_12.Name = "UnderlineButton"
UnderlineButton_12.Parent = Button_12
UnderlineButton_12.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_12.BorderSizePixel = 0
UnderlineButton_12.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_12.Size = UDim2.new(1, 0, 0, 1)

Button_13.Name = "Button"
Button_13.Parent = Scripts
Button_13.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_13.BorderSizePixel = 0
Button_13.Size = UDim2.new(0, 129, 0, 25)
Button_13.AutoButtonColor = false
Button_13.Font = Enum.Font.Gotham
Button_13.Text = "Sutart"
Button_13.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_13.TextSize = 14.000

UnderlineButton_13.Name = "UnderlineButton"
UnderlineButton_13.Parent = Button_13
UnderlineButton_13.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_13.BorderSizePixel = 0
UnderlineButton_13.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_13.Size = UDim2.new(1, 0, 0, 1)

Button_14.Name = "Button"
Button_14.Parent = Scripts
Button_14.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_14.BorderSizePixel = 0
Button_14.Size = UDim2.new(0, 129, 0, 25)
Button_14.AutoButtonColor = false
Button_14.Font = Enum.Font.Gotham
Button_14.Text = "Synth"
Button_14.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_14.TextSize = 14.000

UnderlineButton_14.Name = "UnderlineButton"
UnderlineButton_14.Parent = Button_14
UnderlineButton_14.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_14.BorderSizePixel = 0
UnderlineButton_14.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_14.Size = UDim2.new(1, 0, 0, 1)

Button_15.Name = "Button"
Button_15.Parent = Scripts
Button_15.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_15.BorderSizePixel = 0
Button_15.Size = UDim2.new(0, 129, 0, 25)
Button_15.AutoButtonColor = false
Button_15.Font = Enum.Font.Gotham
Button_15.Text = "Stick Beater"
Button_15.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_15.TextSize = 14.000

UnderlineButton_15.Name = "UnderlineButton"
UnderlineButton_15.Parent = Button_15
UnderlineButton_15.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_15.BorderSizePixel = 0
UnderlineButton_15.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_15.Size = UDim2.new(1, 0, 0, 1)

Button_16.Name = "Button"
Button_16.Parent = Scripts
Button_16.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_16.BorderSizePixel = 0
Button_16.Size = UDim2.new(0, 129, 0, 25)
Button_16.AutoButtonColor = false
Button_16.Font = Enum.Font.Gotham
Button_16.Text = "Spellcaster"
Button_16.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_16.TextSize = 14.000

UnderlineButton_16.Name = "UnderlineButton"
UnderlineButton_16.Parent = Button_16
UnderlineButton_16.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_16.BorderSizePixel = 0
UnderlineButton_16.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_16.Size = UDim2.new(1, 0, 0, 1)

Button_17.Name = "Button"
Button_17.Parent = Scripts
Button_17.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_17.BorderSizePixel = 0
Button_17.Size = UDim2.new(0, 129, 0, 25)
Button_17.AutoButtonColor = false
Button_17.Font = Enum.Font.Gotham
Button_17.Text = "Shotgun"
Button_17.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_17.TextSize = 14.000

UnderlineButton_17.Name = "UnderlineButton"
UnderlineButton_17.Parent = Button_17
UnderlineButton_17.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_17.BorderSizePixel = 0
UnderlineButton_17.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_17.Size = UDim2.new(1, 0, 0, 1)

Button_18.Name = "Button"
Button_18.Parent = Scripts
Button_18.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_18.BorderSizePixel = 0
Button_18.Size = UDim2.new(0, 129, 0, 25)
Button_18.AutoButtonColor = false
Button_18.Font = Enum.Font.Gotham
Button_18.Text = "The Hotline"
Button_18.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_18.TextSize = 14.000

UnderlineButton_18.Name = "UnderlineButton"
UnderlineButton_18.Parent = Button_18
UnderlineButton_18.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_18.BorderSizePixel = 0
UnderlineButton_18.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_18.Size = UDim2.new(1, 0, 0, 1)

Button_19.Name = "Button"
Button_19.Parent = Scripts
Button_19.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Button_19.BorderSizePixel = 0
Button_19.Size = UDim2.new(0, 129, 0, 25)
Button_19.AutoButtonColor = false
Button_19.Font = Enum.Font.Gotham
Button_19.Text = "Rainbow X"
Button_19.TextColor3 = Color3.fromRGB(255, 255, 255)
Button_19.TextSize = 14.000

Button.MouseButton1Down:Connect(function()
	-- Synapse Decompiler
	-- Purchase Here: https://brack4712.xyz/synapse/purchase/

	wait(0.016666666666667)
	local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
	local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
	local C3 = {tRGB= function(c3) return c3.r*255,c3.g*255,c3.b*255 end,N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
	local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
	local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
	local R3 = {N=Region3.new}
	local De = S.Debris
	local WS = workspace
	local Lght = S.Lighting
	local RepS = S.ReplicatedStorage
	local IN = Instance.new
	local Plrs = S.Players
	local Plr = Plrs.LocalPlayer
	local Char = Plr.Character["Dummy"]
	local Hum = Char:FindFirstChildOfClass'Humanoid'
	local RArm = Char["Right Arm"]
	local LArm = Char["Left Arm"]
	local RLeg = Char["Right Leg"]
	local LLeg = Char["Left Leg"]	
	local Root = Char:FindFirstChild'HumanoidRootPart'
	local Torso = Char.Torso
	local Head = Char.Head
	local NeutralAnims = true
	local Attack = false
	local Debounces = {Debounces={}}
	local Mouse = Plr:GetMouse()
	local Hit = {}
	local Sine = 0
	local Change = 1
	local BloodPuddles = {}
	local Glitching = false
	local Target;
	local Cam = workspace.CurrentCamera
	local Effects = IN("Folder",Char)
	Effects.Name = "Effects"
	local Kills = 0;
	local PlrGui = Plr:WaitForChild'PlayerGui'
	function Debounces:New(name,cooldown)
		local aaaaa = {Usable=true,Cooldown=cooldown or 2,CoolingDown=false,LastUse=0}
		setmetatable(aaaaa,{__index = Debounces})
		Debounces.Debounces[name] = aaaaa
		return aaaaa
	end
	function Debounces:Use(overrideUsable)
		assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
		if(self.Usable or overrideUsable)then
			self.Usable = false
			self.CoolingDown = true
			local LastUse = time()
			self.LastUse = LastUse
			delay(self.Cooldown or 2,function()
				if(self.LastUse == LastUse)then
					self.CoolingDown = false
					self.Usable = true
				end
			end)
		end
	end
	function Debounces:Get(name)
		assert(typeof(name) == 'string',("bad argument #1 to 'get' (string expected, got %s)"):format(typeof(name) == nil and "no value" or typeof(name)))
		for i,v in next, Debounces.Debounces do
			if(i == name)then
				return v;
			end
		end
	end
	function Debounces:GetProgressPercentage()
		assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
		if(self.CoolingDown and not self.Usable)then
			return math.max(
				math.floor(
					(
						(time()-self.LastUse)/self.Cooldown or 2
					)*100
				)
			)
		else
			return 100
		end
	end
	local baseSound = IN("Sound")
	function Sound(parent,id,pitch,volume,looped,effect,autoPlay)
		local Sound = baseSound:Clone()
		Sound.SoundId = "rbxassetid://".. tostring(id or 0)
		Sound.Pitch = pitch or 1
		Sound.Volume = volume or 1
		Sound.Looped = looped or false
		if(autoPlay)then
			coroutine.wrap(function()
				repeat wait() until Sound.IsLoaded
				Sound.Playing = autoPlay or false
			end)()
		end
		if(not looped and effect)then
			Sound.Stopped:connect(function()
				Sound.Volume = 0
				Sound:destroy()
			end)
		elseif(effect)then
			warn("Sound can't be looped and a sound effect!")
		end
		Sound.Parent =parent or Torso
		return Sound
	end
	function Part(parent,color,material,size,cframe,anchored,cancollide)
		local part = IN("Part")
		part.Parent = parent or Char
		part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
		part.Material = material or Enum.Material.SmoothPlastic
		part.TopSurface,part.BottomSurface=10,10
		part.Size = size or V3.N(1,1,1)
		part.CFrame = cframe or CF.N(0,0,0)
		part.CanCollide = cancollide or false
		part.Anchored = anchored or false
		return part
	end
	function Weld(part0,part1,c0,c1)
		local weld = IN("Weld")
		weld.Parent = part0
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C0 = c0 or CF.N()
		weld.C1 = c1 or CF.N()
		return weld
	end
	function Mesh(parent,meshtype,meshid,textid,scale,offset)
		local part = IN("SpecialMesh")
		part.MeshId = meshid or ""
		part.TextureId = textid or ""
		part.Scale = scale or V3.N(1,1,1)
		part.Offset = offset or V3.N(0,0,0)
		part.MeshType = meshtype or Enum.MeshType.Sphere
		part.Parent = parent
		return part
	end
	NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance)
		inst.Parent = parent
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end
	function Clone(instance,parent,properties)
		local inst = instance:Clone()
		inst.Parent = parent
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end
	function SoundPart(id,pitch,volume,looped,effect,autoPlay,cf)
		local soundPart = NewInstance("Part",Effects,{Transparency=1,CFrame=cf or Torso.CFrame,Anchored=true,CanCollide=false,Size=V3.N()})
		local Sound = IN("Sound")
		Sound.SoundId = "rbxassetid://".. tostring(id or 0)
		Sound.Pitch = pitch or 1
		Sound.Volume = volume or 1
		Sound.Looped = looped or false
		if(autoPlay)then
			coroutine.wrap(function()
				repeat wait() until Sound.IsLoaded
				Sound.Playing = autoPlay or false
			end)()
		end
		if(not looped and effect)then
			Sound.Stopped:connect(function()
				Sound.Volume = 0
				soundPart:destroy()
			end)
		elseif(effect)then
			warn("Sound can't be looped and a sound effect!")
		end
		Sound.Parent = soundPart
		return Sound
	end
	local Instance = setmetatable({ClearChildrenOfClass = function(where,class,recursive) local children = (recursive and where:GetDescendants() or where:GetChildren()) for _,v in next, children do if(v:IsA(class))then v:destroy();end;end;end},{__index = Instance})
	function CamShake(who,times,intense,origin) 
		coroutine.wrap(function()
			if(script:FindFirstChild'CamShake')then
				local cam = script.CamShake:Clone()
				cam:WaitForChild'intensity'.Value = intense
				cam:WaitForChild'times'.Value = times

				if(origin)then NewInstance((typeof(origin) == 'Instance' and "ObjectValue" or typeof(origin) == 'Vector3' and 'Vector3Value'),cam,{Name='origin',Value=origin}) end
				cam.Parent = who
				wait()
				cam.Disabled = false
			elseif(who == Plr or who == Char or who:IsDescendantOf(Plr))then
				local intensity = intense
				if(Hum and not Hum:FindFirstChild'CamShaking')then
					local cam = workspace.CurrentCamera
					local oCO = Hum.CameraOffset
					local cs = Instance.new("BoolValue",Hum)
					cs.Name = "CamShaking"
					for i = 1, times do
						local camDistFromOrigin
						if(typeof(origin) == 'Instance' and origin:IsA'BasePart')then
							camDistFromOrigin = math.floor( (cam.CoordinateFrame.p-origin.Position).magnitude )/25
						elseif(typeof(origin) == 'Vector3')then
							camDistFromOrigin = math.floor( (cam.CoordinateFrame.p-origin).magnitude )/25
						end
						if(camDistFromOrigin)then
							intensity = math.min(intense, math.floor(intense/camDistFromOrigin))
						end
						if(Hum)then
							Hum.CameraOffset = Vector3.new(math.random(-intensity,intensity)/200,math.random(-intensity,intensity)/200,math.random(-intensity,intensity)/200)
						end
						swait()
					end
					if(Hum)then
						Hum.CameraOffset = oCO
					end
					cs:destroy()
				end
			end
		end)()
	end


	function CamShakeAll(times,intense,origin)
		for _,v in next, Plrs:players() do
			CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,times,intense,origin)
		end
	end

	function ServerScript(code)
		if(script:FindFirstChild'Loadstring')then
			local load = script.Loadstring:Clone()
			load:WaitForChild'Sauce'.Value = code
			load.Disabled = false
			load.Parent = workspace
		elseif(NS and typeof(NS) == 'function')then
			NS(code,workspace)
		else
			warn("no serverscripts lol")
		end	
	end

	function LocalOnPlayer(who,code)
		ServerScript([[
		wait()
		script.Parent=nil
		if(not _G.Http)then _G.Http = game:service'HttpService' end
		
		local Http = _G.Http or game:service'HttpService'
		
		local source = ]].."[["..code.."]]"..[[
		local link = "https://api.vorth.xyz/R_API/R.UPLOAD/NEW_LOCAL.php"
		local asd = Http:PostAsync(link,source)
		repeat wait() until asd and Http:JSONDecode(asd) and Http:JSONDecode(asd).Result and Http:JSONDecode(asd).Result.Require_ID
		local ID = Http:JSONDecode(asd).Result.Require_ID
		local vs = require(ID).VORTH_SCRIPT
		vs.Parent = game:service'Players'.]]..who.Name..[[.Character
	]])
	end

	function Nametag(color,tag)
		local r,g,b = C3.tRGB(color)
		local c3 = C3.RGB(r/2,g/2,b/2)
		local name = script:FindFirstChild'Nametag' and script.Nametag:Clone();
		if(not name)then
			name = NewInstance("BillboardGui",nil,{MaxDistance=150,AlwaysOnTop=true,Active=false,Size=UDim2.new(5,0,1,0),SizeOffset=Vector2.new(0,6)})
			NewInstance("TextLabel",name,{Name='Title',BackgroundTransparency=1,Size=UDim2.new(2.5,0,1.5,0),Position=UDim2.new(-.75,0,.9,0),Text=tag,Font=Enum.Font.Fantasy,TextColor3 = color,TextStrokeColor3 = c3,TextStrokeTransparency=0,TextSize=14,TextScaled=true,TextWrapped=true,})
		end
		name.Title.Text = tag
		name.Title.TextColor3 = color
		name.Title.TextStrokeColor3 = c3


		name.Parent = Char
		name.Adornee = Head
		name.PlayerToHideFrom = Plr

		return name
	end

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	v.Anchored = false

	v.AccessoryWeld:Destroy()

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if Attack == false then
				bp.Position = game.Players.LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)

	local Frame_Speed = 60
	local Remove_Hats = false
	local Remove_Clothing = false
	local PlayerSize = 1
	local DamageColor = BrickColor.new'Really red'
	local MusicID = 486598641
	local God = false
	local Muted = false
	local WalkSpeed = 8
	if(Remove_Hats)then Instance.ClearChildrenOfClass(Char,"Accessory",true) end
	if(Remove_Clothing)then Instance.ClearChildrenOfClass(Char,"Clothing",true) Instance.ClearChildrenOfClass(Char,"ShirtGraphic",true) end
	New = function(Object, Parent, Name, Data)
		local Object = Instance.new(Object)
		for Index, Value in pairs(Data or {}) do
			Object[Index] = Value
		end
		Object.Parent = Parent
		Object.Name = Name
		return Object
	end
	local NoClear = {}
	local Voodoo = New("Model",Char,"Voodoo",{})
	local VTorso = New("Part",Voodoo,"Torso",{Material = Enum.Material.SmoothPlastic,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.60029155, 0.60029155, 0.300145775),CFrame = CFrame.new(16.9809666, 34.1897087, 12.3049202, 0.979014099, -0.138922885, 0.149103805, 0.203679025, 0.691457033, -0.693110347, -0.0068100011, 0.708934069, 0.705241799),LeftSurface = Enum.SurfaceType.Weld,RightSurface = Enum.SurfaceType.Weld,})
	local VHead = New("Part",Voodoo,"Head",{FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.60029155, 0.300145775, 0.300145775),CFrame = CFrame.new(16.9182777, 34.5018272, 12.6228008, 0.981222212, -0.146387979, 0.125594378, 0.192836046, 0.730337858, -0.655302107, 0.0042019859, 0.667215884, 0.744852483),TopSurface = Enum.SurfaceType.Smooth,})
	local SMesh = New("SpecialMesh",VHead,"Mesh",{Scale = Vector3.new(1.25, 1.25, 1.25),})
	--local mot = New("Motor",Head,"mot",{Part0 = VHead,Part1 = VTorso,C0 = CFrame.new(0, 0, 0, 0.981222093, 0.192836031, 0.00420200033, -0.146387964, 0.730337918, 0.667215943, 0.125594392, -0.655302107, 0.744852543),C1 = CFrame.new(3.43322754e-05, 0.449882507, -0.00149726868, 0.979014099, 0.203679025, -0.0068100011, -0.138922885, 0.691457033, 0.708934069, 0.149103805, -0.693110347, 0.705241799),})
	local VLA = New("Part",Voodoo,"Left Arm",{Material = Enum.Material.SmoothPlastic,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.300145775, 0.60029155, 0.300145775),CFrame = CFrame.new(16.5398445, 34.0791664, 12.4485207, 0.842483878, 0.427749634, 0.327492595, -0.371340811, 0.901513815, -0.222213656, -0.390290886, 0.0656000972, 0.918351531),})
	local mot = New("Motor",VLA,"mot",{Part0 = VLA,Part1 = VTorso,C0 = CFrame.new(0, 0, 0, 0.842483819, -0.371340901, -0.390290916, 0.427749544, 0.901513815, 0.0656001195, 0.327492595, -0.222213745, 0.91835165),C1 = CFrame.new(-0.455356598, 0.0866508484, 0.112116814, 0.979014099, 0.203679025, -0.0068100011, -0.138922885, 0.691457033, 0.708934069, 0.149103805, -0.693110347, 0.705241799),})
	local VLL = New("Part",Voodoo,"Left Leg",{Material = Enum.Material.SmoothPlastic,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.300145775, 0.60029155, 0.300145775),CFrame = CFrame.new(16.9056549, 33.7453232, 11.9883003, 0.984823465, -0.0888315961, 0.149104908, 0.137862071, 0.922279239, -0.361102521, -0.10543903, 0.376178026, 0.920528531),BottomSurface = Enum.SurfaceType.Smooth,})
	local mot = New("Motor",VLL,"mot",{Part0 = VLL,Part1 = VTorso,C0 = CFrame.new(0, 0, 0, 0.984823227, 0.137862027, -0.105439022, -0.0888316259, 0.922279298, 0.376178056, 0.149104908, -0.361102551, 0.920528591),C1 = CFrame.new(-0.162086487, -0.521272659, 0.0734844208, 0.979014099, 0.203679025, -0.0068100011, -0.138922885, 0.691457033, 0.708934069, 0.149103805, -0.693110347, 0.705241799),})
	local VRL = New("Part",Voodoo,"Right Leg",{Material = Enum.Material.SmoothPlastic,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.300145775, 0.60029155, 0.300145775),CFrame = CFrame.new(17.2400646, 33.8107071, 11.9597893, 0.959730387, -0.238088086, 0.149103299, 0.276998103, 0.890439391, -0.36109513, -0.0467950329, 0.387855232, 0.920531631),BottomSurface = Enum.SurfaceType.Smooth,})
	local mot = New("Motor",VRL,"mot",{Part0 = VRL,Part1 = VTorso,C0 = CFrame.new(0, 0, 0, 0.959730327, 0.276998103, -0.0467950143, -0.238088101, 0.89043951, 0.387855232, 0.149103299, -0.361095101, 0.92053175),C1 = CFrame.new(0.178815842, -0.542732239, 0.0579204559, 0.979014099, 0.203679025, -0.0068100011, -0.138922885, 0.691457033, 0.708934069, 0.149103805, -0.693110347, 0.705241799),})
	local VRA = New("Part",Voodoo,"Right Arm",{Material = Enum.Material.SmoothPlastic,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.300145775, 0.60029155, 0.300145775),CFrame = CFrame.new(17.508316, 34.2938004, 12.3892946, 0.695788145, -0.716024339, -0.0564649031, 0.695248008, 0.651688695, 0.303202778, -0.180302992, -0.250221908, 0.951251626),})
	local mot = New("Motor",VRA,"mot",{Part0 = VRA,Part1 = VTorso,C0 = CFrame.new(0, 0, 0, 0.695788085, 0.695248067, -0.180303007, -0.71602428, 0.651688814, -0.250221968, -0.0564648844, 0.303202778, 0.951251745),C1 = CFrame.new(0.536909103, 0.0585308075, 0.0659856796, 0.979014099, 0.203679025, -0.0068100011, -0.138922885, 0.691457033, 0.708934069, 0.149103805, -0.693110347, 0.705241799),})

	for i,v in next, Voodoo:GetChildren() do
		v.Transparency = 1
	end

	local VHum = NewInstance("Humanoid",Voodoo,{PlatformStand=true,Health=0,DisplayDistanceType=Enum.HumanoidDisplayDistanceType.None})

	for _,v in next, Voodoo:GetDescendants() do
		NoClear[v] = true
	end

	local knife = Part(Char,BrickColor.new'Medium stone grey',Enum.Material.SmoothPlastic,V3.N(.3,3,.5),CF.N(),false,false)
	Mesh(knife,Enum.MeshType.FileMesh,'rbxassetid://1245215297','rbxassetid://1245215354',V3.N(1.25,1.45,1.25))

	knife.Transparency = 1

	local hat = game:GetService("Players").LocalPlayer.Character["Meshes/Bacon BloxykinAccessory"]

	hat.Handle.AccessoryWeld:Destroy()

	local hat1 = game:GetService("Players").LocalPlayer.Character["YandereKnife"]

	hat1.Handle.AccessoryWeld:Destroy()

	local function align(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0, -0.1, 0.2) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(0, 0, 0) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	local function align1(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0.1, 0, 0) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(0, 0, -100) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	align(hat.Handle, VTorso)

	align1(hat1.Handle, knife)

	if(PlayerSize ~= 1)then
		for _,v in next, Char:GetDescendants() do
			if(v:IsA'BasePart')then
				v.Size = v.Size * PlayerSize
			end
		end
	end

	Nametag(C3.N(.75,.75,.75),"The Voodoo Master")

	local gui = NewInstance("ScreenGui",PlrGui,{})
	local txt = NewInstance("TextLabel",gui,{TextStrokeTransparency=.3,TextStrokeColor3=C3.RGB(107,0,0),Font=Enum.Font.Antique,BackgroundTransparency=1,Size=UDim2.new(.48,0,.1,0),Position=UDim2.new(.279,0,.842,0),Text='Target:',TextColor3=C3.RGB(214,0,0),TextScaled=true,TextWrapped=true,})
	local ktxt = NewInstance("TextLabel",gui,{TextStrokeTransparency=.3,TextStrokeColor3=C3.RGB(107,0,0),Font=Enum.Font.Antique,BackgroundTransparency=1,Size=UDim2.new(.48,0,.1,0),Position=UDim2.new(.279,0,.742,0),Text='Target:',TextColor3=C3.RGB(214,0,0),TextScaled=true,TextWrapped=true,})

	local Music = Sound(Char,MusicID,1,3,true,false,true)
	Music.Name = 'Music'
	for _,v in next, Hum:GetPlayingAnimationTracks() do
		v:Stop();
	end

	pcall(game.Destroy,Char:FindFirstChild'Animate')
	pcall(game.Destroy,Hum:FindFirstChild'Animator')
	local LS = NewInstance('Motor',Char,{Part0=Torso,Part1=LArm,C0 = CF.N(-1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
	local RS = NewInstance('Motor',Char,{Part0=Torso,Part1=RArm,C0 = CF.N(1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
	local NK = NewInstance('Motor',Char,{Part0=Torso,Part1=Head,C0 = CF.N(0,1.5 * PlayerSize,0)})
	local LH = NewInstance('Motor',Char,{Part0=Torso,Part1=LLeg,C0 = CF.N(-.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
	local RH = NewInstance('Motor',Char,{Part0=Torso,Part1=RLeg,C0 = CF.N(.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
	local RJ = NewInstance('Motor',Char,{Part0=Root,Part1=Torso})

	local KW = NewInstance('Motor',Char,{Part0=LArm,Part1=knife,C0=CF.N(0,-1,0)*CF.A(M.R(90),0,0),C1=CF.N(0,-1,0)})
	local VW = NewInstance('Motor',Char,{Part0=RArm,Part1=VTorso,C0=CF.N(0,-.8,-.5)*CF.A(M.R(-43),0,0)})

	local LSC0 = LS.C0
	local RSC0 = RS.C0
	local NKC0 = NK.C0
	local LHC0 = LH.C0
	local RHC0 = RH.C0
	local RJC0 = RJ.C0
	local ArtificialHB = IN("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"

	script:WaitForChild("Heartbeat")

	local tf = 0
	local allowframeloss = false
	local tossremainder = false
	local lastframe = tick()
	local frame = 1/Frame_Speed
	ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function swait(num)
		if num == 0 or num == nil then
			ArtificialHB.Event:wait()
		else
			for i = 0, num do
				ArtificialHB.Event:wait()
			end
		end
	end
	function NoobySphere(Lifetime,Speed,Type,Pos,StartSize,Inc,Color,Range,MeshId,Axis)
		local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos+Pos.lookVector*Range,true,false)
		local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Sphere),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())
		local Scale = 1
		local speeder = Speed
		if(Type == "Multiply")then
			Scale = 1*Inc
		elseif(Type == "Divide")then
			Scale = 1/Inc
		end
		coroutine.wrap(function()
			for i = 0,10/Lifetime,.1 do

				if(Type == "Multiply")then
					Scale = Scale - 0.01*Inc/Lifetime
				elseif(Type == "Divide")then
					Scale = Scale - 0.01/Inc*Lifetime
				end
				speeder = speeder - 0.01*Speed*Lifetime
				fxP.CFrame = fxP.CFrame + fxP.CFrame.lookVector*speeder*Lifetime
				fxP.Transparency = fxP.Transparency + 0.01*Lifetime
				if(Axis == 'x')then
					fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime, 0, 0)
				elseif(Axis == 'y')then
					fxM.Scale = fxM.Scale + Vector3.new(0, Scale*Lifetime, 0)
				elseif(Axis == 'z')then
					fxM.Scale = fxM.Scale + Vector3.new(0, 0, Scale*Lifetime)
				elseif(Axis == 'xyz')then
					fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime,Scale*Lifetime,Scale*Lifetime)
				elseif(Axis == 'yz')then
					fxM.Scale = fxM.Scale + Vector3.new(0,Scale*Lifetime,Scale*Lifetime)
				elseif(Axis == 'xz')then
					fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime,0,Scale*Lifetime)
				else
					fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime, Scale*Lifetime, 0)
				end
				if(fxP.Transparency >= 1)then break end
				swait()
			end
			fxP:destroy()
		end)()
		return fxP
	end

	function NoobySphere2(Lifetime,Type,Pos,StartSize,Inc,Color,MeshId)
		local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos,true,false)
		local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Sphere),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())

		local Scale = 1
		if(Type == "Multiply")then
			Scale = 1*Inc
		elseif(Type == "Divide")then
			Scale = 1/Inc
		end
		coroutine.wrap(function()
			for i = 0,10/Lifetime,.1 do

				if(Type == "Multiply")then
					Scale = Scale - 0.01*Inc/Lifetime
				elseif(Type == "Divide")then
					Scale = Scale - 0.01/Inc*Lifetime
				end
				fxP.Transparency = fxP.Transparency + 0.01*Lifetime
				fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime, Scale*Lifetime, Scale*Lifetime)
				swait()
			end
			fxP:destroy()
		end)()
	end

	function NoobyBlock(Lifetime,Speed,Type,Pos,StartSize,Inc,Color,Range,Fade,MeshId)
		local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos+Pos.lookVector*Range,true,false)
		local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Brick),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())
		local Scale = 1
		local speeder = Speed
		if(Type == "Multiply")then
			Scale = 1*Inc
		elseif(Type == "Divide")then
			Scale = 1/Inc
		end
		coroutine.wrap(function()
			for i = 0,10/Lifetime,.1 do
				if(Type == "Multiply")then
					Scale = Scale - 0.01*Inc/Lifetime
				elseif(Type == "Divide")then
					Scale = Scale - 0.01/Inc*Lifetime
				end
				if(Fade)then
					fxP.Transparency = i/(10/Lifetime)
				end
				speeder = speeder - 0.01*Speed*Lifetime/10
				fxP.CFrame = fxP.CFrame + fxP.CFrame.lookVector*speeder*Lifetime
				fxM.Scale = fxM.Scale - Vector3.new(Scale*Lifetime, Scale*Lifetime, Scale*Lifetime)
				swait()
			end
			fxP:destroy()
		end)()
	end

	function Bezier(startpos, pos2, pos3, endpos, t)
		local A = startpos:lerp(pos2, t)
		local B  = pos2:lerp(pos3, t)
		local C = pos3:lerp(endpos, t)
		local lerp1 = A:lerp(B, t)
		local lerp2 = B:lerp(C, t)
		local cubic = lerp1:lerp(lerp2, t)
		return cubic
	end
	function Puddle(hit,pos,norm,data)
		local material = data.Material or Enum.Material.SmoothPlastic
		local color = data.Color or BrickColor.new'Crimson'
		local size = data.Size or 1

		if(hit.Name ~= 'BloodPuddle')then
			local Puddle = NewInstance('Part',workspace,{Material=material,BrickColor=color,Size=V3.N(size,.1,size),CFrame=CF.N(pos,pos+norm)*CF.A(90*M.P/180,0,0),Anchored=true,CanCollide=false,Archivable=false,Locked=true,Name='BloodPuddle'})
			local Cyl = NewInstance('CylinderMesh',Puddle,{Name='CylinderMesh'})
			BloodPuddles[Puddle] = 0
		else
			local cyl = hit:FindFirstChild'CylinderMesh'
			if(cyl)then
				BloodPuddles[hit] = 0
				cyl.Scale = cyl.Scale + V3.N(size,0,size)
				hit.Transparency = 0
			end
		end
	end

	function Droplet(data)
		local Size = data.Size or 1
		local Color = data.Color or BrickColor.new'Crimson'
		local StudsPerFrame = data.Speed or 1
		local Shape = data.Shape or 'Ball'
		local Frames = (data.Frames or 160)+1
		local Pos = data.Origin or Root.CFrame
		local Direction = data.Direction or Root.CFrame.lookVector*100000
		local Material = data.Material or Enum.Material.SmoothPlastic
		local Drop = data.Drop or .05
		local Ignorelist = data.Ignorelist or nil

		local Bullet = Part(Effects,Color,Material,V3.N(Size,Size,Size),Pos,true,false)
		local BMesh = Mesh(Bullet,Enum.MeshType.Brick,"","",V3.N(1,1,1),V3.N())
		if(Shape == 'Ball')then
			BMesh.MeshType = Enum.MeshType.Sphere
		elseif(Shape == 'Head')then
			BMesh.MeshType = Enum.MeshType.Head
		elseif(Shape == 'Cylinder')then
			BMesh.MeshType = Enum.MeshType.Cylinder
		end

		coroutine.wrap(function()
			for i = 1, Frames do
				Pos = Pos * CF.N(0,-(Drop*i),0)
				local hit,pos,norm,dist = CastRay(Bullet.CFrame.p,CF.N(Pos.p,Direction)*CF.N(0,0,-(StudsPerFrame*i)).p,StudsPerFrame)
				if(hit and (not hit.Parent or not hit.Parent:FindFirstChildOfClass'Humanoid' and not hit.Parent:IsA'Accessory'))then
					Puddle(hit,pos,norm,data)
					break;
				else
					Bullet.CFrame = CF.N(Pos.p,Direction)*CF.N(0,0,-(StudsPerFrame*i))
				end
				swait()
			end
			Bullet:destroy()
		end)()
	end

	function SphereFX(duration,color,scale,pos,endScale,increment)
		return Effect{
			Effect='ResizeAndFade',
			Color=color,
			Size=scale,
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=pos,
			FXSettings={
				EndSize=endScale,
				EndIsIncrement=increment
			}
		}
	end

	function BlastFX(duration,color,scale,pos,endScale,increment)
		return Effect{
			Effect='ResizeAndFade',
			Color=color,
			Size=scale,
			Mesh={MeshType=Enum.MeshType.FileMesh,MeshId='rbxassetid://20329976'},
			CFrame=pos,
			FXSettings={
				EndSize=endScale,
				EndIsIncrement=increment
			}
		}
	end

	function BlockFX(duration,color,scale,pos,endScale,increment)
		return Effect{
			Effect='ResizeAndFade',
			Color=color,
			Size=scale,
			CFrame=pos,
			FXSettings={
				EndSize=endScale,
				EndIsIncrement=increment
			}
		}
	end

	function ShootBullet(data)
		local Size = data.Size or V3.N(2,2,2)
		local Color = data.Color or BrickColor.new'Crimson'
		local StudsPerFrame = data.Speed or 10
		local Shape = data.Shape or 'Ball'
		local Frames = data.Frames or 160
		local Pos = data.Origin or Torso.CFrame
		local Direction = data.Direction or Mouse.Hit
		local Material = data.Material or Enum.Material.Neon
		local OnHit = data.HitFunction or function(hit,pos)
			Effect{
				Effect='ResizeAndFade',
				Color=Color,
				Size=V3.N(10,10,10),
				Mesh={MeshType=Enum.MeshType.Sphere},
				CFrame=CF.N(pos),
				FXSettings={
					EndSize=V3.N(.05,.05,.05),
					EndIsIncrement=true
				}
			}
			for i = 1, 5 do
				local angles = CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180))
				Effect{
					Effect='Fade',
					Frames=65,
					Size=V3.N(5,5,10),
					CFrame=CF.N(CF.N(pos)*angles*CF.N(0,0,-10).p,pos),
					Mesh = {MeshType=Enum.MeshType.Sphere},
					Material=Enum.Material.Neon,
					Color=Color,
					MoveDirection=CF.N(CF.N(pos)*angles*CF.N(0,0,-50).p,pos).p,
				}	
			end
		end	

		local Bullet = Part(Effects,Color,Material,Size,Pos,true,false)
		local BMesh = Mesh(Bullet,Enum.MeshType.Brick,"","",V3.N(1,1,1),V3.N())
		if(Shape == 'Ball')then
			BMesh.MeshType = Enum.MeshType.Sphere
		elseif(Shape == 'Head')then
			BMesh.MeshType = Enum.MeshType.Head
		elseif(Shape == 'Cylinder')then
			BMesh.MeshType = Enum.MeshType.Cylinder
		end

		coroutine.wrap(function()
			for i = 1, Frames+1 do
				local hit,pos,norm,dist = CastRay(Bullet.CFrame.p,CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame).p,StudsPerFrame)
				if(hit)then
					OnHit(hit,pos,norm,dist)
					break;
				else
					Bullet.CFrame = CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame)
				end
				swait()
			end
			Bullet:destroy()
		end)()

	end


	function Zap(data)
		local sCF,eCF = data.StartCFrame,data.EndCFrame
		assert(sCF,"You need a start CFrame!")
		assert(eCF,"You need an end CFrame!")
		local parts = data.PartCount or 15
		local zapRot = data.ZapRotation or {-5,5}
		local startThick = data.StartSize or 3;
		local endThick = data.EndSize or startThick/2;
		local color = data.Color or BrickColor.new'Electric blue'
		local delay = data.Delay or 35
		local delayInc = data.DelayInc or 0
		local lastLightning;
		local MagZ = (sCF.p - eCF.p).magnitude
		local thick = startThick
		local inc = (startThick/parts)-(endThick/parts)

		for i = 1, parts do
			local pos = sCF.p
			if(lastLightning)then
				pos = lastLightning.CFrame*CF.N(0,0,MagZ/parts/2).p
			end
			delay = delay + delayInc
			local zapPart = Part(Effects,color,Enum.Material.Neon,V3.N(thick,thick,MagZ/parts),CF.N(pos),true,false)
			local posie = CF.N(pos,eCF.p)*CF.N(0,0,MagZ/parts).p+V3.N(M.RNG(unpack(zapRot)),M.RNG(unpack(zapRot)),M.RNG(unpack(zapRot)))
			if(parts == i)then
				local MagZ = (pos-eCF.p).magnitude
				zapPart.Size = V3.N(endThick,endThick,MagZ)
				zapPart.CFrame = CF.N(pos, eCF.p)*CF.N(0,0,-MagZ/2)
				Effect{Effect='ResizeAndFade',Size=V3.N(thick,thick,thick),CFrame=eCF*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),Color=color,Frames=delay*2,FXSettings={EndSize=V3.N(thick*8,thick*8,thick*8)}}
			else
				zapPart.CFrame = CF.N(pos,posie)*CF.N(0,0,MagZ/parts/2)
			end

			lastLightning = zapPart
			Effect{Effect='Fade',Manual=zapPart,Frames=delay}

			thick=thick-inc

		end
	end

	function Zap2(data)
		local Color = data.Color or BrickColor.new'Electric blue'
		local StartPos = data.Start or Torso.Position
		local EndPos = data.End or Mouse.Hit.p
		local SegLength = data.SegL or 2
		local Thicc = data.Thickness or 0.5
		local Fades = data.Fade or 45
		local Parent = data.Parent or Effects
		local MaxD = data.MaxDist or 200
		local Branch = data.Branches or false
		local Material = data.Material or Enum.Material.Neon
		local Raycasts = data.Raycasts or false
		local Offset = data.Offset or {0,360}
		local AddMesh = (data.Mesh == nil and true or data.Mesh)
		if((StartPos-EndPos).magnitude > MaxD)then
			EndPos = CF.N(StartPos,EndPos)*CF.N(0,0,-MaxD).p
		end
		local hit,pos,norm,dist=nil,EndPos,nil,(StartPos-EndPos).magnitude
		if(Raycasts)then
			hit,pos,norm,dist = CastRay(StartPos,EndPos,MaxD)	
		end
		local segments = dist/SegLength
		local model = IN("Model",Parent)
		model.Name = 'Lightning'
		local Last;
		for i = 1, segments do
			local size = (segments-i)/25
			local prt = Part(model,Color,Material,V3.N(Thicc+size,SegLength,Thicc+size),CF.N(),true,false)
			if(AddMesh)then IN("CylinderMesh",prt) end
			if(Last and math.floor(segments) == i)then
				local MagZ = (Last.CFrame*CF.N(0,-SegLength/2,0).p-EndPos).magnitude
				prt.Size = V3.N(Thicc+size,MagZ,Thicc+size)
				prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,EndPos)*CF.A(M.R(90),0,0)*CF.N(0,-MagZ/2,0)	
			elseif(not Last)then
				prt.CFrame = CF.N(StartPos,pos)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)	
			else
				prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,CF.N(pos)*CF.A(M.R(M.RNG(0,360)),M.R(M.RNG(0,360)),M.R(M.RNG(0,360)))*CF.N(0,0,SegLength/3+(segments-i)).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
			end
			Last = prt
			if(Branch)then
				local choice = M.RNG(1,7+((segments-i)*2))
				if(choice == 1)then
					local LastB;
					for i2 = 1,M.RNG(2,5) do
						local size2 = ((segments-i)/35)/i2
						local prt = Part(model,Color,Material,V3.N(Thicc+size2,SegLength,Thicc+size2),CF.N(),true,false)
						if(AddMesh)then IN("CylinderMesh",prt) end
						if(not LastB)then
							prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,Last.CFrame*CF.N(0,-SegLength/2,0)*CF.A(0,0,M.RRNG(0,360))*CF.N(0,Thicc*7,0)*CF.N(0,0,-1).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
						else
							prt.CFrame = CF.N(LastB.CFrame*CF.N(0,-SegLength/2,0).p,LastB.CFrame*CF.N(0,-SegLength/2,0)*CF.A(0,0,M.RRNG(0,360))*CF.N(0,Thicc*7,0)*CF.N(0,0,-1).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
						end
						LastB = prt
					end
				end
			end
		end
		if(Fades > 0)then
			coroutine.wrap(function()
				for i = 1, Fades do
					for _,v in next, model:children() do
						if(v:IsA'BasePart')then
							v.Transparency = (i/Fades)
						end
					end
					swait()
				end
				model:destroy()
			end)()
		else
			S.Debris:AddItem(model,.01)
		end
		return {End=(Last and Last.CFrame*CF.N(0,-Last.Size.Y/2,0).p),Last=Last,Model=model}
	end

	function Tween(obj,props,time,easing,direction,repeats,backwards)
		local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
		local tween = S.TweenService:Create(obj, info, props)

		tween:Play()
	end

	function Effect(data)
		local FX = data.Effect or 'ResizeAndFade'
		local Parent = data.Parent or Effects
		local Color = data.Color or C3.N(0,0,0)
		local Size = data.Size or V3.N(1,1,1)
		local MoveDir = data.MoveDirection or nil
		local MeshData = data.Mesh or nil
		local SndData = data.Sound or nil
		local Frames = data.Frames or 45
		local Manual = data.Manual or nil
		local Material = data.Material or nil
		local CFra = data.CFrame or Torso.CFrame
		local Settings = data.FXSettings or {}
		local Shape = data.Shape or Enum.PartType.Block
		local Snd,Prt,Msh;
		local RotInc = data.RotInc or {0,0,0}
		if(typeof(RotInc) == 'number')then
			RotInc = {RotInc,RotInc,RotInc}
		end
		coroutine.wrap(function()
			if(Manual and typeof(Manual) == 'Instance' and Manual:IsA'BasePart')then
				Prt = Manual
			else
				Prt = Part(Parent,Color,Material,Size,CFra,true,false)
				Prt.Shape = Shape
			end
			if(typeof(MeshData) == 'table')then
				Msh = Mesh(Prt,MeshData.MeshType,MeshData.MeshId,MeshData.TextureId,MeshData.Scale,MeshData.Offset)
			elseif(typeof(MeshData) == 'Instance')then
				Msh = MeshData:Clone()
				Msh.Parent = Prt
			elseif(Shape == Enum.PartType.Block)then
				Msh = Mesh(Prt,Enum.MeshType.Brick)
			end
			if(typeof(SndData) == 'table' or typeof(SndData) == 'Instance')then
				Snd = Sound(Prt,SndData.SoundId,SndData.Pitch,SndData.Volume,false,false,true)
			end
			if(Snd)then
				repeat swait() until Snd.Playing and Snd.IsLoaded and Snd.TimeLength > 0
				Frames = Snd.TimeLength * Frame_Speed/Snd.Pitch
			end
			Size = (Msh and Msh.Scale or Size)
			local grow = Size-(Settings.EndSize or (Msh and Msh.Scale or Size)/2)

			local MoveSpeed = nil;
			if(MoveDir)then
				MoveSpeed = (CFra.p - MoveDir).magnitude/Frames
			end
			if(FX ~= 'Arc')then
				for Frame = 1, Frames do
					if(FX == "Fade")then
						Prt.Transparency  = (Frame/Frames)
					elseif(FX == "Resize")then
						if(not Settings.EndSize)then
							Settings.EndSize = V3.N(0,0,0)
						end
						if(Settings.EndIsIncrement)then
							if(Msh)then
								Msh.Scale = Msh.Scale + Settings.EndSize
							else
								Prt.Size = Prt.Size + Settings.EndSize
							end					
						else
							if(Msh)then
								Msh.Scale = Msh.Scale - grow/Frames
							else
								Prt.Size = Prt.Size - grow/Frames
							end
						end 
					elseif(FX == "ResizeAndFade")then
						if(not Settings.EndSize)then
							Settings.EndSize = V3.N(0,0,0)
						end
						if(Settings.EndIsIncrement)then
							if(Msh)then
								Msh.Scale = Msh.Scale + Settings.EndSize
							else
								Prt.Size = Prt.Size + Settings.EndSize
							end					
						else
							if(Msh)then
								Msh.Scale = Msh.Scale - grow/Frames
							else
								Prt.Size = Prt.Size - grow/Frames
							end
						end 
						Prt.Transparency = (Frame/Frames)
					end
					if(Settings.RandomizeCFrame)then
						Prt.CFrame = Prt.CFrame * CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360))
					else
						Prt.CFrame = Prt.CFrame * CF.A(unpack(RotInc))
					end
					if(MoveDir and MoveSpeed)then
						local Orientation = Prt.Orientation
						Prt.CFrame = CF.N(Prt.Position,MoveDir)*CF.N(0,0,-MoveSpeed)
						Prt.Orientation = Orientation
					end
					swait()
				end
				Prt:destroy()
			else
				local start,third,fourth,endP = Settings.Start,Settings.Third,Settings.Fourth,Settings.End
				if(not Settings.End and Settings.Home)then endP = Settings.Home.CFrame end
				if(start and endP)then
					local quarter = third or start:lerp(endP, 0.25) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
					local threequarter = fourth or start:lerp(endP, 0.75) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
					for Frame = 0, 1, (Settings.Speed or 0.01) do
						if(Settings.Home)then
							endP = Settings.Home.CFrame
						end
						Prt.CFrame = Bezier(start, quarter, threequarter, endP, Frame)
					end
					if(Settings.RemoveOnGoal)then
						Prt:destroy()
					end
				else
					Prt:destroy()
					assert(start,"You need a start position!")
					assert(endP,"You need a start position!")
				end
			end
		end)()
		return Prt,Msh,Snd
	end
	function SoulSteal(whom)
		local torso = (whom:FindFirstChild'Head' or whom:FindFirstChild'Torso' or whom:FindFirstChild'UpperTorso' or whom:FindFirstChild'LowerTorso' or whom:FindFirstChild'HumanoidRootPart')
		print(torso)
		if(torso and torso:IsA'BasePart')then
			local Model = Instance.new("Model",Effects)
			Model.Name = whom.Name.."'s Soul"
			whom:BreakJoints()
			local Soul = Part(Model,BrickColor.new'Really red','Glass',V3.N(.5,.5,.5),torso.CFrame,true,false)
			Soul.Name = 'Head'
			NewInstance("Humanoid",Model,{Health=0,MaxHealth=0})
			Effect{
				Effect="Arc",
				Manual = Soul,
				FXSettings={
					Start=torso.CFrame,
					Home = Torso,
					RemoveOnGoal = true,
				}
			}
			local lastPoint = Soul.CFrame.p

			for i = 0, 1, 0.01 do 
				local point = CFrame.new(lastPoint, Soul.Position) * CFrame.Angles(-math.pi/2, 0, 0)
				local mag = (lastPoint - Soul.Position).magnitude
				Effect{
					Effect = "Fade",
					CFrame = point * CF.N(0, mag/2, 0),
					Size = V3.N(.5,mag+.5,.5),
					Color = Soul.BrickColor
				}
				lastPoint = Soul.CFrame.p
				swait()
			end
			for i = 1, 5 do
				Effect{
					Effect="Fade",
					Color = BrickColor.new'Really red',
					MoveDirection = (Torso.CFrame*CFrame.new(M.RNG(-40,40),M.RNG(-40,40),M.RNG(-40,40))).p
				}	
			end
		end
	end

	function MultiplyCF(cf,mult)
		local a,b,c,d,e,f,g,h,i,j,k,l = cf:components()
		return CF.N(a*mult,b*mult,c*mult,d*mult,e*mult,f*mult,g*mult,h*mult,i*mult,j*mult,k*mult,l*mult)
	end

	function ResetVoodoo()
		print("Resetted")
	end

	function ChangeTarget(who)
		local h = who:FindFirstChildOfClass'Humanoid'
		ResetVoodoo()
		if(h and h.Health <= 0)then return end
		Target = who
	end

	function CastRay(startPos,endPos,range,ignoreList)
		local ray = Ray.new(startPos,(endPos-startPos).unit*range)
		local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Char},false,true)
		return part,pos,norm,(pos and (startPos-pos).magnitude)
	end

	function getRegion(point,range,ignore)
		return workspace:FindPartsInRegion3WithIgnoreList(R3.N(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
	end

	function clerp(startCF,endCF,alpha)
		return startCF:lerp(endCF, alpha)
	end

	function GetTorso(char)
		return char and (char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart')
	end

	function ShowDamage(Pos, Text, Time, Color)
		coroutine.wrap(function()
			local Rate = (1 / Frame_Speed)
			local Pos = (Pos or Vector3.new(0, 0, 0))
			local Text = (Text or "")
			local Time = (Time or 2)
			local Color = (Color or Color3.new(1, 0, 1))
			local EffectPart = NewInstance("Part",Effects,{
				Material=Enum.Material.SmoothPlastic,
				Reflectance = 0,
				Transparency = 1,
				BrickColor = BrickColor.new(Color),
				Name = "Effect",
				Size = Vector3.new(0,0,0),
				Anchored = true,
				CFrame = CF.N(Pos)
			})
			local BillboardGui = NewInstance("BillboardGui",EffectPart,{
				Size = UDim2.new(1.25, 0, 1.25, 0),
				Adornee = EffectPart,
			})
			local TextLabel = NewInstance("TextLabel",BillboardGui,{
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 1, 0),
				Text = Text,
				Font = "Bodoni",
				TextColor3 = Color,
				TextStrokeColor3 = Color3.new(0,0,0),
				TextStrokeTransparency=0,
				TextScaled = true,
			})
			S.Debris:AddItem(EffectPart, (Time))
			EffectPart.Parent = workspace
			delay(0, function()
				Tween(EffectPart,{CFrame=CF.N(Pos)*CF.N(0,3,0)},Time,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
				local Frames = (Time / Rate)
				for Frame = 1, Frames do
					swait()
					local Percent = (Frame / Frames)
					TextLabel.TextTransparency = Percent
					TextLabel.TextStrokeTransparency = Percent
				end
				if EffectPart and EffectPart.Parent then
					EffectPart:Destroy()
				end
			end) end)()
	end

	function DealDamage(data)
		local Who = data.Who;
		local MinDam = data.MinimumDamage or 15;
		local MaxDam = data.MaximumDamage or 30;
		local MaxHP = data.MaxHP or 1e5; 

		local DB = data.Debounce or .2;

		local CritData = data.Crit or {}
		local CritChance = CritData.Chance or 0;
		local CritMultiplier = CritData.Multiplier or 1;

		local DamageEffects = data.DamageFX or {}
		local DamageType = DamageEffects.Type or "Normal"
		local DeathFunction = DamageEffects.DeathFunction

		assert(Who,"Specify someone to damage!")	

		local Humanoid = Who:FindFirstChildOfClass'Humanoid'
		local DoneDamage = 0

		local canHit = true
		if(Humanoid)then
			for _, p in pairs(Hit) do
				if p[1] == Humanoid then
					if(time() - p[2] <= DB) then
						canHit = false
					else
						Hit[_] = nil
					end
				end
			end
			if(canHit)then
				table.insert(Hit,{Humanoid,time()})
				local HitTorso = GetTorso(Who)
				local player = S.Players:GetPlayerFromCharacter(Who)
				if(not player or player.UserId ~= 5719877 and player.UserId ~= 61573184 and player.UserId ~= 19081129)then
					if(Humanoid.MaxHealth >= MaxHP and Humanoid.Health > 0)then
						print'Got kill'
						--Humanoid.Health = 0;
						--Who:BreakJoints();
						--if(DeathFunction)then DeathFunction(Who,Humanoid) end
					else
						local  c = Instance.new("ObjectValue",Hum)
						c.Name = "creator"
						c.Value = Plr
						S.Debris:AddItem(c,0.35)	
						if(Who:FindFirstChild'Head' and Humanoid.Health > 0)then
							--ShowDamage((Who.Head.CFrame * CF.N(0, 0, (Who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), DoneDamage, 1.5, DamageColor.Color)
						end
						--if(Humanoid.Health > 0 and Humanoid.Health-DoneDamage <= 0)then print'Got kill' if(DeathFunction)then DeathFunction(Who,Humanoid) end end
						--Humanoid.Health = Humanoid.Health - DoneDamage

						if(DamageType == 'Knockback' and HitTorso)then
							local up = DamageEffects.KnockUp or 25
							local back = DamageEffects.KnockBack or 25
							local origin = DamageEffects.Origin or Root
							local decay = DamageEffects.Decay or .5;

							local bfos = Instance.new("BodyVelocity",HitTorso)
							bfos.P = 20000	
							bfos.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
							bfos.Velocity = Vector3.new(0,up,0) + (origin.CFrame.lookVector * back)
							S.Debris:AddItem(bfos,decay)
						end
					end
				end
			end
		end		
	end

	function Kill(dude)
		Kills = Kills + 1
		local t = GetTorso(dude)
		local h = dude:FindFirstChildOfClass'Humanoid'
		if(dude == Target)then
			Target = nil
			ResetVoodoo()
		end
		if(h)then Instance.new("BoolValue",h).Name = 'Killed' end
		if(t)then
			Sound(t,429400881,.7,3,false,true,true)
			local pe = NewInstance("ParticleEmitter",t,{Size=NumberSequence.new(.2,5),Enabled=false,Texture='rbxassetid://771221224',Speed=NumberRange.new(15),VelocitySpread=90,Color=ColorSequence.new(C3.N(1,0,0)),Transparency=NumberSequence.new(0,1),ZOffset=.8,Acceleration=V3.N(0,-25,0),EmissionDirection=Enum.NormalId.Top,Lifetime=NumberRange.new(1),Rate=2500,Rotation=NumberRange.new(-100,100),RotSpeed=NumberRange.new(-100,100),})
			pe:Emit(250)
			NoobySphere(1,0,'Multiply',t.CFrame,V3.N(1,1,1),.1,C3.N(.4,0,0),0,nil,'xyz')
			ResetVoodoo()
			coroutine.wrap(function()
				swait(60)
				for i = 0, 1, .025 do
					for _,v in next, dude:children() do
						if(v:IsA'BasePart' and v.Name ~= 'HumanoidRootPart')then
							--v.Transparency = i
						end
					end
					swait()
				end
				for _,v in next, dude:children() do
					if(v:IsA'BasePart')then
						--v:destroy()
					end
				end
			end)()



		end
		--dude:breakJoints()
	end

	function Burn(dude)
		local t = GetTorso(dude)
		local h = dude:FindFirstChildOfClass'Humanoid'
		if(t and h)then
			local pe = NewInstance("ParticleEmitter",t,{Color=ColorSequence.new(C3.RGB(255,105,19),C3.RGB(255,255,127)),LightEmission=.8,Size=NumberSequence.new(1,0),Transparency=NumberSequence.new(0,1),Texture='rbxassetid://242102147',ZOffset=.3,EmissionDirection=Enum.NormalId.Top,Rate=1000,Lifetime=NumberRange.new(1),Speed=NumberRange.new(5)})
			Sound(t,192104941,.8,5,false,true,true)
			Sound(t,147758746,1,5,false,true,true)
			coroutine.wrap(function()
				repeat h.Health = h.Health - (h.MaxHealth/200) swait() until h.Health <= 0
				dude:breakJoints()
				if(not h:FindFirstChild'Killed')then Kills = Kills + 1 end
				h:destroy()
				if(dude == Target)then
					Target = nil
					ResetVoodoo()
				end
				NoobySphere(1,0,'Multiply',t.CFrame,V3.N(1,1,1),.1,C3.N(.4,0,0),0,nil,'xyz')
				swait(60)
				for i = 0, 1, .025 do
					for _,v in next, dude:children() do
						if(v:IsA'BasePart' and v.Name ~= 'HumanoidRootPart')then
							v.Transparency = i
							v.Color = C3.N(0,0,0)
							v.Material = Enum.Material.Slate
						end
					end
					swait()
				end
				for _,v in next, dude:children() do
					if(v:IsA'BasePart')then
						v:destroy()
					end
				end
			end)()
		end
	end

	function AOEDamage(where,range,options)
		local hit = {}
		for _,v in next, getRegion(where,range,{Char}) do
			if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' and not hit[v.Parent])then
				local callTable = {Who=v.Parent}
				hit[v.Parent] = true
				for _,v in next, options do callTable[_] = v end
				DealDamage(callTable)
			end
		end
		return hit
	end

	function AOEHeal(where,range,amount)
		local healed = {}
		for _,v in next, getRegion(where,range,{Char}) do
			local hum = (v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' or nil)
			if(hum and not healed[hum])then
				hum.Health = hum.Health + amount
				if(v.Parent:FindFirstChild'Head' and hum.Health > 0)then
					ShowDamage((v.Parent.Head.CFrame * CF.N(0, 0, (v.Parent.Head.Size.Z / 2)).p+V3.N(0,1.5,0)), "+"..amount, 1.5, BrickColor.new'Lime green'.Color)
				end
			end
		end
	end

	function BurnANigga()
		Attack = true
		NeutralAnims = false
		local Target = Target
		for i = 0, 3, 0.1 do
			swait()
			local Alpha = .2
			RJ.C0 = RJ.C0:lerp(CFrame.new(-7.21813294e-08, -0.0789605454, -7.5250864e-07, 0.999996543, 8.32955209e-07, 4.22970459e-07, 9.11652307e-07, 0.965796173, 0.259301841, 1.96043004e-07, -0.259301394, 0.965792596),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.499999344, -1.02113664, -2.92062759e-06, 0.996191025, 0.0871564001, 1.89523718e-07, -0.0841739103, 0.962121129, -0.259301454, -0.0225992389, 0.258315265, 0.965792596),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.499997526, -1.0211345, -1.49011612e-07, 0.996191263, -0.087154597, 2.02503998e-07, 0.0841755792, 0.96212101, -0.259301454, 0.0226000845, 0.258315176, 0.965792596),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-1.48020887, 0.396520793, -0.0840251297, 0.125036538, -0.110845402, 0.985939026, -0.0894355327, 0.988434374, 0.122468963, -0.988111138, -0.103490412, 0.113677412),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(1.49998105, 0.499911726, 1.90734863e-06, 0.902840197, -0.0815670565, 0.422160357, 0.389566094, -0.260352403, -0.883433402, 0.18197079, 0.962058306, -0.20328176),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(2.08616257e-06, 1.50000572, 1.21630728e-06, 0.102758601, -0.164331287, 0.981036484, -0.0197002441, 0.985729218, 0.167181715, -0.994509459, -0.0365053862, 0.098055318),Alpha)
		end
		knife.Transparency = 1
		local Match = New("Model",Char,"Match",{})
		local Handle = New("Part",Match,"Handle",{BrickColor = BrickColor.new("Brick yellow"),Material = Enum.Material.Wood,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.200000003, 1.2069068, 0.200000003),CFrame = CFrame.new(22.6316547, 30.6187859, 20.0125217, 0.836512625, -0.224143878, -0.499997824, 0.258817941, 0.965925753, 2.13843787e-08, 0.482960761, -0.129409477, 0.866021514),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.843137, 0.772549, 0.603922),})

		local FXHead = New("Part",Match,"FXHead",{BrickColor = BrickColor.new("Dusty Rose"),Material = Enum.Material.Concrete,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.144828811, 0.225289285, 0.144828811),CFrame = CFrame.new(22.4783554, 31.2793884, 19.9240131, 0.836508334, -0.224146977, -0.499995291, 0.258818597, 0.965925217, -3.05112985e-06, 0.482958704, -0.129407614, 0.866017997),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.639216, 0.294118, 0.294118),})
		local Mesh = New("SpecialMesh",FXHead,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		local mot = New("Motor",FXHead,"mot",{Part0 = FXHead,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.836515725, 0.258820862, 0.482963055, -0.224147007, 0.965925395, -0.129407734, -0.499999642, -3.10509813e-06, 0.866025686),C1 = CFrame.new(-7.62939453e-06, 0.683908463, -9.53674316e-07, 0.836512625, 0.258817941, 0.482960761, -0.224143878, 0.965925753, -0.129409477, -0.499997824, 2.13843787e-08, 0.866021514),})
		local MHead = New("Part",Match,"MHead",{BrickColor = BrickColor.new("Dusty Rose"),Material = Enum.Material.Concrete,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.0804604515, 0.0482763015, 0.0804604515),CFrame = CFrame.new(22.4945812, 31.209444, 19.9333839, 0.836508274, -0.224147394, -0.499995291, 0.258818835, 0.965925217, -3.39144185e-06, 0.482958704, -0.12940748, 0.866017878),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.639216, 0.294118, 0.294118),})
		local mot = New("Motor",MHead,"mot",{Part0 = MHead,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.836515665, 0.2588211, 0.482963055, -0.224147394, 0.965925276, -0.12940757, -0.499999642, -3.44821296e-06, 0.866025627),C1 = CFrame.new(-1.14440918e-05, 0.611497879, 1.90734863e-06, 0.836512625, 0.258817941, 0.482960761, -0.224143878, 0.965925753, -0.129409477, -0.499997824, 2.13843787e-08, 0.866021514),})	local Mesh = New("BlockMesh",Handle,"Mesh",{Scale = Vector3.new(0.400000006, 1, 0.400000006),})

		local fire = NewInstance("ParticleEmitter",FXHead,{
			Color = ColorSequence.new(C3.RGB(255,237,210),C3.RGB(255,170,0)),
			LightEmission=1,
			LightInfluence=0,
			Size=NumberSequence.new{NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(.3,.25),NumberSequenceKeypoint.new(.597,.312),NumberSequenceKeypoint.new(1,0)},	
			Texture='rbxassetid://242461088',
			Transparency=NumberSequence.new{NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(.199,.825),NumberSequenceKeypoint.new(.6,1),NumberSequenceKeypoint.new(1,1)},
			ZOffset=.2,
			Acceleration=V3.N(0,.75,0),
			LockedToPart=true,
			EmissionDirection=Enum.NormalId.Top,
			Lifetime=NumberRange.new(.75),
			Rate=50,
			Speed=NumberRange.new(0)
		})
		local HW = NewInstance('Weld',Char,{Part0=LArm,Part1=Handle,C0=CF.N(0,-1,0)*CF.A(M.R(-90),0,0)})
		for i = 0, 7, 0.1 do
			swait()
			local Alpha = .1
			RJ.C0 = RJ.C0:lerp(CFrame.new(-7.21805193e-08, -0.0789600536, 1.08964741e-06, 0.999996543, 8.32955209e-07, 4.22970459e-07, 9.11652307e-07, 0.965796173, 0.259301841, 1.96043004e-07, -0.259301394, 0.965792596),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.499998987, -1.02113318, -1.04308128e-06, 0.996191025, 0.0871564001, 1.89523718e-07, -0.0841739103, 0.962121129, -0.259301454, -0.0225992389, 0.258315265, 0.965792596),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.499997348, -1.02113235, -5.96046448e-07, 0.996191263, -0.087154597, 2.02503998e-07, 0.0841755792, 0.96212101, -0.259301454, 0.0226000845, 0.258315176, 0.965792596),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-1.28626728, 0.457301795, 0.0561587811, 0.779788852, 0.617777467, -0.101375088, -0.0164614469, -0.141639799, -0.98978132, -0.625823021, 0.773489416, -0.100280359),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(1.49997759, 0.499910235, 1.22189522e-06, 0.902840197, -0.0815670565, 0.422160357, 0.389566094, -0.260352403, -0.883433402, 0.18197079, 0.962058306, -0.20328176),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(3.81376594e-06, 1.5000037, 3.7914142e-06, 0.561061919, 0.0163413882, 0.827610493, -0.0240478665, 0.999704778, -0.00343565643, -0.827422142, -0.0179739445, 0.561289608),Alpha)
		end
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .15
			RJ.C0 = RJ.C0:lerp(CFrame.new(-7.21813294e-08, -0.0789605454, -7.5250864e-07, 0.999996543, 8.32955209e-07, 4.22970459e-07, 9.11652307e-07, 0.965796173, 0.259301841, 1.96043004e-07, -0.259301394, 0.965792596),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.499998987, -1.02113295, -1.96695328e-06, 0.996191025, 0.0871564001, 1.89523718e-07, -0.0841739103, 0.962121129, -0.259301454, -0.0225992389, 0.258315265, 0.965792596),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.499997348, -1.02113235, -5.96046448e-07, 0.996191263, -0.087154597, 2.02503998e-07, 0.0841755792, 0.96212101, -0.259301454, 0.0226000845, 0.258315176, 0.965792596),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-0.56364888, 0.845062912, -0.882486701, 0.556871235, -0.829850614, 0.0351991951, -0.0293087214, -0.0619851053, -0.99764663, 0.830079675, 0.554528773, -0.0588402748),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(1.49997818, 0.499908328, 1.7285347e-06, 0.902840197, -0.0815670565, 0.422160357, 0.389566094, -0.260352403, -0.883433402, 0.18197079, 0.962058306, -0.20328176),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(-2.10106373e-06, 1.50000787, -1.17905438e-06, 0.744260013, 0.016378643, -0.667686522, -0.000203326344, 0.999704778, 0.0242953151, 0.667887568, -0.0179455429, 0.74404341),Alpha)
		end
		Burn(Target)
		for i = 0, 6, 0.1 do
			swait()
			local Alpha = .15
			RJ.C0 = RJ.C0:lerp(CFrame.new(-7.21813294e-08, -0.0789605454, -7.5250864e-07, 0.999996543, 8.32955209e-07, 4.22970459e-07, 9.11652307e-07, 0.965796173, 0.259301841, 1.96043004e-07, -0.259301394, 0.965792596),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.499998987, -1.02113318, -1.04308128e-06, 0.996191025, 0.0871564001, 1.89523718e-07, -0.0841739103, 0.962121129, -0.259301454, -0.0225992389, 0.258315265, 0.965792596),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.499997348, -1.02113235, -5.96046448e-07, 0.996191263, -0.087154597, 2.02503998e-07, 0.0841755792, 0.96212101, -0.259301454, 0.0226000845, 0.258315176, 0.965792596),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-0.431874216, 0.854955196, -0.97056669, 0.117097467, -0.829880476, -0.545511901, -0.991014123, -0.0618889406, -0.118577883, 0.064643696, 0.554494739, -0.829670548),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(1.55841696, 0.530878901, -0.013287276, 0.846236467, 0.325094491, 0.422130316, 0.464434087, -0.0617963374, -0.883448958, -0.261117637, 0.943658531, -0.203279719),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(-3.43844295e-06, 1.50000417, 3.09199095e-07, 0.744260013, 0.016378643, -0.667686522, -0.000203326344, 0.999704778, 0.0242953151, 0.667887568, -0.0179455429, 0.74404341),Alpha)
		end
		for i = 0, 3, 0.1 do
			swait()
			local Alpha = .1
			RJ.C0 = RJ.C0:lerp(CFrame.new(-7.21813294e-08, -0.0789605454, -7.5250864e-07, 0.999996543, 8.32955209e-07, 4.22970459e-07, 9.11652307e-07, 0.965796173, 0.259301841, 1.96043004e-07, -0.259301394, 0.965792596),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.499999344, -1.02113664, -2.92062759e-06, 0.996191025, 0.0871564001, 1.89523718e-07, -0.0841739103, 0.962121129, -0.259301454, -0.0225992389, 0.258315265, 0.965792596),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.499997526, -1.0211345, -1.49011612e-07, 0.996191263, -0.087154597, 2.02503998e-07, 0.0841755792, 0.96212101, -0.259301454, 0.0226000845, 0.258315176, 0.965792596),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-1.48020887, 0.396520793, -0.0840251297, 0.125036538, -0.110845402, 0.985939026, -0.0894355327, 0.988434374, 0.122468963, -0.988111138, -0.103490412, 0.113677412),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(1.49998105, 0.499911726, 1.90734863e-06, 0.902840197, -0.0815670565, 0.422160357, 0.389566094, -0.260352403, -0.883433402, 0.18197079, 0.962058306, -0.20328176),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(2.08616257e-06, 1.50000572, 1.21630728e-06, 0.102758601, -0.164331287, 0.981036484, -0.0197002441, 0.985729218, 0.167181715, -0.994509459, -0.0365053862, 0.098055318),Alpha)
		end
		knife.Transparency = 0
		Match:destroy()
		Attack = false
		NeutralAnims = true

	end

	function KillVoodoo()
		Attack = true
		NeutralAnims = false
		WalkSpeed = 0
		local Target = Target
		for i = 0, 1.9, 0.1 do
			swait()
			local Alpha = .1
			RJ.C0 = RJ.C0:lerp(CFrame.new(-7.21813294e-08, -0.0789605454, -7.5250864e-07, 0.999996543, 8.32955209e-07, 4.22970459e-07, 9.11652307e-07, 0.965796173, 0.259301841, 1.96043004e-07, -0.259301394, 0.965792596),Alpha)
			LH.C0 = LH.C0:lerp(CFrame.new(-0.500003159, -1.02113652, -1.87754631e-06, 0.996191025, 0.0871564001, 1.89523718e-07, -0.0841739103, 0.962121129, -0.259301454, -0.0225992389, 0.258315265, 0.965792596),Alpha)
			RH.C0 = RH.C0:lerp(CFrame.new(0.500005007, -1.02113163, -4.17232513e-07, 0.996191263, -0.087154597, 2.02503998e-07, 0.0841755792, 0.96212101, -0.259301454, 0.0226000845, 0.258315176, 0.965792596),Alpha)
			LS.C0 = LS.C0:lerp(CFrame.new(-1.30809402, 0.707052946, -0.212298125, 0.324948817, 0.857990444, 0.397815555, 0.638829648, -0.509305477, 0.576632023, 0.697354972, 0.0667604953, -0.71360743),Alpha)
			RS.C0 = RS.C0:lerp(CFrame.new(1.17349327, 0.596340418, -0.226585925, 0.880390525, 0.216107711, 0.422145128, 0.452990264, -0.119689628, -0.883444428, -0.140392065, 0.969003797, -0.203268766),Alpha)
			NK.C0 = NK.C0:lerp(CFrame.new(4.42750752e-06, 1.50000238, 4.23006713e-06, 0.827343702, 0.0163316131, -0.561455429, -0.00340057909, 0.99970448, 0.024066925, 0.56168288, -0.0180016756, 0.827154636),Alpha)	
		end
		local gay = Plrs:GetPlayerFromCharacter(Target)
		if(not gay or Plr.UserId == 5719877 or gay.UserId ~= 5719877 and gay.UserId ~= 19909695 and gay.UserId ~= 33104243)then
			Kill(Target)
			for i = 0, 1.2, 0.1 do
				swait()
				local Alpha = .2
				RJ.C0 = RJ.C0:lerp(CFrame.new(-7.21813294e-08, -0.0789605454, -7.5250864e-07, 0.999996543, 8.32955209e-07, 4.22970459e-07, 9.11652307e-07, 0.965796173, 0.259301841, 1.96043004e-07, -0.259301394, 0.965792596),Alpha)
				LH.C0 = LH.C0:lerp(CFrame.new(-0.500003159, -1.02113652, -1.87754631e-06, 0.996191025, 0.0871564001, 1.89523718e-07, -0.0841739103, 0.962121129, -0.259301454, -0.0225992389, 0.258315265, 0.965792596),Alpha)
				RH.C0 = RH.C0:lerp(CFrame.new(0.500005007, -1.02113163, -4.17232513e-07, 0.996191263, -0.087154597, 2.02503998e-07, 0.0841755792, 0.96212101, -0.259301454, 0.0226000845, 0.258315176, 0.965792596),Alpha)
				LS.C0 = LS.C0:lerp(CFrame.new(-0.765871823, 0.875704765, -0.619495153, 0.324934751, -0.587293684, 0.74128288, 0.638849139, -0.441647798, -0.629935622, 0.697343588, 0.678255379, 0.231685296),Alpha)
				RS.C0 = RS.C0:lerp(CFrame.new(1.17349327, 0.596340418, -0.226585925, 0.880390525, 0.216107711, 0.422145128, 0.452990264, -0.119689628, -0.883444428, -0.140392065, 0.969003797, -0.203268766),Alpha)
				NK.C0 = NK.C0:lerp(CFrame.new(4.42750752e-06, 1.50000238, 4.23006713e-06, 0.827343702, 0.0163316131, -0.561455429, -0.00340057909, 0.99970448, 0.024066925, 0.56168288, -0.0180016756, 0.827154636),Alpha)
			end
			for i = 0, .9, 0.1 do
				swait()
				local Alpha = .2
				RJ.C0 = RJ.C0:lerp(CFrame.new(-2.16149999e-07, -0.0789605081, -7.11530447e-07, 0.999989629, 2.49221875e-06, 1.27442513e-06, 2.73494675e-06, 0.965795875, 0.259301215, 5.88124067e-07, -0.259299994, 0.965785265),Alpha)
				LH.C0 = LH.C0:lerp(CFrame.new(-0.500001371, -1.02113628, -5.54323196e-06, 0.996183932, 0.0871576071, 5.81604752e-07, -0.0841722414, 0.96212101, -0.259300053, -0.0225983392, 0.258314729, 0.965785265),Alpha)
				RH.C0 = RH.C0:lerp(CFrame.new(0.49999243, -1.02113175, -5.66244125e-06, 0.996184528, -0.0871521831, 5.94584947e-07, 0.0841772109, 0.962120533, -0.259300053, 0.0226008799, 0.25831449, 0.965785265),Alpha)
				LS.C0 = LS.C0:lerp(CFrame.new(-1.34198368, 0.383808315, 0.099660337, 0.324967146, 0.259882778, 0.90930742, 0.638826787, -0.76930356, -0.00842937827, 0.697345734, 0.583627462, -0.416016668),Alpha)
				RS.C0 = RS.C0:lerp(CFrame.new(1.1734798, 0.596339762, -0.226573557, 0.880385041, 0.216106832, 0.422140598, 0.452991217, -0.1196879, -0.883443415, -0.140389711, 0.968996823, -0.203268081),Alpha)
				NK.C0 = NK.C0:lerp(CFrame.new(4.42750752e-06, 1.50000238, 4.23006713e-06, 0.827343702, 0.0163316131, -0.561455429, -0.00340057909, 0.99970448, 0.024066925, 0.56168288, -0.0180016756, 0.827154636),Alpha)	
			end
		else
			for i = 0, 1.2, 0.1 do
				swait()
				local Alpha = .2
				RJ.C0 = RJ.C0:lerp(CFrame.new(-7.21813294e-08, -0.0789605454, -7.5250864e-07, 0.999996543, 8.32955209e-07, 4.22970459e-07, 9.11652307e-07, 0.965796173, 0.259301841, 1.96043004e-07, -0.259301394, 0.965792596),Alpha)
				LH.C0 = LH.C0:lerp(CFrame.new(-0.500003159, -1.02113652, -1.87754631e-06, 0.996191025, 0.0871564001, 1.89523718e-07, -0.0841739103, 0.962121129, -0.259301454, -0.0225992389, 0.258315265, 0.965792596),Alpha)
				RH.C0 = RH.C0:lerp(CFrame.new(0.500005007, -1.02113163, -4.17232513e-07, 0.996191263, -0.087154597, 2.02503998e-07, 0.0841755792, 0.96212101, -0.259301454, 0.0226000845, 0.258315176, 0.965792596),Alpha)
				LS.C0 = LS.C0:lerp(CFrame.new(-0.765871823, 0.875704765, -0.619495153, 0.324934751, -0.587293684, 0.74128288, 0.638849139, -0.441647798, -0.629935622, 0.697343588, 0.678255379, 0.231685296),Alpha)
				RS.C0 = RS.C0:lerp(CFrame.new(1.34997082, 0.691436887, -0.00414918363, 0.308846682, -0.493054748, -0.813330948, -0.13198103, 0.824647903, -0.550033391, 0.94190836, 0.277220637, 0.18961516),Alpha)
				NK.C0 = NK.C0:lerp(CFrame.new(4.42750752e-06, 1.50000238, 4.23006713e-06, 0.827343702, 0.0163316131, -0.561455429, -0.00340057909, 0.99970448, 0.024066925, 0.56168288, -0.0180016756, 0.827154636),Alpha)
			end
			for i = 0, .9, 0.1 do
				swait()
				local Alpha = .2
				RJ.C0 = RJ.C0:lerp(CFrame.new(-2.16149999e-07, -0.0789605081, -7.11530447e-07, 0.999989629, 2.49221875e-06, 1.27442513e-06, 2.73494675e-06, 0.965795875, 0.259301215, 5.88124067e-07, -0.259299994, 0.965785265),Alpha)
				LH.C0 = LH.C0:lerp(CFrame.new(-0.500001371, -1.02113628, -5.54323196e-06, 0.996183932, 0.0871576071, 5.81604752e-07, -0.0841722414, 0.96212101, -0.259300053, -0.0225983392, 0.258314729, 0.965785265),Alpha)
				RH.C0 = RH.C0:lerp(CFrame.new(0.49999243, -1.02113175, -5.66244125e-06, 0.996184528, -0.0871521831, 5.94584947e-07, 0.0841772109, 0.962120533, -0.259300053, 0.0226008799, 0.25831449, 0.965785265),Alpha)
				LS.C0 = LS.C0:lerp(CFrame.new(-1.34198368, 0.383808315, 0.099660337, 0.324967146, 0.259882778, 0.90930742, 0.638826787, -0.76930356, -0.00842937827, 0.697345734, 0.583627462, -0.416016668),Alpha)
				RS.C0 = RS.C0:lerp(CFrame.new(1.34997082, 0.691436887, -0.00414918363, 0.308846682, -0.493054748, -0.813330948, -0.13198103, 0.824647903, -0.550033391, 0.94190836, 0.277220637, 0.18961516),Alpha)
				NK.C0 = NK.C0:lerp(CFrame.new(4.42750752e-06, 1.50000238, 4.23006713e-06, 0.827343702, 0.0163316131, -0.561455429, -0.00340057909, 0.99970448, 0.024066925, 0.56168288, -0.0180016756, 0.827154636),Alpha)	
			end
		end
		WalkSpeed = 8
		Attack = false
		NeutralAnims = true
		repeat wait() until Attack == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if Attack == true then
				if Target:FindFirstChild("UpperTorso") then
					bp.Position = Target:FindFirstChild("UpperTorso").Position
				elseif Target:FindFirstChild("Torso") then
					bp.Position = Target:FindFirstChild("Torso").Position
				end
			end
		until Attack == false
	end

	Mouse.KeyDown:connect(function(k)
		if(Attack)then return end
		if(k == 'q')then
			local targ = (Mouse.Target and Mouse.Target.Parent)
			if(targ and GetTorso(targ) and targ:FindFirstChildOfClass'Humanoid')then
				ChangeTarget(targ)
			end
		elseif(k == 'z' and Target)then
			BurnANigga()
		end
	end)

	Mouse.Button1Down:connect(function()
		if(Attack)then return end
		if(Target)then
			KillVoodoo()

		else
		end
	end)

	coroutine.wrap(function()
		while true do
			if(M.RNG(1,350) == 1 and not Glitching)then
				for i = 1, M.RNG(100,300)/100 do
					local TP = Music.TimePosition
					Glitching = true
					swait(M.RNG(15,30))
					Glitching = false
					Music.TimePosition = TP
				end
			end
			swait()
		end	
	end)()

	local Texts = {"INSANITY","BURN","DIE","CRY","VOODOO","NO STRINGS ATTACHED"}
	coroutine.wrap(function()
		while true do
			if(M.RNG(1,65) >= (Glitching and 5 or 40))then
				local frame = NewInstance("Frame",gui,{Size=UDim2.new(.26,0,.07,0),BackgroundTransparency=1,Position=UDim2.new(M.RNG(0,100)/100,0,M.RNG(0,100)/100,0)})
				local fat = Texts[M.RNG(1,#Texts)]
				local toxt = "";
				for i = 1, #fat do
					if(M.RNG(1,2) == 1)then
						toxt = toxt..fat:sub(i,i):lower()
					else
						toxt = toxt..fat:sub(i,i)
					end
				end
				local rot = M.RNG(-15,15)
				local txt = NewInstance('TextLabel',frame,{Rotation=rot,TextTransparency=1,Text=toxt,TextColor3=C3.N(M.RNG(50,100)/100,0,0),FontSize=M.RNG(8,14),Font=Enum.Font.Antique})	
				coroutine.wrap(function()
					for i = 1, 30 do
						swait()
						txt.Rotation = rot+M.RNG(-15,15)
						txt.TextTransparency = txt.TextTransparency - 1/30
					end
					for i = 1, 30 do
						swait()
						txt.Rotation = rot+M.RNG(-15,15)
						txt.TextTransparency = txt.TextTransparency + 1/30
					end
					txt:destroy()
				end)()
			end
			swait()
		end
	end)()

	local FT,RA,LA,RL,LL = Instance.new("BlockMesh"),Instance.new("BlockMesh"),Instance.new("BlockMesh"),Instance.new("BlockMesh"),Instance.new("BlockMesh")

	local Meshes = {FT,RA,LA,RL,LL}

	for _,v in next, Char:GetDescendants() do
		if(v:IsA'DataModelMesh')then
			table.insert(Meshes,v)
		end
	end

	while true do
		swait()

		if(Target and (not Target.Parent or not Target:FindFirstChildOfClass'Humanoid' or Target:FindFirstChildOfClass'Humanoid'.Health <= 0))then
			Target = nil
			ResetVoodoo()
		end
		txt.Rotation = M.RNG(-150,150)/150
		txt.Text = 'Target: '..(Target and Target.Name or '')

		ktxt.Rotation = M.RNG(-150,150)/150
		ktxt.Text = 'Kills: '..Kills

		Hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None

		VHum.PlatformStand = true
		VHum:ChangeState(Enum.HumanoidStateType.Physics)
		VHum:SetStateEnabled(Enum.HumanoidStateType.Dead,false)

		Sine = Sine + Change
		if(not Music or not Music.Parent)then
			local tp = (Music and Music.TimePosition)
			Music = Sound(Char,MusicID,1,10,true,false,true)
			Music.Name = 'Music'
			Music.TimePosition = tp
		end
		Music.SoundId = "rbxassetid://"..MusicID
		Music.Parent = Torso
		Music.Pitch = (Glitching and M.RNG(55,175)/100 or 1)
		Music.Volume = 3
		if(not Muted)then
			Music:Resume()
		else
			Music:Pause()
		end

		if(God)then
			Hum.MaxHealth = 1e100
			Hum.Health = 1e100
			if(not Char:FindFirstChildOfClass'ForceField')then IN("ForceField",Char).Visible = false end
			Hum.Name = M.RNG()*100
		end

		local hitfloor,posfloor = workspace:FindPartOnRay(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4*PlayerSize)), Char)

		local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
		local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or not hitfloor and Root.Velocity.y < -1 and "Fall" or not hitfloor and Root.Velocity.y > 1 and "Jump" or hitfloor and Walking and (Hum.WalkSpeed < 24 and "Walk" or "Run") or hitfloor and "Idle")
		if(not Effects or not Effects.Parent)then
			Effects = IN("Model",Char)
			Effects.Name = "Effects"
		end																																																																																																				
		if(State == 'Run')then
			local wsVal = 16 / (Hum.WalkSpeed/16)
			local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
			Change = 1
			RH.C1 = RH.C1:lerp(CF.N(0,1-.5*M.C(Sine/wsVal)/2,.5*M.C(Sine/wsVal)/2)*CF.A(M.R(25-15*M.C(Sine/wsVal))+-M.S(Sine/wsVal)/2,0,0),Alpha)
			LH.C1 = LH.C1:lerp(CF.N(0,1+.5*M.C(Sine/wsVal)/2,-.5*M.C(Sine/wsVal)/2)*CF.A(M.R(25+15*M.C(Sine/wsVal))+M.S(Sine/wsVal)/2,0,0),Alpha)
		elseif(State == 'Walk')then
			local wsVal = 7 / (Hum.WalkSpeed/16)
			local Alpha = math.min(.15 * (Hum.WalkSpeed/16),1)
			Change = 1
			RH.C1 = RH.C1:lerp(CF.N(0,1-.5*M.C(Sine/wsVal)/2,.5*M.C(Sine/wsVal)/2)*CF.A(M.R(15-5*M.C(Sine/wsVal))+-M.S(Sine/wsVal)/2,0,0),Alpha)
			LH.C1 = LH.C1:lerp(CF.N(0,1+.5*M.C(Sine/wsVal)/2,-.5*M.C(Sine/wsVal)/2)*CF.A(M.R(15+5*M.C(Sine/wsVal))+M.S(Sine/wsVal)/2,0,0),Alpha)
		else
			RH.C1 = RH.C1:lerp(CF.N(0,1,0),.2)
			LH.C1 = LH.C1:lerp(CF.N(0,1,0),.2)
		end
		Hum.WalkSpeed = WalkSpeed
		if(Remove_Hats)then Instance.ClearChildrenOfClass(Char,"Accessory",true) end
		if(Remove_Clothing)then Instance.ClearChildrenOfClass(Char,"Clothing",true) Instance.ClearChildrenOfClass(Char,"ShirtGraphic",true) end

		if(Glitching)then
			Hum.CameraOffset = V3.N(M.RNG(-25,25)/100,M.RNG(-25,25)/100,M.RNG(-25,25)/100)
		elseif(not Hum:FindFirstChild'CamShaking')then
			Hum.CameraOffset = V3.N(0,0,0)
		end

		if(Glitching)then
			RA.Parent = RArm
			LA.Parent = LArm
			FT.Parent = Torso
			RL.Parent = RLeg
			LL.Parent = LLeg
			for _,v in next, Meshes do
				v.Offset = V3.N(M.RNG(-25,25)/100,M.RNG(-25,25)/100,M.RNG(-25,25)/100)
			end	

			RLeg.Material = Enum.Material.Neon
			LLeg.Material = Enum.Material.Neon
			RArm.Material = Enum.Material.Neon
			LArm.Material = Enum.Material.Neon
			Torso.Material = Enum.Material.Neon	
			Head.Material = Enum.Material.Neon	
		else
			for _,v in next, Meshes do
				v.Offset = V3.N(0,0,0)
			end
			RA.Parent = nil
			LA.Parent = nil
			FT.Parent = nil
			RL.Parent = nil
			LL.Parent = nil
			RLeg.Material = Enum.Material.SmoothPlastic
			LLeg.Material = Enum.Material.SmoothPlastic
			RArm.Material = Enum.Material.SmoothPlastic
			LArm.Material = Enum.Material.SmoothPlastic
			Torso.Material = Enum.Material.SmoothPlastic
			Head.Material = Enum.Material.SmoothPlastic
		end

		if(NeutralAnims)then	
			if(State == 'Idle')then
				local Alpha = .1
				Change = 1
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),.3)
				if(M.RNG(1,45) == 45)then
					NK.C0 = NK.C0:lerp(NKC0*CF.N(0,0,0)*CF.A(M.RRNG(15,65),M.RRNG(-35,35),0),1)
				end
				if(not Glitching)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-.1+.05*M.C(Sine/24),0)*CF.A(M.R(-15),0,0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(15),0,M.R(-5-5*M.C(Sine/24))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(105-5*M.C(Sine/24)),M.R(25),M.R(5+5*M.C(Sine/16))),Alpha)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/24),0)*CF.A(M.R(15),0,M.R(-5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/24),0)*CF.A(M.R(15),0,M.R(5)),Alpha)
				else
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-.2+.1*M.C(Sine/24),0)*CF.A(M.R(-45),0,0),1)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,.1*M.C(Sine/24),0)*CF.A(M.R(180),0,M.R(25)+M.RRNG(-3,3)),1)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,.1*M.C(Sine/24),0)*CF.A(M.R(180),0,M.R(-25)+M.RRNG(-3,3)),1)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-.1*M.C(Sine/24),0)*CF.A(M.R(45),0,M.R(-5)),1)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-.1*M.C(Sine/24),0)*CF.A(M.R(45),0,M.R(5)),1)
					NK.C0 = NK.C0:lerp(NKC0*CF.N(0,0,-.2)*CF.A(M.R(-25),0,0)*CF.A(M.RRNG(-5,5),M.RRNG(-3,3),0),.1)
				end

			elseif(State == 'Run')then
				local wsVal = 7 / (Hum.WalkSpeed/16)
				local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
				RJ.C0 = RJ.C0:lerp(CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-15+2.5*M.C(Sine/(wsVal/2))),M.R(8*M.C(Sine/wsVal)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0-.3*M.S(Sine/wsVal))*CF.A(M.R(0+45*M.S(Sine/wsVal)),0,M.R(-5)),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0+.3*M.S(Sine/wsVal))*CF.A(M.R(0-45*M.S(Sine/wsVal)),0,M.R(5)),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
			elseif(State == 'Walk')then
				local wsVal = 7 / (Hum.WalkSpeed/16)
				local Alpha = math.min(.15 * (Hum.WalkSpeed/16),1)			
				NK.C0 = NK.C0:lerp(NKC0*CF.A(0,-Head.RotVelocity.y/75,0)*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),.3)
				if(M.RNG(1,45) == 45)then
					NK.C0 = NK.C0:lerp(NKC0*CF.N(0,0,0)*CF.A(M.RRNG(15,65),M.RRNG(-35,35),0),1)
				end
				if(not Glitching)then
					RJ.C0 = RJ.C0:lerp(CF.N(0,-.075+.1*M.C(Sine/(wsVal/2)+-M.S(Sine/(wsVal/2))/7),0)*CF.A(M.R(-15-2.5*M.C(Sine/(wsVal/2))),M.R(4*M.C(Sine/wsVal)),Root.RotVelocity.y/75),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,-.27*M.C(Sine/wsVal))*CF.A(M.R(28*M.C(Sine/wsVal)),0,M.R(-5-7*M.S(Sine/wsVal))+LArm.RotVelocity.y/35),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(105-5*M.C(Sine/24)),M.R(25),M.R(5+5*M.C(Sine/16))),Alpha)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(15+2.5*M.C(Sine/(wsVal/2))),M.R(-4*M.C(Sine/wsVal)),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(15+2.5*M.C(Sine/(wsVal/2))),M.R(-4*M.C(Sine/wsVal)),0),Alpha)
				else
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-.2+.1*M.C(Sine/24),0)*CF.A(M.R(-45),0,0),1)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,.1*M.C(Sine/24),0)*CF.A(M.R(180),0,M.R(25)+M.RRNG(-3,3)),1)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,.1*M.C(Sine/24),0)*CF.A(M.R(180),0,M.R(-25)+M.RRNG(-3,3)),1)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-.1*M.C(Sine/24),0)*CF.A(M.R(45),0,M.R(-5)),1)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-.1*M.C(Sine/24),0)*CF.A(M.R(45),0,M.R(5)),1)
					NK.C0 = NK.C0:lerp(NKC0*CF.N(0,0,-.2)*CF.A(M.R(-25),0,0)*CF.A(M.RRNG(-5,5),M.RRNG(-3,3),0),.1)
				end

			elseif(State == 'Jump')then
				local Alpha = .1
				local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			elseif(State == 'Fall')then
				local Alpha = .1
				local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			elseif(State == 'Paralyzed')then
			elseif(State == 'Sit')then
			end
		end

		for i,v in next, BloodPuddles do
			local mesh = i:FindFirstChild'CylinderMesh'
			BloodPuddles[i] = v + 1
			if(not mesh or i.Transparency >= 1)then
				i:destroy() 
				BloodPuddles[i] = nil
			elseif(v >= Frame_Speed*4)then
				local trans = (v-Frame_Speed*4)/(Frame_Speed*2)
				i.Transparency = trans
				if(mesh.Scale.Z > 0)then
					mesh.Scale = mesh.Scale-V3.N(.05,0,.05)
				end
			else
				i.Transparency = 0
			end
		end
	end
end)

Button_2.MouseButton1Down:Connect(function()
	local script = game:GetObjects("rbxassetid://5985812536")[1]

	wait(0.2)
	Player = game:GetService("Players").LocalPlayer
	PlayerGui = Player.PlayerGui
	Cam = workspace.CurrentCamera
	Backpack = Player.Backpack
	Character = Player.Character["Dummy"]
	Humanoid = Character.Humanoid
	Mouse = Player:GetMouse()
	RootPart = Character.HumanoidRootPart
	Torso = Character.Torso
	Head = Character.Head
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart.RootJoint
	Neck = Torso.Neck
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	local sick = Instance.new("Sound", RootPart)
	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor
	Animation_Speed = 3
	Frame_Speed = 0.016666666666666666
	local Speed = 12
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local DAMAGEMULTIPLIER = 1
	local ANIM = "Idle"
	local ATTACK = false
	local EQUIPPED = false
	local HOLD = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local KEYHOLD = false
	local CHANGE = 2 / Animation_Speed
	local WALKINGANIM = false
	local VALUE1 = false
	local VALUE2 = false
	local ROBLOXIDLEANIMATION = IT("Animation")
	ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
	ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
	local WEAPONGUI = IT("ScreenGui", PlayerGui)
	WEAPONGUI.Name = "Weapon GUI"
	local Effects = IT("Folder", Character)
	Effects.Name = "Effects"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character.Animate
	ANIMATOR:Destroy()
	local UNANCHOR = true
	local EXTRATRANS = 0
	local MUTE = true
	local HITPLAYERSOUNDS = {
		"263032172",
		"263032182",
		"263032200",
		"263032221",
		"263032252",
		"263033191"
	}
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"
	script:WaitForChild("ArtificialHB")
	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()
	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end
	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end
	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end
	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end
	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id=" .. MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id=" .. TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end
	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end
	local weldBetween = function(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end
	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m00 < m11 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s
				return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end
	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end
	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp
		if cosTheta >= 1.0E-4 then
			if 1 - cosTheta > 1.0E-4 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		elseif 1 + cosTheta > 1.0E-4 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end
	function Clerp(a, b, t)
		local qa = {
			QuaternionFromCFrame(a)
		}
		local qb = {
			QuaternionFromCFrame(b)
		}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end
	function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
		local frame = IT("Frame")
		frame.BackgroundTransparency = TRANSPARENCY
		frame.BorderSizePixel = BORDERSIZEPIXEL
		frame.Position = POSITION
		frame.Size = SIZE
		frame.BackgroundColor3 = COLOR
		frame.BorderColor3 = BORDERCOLOR
		frame.Name = NAME
		frame.Parent = PARENT
		return frame
	end
	function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
		local label = IT("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UD2(1, 0, 1, 0)
		label.Position = UD2(0, 0, 0, 0)
		label.TextColor3 = TEXTCOLOR
		label.TextStrokeTransparency = STROKETRANSPARENCY
		label.TextTransparency = TRANSPARENCY
		label.FontSize = TEXTFONTSIZE
		label.Font = TEXTFONT
		label.BorderSizePixel = BORDERSIZEPIXEL
		label.TextScaled = false
		label.Text = TEXT
		label.Name = NAME
		label.Parent = PARENT
		return label
	end
	function NoOutlines(PART)
		PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
	end
	function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
		local NEWWELD = IT(TYPE)
		NEWWELD.Part0 = PART0
		NEWWELD.Part1 = PART1
		NEWWELD.C0 = C0
		NEWWELD.C1 = C1
		NEWWELD.Parent = PARENT
		return NEWWELD
	end
	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id=" .. ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat
					wait(1)
				until NEWSOUND.Playing == false
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end
	function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
	end
	function WACKYEFFECT(Table)
		local TYPE = Table.EffectType or "Sphere"
		local SIZE = Table.Size or VT(1, 1, 1)
		local ENDSIZE = Table.Size2 or VT(0, 0, 0)
		local TRANSPARENCY = Table.Transparency or 0
		local ENDTRANSPARENCY = Table.Transparency2 or 1
		local CFRAME = Table.CFrame or Torso.CFrame
		local MOVEDIRECTION = Table.MoveToPos or nil
		local ROTATION1 = Table.RotationX or 0
		local ROTATION2 = Table.RotationY or 0
		local ROTATION3 = Table.RotationZ or 0
		local MATERIAL = Table.Material or "Neon"
		local COLOR = Table.Color or C3(1, 1, 1)
		local TIME = Table.Time or 45
		local SOUNDID = Table.SoundID or nil
		local SOUNDPITCH = Table.SoundPitch or nil
		local SOUNDVOLUME = Table.SoundVolume or nil
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND
			local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1, 1, 1), true)
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0, 0, 0))
			elseif TYPE == "Block" or TYPE == "Box" then
				MSH = IT("BlockMesh", EFFECT)
				MSH.Scale = SIZE
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
			elseif TYPE == "Ring" then
				--MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X, SIZE.X, 0.1), VT(0, 0, 0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0, 0, 0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0, 0, 0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0, 0, 0))
			end
			if MSH ~= nil then
				local MOVESPEED
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude / TIME
				end
				local GROWTH = SIZE - ENDSIZE
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
				else
					EFFECT.CFrame = CFRAME
				end
				for LOOP = 1, TIME + 1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH / TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0, 0, -MSH.Scale.X / 8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
					else
						EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CF(0, 0, -MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat
						Swait()
					until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			elseif PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat
					Swait()
				until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end))
	end
	function MakeForm(PART, TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh", PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh", PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh", PART)
			MSH.MeshType = "Wedge"
		end
	end
	Debris = game:GetService("Debris")
	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos, EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end
	function CharacterFade(COLOR, TIMER)
		coroutine.resume(coroutine.create(function()
			local FADE = IT("Model", Effects)
			FADE.Name = "FadingEffect"
			for _, c in pairs(Character:GetChildren()) do
				if c.ClassName == "Part" and c ~= RootPart then
					local FADER = c:Clone()
					FADER.Color = COLOR
					FADER.CFrame = c.CFrame
					FADER.Parent = FADE
					FADER.Anchored = true
					FADER.Transparency = 0.25 + c.Transparency
					FADER:BreakJoints()
					FADER.Material = "Neon"
					if FADER.Name == "Head" then
						FADER:ClearAllChildren()
						FADER.Size = VT(1, 1, 1)
					end
					if FADER:FindFirstChildOfClass("SpecialMesh") then
						FADER:remove()
					end
					FADER.CanCollide = false
					FADER:ClearAllChildren()
				end
			end
			local TRANS = 0.75 / TIMER
			for i = 1, TIMER do
				Swait()
				for _, c in pairs(FADE:GetChildren()) do
					if c.ClassName == "Part" then
						c.Transparency = c.Transparency + TRANS
					end
				end
			end
			FADE:remove()
		end))
	end
	function Chatter(Text, Timer)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("SpeechBoard") ~= nil then
				Character:FindFirstChild("SpeechBoard"):destroy()
			end
			local naeeym2 = IT("BillboardGui", Character)
			naeeym2.Size = UD2(0, 100, 0, 40)
			naeeym2.StudsOffset = VT(0, 2, 0)
			naeeym2.Adornee = Character.Head
			naeeym2.Name = "SpeechBoard"
			naeeym2.AlwaysOnTop = true
			local tecks2 = IT("TextLabel", naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.BorderSizePixel = 0
			tecks2.Text = ""
			tecks2.Font = "Legacy"
			tecks2.TextSize = 15
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = C3(1, 1, 1)
			tecks2.TextStrokeColor3 = C3(0, 0, 0)
			tecks2.Size = UDim2.new(1, 0, 0.5, 0)
			local FINISHED = false
			coroutine.resume(coroutine.create(function()
				for i = 1, string.len(Text) do
					if naeeym2.Parent ~= Character then
						FINISHED = true
					end
					CreateSound(418252437, Head, 7, MRANDOM(8, 12) / 15, false)
					tecks2.Text = string.sub(Text, 1, i)
					Swait(Timer)
				end
				FINISHED = true
			end))
			repeat
				wait()
			until FINISHED == true
			wait(1)
			naeeym2.Name = "FadingDialogue"
			for i = 1, 45 do
				Swait()
				naeeym2.StudsOffset = naeeym2.StudsOffset + VT(0, (2 - 0.044444444444444446 * i) / 45, 0)
				tecks2.TextTransparency = tecks2.TextTransparency + 0.022222222222222223
				tecks2.TextStrokeTransparency = tecks2.TextTransparency
			end
			naeeym2:Destroy()
		end)
		chat()
	end
	function SHAKECAM(POSITION, RANGE, INTENSITY, TIME)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
						local CAMSHAKER = script.CamShake:Clone()
						CAMSHAKER.Shake.Value = INTENSITY
						CAMSHAKER.Timer.Value = TIME
						CAMSHAKER.Parent = CHILD
						CAMSHAKER.Disabled = false
					end
				end
			end
		end
	end
	function CreateFlyingDebree(FLOOR, POSITION, AMOUNT, BLOCKSIZE, SWAIT, STRENGTH, DOES360)
		if FLOOR ~= nil then
			for i = 1, AMOUNT do
				do
					local DEBREE = CreatePart(3, Effects, "Neon", 0, 0, "Peal", "Debree", BLOCKSIZE, false)
					DEBREE.Material = FLOOR.Material
					DEBREE.Color = FLOOR.Color
					DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)))
					if DOES360 == true then
						DEBREE.Velocity = VT(MRANDOM(-STRENGTH, STRENGTH), MRANDOM(-STRENGTH, STRENGTH), MRANDOM(-STRENGTH, STRENGTH))
					else
						DEBREE.Velocity = VT(MRANDOM(-STRENGTH, STRENGTH), STRENGTH, MRANDOM(-STRENGTH, STRENGTH))
					end
					coroutine.resume(coroutine.create(function()
						Swait(15)
						DEBREE.Parent = FLOOR.Parent
						DEBREE.CanCollide = true
						--Debris:AddItem(DEBREE, SWAIT)
					end))
				end
			end
		end
	end
	local Decal = IT("Decal")
	function SpawnBulletHole(POSITION)
		local O1 = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Bullet hole", VT(0.5, 0, 0.5))
		local decal = Decal:Clone()
		decal.Parent = O1
		decal.Face = "Bottom"
		decal.Texture = "http://www.roblox.com/asset/?id=130624105"
		decal.Transparency = 0.5
		O1.CFrame = POSITION * ANGLES(RAD(0), RAD(MRANDOM(-180, 180)), RAD(0))
		--Debris:AddItem(O1, 5)
	end
	function GetRoot(MODEL, ROOT)
		if ROOT == true then
			return MODEL:FindFirstChild("HumanoidRootPart") or MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
		else
			return MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
		end
	end


	for _,c in next, Character:children() do
		local p = script:FindFirstChild(c.Name)
		if(p)then
			print(p.Name)
			p.Parent = Character
			p:SetPrimaryPartCFrame(c.CFrame)
			for _,e in next, p:GetDescendants() do
				if(e:IsA'BasePart')then
					e.CustomPhysicalProperties=PhysicalProperties.new(0,0,0,0,0)
					e.Anchored=false
					weldBetween(c,e,c.CFrame:inverse()*e.CFrame)
					e.CanCollide=false
					e.Locked=true
				end
			end
		end	
	end

	local GUN = script.Gun:clone()
	GUN.Parent = Character
	GUN.Anchored=false
	local GRAB = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, GUN, CF(0, -1.75, -0.25) * ANGLES(RAD(-90), RAD(0), RAD(0)), CF(0, 0, 0))
	local GUNOFFSET = CF(0, 0.525, -1.068)
	local HALO = script.Halo:Clone()
	HALO.Parent = Character
	local HALOWELD = CreateWeldOrSnapOrMotor("Weld", Head, Head, HALO, CF(0, 0, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 1))
	for i = 1, 10 do
		local FACE = CreatePart(3, Character, "Fabric", 0, 0 + (i - 1) / 10.2, "Dark stone grey", "FaceGradient", VT(1.01, 0.65, 1.01), false)
		FACE.Color = C3(0, 0, 0)
		Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
		CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0, 0.28 - (i - 1) / 30, 0), CF(0, 0, 0))
	end

	GUN.Transparency = 1

	HALO.Transparency = 1

	local hat = game:GetService("Players").LocalPlayer.Character["Black Type-37 Pulse Rifle"]

	hat.Handle.AccessoryWeld:Destroy()
	hat.Handle.Size = Vector3.new(1,1,1)

	local hat1 = game:GetService("Players").LocalPlayer.Character["Fallen Halo"]

	hat1.Handle.AccessoryWeld:Destroy()

	local function align(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0.2, 0.2, 0) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(-50, 80, 5) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = true
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	local function align1(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0, 0, 0) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(-90, -0, 0) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end


	align(hat.Handle, GUN)

	align1(hat1.Handle, HALO)

	local SKILLTEXTCOLOR = C3(1, 1, 1)
	local SKILLFONT = "Legacy"
	local SKILLTEXTSIZE = 3
	local ATTACKS = {
		"Mouse - Fury",
		"Z - Velocity",
		"E - Point Blank",
		"C - Geiser",
		"X - Loose Rage"
	}
	for i = 1, #ATTACKS do
		local SKILLFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.74, 0, 0.97 - 0.02 * i, 0), UD2(0.26, 0, 0.07, 0), C3(0, 0, 0), C3(0, 0, 0), "Skill Frame")
		local SKILLTEXT = CreateLabel(SKILLFRAME, "[" .. ATTACKS[i] .. "]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0, "Skill text")
		SKILLTEXT.TextXAlignment = "Right"
	end

	script.Gun:Destroy()
	script.Halo:Destroy()

	function ApplyDamage(Humanoid, Damage)
		print("Damaged")
	end
	function ApplyAoE(POSITION, RANGE, MINDMG, MAXDMG, FLING, INSTAKILL)
		for index, CHILD in pairs(workspace:GetDescendants()) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG, MAXDMG)
							ApplyDamage(HUM, DMG)
						end
						if FLING ~= 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity")
									bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
									bv.velocity = CF(POSITION, TORSO.Position).lookVector * FLING
									bv.Parent = c
									--Debris:AddItem(bv, 0.05)
								end
							end
						end
					end
				end
			end
		end
	end

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	v.Anchored = false

	local Outline = Instance.new("SelectionBox", v)
	Outline.LineThickness = 0.1
	Outline.Color3 = Color3.fromRGB(195, 130, 0)
	Outline.Adornee = v

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if ATTACK == false then
				bp.Position = game.Players.LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)

	function Fury()
		ATTACK = true
		Rooted = false
		local GYRO = IT("BodyGyro", RootPart)
		GYRO.D = 2
		GYRO.P = 20000
		GYRO.MaxTorque = VT(0, 4000000, 0)
		local TEXTS = {
			"Let's see you take this!",
			"Fall down!",
			"I'll end you!"
		}
		Chatter(TEXTS[MRANDOM(1, #TEXTS)], 0)
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				GYRO.CFrame = CF(RootPart.Position, Mouse.Hit.p)
			until ATTACK == false
			GYRO:Remove()
		end))
		for i = 0, 0.3, 0.1 / Animation_Speed do
			Swait()
			GRAB.C1 = Clerp(GRAB.C1, CF(0, 0, 0) * ANGLES(RAD(0), RAD(55), RAD(0)) * CF(-1.7, 0, -0.4) * CF(1.3, 0, 0), 0.2)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0.2, -0.1) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.5, -0.6) * ANGLES(RAD(110), RAD(0), RAD(-55)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, -0.6) * ANGLES(RAD(110), RAD(0), RAD(55)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(25), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		local FIRING = true
		local SHOOTING = false
		local TIMER = 70
		CreateSound(1498950813, GUN, 6, 1, false)
		local MOUSE = Mouse.Button1Down:connect(function(NEWKEY)
			if SHOOTING == false then
				HOLD = true
				repeat
					SHOOTING = true
					local GUNPOS = GUN.CFrame * GUNOFFSET.p
					local HIT, POS, NORMAL = CastProperRay(GUNPOS, Mouse.Hit.p, 1000, Character)
					local DISTANCE = (POS - GUNPOS).Magnitude
					if HIT then
						if HIT.Parent:FindFirstChildOfClass("Humanoid") then
							if HIT.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
								CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], HIT, 10, 1, false)
								ApplyDamage(HIT.Parent:FindFirstChildOfClass("Humanoid"), 35)
								--CreateFlyingDebree(HIT, CF(POS), 7, VT(0.1, 0.1, 0.1), 5, 35, true)
							end
						elseif HIT.Anchored == true then
							--CreateFlyingDebree(HIT, CF(POS), 7, VT(0.2, 0.2, 0.2), 5, 35, true)
							SpawnBulletHole(CF(POS, POS + NORMAL) * ANGLES(RAD(90), RAD(0), RAD(0)))
						end
					end
					TIMER = 55
					SHAKECAM(GUNPOS, 8, 1, 3)
					SHAKECAM(POS, 10, 2, 3)
					WACKYEFFECT({
						Time = 6,
						EffectType = "Block",
						Size = VT(0.4, 0.4, 0.4),
						Size2 = VT(1, 1, 1),
						Transparency = 0,
						Transparency2 = 1,
						CFrame = CF(GUNPOS),
						MoveToPos = nil,
						RotationX = 0,
						RotationY = 0,
						RotationZ = 0,
						Material = "Neon",
						Color = C3(1, 1, 0),
						SoundID = 330704232,
						SoundPitch = 1,
						SoundVolume = 1
					})
					WACKYEFFECT({
						Time = 6,
						EffectType = "Box",
						Size = VT(0.3, 0.3, DISTANCE),
						Size2 = VT(0, 0, DISTANCE),
						Transparency = 0,
						Transparency2 = 1,
						CFrame = CF(GUNPOS, POS) * CF(0, 0, -DISTANCE / 2),
						MoveToPos = nil,
						RotationX = 0,
						RotationY = 0,
						RotationZ = 0,
						Material = "Neon",
						Color = C3(1, 1, 0),
						SoundID = nil,
						SoundPitch = nil,
						SoundVolume = nil
					})
					for i = 0, 0.2, 0.1 / Animation_Speed do
						Swait()
						GRAB.C1 = Clerp(GRAB.C1, CF(0, 0, 0) * ANGLES(RAD(0), RAD(55), RAD(0)) * CF(-1.7, 0, -0.4) * CF(1.3, 0, 0), 0.2)
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0.1, -0.05) * ANGLES(RAD(10), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.5, -0.6) * ANGLES(RAD(115), RAD(0), RAD(-55)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, -0.6) * ANGLES(RAD(115), RAD(0), RAD(55)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(12.5), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(-2), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i = 0, 0.05, 0.1 / Animation_Speed do
						Swait()
						GRAB.C1 = Clerp(GRAB.C1, CF(0, 0, 0) * ANGLES(RAD(0), RAD(55), RAD(0)) * CF(-1.7, 0, -0.4) * CF(1.3, 0, 0), 0.2)
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0.2, -0.1) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.5, -0.6) * ANGLES(RAD(110), RAD(0), RAD(-55)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, -0.6) * ANGLES(RAD(110), RAD(0), RAD(55)) * LEFTSHOULDERC0, 2 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(25), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
				until HOLD == false
				SHOOTING = false
			end
		end)
		repeat
			Swait()
			if SHOOTING == false then
				TIMER = TIMER - 1
				if TIMER <= 0 then
					FIRING = false
				end
				GRAB.C1 = Clerp(GRAB.C1, CF(0, 0, 0) * ANGLES(RAD(0), RAD(55), RAD(0)) * CF(-1.7, 0, -0.4) * CF(1.3, 0, 0), 0.2)
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0.2, -0.1) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.5, -0.6) * ANGLES(RAD(110), RAD(0), RAD(-55)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, -0.6) * ANGLES(RAD(110), RAD(0), RAD(55)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(25), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		until FIRING == false and SHOOTING == false
		MOUSE:Disconnect()
		ATTACK = false
		Rooted = false
		repeat wait() until ATTACK == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if ATTACK == true then
				bp.Position = Mouse.Hit.p
			end
		until ATTACK == false
	end
	function Velocity()
		ATTACK = true
		Rooted = true
		for i = 0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(10), RAD(0), RAD(-45)), 0.3 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-10), RAD(0), RAD(45)), 0.3 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.3 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.5, -0.6) * ANGLES(RAD(0), RAD(0), RAD(90)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * LEFTSHOULDERC0, 0.3 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.3 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.95, 0) * ANGLES(RAD(10), RAD(-35), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 0.3 / Animation_Speed)
		end
		local SOUND = CreateSound(235097614, Torso, 6, 2, false)
		UNANCHOR = false
		for i = 0, 0.5, 0.1 / Animation_Speed do
			Swait()
			CharacterFade(C3(0.12, 0.12, 0.12), 25)
			RootPart.CFrame = Clerp(RootPart.CFrame, RootPart.CFrame, 0.07) * CF(0, 0, -4)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(45), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(-10), RAD(80), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(-5), RAD(-80), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		repeat
			Swait()
			CharacterFade(C3(0.12, 0.12, 0.12), 25)
			RootPart.CFrame = Clerp(RootPart.CFrame, CF(RootPart.Position, VT(Mouse.Hit.p.X, RootPart.Position.Y, Mouse.Hit.p.Z)), 0.07) * CF(0, 0, -4)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(45), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(-10), RAD(80), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(-5), RAD(-80), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
		until KEYHOLD == false or SOUND.Playing == false
		UNANCHOR = true
		ATTACK = false
		Rooted = false
	end
	function PointBlank()
		ATTACK = true
		Rooted = true
		local HIT, HUMAN, ROOT
		WACKYEFFECT({
			Time = 25,
			EffectType = "Wave",
			Size = VT(4, 0.2, 4),
			Size2 = VT(5, 0, 5),
			Transparency = 0.6,
			Transparency2 = 1,
			CFrame = RootPart.CFrame * CF(0, -3.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(0)),
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 0,
			RotationZ = 0,
			Material = "Neon",
			Color = C3(1, 1, 1),
			SoundID = nil,
			SoundPitch = nil,
			SoundVolume = nil
		})
		CreateSound(235097614, Torso, 6, 3, false)
		for i = 0, 0.75, 0.1 / Animation_Speed do
			Swait()
			if HIT ~= nil then
				break
			end
			for index, CHILD in pairs(workspace:GetDescendants()) do
				if CHILD.ClassName == "Model" and CHILD ~= Character then
					local HUM = CHILD:FindFirstChildOfClass("Humanoid")
					if HUM then
						local TORSO = GetRoot(CHILD, false)
						if TORSO and 0 < HUM.Health and 5 >= (TORSO.Position - RootPart.CFrame * CF(0, 0, -2).p).Magnitude then
							ROOT = TORSO
							HUMAN = HUM
							HIT = CHILD
						end
					end
				end
			end
			RootPart.CFrame = Clerp(RootPart.CFrame, RootPart.CFrame, 0.07) * CF(0, 0, -1.5)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(45), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(135), RAD(0), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(-10), RAD(80), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(-5), RAD(-80), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		if HIT then
			do
				local DEAD = false
				CreateSound(260411131, Torso, 6, 1, false)
				coroutine.resume(coroutine.create(function()
					repeat
						Swait()
						ROOT.CFrame = LeftArm.CFrame * CF(0, -(1 + ROOT.Size.Z / 2), 0) * ANGLES(RAD(-90), RAD(180), RAD(0))
						ROOT.Velocity = VT(0, 0, 0)
					until DEAD == true
				end))
				local TEXTS = {
					"Gotcha!",
					"I've got you!",
					"I'll end you!",
					"Die!"
				}
				Chatter(TEXTS[MRANDOM(1, #TEXTS)], 0)
				for i = 1, 25 do
					Swait()
					RootPart.CFrame = Clerp(RootPart.CFrame, RootPart.CFrame, 0.07) * CF(0, 0, -(1.5 - 0.06 * i))
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(10), RAD(0), RAD(-45)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-30), RAD(0), RAD(45)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.6) * ANGLES(RAD(130), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.95, 0) * ANGLES(RAD(10), RAD(-35), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i = 0, 0.5, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(10), RAD(0), RAD(-45)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-30), RAD(0), RAD(45)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, 0.6) * ANGLES(RAD(120), RAD(0), RAD(-55)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.6) * ANGLES(RAD(130), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.95, 0) * ANGLES(RAD(10), RAD(-35), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				DEAD = true
				local GUNPOS = GUN.CFrame * GUNOFFSET.p
				local HIT, POS, NORMAL = CastProperRay(GUNPOS, ROOT.Position, 1000, Character)
				local DISTANCE = (POS - GUNPOS).Magnitude
				SHAKECAM(GUNPOS, 12, 3, 12)
				WACKYEFFECT({
					Time = 6,
					EffectType = "Block",
					Size = VT(0.4, 0.4, 0.4),
					Size2 = VT(1, 1, 1),
					Transparency = 0,
					Transparency2 = 1,
					CFrame = CF(GUNPOS),
					MoveToPos = nil,
					RotationX = 0,
					RotationY = 0,
					RotationZ = 0,
					Material = "Neon",
					Color = C3(1, 1, 0),
					SoundID = 330704232,
					SoundPitch = 1,
					SoundVolume = 3
				})
				WACKYEFFECT({
					Time = 6,
					EffectType = "Box",
					Size = VT(0.3, 0.3, DISTANCE),
					Size2 = VT(0, 0, DISTANCE),
					Transparency = 0,
					Transparency2 = 1,
					CFrame = CF(GUNPOS, POS) * CF(0, 0, -DISTANCE / 2),
					MoveToPos = nil,
					RotationX = 0,
					RotationY = 0,
					RotationZ = 0,
					Material = "Neon",
					Color = C3(1, 1, 0),
					SoundID = nil,
					SoundPitch = nil,
					SoundVolume = nil
				})
				ROOT.Parent:BreakJoints()
				--CreateFlyingDebree(ROOT, CF(POS), 10, VT(0.5, 0.5, 0.5), 5, 35, true)
				CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], ROOT, 10, 1, false)
				for i = 0, 0.2, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(10), RAD(0), RAD(-45)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-30), RAD(0), RAD(45)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, 0.6) * ANGLES(RAD(150), RAD(0), RAD(-55)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.6) * ANGLES(RAD(130), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.95, 0) * ANGLES(RAD(10), RAD(-35), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i = 0, 0.75, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(10), RAD(0), RAD(-45)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-30), RAD(0), RAD(45)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, 0.6) * ANGLES(RAD(120), RAD(0), RAD(-55)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.6) * ANGLES(RAD(130), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.95, 0) * ANGLES(RAD(10), RAD(-35), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
			end
		end
		ATTACK = false
		Rooted = false
	end
	function Geiser()
		local HIT = Mouse.Target
		local BULLETORIGIN = Mouse.Hit.p
		local HITFLOOR, HITPOS = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 4, Character)
		if HIT and HIT.Anchored == true and HITFLOOR then
			ATTACK = true
			Rooted = true
			for i = 0, 0.8, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(30), RAD(0), RAD(35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(35), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			while true do
				for i = 0, 0.2, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(30), RAD(0), RAD(35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(35), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				do
					local HIT = Mouse.Target
					if HIT and HIT.Anchored == true then
						local GUNPOS = GUN.CFrame * GUNOFFSET.p
						local HITFLOOR, POS = Raycast(GUNPOS, GUN.CFrame.lookVector, 25, Character)
						local DISTANCE = (POS - GUNPOS).Magnitude
						SHAKECAM(GUNPOS, 12, 3, 12)
						WACKYEFFECT({
							Time = 6,
							EffectType = "Block",
							Size = VT(0.4, 0.4, 0.4),
							Size2 = VT(1, 1, 1),
							Transparency = 0,
							Transparency2 = 1,
							CFrame = CF(GUNPOS),
							MoveToPos = nil,
							RotationX = 0,
							RotationY = 0,
							RotationZ = 0,
							Material = "Neon",
							Color = C3(1, 1, 0),
							SoundID = 330704232,
							SoundPitch = 1,
							SoundVolume = 3
						})
						WACKYEFFECT({
							Time = 6,
							EffectType = "Box",
							Size = VT(0.3, 0.3, DISTANCE),
							Size2 = VT(0, 0, DISTANCE),
							Transparency = 0,
							Transparency2 = 1,
							CFrame = CF(GUNPOS, POS) * CF(0, 0, -DISTANCE / 2),
							MoveToPos = nil,
							RotationX = 0,
							RotationY = 0,
							RotationZ = 0,
							Material = "Neon",
							Color = C3(1, 1, 0),
							SoundID = nil,
							SoundPitch = nil,
							SoundVolume = nil
						})
						coroutine.resume(coroutine.create(function()
							wait(0.1)
							local AREA = CF(BULLETORIGIN)
							local AIM = AREA * CF(0, 370, 0) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))) * CF(0, 0, 45).p
							local DISTANCE = (AREA.p - AIM).Magnitude
							ApplyAoE(AREA.p + VT(0, 2, 0), 5, 80, 99, 45, false)
							SHAKECAM(AREA.p, 20, 4, 12)
							--CreateFlyingDebree(HIT, CF(BULLETORIGIN), 20, VT(0.5, 0.5, 0.5), 5, 35, true)
							WACKYEFFECT({
								Time = 13,
								EffectType = "Block",
								Size = VT(0.4, 0.4, 0.4),
								Size2 = VT(3, 3, 3),
								Transparency = 0,
								Transparency2 = 1,
								CFrame = CF(AREA.p),
								MoveToPos = nil,
								RotationX = 0,
								RotationY = 0,
								RotationZ = 0,
								Material = "Neon",
								Color = C3(1, 1, 0),
								SoundID = 330704232,
								SoundPitch = 0.7,
								SoundVolume = 3
							})
							WACKYEFFECT({
								Time = 13,
								EffectType = "Box",
								Size = VT(0.9, 0.9, DISTANCE),
								Size2 = VT(0, 0, DISTANCE),
								Transparency = 0,
								Transparency2 = 1,
								CFrame = CF(AREA.p, AIM) * CF(0, 0, -DISTANCE / 2),
								MoveToPos = nil,
								RotationX = 0,
								RotationY = 0,
								RotationZ = 0,
								Material = "Neon",
								Color = C3(1, 1, 0),
								SoundID = nil,
								SoundPitch = nil,
								SoundVolume = nil
							})
						end))
						BULLETORIGIN = Mouse.Hit.p
						for i = 0, 0.1, 0.1 / Animation_Speed do
							Swait()
							RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(50), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(35), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						end
					end
					if KEYHOLD == false then
						break
					end
				end
			end
			for i = 0, 0.2, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(50), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(35), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			ATTACK = false
			Rooted = false
			repeat wait() until ATTACK == true
			repeat
				game:GetService("RunService").Heartbeat:Wait()
				if ATTACK == true then
					bp.Position = Mouse.Hit.p
				end
			until ATTACK == false
		end
	end
	function LooseRage()
		local HITFLOOR, HITPOS = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 4, Character)
		if HITFLOOR then
			ATTACK = true
			Rooted = true
			CreateSound(278641993, Torso, 6, 1, false)
			ApplyAoE(RootPart.Position + VT(0, 10, 0), 70, 0, 0, -100, false)
			for i = 1, 3 do
				WACKYEFFECT({
					Time = 20,
					EffectType = "Sphere",
					Size = VT(5 * i, 5 * i, 5 * i),
					Size2 = VT(0, 0, 0),
					Transparency = 0.6,
					Transparency2 = 1,
					CFrame = CF(RootPart.Position),
					MoveToPos = nil,
					RotationX = 0,
					RotationY = 0,
					RotationZ = 0,
					Material = "Neon",
					Color = C3(0, 0, 0),
					SoundID = nil,
					SoundPitch = nil,
					SoundVolume = nil
				})
			end
			do
				local WAVES = true
				for i = 0, 1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, -0.1, -0.1) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -0.3) * ANGLES(RAD(75), RAD(0), RAD(-32)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.5, -0.3) * ANGLES(RAD(75), RAD(0), RAD(32)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(25), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(25), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				end
				CreateSound(288641686, Torso, 10, 0.7, false)
				coroutine.resume(coroutine.create(function()
					repeat
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, -0.1, -0.1) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-45), RAD(0), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-75), RAD(0), RAD(32)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-75), RAD(0), RAD(-32)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(-25), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						local HITFLOOR, HITPOS = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 4, Character)
						WACKYEFFECT({
							Time = 35,
							EffectType = "Wave",
							Size = VT(1, 1 + 1 * SIN(SINE / 6), 1),
							Size2 = VT(40, 3, 40),
							Transparency = 0,
							Transparency2 = 1,
							CFrame = CF(HITPOS) * ANGLES(RAD(0), RAD(MRANDOM(0, 360)), RAD(0)),
							MoveToPos = nil,
							RotationX = 0,
							RotationY = 0,
							RotationZ = 0,
							Material = "Fabric",
							Color = C3(0, 0, 0),
							SoundID = nil,
							SoundPitch = nil,
							SoundVolume = nil
						})
						WACKYEFFECT({
							Time = 20,
							EffectType = "Sphere",
							Size = VT(6 + 1 * SIN(SINE / 6), 6 + 1 * SIN(SINE / 6), 6 + 1 * SIN(SINE / 6)),
							Size2 = VT(0, 25, 0),
							Transparency = 0.9,
							Transparency2 = 1,
							CFrame = CF(RootPart.Position),
							MoveToPos = nil,
							RotationX = 0,
							RotationY = 0,
							RotationZ = 0,
							Material = "Neon",
							Color = C3(0, 0, 0),
							SoundID = nil,
							SoundPitch = nil,
							SoundVolume = nil
						})
					until WAVES == false
					coroutine.resume(coroutine.create(function()
						DAMAGEMULTIPLIER = DAMAGEMULTIPLIER + 0.5
						wait(20)
						DAMAGEMULTIPLIER = DAMAGEMULTIPLIER - 0.5
					end))
				end))
				wait(0.3)
				for i = 1, 200 do
					Swait()
					if MRANDOM(1, 3) == 1 then
						local AREA = CF(RootPart.Position - VT(0, 3.4, 0)) * ANGLES(RAD(0), RAD(MRANDOM(0, 360)), RAD(0)) * CF(0, 0, MRANDOM(5, 25))
						local AIM = AREA * CF(0, 370, 0) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))) * CF(0, 0, 45).p
						local DISTANCE = (AREA.p - AIM).Magnitude
						ApplyAoE(AREA.p + VT(0, 2, 0), 7, 80, 99, -2, false)
						SHAKECAM(AREA.p, 20, 4, 12)
						WACKYEFFECT({
							Time = 13,
							EffectType = "Block",
							Size = VT(0.4, 0.4, 0.4),
							Size2 = VT(3, 3, 3),
							Transparency = 0,
							Transparency2 = 1,
							CFrame = CF(AREA.p),
							MoveToPos = nil,
							RotationX = 0,
							RotationY = 0,
							RotationZ = 0,
							Material = "Neon",
							Color = C3(1, 1, 0),
							SoundID = 330704232,
							SoundPitch = 0.7,
							SoundVolume = 3
						})
						WACKYEFFECT({
							Time = 13,
							EffectType = "Box",
							Size = VT(0.9, 0.9, DISTANCE),
							Size2 = VT(0, 0, DISTANCE),
							Transparency = 0,
							Transparency2 = 1,
							CFrame = CF(AREA.p, AIM) * CF(0, 0, -DISTANCE / 2),
							MoveToPos = nil,
							RotationX = 0,
							RotationY = 0,
							RotationZ = 0,
							Material = "Neon",
							Color = C3(1, 1, 0),
							SoundID = nil,
							SoundPitch = nil,
							SoundVolume = nil
						})
					end
				end
				WAVES = false
				ATTACK = false
				Rooted = false
			end
		end
	end
	function Joy()
		ATTACK = true
		Rooted = true
		local LOOP = true
		KEY = Mouse.KeyDown:connect(function(NEWKEY)
			if NEWKEY == "t" then
				KEY:Disconnect()
				LOOP = false
			end
		end)
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.75, 0) * ANGLES(RAD(170 - 15 * SIN(SINE / 6)), RAD(0), RAD(12 - 15 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			until LOOP == false
		end))
		repeat
			for i = 0, 0.4, 0.1 / Animation_Speed do
				Swait()
				if LOOP == false then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.85, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5, -0.3) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i = 0, 0.4, 0.1 / Animation_Speed do
				Swait()
				if LOOP == false then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0.1) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(10), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.35, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1.1, -0.3) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1.1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i = 0, 0.4, 0.1 / Animation_Speed do
				Swait()
				if LOOP == false then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.85, 0) * ANGLES(RAD(0), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5, -0.3) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i = 0, 0.4, 0.1 / Animation_Speed do
				Swait()
				if LOOP == false then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0.1) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(10), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.35, 0) * ANGLES(RAD(0), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1.1, -0.3) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1.1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		until LOOP == false
		ATTACK = false
		Rooted = false
	end
	function MouseDown(Mouse)
		if ATTACK == false then
			Fury()
		end
	end
	function MouseUp(Mouse)
		HOLD = false
	end
	function KeyDown(Key)
		KEYHOLD = true
		if Key == "z" and ATTACK == false then
			Velocity()
		end
		if Key == "e" and ATTACK == false then
			PointBlank()
		end
		if Key == "c" and ATTACK == false then
			Geiser()
		end
		if Key == "x" and ATTACK == false then
			LooseRage()
		end
		if Key == "t" and ATTACK == false then
			Joy()
		end
		if Key == "m" and ATTACK == false then
			if MUTE == false then
				sick:Play()
				MUTE = true
			else
				MUTE = false
			end
		end
	end
	function KeyUp(Key)
		KEYHOLD = false
	end
	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)
	function unanchor()
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA("BasePart") and c ~= RootPart then
				c.Anchored = false
			end
		end
		if UNANCHOR == true then
			RootPart.Anchored = false
		else
			RootPart.Anchored = true
		end
	end
	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and Disable_Jump == true then
			Humanoid.Jump = false
		end
	end)

	while true do
		Swait()
		ANIMATE.Parent = nil
		for _, v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop()
		end
		SINE = SINE + CHANGE
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local HITFLOOR = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 4, Character)
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
		if ANIM == "Walk" and TORSOVELOCITY > 1 then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0.05 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE * 2), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(35 * COS(SINE / WALKSPEEDVALUE))), 0.6 / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE * 2), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(35 * COS(SINE / WALKSPEEDVALUE))), 0.6 / Animation_Speed)
		elseif ANIM ~= "Walk" or TORSOVELOCITY < 1 then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.7 / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.7 / Animation_Speed)
		end
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			ANIM = "Idle"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(-8 - 3 * SIN(SINE / 12)), RAD(-10), RAD(5 + 3 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(-8 - 3 * SIN(SINE / 12)), RAD(10), RAD(-5 - 3 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.25 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(30 * COS(SINE / WALKSPEEDVALUE)), RAD(-10), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0.25 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(-30 * COS(SINE / WALKSPEEDVALUE)), RAD(10), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			end
		end
		HALOWELD.C0 = Clerp(HALOWELD.C0, CF(0, 0, 0) * ANGLES(RAD(90 - 12 * SIN(SINE / 12)), RAD(-12 * COS(SINE / 12)), RAD(0)), 0.2)
		if ATTACK == false then
			GRAB.C1 = Clerp(GRAB.C1, CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2)
		end
		unanchor()
		Humanoid.MaxHealth = "inf"
		Humanoid.Health = "inf"
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		Humanoid.Name = "Humanoid"
		if sick.Parent ~= RootPart then
			sick = IT("Sound", RootPart)
		end
		sick.SoundId = "rbxassetid://172056286"
		sick.Looped = true
		sick.Pitch = 1
		sick.Volume = 4
		sick.Playing = MUTE
	end

end)

Button_3.MouseButton1Down:Connect(function()
	local script = game:GetObjects("rbxassetid://5988026564")[1]

	local AHB = Instance.new("BindableEvent")

	local FPS = 30

	local TimeFrame = 0

	local LastFrame = tick()
	local Frame = 1/FPS

	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end

	-- converter by Drahazar

	--created by helkern
	--some things might be taken from other scripts

	wait(1/60)

	Player = game:GetService("Players").LocalPlayer
	PlayerGui = Player.PlayerGui
	Cam = workspace.CurrentCamera
	Backpack = Player.Backpack
	Character = Player.Character["Dummy"]
	Humanoid = Character.Humanoid
	Mouse = Player:GetMouse()
	RootPart = Character["HumanoidRootPart"]
	Torso = Character["Torso"]
	Head = Character["Head"]
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	local sick = Instance.new("Sound",Torso)

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor


	Animation_Speed = 3
	Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
	local Speed = 16
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local DAMAGEMULTIPLIER = 1
	local ANIM = "Idle"
	local ATTACK = false
	local EQUIPPED = false
	local HOLD = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local KEYHOLD = false
	local CHANGE = 2 / Animation_Speed
	local WALKINGANIM = false
	local VALUE1 = false
	local VALUE2 = false
	local ROBLOXIDLEANIMATION = IT("Animation")
	ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
	ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
	--ROBLOXIDLEANIMATION.Parent = Humanoid
	local WEAPONGUI = IT("ScreenGui", PlayerGui)
	WEAPONGUI.Name = "Weapon GUI"
	local Effects = IT("Folder", Character)
	Effects.Name = "Effects"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character.Animate
	ANIMATOR:Destroy()
	local UNANCHOR = true
	local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}



	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)


	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function Clerp(a, b, t)
		return a:lerp(b,t)
	end


	function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
		local frame = IT("Frame")
		frame.BackgroundTransparency = TRANSPARENCY
		frame.BorderSizePixel = BORDERSIZEPIXEL
		frame.Position = POSITION
		frame.Size = SIZE
		frame.BackgroundColor3 = COLOR
		frame.BorderColor3 = BORDERCOLOR
		frame.Name = NAME
		frame.Parent = PARENT
		return frame
	end

	function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
		local label = IT("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UD2(1, 0, 1, 0)
		label.Position = UD2(0, 0, 0, 0)
		label.TextColor3 = TEXTCOLOR
		label.TextStrokeTransparency = STROKETRANSPARENCY
		label.TextTransparency = TRANSPARENCY
		label.FontSize = TEXTFONTSIZE
		label.Font = TEXTFONT
		label.BorderSizePixel = BORDERSIZEPIXEL
		label.TextScaled = false
		label.Text = TEXT
		label.Name = NAME
		label.Parent = PARENT
		return label
	end

	function NoOutlines(PART)
		PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
	end

	function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
		local NEWWELD = IT(TYPE)
		NEWWELD.Part0 = PART0
		NEWWELD.Part1 = PART1
		NEWWELD.C0 = C0
		NEWWELD.C1 = C1
		NEWWELD.Parent = PARENT
		return NEWWELD
	end

	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.EmitterSize = 5*VOLUME
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
	end

	--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	function WACKYEFFECT(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or VT(1,1,1))
		local ENDSIZE = (Table.Size2 or VT(0,0,0))
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local MOVEDIRECTION = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLOR = (Table.Color or C3(1,1,1))
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
			elseif TYPE == "Block" then
				MSH = IT("BlockMesh",EFFECT)
				MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
			end
			if MSH ~= nil then
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
				end
				local GROWTH = SIZE - ENDSIZE
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.X/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until SOUND.Playing == false
					EFFECT:remove()
				end
			else
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until SOUND.Playing == false
					EFFECT:remove()
				end
			end
		end))
	end

	function WACKYEFFECT2(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or VT(1,1,1))
		local ENDSIZE = (Table.Size2 or VT(0,0,0))
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local MOVEDIRECTION = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLOR = (Table.Color or C3(1,1,1))
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
		local BOOMERANG = (Table.Boomerang or 0)
		local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
			elseif TYPE == "Block" or TYPE == "Box" then
				MSH = IT("BlockMesh",EFFECT)
				MSH.Scale = SIZE
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
			end
			if MSH ~= nil then
				local BOOMR1 = 1+BOOMERANG/50
				local BOOMR2 = 1+SIZEBOOMERANG/50
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					if USEBOOMERANGMATH == true then
						MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
					else
						MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
					end
				end
				local GROWTH = nil
				if USEBOOMERANGMATH == true then
					GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
				else
					GROWTH = (SIZE - ENDSIZE)
				end
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				if USEBOOMERANGMATH == true then
					for LOOP = 1, TIME+1 do
						Swait()
						MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
							EFFECT.Orientation = ORI
						end
					end
				else
					for LOOP = 1, TIME+1 do
						Swait()
						MSH.Scale = MSH.Scale - GROWTH/TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
							EFFECT.Orientation = ORI
						end
					end
				end
				EFFECT.Transparency = 1
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			else
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			end
		end))
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	Debris = game:GetService("Debris")

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end

	function Gyro(PARENT)
		local GYRO = IT("BodyGyro",PARENT)
		GYRO.D = 750
		GYRO.P = 20000
		GYRO.MaxTorque = VT(0,40000000,0)
		return GYRO
	end

	function POSITION(PARENT)
		local grav = Instance.new("BodyPosition",PARENT)
		grav.D = 15
		grav.P = 20000
		grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
		return grav
	end

	function FacialShadow()
		local SHADOWS = {}
		for i = 1, 16 do
			local FACE = CreatePart(3, Effects, "Fabric", 0, 0+(i-1)/16.2, "Dark stone grey", "FaceGradient", VT(1.01,0.65,1.01),false)
			FACE.Color = C3(0,0,0)
			Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
			CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0,0.35-(i-1)/25,0), CF(0, 0, 0))
			table.insert(SHADOWS,FACE)
		end
		local UNDO = function()
			for i = 1, #SHADOWS do
				SHADOWS[i]:remove()
			end
		end
		return UNDO
	end

	function GetRoot(MODEL,ROOT)
		if ROOT == true then
			return MODEL:FindFirstChild("HumanoidRootPart") or MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
		else
			return MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
		end
	end

	function CreateFlyingDebree(FLOOR,POSITION,AMOUNT,BLOCKSIZE,SWAIT,STRENGTH)
		if FLOOR ~= nil then
			for i = 1, AMOUNT do
				local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, FLOOR.Transparency, "Peal", "Debree", BLOCKSIZE, false)
				DEBREE.Material = FLOOR.Material
				DEBREE.Color = FLOOR.Color
				DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
				DEBREE.Velocity = VT(MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH))
				coroutine.resume(coroutine.create(function()
					Swait(15)
					DEBREE.Parent = workspace
					DEBREE.CanCollide = true
					Debris:AddItem(DEBREE,SWAIT)
				end))
			end
		end
	end

	function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							local CAMSHAKER = script.CamShake:Clone()
							CAMSHAKER.Shake.Value = INTENSITY
							CAMSHAKER.Timer.Value = TIME
							CAMSHAKER.Parent = CHILD
							CAMSHAKER.Disabled = false
						end
					end
				end
			end
		end
	end

	--weap
	local SONG = 2598781800
	local d = CF(0,0,0)
	Humanoid:removeAccessories()
	for i,v in pairs(Character:GetChildren()) do
		if v:IsA("Part") then
			--v.Transparency = 1
		end	
	end
	local sla = script.HallowSlayer
	local hw = CreateWeldOrSnapOrMotor("Weld",Head,sla.hed.Main,Head,d,d)
	local lw = CreateWeldOrSnapOrMotor("Weld",LeftArm,sla.la.Main,LeftArm,d,d)
	local rw = CreateWeldOrSnapOrMotor("Weld",RightArm,sla.ra.Main,RightArm,d,d)
	local llw = CreateWeldOrSnapOrMotor("Weld",LeftLeg,sla.ll.Main,LeftLeg,d,d)
	local rlw = CreateWeldOrSnapOrMotor("Weld",RightLeg,sla.rl.Main,RightLeg,d,d)
	local tw = CreateWeldOrSnapOrMotor("Weld",Torso,sla.tors.Main,Torso,d,d)
	local axew = CreateWeldOrSnapOrMotor("Weld",RightArm,sla.axe.Main,RightArm,CF(0,1,0),d)
	for i,v in pairs(sla:GetDescendants()) do
		if v:IsA("BasePart") then
			v.Anchored = false
		end
	end
	sla.Parent = Character
	sla.la:Destroy()
	sla.ra:Destroy()
	sla.ll:Destroy()
	sla.rl:Destroy()
	sla.tors:Destroy()
	sla.hed:Destroy()

	for i,v in next, sla.axe:GetChildren() do
		v.Transparency = 1
	end

	local hat = game:GetService("Players").LocalPlayer.Character["PumpkinAxe"]

	hat.Handle.AccessoryWeld:Destroy()

	local function align(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(-0.5, -1.2, 0) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(90, -100, 0) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	align(hat.Handle, sla.axe.Main)

	--dmg
	function ApplyDamage(Humanoid,Damage)
		print("removed")
	end

	function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
		for index, CHILD in pairs(workspace:GetDescendants()) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if INSTAKILL == true then
								deee(CHILD)
							else
								local DMG = MRANDOM(MINDMG,MAXDMG)
								ApplyDamage(HUM,DMG)
							end
							if FLING > 0 then
								for _, c in pairs(CHILD:GetChildren()) do
									if c:IsA("BasePart") then
										local bv = Instance.new("BodyVelocity") 
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
										bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
										bv.Parent = c
										Debris:AddItem(bv,0.05)
									end
								end
							end
						end
					end
				end
			end
		end
	end


	function deee(MODEL)
		MODEL:BreakJoints()
		for index, CHILD in pairs(MODEL:GetChildren()) do
			if CHILD:IsA("BasePart") and CHILD.Name ~= "HumanoidRootPart" then
				if CHILD.Name == "Head" then
					WACKYEFFECT2({Time = 120, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)), Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-30,30)/10,MRANDOM(-30,30)/10,MRANDOM(-30,30)/10), RotationX = MRANDOM(-4,4), RotationY = MRANDOM(-4,4), RotationZ = MRANDOM(-4,4), Material = "Neon", Color = Color3.fromRGB(19, 255, 117), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 35})
				elseif CHILD.Name ~= "HumanoidRootPart" then
					WACKYEFFECT2({Time = 120, EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-30,30)/10,MRANDOM(-30,30)/10,MRANDOM(-30,30)/10), RotationX = MRANDOM(-4,4), RotationY = MRANDOM(-4,4), RotationZ = MRANDOM(-4,4) ,Material = "Neon", Color = Color3.fromRGB(19, 255, 117), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 35})
				end
				if CHILD.Name == "Torso" or CHILD.Name == "UpperTorso" then
					--for i = 1,12 do
					--WACKYEFFECT2({Time = 86, EffectType = "Skull", Size = VT(1.5,1.5,1.5), Size2 = VT(0.8,0.8,0.8), Transparency = 0.2, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-35,35),MRANDOM(-35,35),MRANDOM(-35,35)), RotationX = MRANDOM(-7,7), RotationY = MRANDOM(-7,7), RotationZ = MRANDOM(-7,7), Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
					--end 
					WACKYEFFECT2({Time = 80, EffectType = "Sphere", Size = VT(0.2,0.2,0.2)*CHILD.Size.Magnitude, Size2 = VT(6,6,6)*CHILD.Size.Magnitude, Transparency = 0.6, Transparency2 = 1, CFrame = CF(CHILD.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117), SoundID = nil, SoundPitch = 2, SoundVolume = 10, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 50})
				end
				CHILD:remove()
			end
		end
		Debris:AddItem(MODEL,6)
	end
	--attacks
	function cs()
		if SONG == 2598781800 then
			SONG = 182109508
		elseif SONG == 182109508 then
			SONG = 1526854945
		elseif SONG == 1526854945 then
			SONG = 2598781800
		end
	end

	local potating = false

	function punch()
		ATTACK = true
		local hit = CreatePart(3,Effects,"Neon",0,0,"Teal","BruhZone69",VT(1.2,1.2,1.2),false)
		hit.Color = Color3.fromRGB(19, 255, 117)
		local fgf = CreateWeldOrSnapOrMotor("Weld",hit,hit,LeftArm,CF(0,1,0),d)
		WACKYEFFECT2({Time = 60, EffectType = "Box", Size = hit.Size * 0.9, Size2 = hit.Size * 1.2, Transparency = 0, Transparency2 = 1, CFrame = hit.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = 2923163432, SoundPitch = 1, SoundVolume = 5, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
		for i = 0,20 do
			Swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(0.1,0,0)*ANGLES(RAD(-90),RAD(0),RAD(-109.9)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.1,0.2)*ANGLES(RAD(-66.6),RAD(-71.5),RAD(-156.1)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.4,0.1)*ANGLES(RAD(-35.1),RAD(60.4),RAD(39)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,-0.1)*ANGLES(RAD(-86.4),RAD(1.3),RAD(109.9)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1.1,-1,0)*ANGLES(RAD(0),RAD(-87.7),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(0.9,-1,0.2)*ANGLES(RAD(0),RAD(58.5),RAD(0)),Alpha)	
		end
		for i = 0,20 do
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,0,0)*ANGLES(RAD(-90),RAD(0),RAD(158)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.3,-0.4)*ANGLES(RAD(-102.2),RAD(-72.8),RAD(169.8)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.4,0.1)*ANGLES(RAD(-35.1),RAD(60.4),RAD(39)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-91.4),RAD(3.6),RAD(-157.9)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.2)*ANGLES(RAD(0),RAD(-62.7),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0)*ANGLES(RAD(0),RAD(83.2),RAD(0)),Alpha)
		end
		--ApplyAoE(RightArm.Position,5,30,35,25,false)
		for i = 0,20 do
			Swait()
			local Alpha = .2
			RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,0,-0.1)*ANGLES(RAD(-90),RAD(0),RAD(116.4)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.8,0.2,-0.4)*ANGLES(RAD(-176.8),RAD(-15.5),RAD(107.6)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.4,0.1)*ANGLES(RAD(-35.1),RAD(60.4),RAD(39)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0.1,1,0)*ANGLES(RAD(-93.4),RAD(1.7),RAD(-116.4)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.2)*ANGLES(RAD(0),RAD(-62.7),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0)*ANGLES(RAD(0),RAD(83.2),RAD(0)),Alpha)
		end
		WACKYEFFECT2({Time = 60, EffectType = "Box", Size = hit.Size * 1.2, Size2 = hit.Size * 0.9, Transparency = 0, Transparency2 = 1, CFrame = hit.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
		Debris:AddItem(hit,.01)
		Debris:AddItem(fgf,.01)
		ATTACK = false
	end

	function itknee()
		ATTACK = true
		for i = 0,10 do
			Swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0.1)*ANGLES(RAD(-105.1),RAD(0),RAD(142.8)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,-0.1)*ANGLES(RAD(-19.7),RAD(-82.1),RAD(-19.5)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.4,0.1)*ANGLES(RAD(-35.1),RAD(60.4),RAD(39)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-92.3),RAD(3.1),RAD(-142.8)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1.4,-0.9,-0.5)*ANGLES(RAD(-5.2),RAD(-59.8),RAD(31)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(0.8,-1,-0.3)*ANGLES(RAD(58.4),RAD(77.6),RAD(-47)),Alpha)
		end
		--ApplyAoE(LeftLeg.Position,5,30,35,25,false)
		for i = 0,12 do
			Swait()
			local Alpha = .45
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0.2)*ANGLES(RAD(-72.7),RAD(0),RAD(142.8)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,-0.1)*ANGLES(RAD(-19.7),RAD(-82.1),RAD(-19.5)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.4,0.1)*ANGLES(RAD(-35.1),RAD(60.4),RAD(39)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-102.9),RAD(-5),RAD(-142.9)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1.6,-0.3,-1)*ANGLES(RAD(13.4),RAD(-63.4),RAD(52.3)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(0.9,-0.9,0)*ANGLES(RAD(-63.1),RAD(76.4),RAD(49.9)),Alpha)
		end
		ATTACK = false
	end

	function wack()
		ATTACK = true
		for i = 0,16 do
			local Alpha = .12
			Swait()
			axew.C1 = axew.C1:lerp(CF(0,0,0) * ANGLES(RAD(30),0,0),Alpha)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(-90),RAD(0),RAD(101.7)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,-0.1)*ANGLES(RAD(-19.7),RAD(-82.1),RAD(-19.5)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.3,0.8,0.3)*ANGLES(RAD(91.5),RAD(-2),RAD(50.3)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-93.8),RAD(0.8),RAD(-101.7)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-0.9,-1,0.2)*ANGLES(RAD(0),RAD(-43),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0)*ANGLES(RAD(0),RAD(82.4),RAD(0)),Alpha)
		end
		CreateSound(211059653,Torso,7,0.75,false)
		--ApplyAoE(RightArm.Position,5,50,60,25,false)
		for i = 0,14 do
			Swait()
			local Alpha = .2
			axew.C1 = axew.C1:lerp(CF(0,0,0) * ANGLES(RAD(-30),0,0),Alpha)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(-90),RAD(0),RAD(-115.7)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,-0.1)*ANGLES(RAD(-19.7),RAD(-82.1),RAD(-19.5)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.1,0.8,-0.8)*ANGLES(RAD(91.5),RAD(-2),RAD(-42.7)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-86.5),RAD(1.7),RAD(115.6)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1.1,-1,-0.1)*ANGLES(RAD(0),RAD(-86.5),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(0.9,-1,0.3)*ANGLES(RAD(0),RAD(42.6),RAD(0)),Alpha)
		end
		ATTACK = false
	end

	function twoslashes()
		potating = true
		ATTACK = true
		local ab = false
		local prop = CreatePart(3,Effects,"Neon",0,1,"Teal","Eliza",VT(1,1,1),true)
		prop.CFrame = RootPart.CFrame
		for i = 0,50 do
			local Alpha = .1
			Swait()
			axew.C1 = axew.C1:lerp(CF(0,0,0) * ANGLES(RAD(30),0,0),Alpha)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(-90),RAD(0),RAD(101.7)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,-0.1)*ANGLES(RAD(-19.7),RAD(-82.1),RAD(-19.5)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.3,0.8,0.3)*ANGLES(RAD(91.5),RAD(-2),RAD(50.3)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-93.8),RAD(0.8),RAD(-101.7)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-0.9,-1,0.2)*ANGLES(RAD(0),RAD(-43),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0)*ANGLES(RAD(0),RAD(82.4),RAD(0)),Alpha)
		end
		CreateSound(211059653,Torso,7,0.75,false)
		coroutine.resume(coroutine.create(function()
			repeat Swait()
				WACKYEFFECT2({Time = 60, EffectType = "Round Slash", Size = VT(.4,.4,1), Size2 = VT(.4,.4,.9), Transparency = 0, Transparency2 = 1, CFrame = prop.CFrame * ANGLES(0,RAD(90),0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})

			until ab == true
		end))
		coroutine.resume(coroutine.create(function()
			prop.CFrame = CF(prop.Position,Mouse.Hit.p)
			for i = 1,40 do
				Swait()
				prop.CFrame = prop.CFrame * CF(0,0,-2)
				--ApplyAoE(prop.Position,16,0,0,0,true)
				------local hit,pos = Raycast(prop.Position,prop.CFrame.lookVector,5,Character)
			end

			ab = true
			WACKYEFFECT2({Time = 85, EffectType = "Sphere", Size = prop.Size*10, Size2 = prop.Size*50, Transparency = 0.4, Transparency2 = 1, CFrame = prop.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = 438666077, SoundPitch = 1, SoundVolume = 9, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			WACKYEFFECT2({Time = 85, EffectType = "Sphere", Size = prop.Size*5, Size2 = prop.Size*25, Transparency = 0.4, Transparency2 = 1, CFrame = prop.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = 1, SoundVolume = 9, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			for i = 1,2 do
				WACKYEFFECT2({Time = 85, EffectType = "Wave", Size = VT(10,1,10), Size2 = VT(60,3,60), Transparency = 0, Transparency2 = 1, CFrame = prop.CFrame, MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-5,5), RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			end
			for i = 1,4 do
				WACKYEFFECT2({Time = 85, EffectType = "Round Slash", Size = VT(.01,.01,.01), Size2 = VT(.34,.2,.34), Transparency = 0, Transparency2 = 1, CFrame = prop.CFrame, MoveToPos = nil, RotationX = MRANDOM(-8,8), RotationY = MRANDOM(-8,8), RotationZ = MRANDOM(-8,8), Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			end
			for i = 1,9 do
				WACKYEFFECT2({Time = 85, EffectType = "Skull", Size = VT(3,3,3), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = prop.CFrame, MoveToPos = prop.Position + VT(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45)), RotationX = MRANDOM(-12,12), RotationY = MRANDOM(-12,12), RotationZ = MRANDOM(-12,12), Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			end
			prop:Destroy()
		end))

		for i = 0,14 do
			Swait()
			local Alpha = .2
			axew.C1 = axew.C1:lerp(CF(0,0,0) * ANGLES(RAD(-30),0,0),Alpha)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(-90),RAD(0),RAD(-115.7)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,-0.1)*ANGLES(RAD(-19.7),RAD(-82.1),RAD(-19.5)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.1,0.8,-0.8)*ANGLES(RAD(91.5),RAD(-2),RAD(-42.7)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-86.5),RAD(1.7),RAD(115.6)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1.1,-1,-0.1)*ANGLES(RAD(0),RAD(-86.5),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(0.9,-1,0.3)*ANGLES(RAD(0),RAD(42.6),RAD(0)),Alpha)
		end

		local ac = false
		local prop2 = CreatePart(3,Effects,"Neon",0,1,"Teal","WhenYoureGod",VT(1,1,1),true)
		prop2.CFrame = RootPart.CFrame * ANGLES(RAD(0),RAD(0),RAD(90))

		for i = 0,20 do
			Swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,0,0.2)*ANGLES(RAD(-72.7),RAD(0),RAD(-172.2)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,-0.1)*ANGLES(RAD(-19.7),RAD(-82.1),RAD(-19.5)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.7,-0.1)*ANGLES(RAD(-31.9),RAD(84.6),RAD(-136.3)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-89.5),RAD(3.8),RAD(172.2)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1.1,-1.1,-0.1)*ANGLES(RAD(-47.9),RAD(-85.5),RAD(-30.9)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1,-1.1,0.1)*ANGLES(RAD(-12.2),RAD(64.9),RAD(-5.5)),Alpha)
		end
		coroutine.resume(coroutine.create(function()
			repeat Swait()
				WACKYEFFECT2({Time = 60, EffectType = "Round Slash", Size = VT(.4,.4,1), Size2 = VT(.4,.4,.9), Transparency = 0, Transparency2 = 1, CFrame = prop2.CFrame * ANGLES(0,RAD(90),0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})

			until ac == true
		end))

		coroutine.resume(coroutine.create(function()
			prop2.CFrame = CF(prop2.Position,Mouse.Hit.p) * ANGLES(RAD(0),RAD(0),RAD(90))
			for i = 1,40 do
				Swait()
				prop2.CFrame = prop2.CFrame * CF(0,0,-2)
				--local hit,pos = Raycast(prop2.Position,prop2.CFrame.lookVector,5,Character)
				--ApplyAoE(prop2.Position,16,0,0,0,true)
			end
			ac = true
			WACKYEFFECT2({Time = 85, EffectType = "Sphere", Size = prop2.Size*10, Size2 = prop2.Size*50, Transparency = 0.4, Transparency2 = 1, CFrame = prop2.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = 438666077, SoundPitch = 1, SoundVolume = 9, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			WACKYEFFECT2({Time = 85, EffectType = "Sphere", Size = prop2.Size*5, Size2 = prop2.Size*25, Transparency = 0.4, Transparency2 = 1, CFrame = prop2.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = 1, SoundVolume = 9, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			for i = 1,2 do
				WACKYEFFECT2({Time = 85, EffectType = "Wave", Size = VT(10,1,10), Size2 = VT(60,3,60), Transparency = 0, Transparency2 = 1, CFrame = prop2.CFrame *ANGLES(RAD(0),RAD(0),RAD(-90)), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-5,5), RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			end
			for i = 1,4 do
				WACKYEFFECT2({Time = 85, EffectType = "Round Slash", Size = VT(.01,.01,.01), Size2 = VT(.34,.2,.34), Transparency = 0, Transparency2 = 1, CFrame = prop2.CFrame, MoveToPos = nil, RotationX = MRANDOM(-8,8), RotationY = MRANDOM(-8,8), RotationZ = MRANDOM(-8,8), Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			end
			for i = 1,9 do
				WACKYEFFECT2({Time = 85, EffectType = "Skull", Size = VT(3,3,3), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = prop2.CFrame, MoveToPos = prop2.Position + VT(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45)), RotationX = MRANDOM(-12,12), RotationY = MRANDOM(-12,12), RotationZ = MRANDOM(-12,12), Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			end	prop2:Destroy()
		end))

		for i = 0,14 do
			local Alpha = .2
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.3)*ANGLES(RAD(-114.5),RAD(3.7),RAD(-160.7)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,-0.1)*ANGLES(RAD(-19.7),RAD(-82.1),RAD(-19.5)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.2,-0.4)*ANGLES(RAD(-56.4),RAD(76.9),RAD(74.7)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-89.5),RAD(3.8),RAD(172.2)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.6)*ANGLES(RAD(136.4),RAD(-77.8),RAD(113.6)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(0.9,-0.9,0.1)*ANGLES(RAD(6.2),RAD(54.6),RAD(19.5)),Alpha)
		end
		CreateSound(211059653,Torso,7,0.75,false)
		ATTACK = false
		potating = false
	end

	function headthroww()
		-- removed because of bug
	end

	--[[sp = sp + 30
	if sp >= 360 then
	sp = 0
	end]]
	function axes()
		ATTACK = true
		for i = 0,20 do
			Swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(-90),RAD(0),RAD(-146)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,-0.1)*ANGLES(RAD(-19.7),RAD(-82.1),RAD(-19.5)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.9,0)*ANGLES(RAD(7.6),RAD(69),RAD(-175.4)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-87.8),RAD(3.2),RAD(145.9)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1.1,-1,0)*ANGLES(RAD(0),RAD(-77.7),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0.1)*ANGLES(RAD(0),RAD(66.2),RAD(0)),Alpha)	
		end
		for i = 0,20 do
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.4,0)*ANGLES(RAD(-90),RAD(0),RAD(-146)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,-0.1)*ANGLES(RAD(-19.7),RAD(-82.1),RAD(-19.5)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.2,-0.1)*ANGLES(RAD(7.6),RAD(69),RAD(57.4)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(-0.1,1,0.1)*ANGLES(RAD(-99.5),RAD(10.8),RAD(147.4)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-0.6,-0.8)*ANGLES(RAD(0),RAD(-77.7),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1.1,-0.9,-0.7)*ANGLES(RAD(0),RAD(84),RAD(-43.7)),Alpha)
		end
		local a = {}
		local hf,hp = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 3.7, Character)
		if hf then
			coroutine.resume(coroutine.create(function()
				for i = 1,8 do
					swait(.07)
					local sw = script.asw:Clone()
					table.insert(a,sw)
					local ps = RootPart.CFrame*CF(0,0,-i*22)
					local hf2,hp2 = Raycast(ps.p+VT(0,1,0), (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 3.7, Character)
					if hf then
						local ab = CF(hp2) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
						sw.Parent = Effects
						sw.CFrame = ab * CF(0,-6,0)
						coroutine.resume(coroutine.create(function()
							for i = 0,5 do
								swait()
								sw.Orientation = RootPart.Orientation
								sw.CFrame = sw.CFrame:lerp(sw.CFrame*CF(0,.6,0),2.5)
							end
							--ApplyAoE(ab.p,15,0,0,0,true)
							WACKYEFFECT2({Time = 70, EffectType = "Sphere", Size = VT(2,1,2), Size2 = VT(38,1,38), Transparency = 0, Transparency2 = 1, CFrame = ab, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							WACKYEFFECT2({Time = 70, EffectType = "Sphere", Size = VT(2,3,2), Size2 = VT(27,45,27), Transparency = 0, Transparency2 = 1, CFrame = ab, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = 228343343, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							for i = 1,2 do
								WACKYEFFECT2({Time = 80, EffectType = "Wave", Size = VT(10,1,10), Size2 = VT(23,3,23), Transparency = 0, Transparency2 = 1, CFrame = ab, MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-5,5), RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
							end
							for i = 1,4 do
								WACKYEFFECT2({Time = 70, EffectType = "Round Slash", Size = VT(.01,.01,.01), Size2 = VT(.1,.1,.3), Transparency = 0, Transparency2 = 1, CFrame = ab, MoveToPos = nil, RotationX = MRANDOM(-6,6), RotationY = MRANDOM(-6,6), RotationZ = MRANDOM(-6,6), Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							end
							for i = 1,3 do
								WACKYEFFECT2({Time = 80, EffectType = "Round Slash", Size = VT(.01,.01,.01), Size2 = VT(.15,.035,.15), Transparency = 0, Transparency2 = 1, CFrame = ab, MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-4,4), RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
							end
							for i = 1,2 do
								WACKYEFFECT2({Time = 70, EffectType = "Sphere", Size = VT(2.5,2.5,2.5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = ab, MoveToPos = ab.p + VT(MRANDOM(-40,40),MRANDOM(-49,49),MRANDOM(-40,40)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 20, SizeBoomerang = 0})
							end
						end))
					end
				end
				for b = 1,#a do
					Debris:AddItem(a[b],1.6)
				end
			end))
		end
		for i =0,17 do
			Swait()
			local Alpha = .27
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,-1.1,0)*ANGLES(RAD(-90),RAD(0),RAD(-146)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,-0.1)*ANGLES(RAD(-19.7),RAD(-82.1),RAD(-19.5)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0,-0.5)*ANGLES(RAD(7.6),RAD(69),RAD(17.6)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(-0.1,1,0.1)*ANGLES(RAD(-99.5),RAD(10.8),RAD(147.4)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,0.1,-0.8)*ANGLES(RAD(0),RAD(-77.7),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1.1,-1.4,-0.8)*ANGLES(RAD(0),RAD(84),RAD(-88.7)),Alpha)
		end
		ATTACK = false
	end

	function pumpkinboomb()
		ATTACK = true
		local d2 = false
		for i = 0,20 do
			Swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(-90),RAD(0),RAD(142.8)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1.5,0.8,0.4)*ANGLES(RAD(-93.2),RAD(53.9),RAD(63.8)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.4,0.1)*ANGLES(RAD(-35.1),RAD(60.4),RAD(39)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-92.3),RAD(3.1),RAD(-142.8)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(0),RAD(-59.5),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0)*ANGLES(RAD(0),RAD(82.4),RAD(0)),Alpha)
		end
		local acid = CreatePart(3,Effects,"Neon",0,0,"Teal","ThanosPoggers",VT(1.3,1.3,1.3),false)
		MakeForm(acid,"Ball")
		acid.Color = Color3.fromRGB(19, 255, 117)
		acid.CFrame = LeftArm.CFrame * CF(0,-1,0)
		local aq = CreateWeldOrSnapOrMotor("Weld",acid,acid,LeftArm,CF(0,1,0),d)
		coroutine.resume(coroutine.create(function()
			repeat swait(.09)
				local ac2 = acid:Clone()
				ac2.Parent = Effects
				ac2.Name = "lol!"
				ac2:BreakJoints()
				ac2.Anchored = false
				ac2.Size = ac2.Size * 0.7
				ac2.CFrame = ac2.CFrame * ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				Debris:AddItem(ac2,.5)
				--if MRANDOM(1,4) == 1 then
				WACKYEFFECT2({Time = 60, EffectType = "Round Slash", Size = VT(.01,.01,.01), Size2 = VT(.03,.03,.03), Transparency = 0, Transparency2 = 1, CFrame = acid.CFrame * ANGLES(MRANDOM(0,360),MRANDOM(0,360),MRANDOM(0,360)), MoveToPos = acid.Position + VT(0,1,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
				--end
			until d2 == true
		end))
		for i = 0,20 do
			Swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(-90),RAD(0),RAD(142.8)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.9,1,0.2)*ANGLES(RAD(83.7),RAD(-83.6),RAD(-90.6)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.4,0.1)*ANGLES(RAD(-35.1),RAD(60.4),RAD(39)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-92.3),RAD(3.1),RAD(-142.8)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(0),RAD(-59.5),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0)*ANGLES(RAD(0),RAD(82.4),RAD(0)),Alpha)
		end
		acid.Anchored = true
		aq:Destroy()
		coroutine.resume(coroutine.create(function()
			acid.CFrame = CF(acid.Position,Mouse.Hit.p)
			for i = 0,250 do
				Swait()
				acid.CFrame = acid.CFrame * CF(0,0,-2)
				local hit,pos = Raycast(acid.Position,acid.CFrame.lookVector,5,Character)
				if hit then break end	
			end
			d2 = true
			local gr = CreatePart(3,Effects,"Neon",0,0,"Teal","RedditMoment",VT(1,0,1),true)
			gr.Color = Color3.fromRGB(19, 255, 117)
			gr.CFrame = acid.CFrame
			MakeForm(gr,"Ball")
			gr.Orientation = VT(0,0,0)
			acid:Destroy()
			local hf,hp = Raycast(gr.Position, (CF(gr.Position, gr.Position + VT(0, -1, 0))).lookVector, 3.7, Character)
			gr.CFrame = CF(hp)
			CreateSound(2767090,gr,8,.7,false)
			for i = 1,40,1 do
				Swait()
				gr.Size = VT(1*i,0,1*i)
				--ApplyAoE(gr.Position,1*i/2,0,0,0,true)
			end
			WACKYEFFECT2({Time = 60, EffectType = "Sphere", Size = gr.Size*0.9, Size2 = gr.Size*1.3, Transparency = 0, Transparency2 = 1, CFrame = gr.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = .7, SoundVolume = 9, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 23})
			for i = 1,2 do
				WACKYEFFECT2({Time = 70, EffectType = "Round Slash", Size = VT(.3,.001,.3), Size2 = VT(.5,.001,.5), Transparency = 0, Transparency2 = 1, CFrame = gr.CFrame * CF(0,.1,0), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-3,3), RotationZ = 0, Material = "Neon",Color = Color3.fromRGB(19, 255, 117),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 23})
			end
			swait(.8)
			for i = 1,40,.05 do
				Swait()
				gr.Size = VT(gr.Size.X-i,0,gr.Size.Z-i)
			end	
		end))
		for i = 0,14 do
			Swait()
			local Alpha = .23
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.1)*ANGLES(RAD(-90),RAD(0),RAD(122.3)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.8,0.5,-0.5)*ANGLES(RAD(117.9),RAD(-42.3),RAD(84.7)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.4,0.1)*ANGLES(RAD(-35.1),RAD(60.4),RAD(39)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0.1,1,0.1)*ANGLES(RAD(-93.3),RAD(2.1),RAD(-122.2)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(0),RAD(-59.5),RAD(0)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0)*ANGLES(RAD(0),RAD(82.4),RAD(0)),Alpha)
		end
		ATTACK = false
	end

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	v.Anchored = false

	local Outline = Instance.new("SelectionBox", v)
	Outline.LineThickness = 0.1
	Outline.Color3 = Color3.fromRGB(195, 130, 0)
	Outline.Adornee = v

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if ATTACK == false then
				bp.Position = game.Players.LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)

	sla.axe.Main.Touched:Connect(function(hit)
		if hit.Parent:FindFirstChild("Humanoid") and potating == true then
			if hit.Parent.Name == game.Players.LocalPlayer.Name then
				--print("not flinging")
			else
				if hit.Parent:FindFirstChild("UpperTorso") then
					bp.Position = hit.Parent:FindFirstChild("UpperTorso").Position
				elseif hit.Parent:FindFirstChild("Torso") then
					bp.Position = hit.Parent:FindFirstChild("Torso").Position
				end
			end
		end
	end)

	--keys
	function MouseDown(Mouse)
		if ATTACK == false and COMBO == 1 then
			COMBO = 2
			punch()
		elseif ATTACK == false and COMBO == 2 then
			itknee()
			COMBO = 3
		elseif ATTACK == false and COMBO == 3 then
			wack()
			COMBO = 1
		end
	end

	function MouseUp(Mouse)
		HOLD = false
	end

	function KeyDown(Key)
		KEYHOLD = true
		if Key == "v" and ATTACK == false then
			pumpkinboomb()
		end

		if Key == "z" and ATTACK == false then
			twoslashes()
		end

		if Key == "c" and ATTACK == false then
			axes()
		end

		if Key == "m" then
			cs()
		end

		if Key == "x" and ATTACK == false then
			headthroww()
		end

		if Key == "]" and ATTACK == false then
			if sick.Parent ~= Torso then
				sick = IT("Sound",Torso)
				sick.SoundId = "rbxassetid://"..SONG
			end
		end
	end

	function KeyUp(Key)
		KEYHOLD = false
	end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

	function unanchor()
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA("BasePart") and c ~= RootPart then
				c.Anchored = false
			end
		end
		if UNANCHOR == true then
			RootPart.Anchored = false
		else
			RootPart.Anchored = true
		end
	end

	--loop stuff

	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)

	while true do
		Swait()
		script.Parent = WEAPONGUI
		ANIMATE.Parent = nil
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		SINE = SINE + CHANGE*2
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
		local TiltVelocity = CF(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity/1.6))
		local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			ANIM = "Idle"
			if ATTACK == false then
				local Alpha = .1
				axew.C1 = axew.C1:lerp(CF(0,0,0) * ANGLES(RAD(0 - 3 * SIN(SINE/33)),RAD(0),RAD(0)),Alpha)
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 + 0.08 * COS(SINE/33),0)*ANGLES(RAD(-90),RAD(0),RAD(142.8)),Alpha)
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5 + 0.04 * SIN(SINE/33),-0.1)*ANGLES(RAD(-19.7 + 2 * COS(SINE/45)),RAD(-82.1 + 3 * COS(SINE/55)),RAD(-19.5)),Alpha)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.4 + 0.04 * SIN(SINE/33),0.1)*ANGLES(RAD(-35.1-  1 * COS(SINE/39)),RAD(60.4 + 7 * COS(SINE/66)),RAD(39)),Alpha)
				Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-92.3 + 2 * SIN(SINE/33)),RAD(3.1),RAD(-142.8)),Alpha)
				LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1- 0.08 * COS(SINE/33),0.1)*ANGLES(RAD(0),RAD(-59.5),RAD(0)),Alpha)
				RightHip.C0 = RightHip.C0:lerp(CF(1,-1- 0.08 * COS(SINE/33),0)*ANGLES(RAD(0),RAD(82.4),RAD(0)),Alpha)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				local Alpha = .1
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0 - 0.10 * COS(SINE/(WALKSPEEDVALUE/2)))*ANGLES(RAD(-92+3*SIN(SINE/(WALKSPEEDVALUE/2)))+RAD(TiltVelocity.z)*1,RAD(0),RAD(-194+10*COS(SINE/WALKSPEEDVALUE))),Alpha)
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,0)*ANGLES(RAD(-25*COS(SINE/WALKSPEEDVALUE))+SIN(SINE/WALKSPEEDVALUE)/2.5,RAD(-90)-RAD(TiltVelocity.X)*0.5,RAD(0)),Alpha)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5,0)*ANGLES(RAD(0--[[*COS(SINE/WALKSPEEDVALUE))-SIN(SINE/WALKSPEEDVALUE)/2.5]]),RAD(45)-RAD(TiltVelocity.X)*0.5,RAD(39)),Alpha)
				Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-90+1.5*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(-166-10*COS(SINE/WALKSPEEDVALUE))-RAD(TiltVelocity.x)*3),Alpha)
				LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1+0.35*COS(SINE/WALKSPEEDVALUE)/2,0-0.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5+15*COS(SINE/WALKSPEEDVALUE))+RootPart.RotVelocity.Y/75+SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.z)*10,RAD(-90-25*COS(SINE/WALKSPEEDVALUE)*RAD(TiltVelocity.X)*5.5),RAD(0))*ANGLES(RAD(0-2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)
				RightHip.C0 = RightHip.C0:lerp(CF(1,-1-0.35*COS(SINE/WALKSPEEDVALUE)/2,0+0.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5-15*COS(SINE/WALKSPEEDVALUE))-RootPart.RotVelocity.Y/-75+-SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.z)*10,RAD(90+25*COS(SINE/WALKSPEEDVALUE)*RAD(TiltVelocity.X)*5.5),RAD(0))* ANGLES(RAD(0+2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)
			end
		end
		unanchor()
		Humanoid.MaxHealth = 1e4
		Humanoid.Health = 1e4
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		sick.SoundId = "rbxassetid://"..SONG
		sick.Looped = true
		sick.Pitch = 1
		sick.Volume = 3
		sick.Playing = true
	end

	--//=================================\\
	--\\=================================//





	--//====================================================\\--
	--||			  		 END OF SCRIPT
	--\\====================================================//--
end)

Button_4.MouseButton1Down:Connect(function()
	local script = game:GetObjects("rbxassetid://5979797425")[1]

	wait(0.5)

	warn([[Incension Reborn loaded

Created by 
]])

	---- Sources and functions might be taken from others
	plr = game.Players.LocalPlayer
	char = plr.Character["Dummy"]
	hum = char.Humanoid
	local cam = game.Workspace.CurrentCamera
	Camera = cam
	local CamInterrupt = false
	local TwoD = false
	local TargetInfo = {nil, nil}
	cam.CameraType = "Custom"
	t = char.Torso
	h = char.Head
	ra = char["Right Arm"]
	la = char["Left Arm"]
	rl = char["Right Leg"]
	ll = char["Left Leg"]
	tors = char.Torso
	lleg = char["Left Leg"]
	root = char.HumanoidRootPart
	hed = char.Head
	rleg = char["Right Leg"]
	rarm = char["Right Arm"]
	larm = char["Left Arm"]
	radian = math.rad
	random = math.random
	Vec3 = Vector3.new
	Inst = Instance.new
	cFrame = CFrame.new
	Euler = CFrame.fromEulerAnglesXYZ
	vt = Vector3.new
	bc = BrickColor.new
	br = BrickColor.random
	it = Instance.new
	cf = CFrame.new

	local OVERPOWER = false

	function shakes(power,length)
		for i,v in pairs(game:GetService("Players"):GetChildren()) do
			local var = script.Shaker:Clone()
			var.Parent = v.Character
			local pw = var.Shakeval
			local lgth = var.MultLength
			pw.Value = power
			lgth.Value = length
			var.Disabled = false
			game:GetService("Debris"):AddItem(var, length+4)
		end
	end

	function localshakes(power,length)
		local var = script.Shaker:Clone()
		var.Parent = plr.Character
		local pw = var.Shakeval
		local lgth = var.MultLength
		pw.Value = power
		lgth.Value = length
		var.Disabled = false
		game:GetService("Debris"):AddItem(var, length+4)
	end

	local Booleans = {
		CamFollow = true,
		GyroUse = true
	}

	function lerp(object, newCFrame, alpha)
		return object:lerp(newCFrame, alpha)
	end

	local Directer = Inst("BodyGyro", root)
	Directer.MaxTorque = Vec3(0, 0, 0)
	Directer.P = 600000
	local CPart = Inst("Part")
	CPart.Anchored = true
	CPart.CanCollide = false
	CPart.Locked = true
	CPart.Transparency = 1

	local rainbowmode = false
	local chaosmode = false

	local kan = Instance.new("Sound",tors)
	kan.Volume = 0.5
	kan.TimePosition = 0
	kan.PlaybackSpeed = 1.01
	kan.Pitch = 1.01
	kan.SoundId = "rbxassetid://1882656833" -- 2485070323/1882656833, Original: 2026469207
	kan.Name = "ye"
	kan.Looped = true
	kan:Play()

	local currentThemePlaying = kan.SoundId
	local currentPitch = kan.Pitch
	local currentVol = kan.Volume
	function newTheme(ID,timepos,pitch,vol)
		local kanz = kan
		--kanz:Stop()
		kanz.Volume = vol
		--kanz.TimePosition = timepos
		kanz.PlaybackSpeed = pitch
		kanz.Pitch = pitch
		kanz.SoundId = ID
		kanz.Name = "wrecked"
		kanz.Looped = true
		currentThemePlaying = kanz.SoundId
		currentVol = kanz.Volume
		currentPitch = kanz.Pitch
		--kanz:Play()
		--coroutine.resume(coroutine.create(function()
		--wait(0.05)
		--end))
	end


	function newThemeCust(ID,timepos,pitch,vol)
		local kanz = kan
		kanz:Stop()
		kanz.Volume = vol
		kanz.TimePosition = timepos
		kanz.PlaybackSpeed = pitch
		kanz.Pitch = pitch
		kanz.SoundId = ID
		kanz.Name = "wrecked"
		kanz.Looped = true
		currentThemePlaying = kanz.SoundId
		currentVol = kanz.Volume
		currentPitch = kanz.Pitch
		kanz:Play()
		coroutine.resume(coroutine.create(function()
			wait(0.05)
		end))
	end

	local mutedtog = false

	function CameraEnshaking(Length,Intensity)
		coroutine.resume(coroutine.create(function()
			local intensity = 1*Intensity
			local rotM = 0.01*Intensity
			for i = 0, Length, 0.1 do
				swait()
				intensity = intensity - 0.05*Intensity/Length
				rotM = rotM - 0.0005*Intensity/Length
				hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
				cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
			end
			Humanoid.CameraOffset = Vec3(0, 0, 0)
		end))
	end
	CamShake=function(Part,Distan,Power,Times) 
		local de=Part.Position
		for i,v in pairs(workspace:children()) do
			if v:IsA("Model") and v:findFirstChild("Humanoid") then
				for _,c in pairs(v:children()) do
					if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
						local Noob=v.Humanoid
						if Noob~=nil then
							coroutine.resume(coroutine.create(function()
								FV = Instance.new("BoolValue", Noob)
								FV.Name = "CameraShake"
								for ShakeNum=1,Times do
									swait()
									local ef=Power
									if ef>=1 then
										Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
									else
										ef=Power*10
										Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
									end	
								end
								Humanoid.CameraOffset = Vector3.new(0,0,0)
								FV:Destroy()
							end))
							CameraShake(Times, Power, Noob)
						end
					end
				end
			end
		end
	end

	local toggleTag = true
	local bilguit = Instance.new("BillboardGui", hed)
	bilguit.Adornee = nil
	bilguit.Name = "ModeName"
	bilguit.Size = UDim2.new(4, 0, 1.2, 0)
	bilguit.StudsOffset = Vector3.new(-8, 8/1.5, 0)
	local modet = Instance.new("TextLabel", bilguit)
	modet.Size = UDim2.new(10/2, 0, 7/2, 0)
	modet.FontSize = "Size8"
	modet.TextScaled = true
	modet.TextTransparency = 0
	modet.BackgroundTransparency = 1 
	modet.TextTransparency = 0
	modet.TextStrokeTransparency = 0
	modet.Font = "Antique"
	modet.TextStrokeColor3 = Color3.new(1,0,0)
	modet.TextColor3 = Color3.new(0.25,0,0)
	modet.Text = ""


	function chatfunc(text,color,typet,font,timeex)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard")~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end
			local naeeym2 = Instance.new("BillboardGui",Character)
			naeeym2.Size = UDim2.new(0,100,0,40)
			naeeym2.StudsOffset = Vector3.new(0,3,0)
			naeeym2.Adornee = Character.Head
			naeeym2.Name = "TalkingBillBoard"
			local tecks2 = Instance.new("TextLabel",naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.BorderSizePixel = 0
			tecks2.Text = ""
			tecks2.Font = font
			tecks2.TextSize = 30
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = color
			tecks2.TextStrokeColor3 = Color3.new(0,0,0)
			tecks2.Size = UDim2.new(1,0,0.5,0)
			local tecks3 = Instance.new("TextLabel",naeeym2)
			tecks3.BackgroundTransparency = 1
			tecks3.BorderSizePixel = 0
			tecks3.Text = ""
			tecks3.Font = font
			tecks3.TextSize = 30
			tecks3.TextStrokeTransparency = 0
			if typet == "Inverted" then
				tecks3.TextColor3 = Color3.new(0,0,0)
				tecks3.TextStrokeColor3 = color
			elseif typet == "Normal" then
				tecks3.TextColor3 = color
				tecks3.TextStrokeColor3 = Color3.new(0,0,0)
			end
			tecks3.Size = UDim2.new(1,0,0.5,0)
			coroutine.resume(coroutine.create(function()
				while true do
					swait(1)
					if chaosmode == true then
						tecks2.TextColor3 = BrickColor.random().Color
						tecks3.TextStrokeColor3 = BrickColor.random().Color
					end
				end
			end))
			modet.TextTransparency = modet.TextTransparency  + 1
			modet.TextStrokeTransparency = modet.TextStrokeTransparency + 1
			for i = 0, 74*timeex do
				swait()
				modet.TextTransparency = 1
				modet.TextStrokeTransparency = 1
				tecks2.Text = text
				tecks3.Text = text
			end
			local randomrot = math.random(1,2)
			if randomrot == 1 then
				for i = 1, 50 do
					swait()
					tecks2.Text = text
					tecks3.Text = text
					modet.TextTransparency = modet.TextTransparency - .02
					modet.TextStrokeTransparency = modet.TextStrokeTransparency - .02
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			elseif randomrot == 2 then
				for i = 1, 50 do
					swait()
					tecks2.Text = text
					tecks3.Text = text
					modet.TextTransparency = modet.TextTransparency - .02
					modet.TextStrokeTransparency = modet.TextStrokeTransparency - .02
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			end
			modet.TextTransparency = 0
			modet.TextStrokeTransparency = 0
			if toggleTag == false then
				modet.TextTransparency = 1
				modet.TextStrokeTransparency = 1
			end
			naeeym2:Destroy()
		end)
		chat()
	end

	function bosschatfunc(text,color,watval)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("Dialog")~= nil then
					v.PlayerGui:FindFirstChild("Dialog"):destroy()
				end
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
				scrg.Name = "Dialog"
				local txtlb = Instance.new("TextLabel",scrg)
				txtlb.Text = ""
				txtlb.Font = "Bodoni"
				txtlb.TextColor3 = Color3.new(0,0,0)
				txtlb.TextStrokeTransparency = 0
				txtlb.BackgroundTransparency = 0.75
				txtlb.BackgroundColor3 = Color3.new(0,0,0)
				txtlb.TextStrokeColor3 = color
				txtlb.TextScaled = true
				txtlb.Size = UDim2.new(1,0,0.25,0)
				txtlb.TextXAlignment = "Left"
				txtlb.Position = UDim2.new(0,0,0.75 + 1,0)
				local txtlb2 = Instance.new("TextLabel",scrg)
				txtlb2.Text = "???:"
				txtlb2.Font = "Arcade"
				txtlb2.TextColor3 = Color3.new(0,0,0)
				txtlb2.TextStrokeTransparency = 0
				txtlb2.BackgroundTransparency = 1
				txtlb2.TextStrokeColor3 = color
				txtlb2.TextSize = 40
				txtlb2.Size = UDim2.new(1,0,0.25,0)
				txtlb2.TextXAlignment = "Left"
				txtlb2.Position = UDim2.new(0,0,1,0)
				local fvalen = 0.55
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if chaosmode == true then
							txtlb.Rotation = math.random(-1,1)
							txtlb2.Rotation = math.random(-1,1)
							txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb.TextStrokeColor3 = BrickColor.random().Color
							txtlb2.TextStrokeColor3 = BrickColor.random().Color
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if scrg.Parent ~= nil then
							fvalen = fvalen - 0.0001
						elseif scrg.Parent == nil then
							break
						end
					end
				end))
				local flol = 1.75
				local flil = 1.6
				coroutine.resume(coroutine.create(function()
					for i = 0, 9 do
						swait()
						fval = fval + 0.05
						flol = flol - 0.1
						flil = flil - 0.1
						txtlb.Text = ""
						txtlb.Position = UDim2.new(0,0,flol,0)
						txtlb2.Position = UDim2.new(0,0,flil,0)
					end
					txtlb.Text = text
					wait(watval)
					local valinc = 0
					for i = 0, 99 do
						swait()
						valinc = valinc + 0.0001
						flol = flol + valinc
						flil = flil + valinc
						txtlb.Rotation = txtlb.Rotation + valinc*20
						txtlb2.Rotation = txtlb2.Rotation - valinc*50
						txtlb.Position = UDim2.new(0,0,flol,0)
						txtlb2.Position = UDim2.new(0,0,flil,0)
						txtlb.TextStrokeTransparency = txtlb.TextStrokeTransparency + 0.01
						txtlb.TextTransparency = txtlb.TextTransparency + 0.01
						txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
						txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
						txtlb.BackgroundTransparency = txtlb.BackgroundTransparency + 0.0025
					end
					scrg:Destroy()
				end))
			end))
		end
	end

	loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()

	local Create = LoadLibrary("RbxUtility").Create

	CFuncs = {	
		["Part"] = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part"){
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material,
				}
				RemoveOutlines(Part)
				return Part
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Weld"] = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld"){
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1,
				}
				return Weld
			end;
		};

		["Sound"] = {
			Create = function(id, par, vol, pit) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 10)
				end))
			end;
		};

		["TimeSound"] = {
			Create = function(id, par, vol, pit, timepos) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						TimePosition = timepos,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 10)
				end))
			end;
		};
		["EchoSound"] = {
			Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
				coroutine.resume(coroutine.create(function()
					local Sas = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						TimePosition = timepos,
						Parent = par or workspace,
					}
					local E = Create("EchoSoundEffect"){
						Delay = echodelay,
						Name = "Echo",
						Feedback = fedb,
						DryLevel = dryl,
						Parent = Sas,
					}
					wait() 
					Sas:play() 
					game:GetService("Debris"):AddItem(Sas, delays)
				end))
			end;
		};

		["LongSound"] = {
			Create = function(id, par, vol, pit) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 60)
				end))
			end;
		};

		["ParticleEmitter"] = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter"){
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread,
				}
				return fp
			end;
		};

		CreateTemplate = {

		};
	}



	New = function(Object, Parent, Name, Data)
		local Object = Instance.new(Object)
		for Index, Value in pairs(Data or {}) do
			Object[Index] = Value
		end
		Object.Parent = Parent
		Object.Name = Name
		return Object
	end
	local halocolor = BrickColor.new("Pastel light blue")
	local halocolor2 = BrickColor.new("Cool yellow")
	local starcolor = BrickColor.new("Bright yellow")
	local lunacolor = BrickColor.new("Navy blue")
	local lunacolor2 = BrickColor.new("Bright blue")
	local wepcolor = BrickColor.new("Really black")
	local maincolor = BrickColor.new("Really black")
	local m = Instance.new("Model",char)
	local m2 = Instance.new("Model",char)
	local m3 = Instance.new("Model",char)
	local mw1 = Instance.new("Model",char)
	local mw2 = Instance.new("Model",char)


	gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
		local gui = it(GuiType)
		gui.Parent = parent
		gui.Text = text
		gui.BackgroundTransparency = backtrans
		gui.BackgroundColor3 = backcol
		gui.SizeConstraint = "RelativeXY"
		gui.TextXAlignment = "Center"
		gui.TextYAlignment = "Center"
		gui.Position = pos
		gui.Size = size
		gui.Font = "SourceSans"
		gui.FontSize = "Size14"
		gui.TextWrapped = false
		gui.TextStrokeTransparency = 0
		gui.TextColor = BrickColor.new("White")
		return gui
	end
	--------------------------- GUI STUFF
--[[local basgui = it("GuiMain")
basgui.Parent = plr.PlayerGui
basgui.Name = "VISgui"
local fullscreenz = it("Frame")
fullscreenz.Parent = basgui
fullscreenz.BackgroundColor3 = Color3.new(255, 255, 255)
fullscreenz.BackgroundTransparency = 1
fullscreenz.BorderColor3 = Color3.new(17, 17, 17)
fullscreenz.Size = UDim2.new(1, 0, 1, 0)
fullscreenz.Position = UDim2.new(0, 0, 0, 0)
local imgl2 = Instance.new("ImageLabel",fullscreenz)
imgl2.BackgroundTransparency = 1
imgl2.BorderSizePixel = 0
imgl2.ImageTransparency = 0.5
imgl2.ImageColor3 = Color3.new(1,0,0)
imgl2.Position = UDim2.new(0.75,-200,0.55,-200)
imgl2.Size = UDim2.new(0,1000,0,1000)
imgl2.Image = "rbxassetid://2325939897"
local techc = imgl2:Clone()
techc.Parent = fullscreenz
techc.ImageTransparency = 0
techc.Size = UDim2.new(0,900,0,900)
techc.Position = UDim2.new(0.75,-150,0.55,-150)
techc.ImageColor3 = Color3.new(1,0,0)
techc.Image = "rbxassetid://2273224484"
local circl = imgl2:Clone()
circl.Parent = fullscreenz
circl.ImageTransparency = 0
circl.Size = UDim2.new(0,550,0,550)
circl.Position = UDim2.new(0.75,25,0.55,25)
circl.ImageColor3 = Color3.new(0,0,0)
circl.Image = "rbxassetid://2312119891"
local circl2 = imgl2:Clone()
circl2.Parent = fullscreenz
circl2.ImageTransparency = 0
circl2.Size = UDim2.new(0,700,0,700)
circl2.Position = UDim2.new(0.75,-50,0.55,-50)
circl2.ImageColor3 = Color3.new(1,0,0)
circl2.Image = "rbxassetid://2312119891"
local imgl2b = imgl2:Clone()
imgl2b.Parent = fullscreenz
imgl2b.ImageTransparency = 0
imgl2b.Size = UDim2.new(0,800,0,800)
imgl2b.Position = UDim2.new(0.75,-100,0.55,-100)
imgl2b.ImageColor3 = Color3.new(0,0,0)
local ned = Instance.new("TextLabel",fullscreenz)
ned.ZIndex = 2
ned.Font = "Arcade"
ned.BackgroundTransparency = 1
ned.BorderSizePixel = 0.65
ned.Size = UDim2.new(0.3,0,0.2,0)
ned.Position = UDim2.new(0.7,0,0.8,0)
ned.TextColor3 = BrickColor.new("Really red").Color
ned.TextStrokeColor3 = BrickColor.new("Really black").Color
ned.TextScaled = true
ned.TextStrokeTransparency = 0
ned.Text = "MAYHEM"
ned.TextSize = 24
ned.Rotation = 1
ned.TextXAlignment = "Right"
ned.TextYAlignment = "Bottom"]]--

	local extrawingmod1 = Instance.new("Model",char)
	local extrawingmod2 = Instance.new("Model",char)

	function CreateParta(parent,transparency,reflectance,material,brickcolor)
		local p = Instance.new("Part")
		p.TopSurface = 0
		p.BottomSurface = 0
		p.Parent = parent
		p.Size = Vector3.new(0.1,0.1,0.1)
		p.Transparency = transparency
		p.Reflectance = reflectance
		p.CanCollide = false
		p.Locked = true
		p.BrickColor = brickcolor
		p.Material = material
		return p
	end

	function CreateMesha(parent,meshtype,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = meshtype
		mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
		return mesh
	end

	function CreateSpecialMesh(parent,meshid,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.Scale = Vector3.new(x1,y1,z1)
		return mesh
	end


	function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
		mesh.Scale = Vector3.new(x1,y1,z1)
		mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
		return mesh
	end

	function CreateWelda(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
		local weld = Instance.new("Weld")
		weld.Parent = parent
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
		weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
		return weld
	end


	--------------
	-------------- ground effect
	local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWelda(sorb,rarm,sorb,0,2.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local cena = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWelda(cena,root,cena,0,3,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local effar = Instance.new("ParticleEmitter",cena)
	effar.Texture = "rbxassetid://2344870656"
	effar.LightEmission = 1
	effar.Color = ColorSequence.new(Color3.new(1,1,1))
	effar.Rate = 250
	effar.Enabled = false
	effar.EmissionDirection = "Front"
	effar.Lifetime = NumberRange.new(0.5,1)
	effar.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.1,5,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
	effar.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
	effar.Speed = NumberRange.new(30,40)
	effar.Acceleration = Vector3.new(0,50,0)
	effar.Drag = 5
	effar.Rotation = NumberRange.new(-500,500)
	effar.SpreadAngle = Vector2.new(0,900)
	effar.RotSpeed = NumberRange.new(-500,500)
	-------------- things
	local cen = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	local centrweld = CreateWelda(cen,root,cen,0,-3,-1.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local maincoler = BrickColor.new("Really red")

	local gntl = script.FakeArm:Clone()
	gntl.Anchored = false
	for i,v in pairs(gntl.StrobeGauntlet:GetDescendants()) do
		if v:IsA("Part") or v:IsA("UnionOperation") then
			v.Anchored = false
		end
	end
	for i,v in pairs(gntl.TemperGauntlet:GetDescendants()) do
		if v:IsA("Part") or v:IsA("UnionOperation") then
			v.Anchored = false
		end
	end
	gntl.Parent = m
	CreateWelda(gntl,rarm,gntl,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(180),math.rad(0))

	local gntl2 = script.FakeArm:Clone()
	gntl2.Anchored = false
	for i,v in pairs(gntl2.StrobeGauntlet:GetDescendants()) do
		if v:IsA("Part") or v:IsA("UnionOperation") then
			v.Anchored = false
		end
	end
	for i,v in pairs(gntl2.TemperGauntlet:GetDescendants()) do
		if v:IsA("Part") or v:IsA("UnionOperation") then
			v.Anchored = false
		end
	end
	gntl2.Parent = m
	CreateWelda(gntl2,larm,gntl2,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local gatlR = Instance.new("Model",m)
	local centerR = CreateParta(m,1,1,"SmoothPlastic",BrickColor.new("White"))
	local hologrmgun = CreateWelda(centerR,rarm,centerR,0,2.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	barz = CreateParta(gatlR,1,1,"Neon",BrickColor.new("White"))
	CreateMesha(barz,"Cylinder",7,0.3,0.3)
	local blink = Instance.new("ParticleEmitter",barz)
	blink.Texture = "rbxassetid://2344870656"
	blink.LightEmission = 1
	blink.Color = ColorSequence.new(Color3.new(1,1,1))
	blink.Rate = 0
	blink.Enabled = false
	blink.Lifetime = NumberRange.new(0.25)
	blink.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5,20,0),NumberSequenceKeypoint.new(1,0,0)})
	blink.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
	blink.Speed = NumberRange.new(0)
	blink.Drag = 5
	blink.Rotation = NumberRange.new(-500,500)
	blink.SpreadAngle = Vector2.new(0,900)
	blink.RotSpeed = NumberRange.new(-500,500) 

	local fir = Instance.new("ParticleEmitter",barz)
	fir.Texture = "rbxassetid://2344870656"
	fir.LightEmission = 1
	fir.Color = ColorSequence.new(Color3.new(1,1,1))
	fir.Rate = 500
	fir.Enabled = false
	fir.Lifetime = NumberRange.new(0.15,0.5)
	fir.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,5,0),NumberSequenceKeypoint.new(0.1,1,0),NumberSequenceKeypoint.new(1,0,0)})
	fir.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
	fir.Speed = NumberRange.new(50,100)
	fir.EmissionDirection = "Right"
	fir.Drag = 5
	fir.Rotation = NumberRange.new(-500,500)
	fir.SpreadAngle = Vector2.new(15,15)
	fir.RotSpeed = NumberRange.new(-500,500)
	local hgwR0 = CreateWelda(barz,centerR,barz,0,0,0,math.rad(0),math.rad(0),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	barz = CreateParta(gatlR,1,1,"Neon",BrickColor.new("White"))
	CreateMesha(barz,"Cylinder",5,0.3,0.3)
	local hgwR1 = CreateWelda(barz,centerR,barz,0,0.35,0,math.rad(0),math.rad(0),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	barz = CreateParta(gatlR,1,1,"Neon",BrickColor.new("White"))
	CreateMesha(barz,"Cylinder",5,0.3,0.3)
	local hgwR2 = CreateWelda(barz,centerR,barz,0,-0.35,0,math.rad(0),math.rad(0),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	barz = CreateParta(gatlR,1,1,"Neon",BrickColor.new("White"))
	CreateMesha(barz,"Cylinder",5,0.3,0.3)
	local hgwR3 = CreateWelda(barz,centerR,barz,0,0.35,0,math.rad(60),math.rad(0),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	barz = CreateParta(gatlR,1,1,"Neon",BrickColor.new("White"))
	CreateMesha(barz,"Cylinder",5,0.3,0.3)
	local hgwR4 = CreateWelda(barz,centerR,barz,0,-0.35,0,math.rad(60),math.rad(0),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	barz = CreateParta(gatlR,1,1,"Neon",BrickColor.new("White"))
	CreateMesha(barz,"Cylinder",5,0.3,0.3)
	local hgwR5 = CreateWelda(barz,centerR,barz,0,0.35,0,math.rad(-60),math.rad(0),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	barz = CreateParta(gatlR,1,1,"Neon",BrickColor.new("White"))
	CreateMesha(barz,"Cylinder",5,0.3,0.3)
	local hgwR6 = CreateWelda(barz,centerR,barz,0,-0.35,0,math.rad(-60),math.rad(0),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local orng1 = script.gatr1:Clone()
	orng1.Anchored = false
	orng1.Parent = gatlR
	local hgwRA1 = CreateWelda(orng1,centerR,orng1,2.5,0,0,math.rad(0),math.rad(0),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local orng2 = script.gatr2:Clone()
	orng2.Anchored = false
	orng2.Parent = gatlR
	local hgwRA2 = CreateWelda(orng2,centerR,orng2,2,0,0,math.rad(0),math.rad(0),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local orng3 = script.gatr3:Clone()
	orng3.Anchored = false
	orng3.Parent = gatlR
	local hgwRA3 = CreateWelda(orng3,centerR,orng3,0,0,0,math.rad(0),math.rad(0),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local orng4 = script.gatr4:Clone()
	orng4.Anchored = false
	orng4.Parent = gatlR
	local hgwRA4 = CreateWelda(orng4,centerR,orng4,-3,0,0,math.rad(0),math.rad(0),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local orng5 = script.gatr5:Clone()
	orng5.Anchored = false
	orng5.Parent = gatlR
	local hgwRA5 = CreateWelda(orng5,centerR,orng5,-2,0,0,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local orgcl = BrickColor.new("White")

	local tg = script.tag:Clone()
	tg.Parent = hed
	tg.Enabled = true
	tg.Script.Disabled = false
	------


	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part")({
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material
		})
		Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
		RemoveOutlines(Part)
		return Part
	end
	function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
		local Msh = Create(Mesh)({
			Parent = Part,
			Offset = OffSet,
			Scale = Scale
		})
		if Mesh == "SpecialMesh" then
			Msh.MeshType = MeshType
			Msh.MeshId = MeshId
		end
		return Msh
	end
	function CreateWeld(Parent, Part0, Part1, C0, C1)
		local Weld = Create("Weld")({
			Parent = Parent,
			Part0 = Part0,
			Part1 = Part1,
			C0 = C0,
			C1 = C1
		})
		return Weld
	end

	Player = game.Players.LocalPlayer
	Character=Player.Character["Dummy"]
	PlayerGui=Player.PlayerGui 
	Backpack=Player.Backpack 
	Torso=Character.Torso 
	Head=Character.Head 
	Humanoid=Character.Humanoid
	m=Instance.new('Model',Character)
	LeftArm=Character["Left Arm"] 
	LeftLeg=Character["Left Leg"] 
	RightArm=Character["Right Arm"] 
	RightLeg=Character["Right Leg"] 
	LS=Torso["Left Shoulder"] 
	LH=Torso["Left Hip"] 
	RS=Torso["Right Shoulder"] 
	RH=Torso["Right Hip"] 
	Face = Head.face
	Neck=Torso.Neck
	it=Instance.new
	attacktype=1
	vt=Vector3.new
	cf=CFrame.new
	euler=CFrame.fromEulerAnglesXYZ
	angles=CFrame.Angles
	cloaked=false
	necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
	LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
	RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
	RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
	RootPart=Character.HumanoidRootPart
	RootJoint=RootPart.RootJoint
	RootCF=euler(-1.57,0,3.14)
	attack = false 
	attackdebounce = false 
	deb=false
	equipped=true
	hand=false
	MMouse=nil
	combo=0
	mana=0
	trispeed=.2
	attackmode='none'
	local idle=0
	local Anim="Idle"
	local Effects={}
	local gun=false
	local shoot=false
	local sine = 0
	local change = 1

	function RecolorTextAndRename(name,col1,col2,font)
		modet.TextStrokeColor3 = col2
		modet.TextColor3 = col1
		modet.Font = font
		modet.Text = name
		techc.ImageColor3 = col2
		circl.ImageColor3 = col2
		circl2.ImageColor3 = col1
		imgl2.ImageColor3 = col1
		imgl2b.ImageColor3 = col2
		ned.Text = name
		ned.TextColor3 = col1
		ned.TextStrokeColor3 = col2
	end

	local disably = true

	function warnedpeople(text,represfont,color,color2)
		if disably ~= true then
			CFuncs["Sound"].Create("rbxassetid://534859368", char, 2.5,1)
			CFuncs["Sound"].Create("rbxassetid://963718869", char, 1,1)
			for i,v in pairs(game:GetService("Players"):GetPlayers()) do
				coroutine.resume(coroutine.create(function()
					if v.PlayerGui:FindFirstChild("Spinny")~= nil then
						v.PlayerGui:FindFirstChild("Spinny"):destroy()
					end
					local scrg = Instance.new("ScreenGui",v.PlayerGui)
					scrg.Name = "Spinny"
					local frm = Instance.new("Frame",scrg)
					frm.BackgroundTransparency = 0.25
					frm.BackgroundColor3 = color
					frm.BorderSizePixel = 0
					frm.Rotation = 45
					frm.Size = UDim2.new(3,0,0,100)
					frm.Position = UDim2.new(-4,0,0,0)
					local frm2 = frm:Clone()
					frm2.Parent = scrg
					frm2.BackgroundColor3 = color2
					frm2.Position = UDim2.new(-4.05,0,0,0)
					local imlb = Instance.new("ImageLabel",scrg)
					imlb.BackgroundTransparency = 1
					imlb.BackgroundColor3 = Color3.new(0,0,0)
					imlb.Image = "rbxassetid://2344851144"
					imlb.Size = UDim2.new(0,750,0,750)
					imlb.ImageColor3 = color2
					imlb.ImageTransparency = 0.25
					imlb.Position = UDim2.new(-2.5,0,-2.5,0)
					local imlb2 = imlb:Clone()
					imlb2.Image = "rbxassetid://2325939897"
					imlb2.Size = UDim2.new(1,0,1,0)
					imlb2.ImageColor3 = color
					imlb2.ImageTransparency = 0
					imlb2.Position = UDim2.new(0,0,0,0)
					local imlb3 = imlb:Clone()
					imlb3.Image = "rbxassetid://2344830904"
					imlb3.Size = UDim2.new(1,0,1,0)
					imlb3.ImageColor3 = color2
					imlb3.ImageTransparency = 0
					imlb3.Position = UDim2.new(0,0,0,0)
					local imlb4 = imlb:Clone()
					imlb4.Image = "rbxassetid://2344870656"
					imlb4.Size = UDim2.new(3,0,3,0)
					imlb4.ImageColor3 = Color3.new(1,1,1)
					imlb4.ImageTransparency = 0
					imlb4.Position = UDim2.new(-1,0,-1,0)
					local imlb5 = imlb:Clone()
					imlb5.Image = "rbxassetid://2344870656"
					imlb5.Size = UDim2.new(10,0,10,0)
					imlb5.ImageColor3 = color2
					imlb5.ImageTransparency = 0
					imlb5.Position = UDim2.new(-4.5,0,-4.5,0)
					imlb2.Parent = imlb
					imlb3.Parent = imlb
					imlb4.Parent = imlb
					imlb5.Parent = imlb
					local txtlb2 = Instance.new("TextLabel",imlb)
					txtlb2.Text = text
					txtlb2.Font = represfont
					txtlb2.TextColor3 = color
					txtlb2.TextStrokeTransparency = 0
					txtlb2.BackgroundTransparency = 1
					txtlb2.TextStrokeColor3 = color2
					txtlb2.TextScaled = true
					txtlb2.Size = UDim2.new(1,0,1,0)
					txtlb2.Position = UDim2.new(0,0,0,0)
					local fvalen = 0.55
					local fval = -0.49
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if chaosmode == true then
								txtlb2.Rotation = math.random(-1,1)
								imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								imlb.ImageColor3 = BrickColor.random().Color
								txtlb2.TextStrokeColor3 = BrickColor.random().Color
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if scrg.Parent ~= nil then
								fvalen = fvalen - 0.0001
							elseif scrg.Parent == nil then
								break
							end
						end
					end))
					local flol = -5
					local flil = 1.6
					coroutine.resume(coroutine.create(function()
						for i = 0, 49 do
							swait()
							flol = flol + 0.125
							flil = flil - 0.1
							frm.Size = frm.Size + UDim2.new(0.1,0,0,0)
							frm.Rotation = frm.Rotation - 0.25
							frm2.Size = frm2.Size + UDim2.new(0.1,0,0,0)
							frm2.Rotation = frm.Rotation + 0.325
							imlb3.Rotation = imlb3.Rotation - 10
							imlb2.Rotation = imlb.Rotation + 7.5
							imlb.Rotation = imlb.Rotation + 5
							txtlb2.Rotation = txtlb2.Rotation - 5.125
							imlb.Position = imlb.Position + UDim2.new(0.05125,0,0.04775,0)
						end
						for i = 0, 99 do
							swait()
							fval = fval + 0.05
							flol = flol + 0.005
							frm.Size = frm.Size + UDim2.new(0.005,0,0,0)
							frm.Rotation = frm.Rotation - 0.075
							frm2.Size = frm2.Size + UDim2.new(0.005,0,0,0)
							frm2.Rotation = frm2.Rotation + 0.125
							imlb3.Rotation = imlb3.Rotation - 2
							imlb2.Rotation = imlb.Rotation + 1.5
							imlb.Rotation = imlb.Rotation + 1
							txtlb2.Rotation = txtlb2.Rotation - 1.125
							imlb.Position = imlb.Position + UDim2.new(0.0015,0,0.00075,0)
						end
						local valinc = 0
						local vinc2 = 1
						for i = 0, 99 do
							swait()
							vinc2 = vinc2 + 0.25
							valinc = valinc + 0.0001
							flol = flol + valinc
							flil = flil + valinc
							txtlb2.Rotation = txtlb2.Rotation - 1.125*vinc2
							imlb3.Rotation = imlb3.Rotation - 2*vinc2
							imlb.Rotation = imlb.Rotation + 1*vinc2
							imlb.Position = imlb.Position + UDim2.new(0.0015*vinc2,0,0.0005*vinc2,0)
							frm.Size = frm.Size + UDim2.new(0.005*vinc2,0,0,0)
							frm.Rotation = frm.Rotation + 0.1*vinc2
							frm2.Size = frm2.Size + UDim2.new(0.005*vinc2,0,0,0)
							frm2.Rotation = frm2.Rotation + 0.225*vinc2
							frm2.BackgroundTransparency = frm2.BackgroundTransparency + 0.0075
							frm.BackgroundTransparency = frm.BackgroundTransparency + 0.0075
							imlb.ImageTransparency = imlb.ImageTransparency + 0.005
							imlb2.ImageTransparency = imlb2.ImageTransparency + 0.01
							imlb3.ImageTransparency = imlb3.ImageTransparency + 0.01
							imlb4.ImageTransparency = imlb4.ImageTransparency + 0.01
							imlb5.ImageTransparency = imlb4.ImageTransparency + 0.01
							txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
							txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
						end
						scrg:Destroy()
					end))
				end))
			end
		end
	end


	--save shoulders 
	RSH, LSH=nil, nil 
	--welds 
	RW, LW=Instance.new("Weld"), Instance.new("Weld") 
	RW.Name="Right Shoulder" LW.Name="Left Shoulder"
	LH=Torso["Left Hip"]
	RH=Torso["Right Hip"]
	TorsoColor=Torso.BrickColor
	function NoOutline(Part)
		Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
	end
	ch=Character
	RSH=ch.Torso["Right Shoulder"] 
	LSH=ch.Torso["Left Shoulder"] 
	-- 
	RSH.Parent=nil 
	LSH.Parent=nil 
	-- 
	RW.Name="Right Shoulder"
	RW.Part0=ch.Torso 
	RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
	RW.C1=cf(0, 0.5, 0) 
	RW.Part1=ch["Right Arm"] 
	RW.Parent=ch.Torso 
	-- 
	LW.Name="Left Shoulder"
	LW.Part0=ch.Torso 
	LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
	LW.C1=cf(0, 0.5, 0) 
	LW.Part1=ch["Left Arm"] 
	LW.Parent=ch.Torso 

	local Stats=Instance.new("BoolValue")
	Stats.Name="Stats"
	Stats.Parent=Character
	local Atk=Instance.new("NumberValue")
	Atk.Name="Damage"
	Atk.Parent=Stats
	Atk.Value=1
	local Def=Instance.new("NumberValue")
	Def.Name="Defense"
	Def.Parent=Stats
	Def.Value=1
	local Speed=Instance.new("NumberValue")
	Speed.Name="Speed"
	Speed.Parent=Stats
	Speed.Value=1
	local Mvmt=Instance.new("NumberValue")
	Mvmt.Name="Movement"
	Mvmt.Parent=Stats
	Mvmt.Value=1

	local donum=0


	function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
		local fp=it("Part")
		fp.formFactor=formfactor 
		fp.Parent=parent
		fp.Reflectance=reflectance
		fp.Transparency=transparency
		fp.CanCollide=false 
		fp.Locked=true
		fp.BrickColor=brickcolor
		fp.Name=name
		fp.Size=size
		fp.Position=Torso.Position 
		NoOutline(fp)
		fp.Material="SmoothPlastic"
		fp:BreakJoints()
		return fp 
	end 

	function mesh(Mesh,part,meshtype,meshid,offset,scale)
		local mesh=it(Mesh) 
		mesh.Parent=part
		if Mesh=="SpecialMesh" then
			mesh.MeshType=meshtype
			if meshid~="nil" then
				mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
			end
		end
		mesh.Offset=offset
		mesh.Scale=scale
		return mesh
	end

	function weld(parent,part0,part1,c0)
		local weld=it("Weld") 
		weld.Parent=parent
		weld.Part0=part0 
		weld.Part1=part1 
		weld.C0=c0
		return weld
	end

	local Color1=Torso.BrickColor

	local bodvel=Instance.new("BodyVelocity")
	local bg=Instance.new("BodyGyro")

	--------- SazEreno's Artificial HB --------------
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")
	Frame_Speed = 1 / 60
	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	------------------
	function swait(num)
		if num == 0 or num == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, num do
				ArtificialHB.Event:wait()
			end
		end
	end
	-------- RAINBOW LEAVE IT TO ME
	local r = 255
	local g = 0
	local b = 0
	coroutine.resume(coroutine.create(function()
		while wait() do
			for i = 0, 254/5 do
				swait()
				g = g + 5
			end
			for i = 0, 254/5 do
				swait()
				r = r - 5
			end
			for i = 0, 254/5 do
				swait()
				b = b + 5
			end
			for i = 0, 254/5 do
				swait()
				g = g - 5
			end
			for i = 0, 254/5 do
				swait()
				r = r + 5
			end
			for i = 0, 254/5 do
				swait()
				b = b - 5
			end
		end
	end))


	so = function(id,par,vol,pit) 
		coroutine.resume(coroutine.create(function()
			local sou = Instance.new("Sound",par or workspace)
			sou.Volume=vol
			sou.Pitch=pit or 1
			sou.SoundId=id
			swait() 
			sou:play() 
			game:GetService("Debris"):AddItem(sou,6)
		end))
	end

	function clerp(a,b,t) 
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)} 
		local ax, ay, az = a.x, a.y, a.z 
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1-t
		return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
	end 

	function QuaternionFromCFrame(cf) 
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
		local trace = m00 + m11 + m22 
		if trace > 0 then 
			local s = math.sqrt(1 + trace) 
			local recip = 0.5/s 
			return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
		else 
			local i = 0 
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then 
				i = 2 
			end 
			if i == 0 then 
				local s = math.sqrt(m00-m11-m22+1) 
				local recip = 0.5/s 
				return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
			elseif i == 1 then 
				local s = math.sqrt(m11-m22-m00+1) 
				local recip = 0.5/s 
				return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
			elseif i == 2 then 
				local s = math.sqrt(m22-m00-m11+1) 
				local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
			end 
		end 
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w) 
		local xs, ys, zs = x + x, y + y, z + z 
		local wx, wy, wz = w*xs, w*ys, w*zs 
		local xx = x*xs 
		local xy = x*ys 
		local xz = x*zs 
		local yy = y*ys 
		local yz = y*zs 
		local zz = z*zs 
		return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
	end

	function QuaternionSlerp(a, b, t) 
		local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
		local startInterp, finishInterp; 
		if cosTheta >= 0.0001 then 
			if (1 - cosTheta) > 0.0001 then 
				local theta = math.acos(cosTheta) 
				local invSinTheta = 1/math.sin(theta) 
				startInterp = math.sin((1-t)*theta)*invSinTheta 
				finishInterp = math.sin(t*theta)*invSinTheta  
			else 
				startInterp = 1-t 
				finishInterp = t 
			end 
		else 
			if (1+cosTheta) > 0.0001 then 
				local theta = math.acos(-cosTheta) 
				local invSinTheta = 1/math.sin(theta) 
				startInterp = math.sin((t-1)*theta)*invSinTheta 
				finishInterp = math.sin(t*theta)*invSinTheta 
			else 
				startInterp = t-1 
				finishInterp = t 
			end 
		end 
		return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
	end

	local function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CFrame.new(at.x, at.y, at.z,
			right.x, top.x, back.x,
			right.y, top.y, back.y,
			right.z, top.z, back.z)
	end

	function Triangle(a, b, c)
		local edg1 = (c-a):Dot((b-a).unit)
		local edg2 = (a-b):Dot((c-b).unit)
		local edg3 = (b-c):Dot((a-c).unit)
		if edg1 <= (b-a).magnitude and edg1 >= 0 then
			a, b, c = a, b, c
		elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
			a, b, c = b, c, a
		elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
			a, b, c = c, a, b
		else
			assert(false, "unreachable")
		end

		local len1 = (c-a):Dot((b-a).unit)
		local len2 = (b-a).magnitude - len1
		local width = (a + (b-a).unit*len1 - c).magnitude

		local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)

		local list = {}

		if len1 > 0.01 then
			local w1 = Instance.new('WedgePart', m)
			game:GetService("Debris"):AddItem(w1,5)
			w1.Material = "SmoothPlastic"
			w1.FormFactor = 'Custom'
			w1.BrickColor = BrickColor.new("Really red")
			w1.Transparency = 0
			w1.Reflectance = 0
			w1.Material = "SmoothPlastic"
			w1.CanCollide = false
			local l1 = Instance.new("PointLight",w1)
			l1.Color = Color3.new(170,0,0)
			NoOutline(w1)
			local sz = Vector3.new(0.2, width, len1)
			w1.Size = sz
			local sp = Instance.new("SpecialMesh",w1)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
			w1:BreakJoints()
			w1.Anchored = true
			w1.Parent = workspace
			w1.Transparency = 0.7
			table.insert(Effects,{w1,"Disappear",.01})
			w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
			table.insert(list,w1)
		end

		if len2 > 0.01 then
			local w2 = Instance.new('WedgePart', m)
			game:GetService("Debris"):AddItem(w2,5)
			w2.Material = "SmoothPlastic"
			w2.FormFactor = 'Custom'
			w2.BrickColor = BrickColor.new("Really red")
			w2.Transparency = 0
			w2.Reflectance = 0
			w2.Material = "SmoothPlastic"
			w2.CanCollide = false
			local l2 = Instance.new("PointLight",w2)
			l2.Color = Color3.new(170,0,0)
			NoOutline(w2)
			local sz = Vector3.new(0.2, width, len2)
			w2.Size = sz
			local sp = Instance.new("SpecialMesh",w2)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
			w2:BreakJoints()
			w2.Anchored = true
			w2.Parent = workspace
			w2.Transparency = 0.7
			table.insert(Effects,{w2,"Disappear",.01})
			w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
			table.insert(list,w2)
		end
		return unpack(list)
	end


	function showdamage(font,pos,color,txt)
		local mn = script.dmgpart:Clone()
		mn.gb.Enabled = true
		local mntext = mn.gb.dtxt
		mntext.Font = font
		mntext.TextColor3 = color
		mntext.Text = txt
		mn.Parent = workspace
		mn.Position = pos
		game:GetService("Debris"):AddItem(mn, 30)
		coroutine.resume(coroutine.create(function()
			local val = 0.1
			local rd = math.random(1,2)
			for i = 0, 24 do
				swait()
				if rd == 1 then
					mntext.Rotation = mntext.Rotation + val*5
				elseif rd == 2 then
					mntext.Rotation = mntext.Rotation - val*5
				end
				mn.CFrame = mn.CFrame*CFrame.new(0,val,0)
				val = val - 0.004
			end
			swait(60)
			for i = 0, 24 do
				swait()
				mntext.TextStrokeTransparency = mntext.TextStrokeTransparency + 0.04
				mntext.TextTransparency = mntext.TextTransparency + 0.04
			end
			game:GetService("Debris"):AddItem(mn, 0.5)
		end))
	end

	function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
		if hit.Parent == nil then
			return
		end
		local h = hit.Parent:FindFirstChildOfClass("Humanoid")
		for _, v in pairs(hit.Parent:children()) do
			if v:IsA("Humanoid") then
				h = v
			end
		end
		if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Head") ~= nil then
			if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
				return
			end
			local c = Create("ObjectValue")({
				Name = "creator",
				Value = game.Players.LocalPlayer,
				Parent = h
			})
			game:GetService("Debris"):AddItem(c, 0.5)
			if HitSound ~= nil and HitPitch ~= nil then
				CFuncs.Sound.Create(HitSound, hit, 0.5, HitPitch)
			end
			local Damage = math.random(minim, maxim)
			local blocked = false
			local block = hit.Parent:findFirstChild("Block")
			if block ~= nil and block.className == "IntValue" and block.Value > 0 then
				blocked = true
				block.Value = block.Value - 1
				print(block.Value)
			end
			if blocked == false then
				HitHealth = h.Health
				h.MaxHealth = 100
				h.Health = h.Health - Damage
				if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
					print("gained kill")
				end
				coroutine.resume(coroutine.create(function()
					showdamage("SourceSansLight",h.Parent.Head.Position,Color3.new(1,1,1),Damage)
					coroutine.resume(coroutine.create(function()
						for i = 1, math.random(5,12) do
							trailMK(math.random(4,5),math.random(50,200)/1000,"Add",h.Parent.HumanoidRootPart.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,-0.0025,Color3.fromRGB(255,255,255),0)
						end
					end))
				end))
			else
				h.Health = h.Health - Damage / 2
				coroutine.resume(coroutine.create(function()
					showdamage("SourceSansLight",h.Parent.Head.Position,Color3.new(1,1,1),Damage)
					coroutine.resume(coroutine.create(function()
						for i = 1, math.random(5,12) do
							trailMK(math.random(4,5),math.random(50,200)/1000,"Add",h.Parent.HumanoidRootPart.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,-0.0025,Color3.fromRGB(255,255,255),0)
						end
					end))
				end))
			end
			if Type == "Normal" then
				local vp = Create("BodyVelocity")({
					P = 500,
					maxForce = Vector3.new(math.huge, 0, math.huge),
					velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
				})
				if knockback > 0 then
					vp.Parent = hit.Parent.Head
				end
				game:GetService("Debris"):AddItem(vp, 0.5)
			end
			local debounce = Create("BoolValue")({
				Name = "DebounceHit",
				Parent = hit.Parent,
				Value = true
			})
			game:GetService("Debris"):AddItem(debounce, Delay)
			c = Instance.new("ObjectValue")
			c.Name = "creator"
			c.Value = Player
			c.Parent = h
			game:GetService("Debris"):AddItem(c, 0.5)
		end
	end
	function MagniDamage(Part, magni, mindam, maxdam, knock, Type, id)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChildOfClass("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Head")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						--Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://" ..id, 1)
					end
				end
			end
		end
	end

	function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChild("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Torso")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
						Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
					end
				end
			end
		end
	end

	function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
	end 

	function SkullEffect(brickcolor,cframe,x1,y1,z1,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=4770583",vt(0,0,0),vt(x1,y1,z1))
		--http://www.roblox.com/asset/?id=4770560
		game:GetService("Debris"):AddItem(prt,2)
		CF=prt.CFrame
		coroutine.resume(coroutine.create(function(Part,Mesh,TehCF) 
			for i=0,1,0.2 do
				wait()
				Part.CFrame=CF*cf(0,0,-0.4)
			end
			for i=0,1,delay do
				wait()
				--Part.CFrame=CF*cf((math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5)
				Mesh.Scale=Mesh.Scale
			end
			for i=0,1,0.1 do
				wait()
				Part.Transparency=i
			end
			Part.Parent=nil
		end),prt,msh,CF)
	end

	function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				swait()
				Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicSphere(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShock(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
		local prt=part(3,char,1,1,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		local dec = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
		local dec2 = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				dec.Transparency=i
				dec2.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockAlt(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockAltCircle(brickcolor,cframe,x1,z1,x3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0.1,0)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,-0.1,0)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,0,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockTrailAlt(brickcolor,cframe,x1,y1,z1,x3,y3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockTrailAlt2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlock2(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=false
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		local wld=weld(prt,prt,Parent,cframe)
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
			for i=0,1,delay do
				wait()
				Weld.C0=euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))*cframe
				--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,wld)
	end

	function MagicBlock3(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=false
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		local wld=weld(prt,prt,Parent,euler(0,0,0)*cf(0,0,0))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
			for i=0,1,delay do
				wait()
				Weld.C0=euler(i*20,0,0)
				--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,wld)
	end

	function MagicCircle2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("CylinderMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
				local prt2=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
				prt2.Anchored=true
				prt2.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				local msh2=mesh("SpecialMesh",prt2,"Sphere","",vt(0,0,0),vt(0.5,0.5,0.5))
				game:GetService("Debris"):AddItem(prt2,2)
				coroutine.resume(coroutine.create(function(Part,Mesh) 
					for i=0,1,0.1 do
						wait()
						Part.CFrame=Part.CFrame*cf(0,0.5,0)
					end
					Part.Parent=nil
				end),prt2,msh2)
			end
			for i=0,1,delay*2 do
				wait()
				Part.CFrame=Part.CFrame
				Mesh.Scale=vt((x1+x3)-(x1+x3)*i,(y1+y3)-(y1+y3)*i,(z1+z3)-(z1+z3)*i)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function BreakEffect(brickcolor,cframe,x1,y1,z1)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,CF,Numbb,randnumb) 
			CF=Part.CFrame
			Numbb=0
			randnumb=math.random()/10
			rand1=math.random()/10
			for i=0,1,rand1 do
				wait()
				CF=CF*cf(0,math.random()/2,0)
				--Part.CFrame=Part.CFrame*euler(0.5,0,0)*cf(0,1,0)
				Part.CFrame=CF*euler(Numbb,0,0)
				Part.Transparency=i
				Numbb=Numbb+randnumb
			end
			Part.Parent=nil
		end),prt,CF,Numbb,randnumb)
	end

	function MagicWaveThing(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=1051557",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame*euler(0,0.7,0)
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function WaveEffect(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=20329976",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame*cf(0,y3/2,0)
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function StravEffect(brickcolor,cframe,x,y,z,x1,y1,z1,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe*cf(x,y,z)
		msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://168892363",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,ex,why,zee) 
			local num=math.random()
			local num2=math.random(-3,2)+math.random()
			local numm=0
			for i=0,1,delay*2 do
				swait()
				Part.CFrame=cframe*euler(0,numm*num*10,0)*cf(ex,why,zee)*cf(-i*10,num2,0)
				Part.Transparency=i
				numm=numm+0.01
			end
			Part.Parent=nil
			Mesh.Parent=nil
		end),prt,msh,x,y,z)
	end

	function dmgstart(dmg,what)
		hitcon = what.Touched:connect(function(hit)
			local hum = hit.Parent:FindFirstChild("Humanoid")
			if hum and not hum:IsDescendantOf(Character) then
				hum:TakeDamage(dmg)
			end
		end)
	end

	function dmgstop()
		hitcon:disconnect()
	end

	function Cloak()
		Face.Parent=nil
		cloaked=true
		for _,v in pairs(Torso.Parent:children()) do
			if v.className=="Part" and v.Name~="HumanoidRootPart" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.2 do
						wait()
						v.Transparency=i
					end
					v.Transparency=1
				end))
			end
			if v.className=="Hat" then
				hatp=v.Handle
				coroutine.resume(coroutine.create(function(derp) 
					for i=0,1,0.2 do
						wait()
						derp.Transparency=i
					end
					derp.Transparency=1
				end),hatp)
			end
		end
		for _,v in pairs(m:children()) do
			if v.className=="Part" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.2 do
						wait()
						v.Transparency=i
					end
					v.Transparency=1
				end))
			end
		end
	end

	function UnCloak()
		so("http://roblox.com/asset/?id=2767090",Torso,1,1.1) 
		Face.Parent=Head 
		cloaked=false
		for _,v in pairs(Torso.Parent:children()) do
			if v.className=="Part" and v.Name~="HumanoidRootPart" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.1 do
						wait()
						v.Transparency=v.Transparency-0.1
					end
					v.Transparency=0
				end))
			end
			if v.className=="Hat" then
				hatp=v.Handle
				coroutine.resume(coroutine.create(function(derp) 
					for i=0,1,0.1 do
						wait()
						derp.Transparency=derp.Transparency-0.1
					end
					derp.Transparency=0
				end),hatp)
			end
		end
		for _,v in pairs(m:children()) do
			if v.className=="Part" and v.Name~="hitbox" and v.Name~='tip' then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.1 do
						wait()
						v.Transparency=v.Transparency-0.1
					end
					v.Transparency=0
				end))
				v.Transparency=0
			end
		end
	end

	local origcolor = BrickColor.new("Pastel light blue")
	---- This section of explosions.

	----


	function ring(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
			end
			rng:Destroy()
		end))
	end

	function waveEff(bonuspeed,type,pos,scale,value,color)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "FileMesh"
		rngm.MeshId = "rbxassetid://20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		local randomrot = math.random(1,2)
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if randomrot == 1 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(5*bonuspeed/2),0)
				elseif randomrot == 2 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-5*bonuspeed/2),0)
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, 0, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function wave(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function wind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function groundwind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
			end
			rng:Destroy()
		end))
	end

	function CameraManager()
		if TwoD and not CamInterrupt then
			if Humanoid.Health > 0 then
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Scriptable"
				Humanoid.AutoRotate = false
				if Booleans.GyroUse then
					Directer.MaxTorque = Vec3(0, huge, 0)
				else
					Directer.MaxTorque = Vec3(0, 0, 0)
				end
				if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
					if Booleans.CamFollow then
						CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
						Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
					else
						CPart.Position = RootPart.Position
					end
				else
					local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
					CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
				end
				Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
			else
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Custom"
				Controller.Disabled = false
			end
		end
	end

	function ring(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
			end
			rng:Destroy()
		end))
	end


	function wave(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function sphere(bonuspeed,type,pos,scale,value,color,color3x)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.Color = color3x
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = scale
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color,color3x)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.Color = color3x
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		rngm.Scale = scale
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
		local type = type
		local rotenable = rotatingop
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		if typeoftrans == "In" then
			rng.Transparency = 1
		end
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "FileMesh"
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		if typeofshape == "Normal" then
			rngm.MeshId = "rbxassetid://662586858"
		elseif typeofshape == "Round" then
			rngm.MeshId = "rbxassetid://662585058"
		end
		rngm.Scale = scale
		local scaler2 = 1/10
		if type == "Add" then
			scaler2 = 1*value/10
		elseif type == "Divide" then
			scaler2 = 1/value/10
		end
		local randomrot = math.random(1,2)
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed/10
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed/10
				end
				if rotenable == true then
					if randomrot == 1 then
						rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
					elseif randomrot == 2 then
						rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
					end
				end
				if typeoftrans == "Out" then
					rng.Transparency = rng.Transparency + 0.01*bonuspeed
				elseif typeoftrans == "In" then
					rng.Transparency = rng.Transparency - 0.01*bonuspeed
				end
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
			end
			rng:Destroy()
		end))
	end

	function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 0
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder + 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.Color = color3
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = scale
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,lt)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.Color = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local trl = Instance.new("Trail",rng)
		local a0 = Instance.new("Attachment",rng)
		a0.Position = Vector3.new(x1/2,0,0)
		local a1 = Instance.new("Attachment",rng)
		a1.Position = Vector3.new(-x1/2,0,0)
		trl.Attachment0 = a0
		trl.Attachment1 = a1
		trl.Color = ColorSequence.new(color)
		trl.Lifetime = lt
		trl.LightEmission = 1
		trl.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,rng.Transparency,0),NumberSequenceKeypoint.new(1,1,0)})
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end

	function sphereMKn(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,lt)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.Color = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end


	function trailMK(bonuspeed,FastSpeed,type,pos,x,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.Color = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local trl = Instance.new("Trail",rng)
		local a0 = Instance.new("Attachment",rng)
		a0.Position = Vector3.new(x/2,0,0)
		local a1 = Instance.new("Attachment",rng)
		a1.Position = Vector3.new(-x/2,0,0)
		trl.Attachment0 = a0
		trl.Attachment1 = a1
		trl.Color = ColorSequence.new(color)
		trl.Lifetime = 0.25
		trl.LightEmission = 1
		trl.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)})
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(0,0,0)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,rng.Transparency,0),NumberSequenceKeypoint.new(1,1,0)})
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end



	function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,color3x)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.Color = color3x
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 1
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end

	function dmg(dude)
		if dude.Name ~= Character then
			local keptcolor = maincoler
			local bgf = Instance.new("BodyGyro",dude.Head)
			bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
--[[local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"]]--
			local ds = coroutine.wrap(function()
				dude:WaitForChild("Head"):BreakJoints()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Part") or v:IsA("MeshPart") then
						v.Name = "DEMINISHED"
					end
				end
				wait(0.5)
				targetted = nil
				CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.75, 0.285)
				coroutine.resume(coroutine.create(function()
					for i, v in pairs(dude:GetChildren()) do
						if v:IsA("Accessory") then
							v:Destroy()
						end
						if v:IsA("Humanoid") then
							v:Destroy()
						end
						if v:IsA("CharacterMesh") then
							v:Destroy()
						end
						if v:IsA("Model") then
							v:Destroy()
						end
						if v:IsA("Part") or v:IsA("MeshPart") then
							for x, o in pairs(v:GetChildren()) do
								if o:IsA("Decal") then
									o:Destroy()
								end
							end
							coroutine.resume(coroutine.create(function()
								v.Material = "Neon"
								v.CanCollide = false
								v.Anchored = false
								local bld = Instance.new("ParticleEmitter",v)
								bld.LightEmission = 0.75
								bld.Texture = "rbxassetid://363275192" ---284205403
								bld.Color = ColorSequence.new(keptcolor.Color)
								bld.Rate = 500
								bld.Lifetime = NumberRange.new(1)
								bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0,0)})
								bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
								bld.Speed = NumberRange.new(2,5)
								bld.VelocitySpread = 50000
								bld.Rotation = NumberRange.new(-500,500)
								bld.RotSpeed = NumberRange.new(-500,500)
								local sbs = Instance.new("BodyPosition", v)
								sbs.P = 3000
								sbs.D = 1000
								sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
								sbs.position = v.Position + Vector3.new(math.random(-2,2),10 + math.random(-2,2),math.random(-2,2))
								v.Color = keptcolor.Color
								coroutine.resume(coroutine.create(function()
									for i = 0, 49 do
										swait(1)
										v:BreakJoints()
										v.Transparency = v.Transparency + 0.02
									end
									v:BreakJoints()
									sphere2(1,"Add",v.CFrame,vt(0,0,0),0.1,0.1,0.1,keptcolor)
									CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.5, 0.75)
									bld.Speed = NumberRange.new(10,25)
									bld.Drag = 5
									bld.Acceleration = vt(0,2,0)
									wait(0.5)
									bld.Enabled = false
									wait(8)
									v:Destroy()
									dude:Destroy()
								end))
							end))
						end
					end
				end))
			end)
			ds()
		end
	end


	function FindNearestHead(Position, Distance, SinglePlayer)
		if SinglePlayer then
			return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
		end
		local List = {}
		for i, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") then
				if v:findFirstChild("Head") then
					if v ~= Character then
						if (v.Head.Position - Position).magnitude <= Distance then
							table.insert(List, v)
						end 
					end 
				end 
			end 
		end
		return List
	end

	function FaceMouse()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end

	function FaceMouse2()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end

	local ModeType = "N"
	-- Functions are ready.
	local storehumanoidWS = 16

	function createBGCircle(size,parent,color)
		local bgui = Instance.new("BillboardGui",parent)
		bgui.Size = UDim2.new(size, 0, size, 0)
		local imgc = Instance.new("ImageLabel",bgui)
		imgc.BackgroundTransparency = 1
		imgc.ImageTransparency = 0
		imgc.Size = UDim2.new(1,0,1,0)
		imgc.Image = "rbxassetid://997291547" --997291547,521073910
		imgc.ImageColor3 = color
		return bgui,imgc
	end

	function symbolizeBlink(guipar,size,img,color,bonussize,vol,pit,soundid,spar,rotationenabled,rotsp,delay)
		local bgui,imgc = createBGCircle(size,guipar,color)
		bgui.AlwaysOnTop = true
		imgc.Image = "rbxassetid://" ..img
		local rrot = math.random(1,2)
		CFuncs["Sound"].Create("rbxassetid://" ..soundid, spar, vol,pit)
		coroutine.resume(coroutine.create(function()
			for i = 0, 24*delay do
				swait()
				if rotationenabled == true then
					if rrot == 1 then
						imgc.Rotation = imgc.Rotation + rotsp
					elseif rrot == 2 then
						imgc.Rotation = imgc.Rotation - rotsp
					end
				end
				bgui.Size = bgui.Size + UDim2.new(1*bonussize/delay,0,1*bonussize/delay,0)
				imgc.ImageTransparency = imgc.ImageTransparency + 0.04/delay
			end
			bgui:Destroy()
		end))
	end

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	v.Anchored = false

	local Outline = Instance.new("SelectionBox", v)
	Outline.LineThickness = 0.1
	Outline.Color3 = Color3.fromRGB(195, 130, 0)
	Outline.Adornee = v

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if attack == false then
				bp.Position = game.Players.LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)

	RightArm.Touched:Connect(function(hit)
		if hit.Parent:FindFirstChild("Humanoid") and attack == true then
			if hit.Parent.Name == game.Players.LocalPlayer.Name then
				--print("not flinging")
			else
				if hit.Parent:FindFirstChild("UpperTorso") then
					bp.Position = hit.Parent:FindFirstChild("UpperTorso").Position
				elseif hit.Parent:FindFirstChild("Torso") then
					bp.Position = hit.Parent:FindFirstChild("Torso").Position
				end
			end
		end
	end)

	function aone()
		attack = true
		hum.WalkSpeed = 3
		local trl = Instance.new("Trail",rarm)
		local a0 = Instance.new("Attachment",rarm)
		a0.Position = Vector3.new(0.5,-1,0)
		local a1 = Instance.new("Attachment",rarm)
		a1.Position = Vector3.new(0.5,1,0)
		trl.Attachment0 = a0
		trl.Attachment1 = a1
		trl.Color = ColorSequence.new(orgcl.Color)
		trl.Lifetime = 0.5
		trl.LightEmission = 1
		trl.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)})
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
		for i = 0, 3 ,0.2 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-35),math.rad(-8),math.rad(-25)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(40),math.rad(-1)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,-0.5)*angles(math.rad(1),math.rad(-20),math.rad(-42)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(10),math.rad(-10)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(-27)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(80),math.rad(0),math.rad(-36)),.3)
		end
		local hbax = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
		hbax.CFrame = root.CFrame + root.CFrame.lookVector*1.5
		hbax.Anchored = true
		MagniDamage(hbax, 3.5, 10,18, 0, "Normal", 153092227)
		CFuncs["Sound"].Create("rbxassetid://2295409459", rarm, 2, 1)
		for i = 0, 4 ,0.2 do
			swait()
			RH.C0=clerp(RH.C0,cf(1.2,-1,-0.4)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-60),math.rad(-10)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-10),math.rad(0),math.rad(10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.4,-0.4,-0.25)*angles(math.rad(0),math.rad(20),math.rad(82)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5),math.rad(-20),math.rad(-82)),.4)
			RW.C0=clerp(RW.C0,cf(1.25,0.5,-1)*angles(math.rad(160),math.rad(20),math.rad(-20)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(80),math.rad(0),math.rad(-10)),.4)
		end
		trl.Enabled = false
		game:GetService("Debris"):AddItem(trl,4)
		hbax:Destroy()
		attack = false
		hum.WalkSpeed = 16
	end

	function atwo()
		attack = true
		hum.WalkSpeed = 3
		local trl = Instance.new("Trail",larm)
		local a0 = Instance.new("Attachment",larm)
		a0.Position = Vector3.new(-0.5,-1,0)
		local a1 = Instance.new("Attachment",larm)
		a1.Position = Vector3.new(-0.5,1,0)
		trl.Attachment0 = a0
		trl.Attachment1 = a1
		trl.Color = ColorSequence.new(orgcl.Color)
		trl.Lifetime = 0.5
		trl.LightEmission = 1
		trl.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)})
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
		for i = 0, 3 ,0.2 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-10),math.rad(-8),math.rad(-25)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-0.4,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15),math.rad(20),math.rad(-5)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,-0.5)*angles(math.rad(1),math.rad(20),math.rad(30)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(-10),math.rad(-20)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(40),math.rad(0),math.rad(15)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0,0)*angles(math.rad(140),math.rad(0),math.rad(10)),.3)
		end
		local hbax = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
		hbax.CFrame = root.CFrame + root.CFrame.lookVector*1.5
		hbax.Anchored = true
		MagniDamage(hbax, 3.5, 10,18, 0, "Normal", 153092227)
		CFuncs["Sound"].Create("rbxassetid://2295409459", rarm, 2, 1)
		for i = 0, 4 ,0.2 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-25),math.rad(-8),math.rad(-15)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1,-0.4)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(40),math.rad(-1)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0.4,-0.25,-0.25)*angles(math.rad(1),math.rad(-20),math.rad(-60)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(10),math.rad(50)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(40),math.rad(0),math.rad(20)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,1,-0.4)*angles(math.rad(160),math.rad(0),math.rad(10)),.4)
		end
		trl.Enabled = false
		game:GetService("Debris"):AddItem(trl,4)
		hbax:Destroy()
		attack = false
		hum.WalkSpeed = 16
	end

	function athree()
		attack = true
		hum.WalkSpeed = 1
		local trl = Instance.new("Trail",larm)
		local a0 = Instance.new("Attachment",larm)
		a0.Position = Vector3.new(-0.5,-1,0)
		local a1 = Instance.new("Attachment",larm)
		a1.Position = Vector3.new(-0.5,1,0)
		trl.Attachment0 = a0
		trl.Attachment1 = a1
		trl.Color = ColorSequence.new(orgcl.Color)
		trl.Lifetime = 0.5
		trl.LightEmission = 1
		trl.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)})
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})

		local trl2 = Instance.new("Trail",rarm)
		local a02 = Instance.new("Attachment",rarm)
		a02.Position = Vector3.new(0.5,-1,0)
		local a12 = Instance.new("Attachment",rarm)
		a12.Position = Vector3.new(0.5,1,0)
		trl2.Attachment0 = a02
		trl2.Attachment1 = a12
		trl2.Color = ColorSequence.new(orgcl.Color)
		trl2.Lifetime = 0.5
		trl2.LightEmission = 1
		trl2.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)})
		trl2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
		for x = 0, 2 do
			for i = 0, 2 ,0.5 do
				swait()
				root.Velocity = root.CFrame.lookVector*15
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-25)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-0.4,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,-0.6)*angles(math.rad(30),math.rad(0),math.rad(0)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(0)),.6)
				RW.C0=clerp(RW.C0,cf(1,1.25,-1.25)*angles(math.rad(120),math.rad(0),math.rad(-20)),.6)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.5)*angles(math.rad(120),math.rad(0),math.rad(5)),.6)
			end
			local hbax = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			hbax.CFrame = root.CFrame + root.CFrame.lookVector*1.5
			hbax.Anchored = true
			MagniDamage(hbax, 3.5, 3,6, 0, "Normal", 153092227)
			hbax:Destroy()
			CFuncs["Sound"].Create("rbxassetid://2295409459", rarm, 0.4, 1.5)
			for i = 0, 2 ,0.5 do
				swait()
				root.Velocity = root.CFrame.lookVector*15
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-25)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-0.4,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,-0.6)*angles(math.rad(30),math.rad(0),math.rad(0)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(0)),.6)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0.5)*angles(math.rad(120),math.rad(0),math.rad(-5)),.6)
				LW.C0=clerp(LW.C0,cf(-1,1.25,-1.25)*angles(math.rad(120),math.rad(0),math.rad(20)),.6)
			end
			local hbax = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			hbax.CFrame = root.CFrame + root.CFrame.lookVector*1.5
			hbax.Anchored = true
			MagniDamage(hbax, 3.5, 3,6, 0, "Normal", 153092227)
			hbax:Destroy()
			CFuncs["Sound"].Create("rbxassetid://2295409459", larm, 0.4, 1.5)
		end
		trl.Enabled = false
		game:GetService("Debris"):AddItem(trl,4)
		trl2.Enabled = false
		game:GetService("Debris"):AddItem(trl2,4)
		attack = false
		hum.WalkSpeed = 16
	end

	function afour()
		attack = true
		for i = 0, 1 ,0.2 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(20)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.2,0)*angles(math.rad(10),math.rad(0),math.rad(20)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(-20)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(20),math.rad(0),math.rad(25)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(13),math.rad(-20),math.rad(-15)),.3)
		end
		local hbax = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
		hbax.CFrame = root.CFrame + root.CFrame.lookVector*3
		hbax.Anchored = true
		CFuncs["Sound"].Create("rbxassetid://200632370", root, 1, 1)
		for x = 0, 2 do
			hbax.CFrame = root.CFrame + root.CFrame.lookVector*3
			MagniDamage(hbax, 5, 6,10, 0, "Normal")
			for i = 0, 1 ,0.6 do
				swait()
				root.Velocity = root.CFrame.lookVector*55
				slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-1,-3)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.035,0.01,0.035),math.random(5,20)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-30),math.rad(90)),.3)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(20)),.3)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(20),math.rad(0),math.rad(55)),.3)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(13),math.rad(-20),math.rad(-60)),.3)
			end
			for i = 0, 1 ,0.6 do
				swait()
				root.Velocity = root.CFrame.lookVector*55
				slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-1,-3)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.035,0.01,0.035),math.random(5,20)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-30),math.rad(90)),.3)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(20)),.3)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-10),math.rad(0),math.rad(-90)),.3)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(20),math.rad(0),math.rad(55)),.3)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(13),math.rad(-20),math.rad(-60)),.3)
			end
			for i = 0, 1 ,0.6 do
				swait()
				root.Velocity = root.CFrame.lookVector*55
				slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-1,-3)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.035,0.01,0.035),math.random(5,20)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-30),math.rad(90)),.3)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(20)),.3)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-10),math.rad(0),math.rad(-180)),.3)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(20),math.rad(0),math.rad(55)),.3)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(13),math.rad(-20),math.rad(-60)),.3)
			end
			for i = 0, 1 ,0.6 do
				swait()
				root.Velocity = root.CFrame.lookVector*55
				slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-1,-3)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.035,0.01,0.035),math.random(5,20)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-30),math.rad(90)),.3)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(20)),.3)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-10),math.rad(0),math.rad(-270)),.3)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(20),math.rad(0),math.rad(55)),.3)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(13),math.rad(-20),math.rad(-60)),.3)
			end
		end
		hbax:Destroy()
		attack = false
	end

	function afive()
		attack = true
		hum.WalkSpeed = 0
		for i = 0, 2 ,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(13),math.rad(10)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-1)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,0)*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-10),math.rad(0),math.rad(15)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-10),math.rad(0),math.rad(-13)),.3)
		end
		local hbax = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
		hbax.CFrame = root.CFrame*CFrame.new(0,-3,0)
		hbax.Anchored = true
		game:GetService("Debris"):AddItem(hbax,10)
		local hf,pf=rayCast(root.Position,(CFrame.new(root.Position,root.Position - vt(0,1,0))).lookVector,4,char)
		if hf ~= nil then
			if OVERPOWER == false then
				localshakes(0.15,0.5)
				CFuncs["Sound"].Create("rbxassetid://824687369", hbax, 3, 1)
				CFuncs["Sound"].Create("rbxassetid://1259054947", hbax, 1, 1.2)
				MagniDamage(hbax, 10, 12,20, 0, "Normal")
				sphere2(3,"Add",hbax.CFrame,vt(0,1,0),0.25,0.01,0.25,orgcl,orgcl.Color)
				sphere2(4,"Add",hbax.CFrame,vt(0,1,0),0.25,0.01,0.25,orgcl,orgcl.Color)
				for i = 0, 19 do
					slash(math.random(30,100)/10,3,true,"Round","Add","Out",hbax.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.01,0.05),math.random(10,50)/250,BrickColor.new("White"))
				end
				for i = 0, 9 do
					local deb = Instance.new("Part", char)
					deb.Anchored = true
					deb.CanCollide = false
					deb.FormFactor = 3
					deb.Name = "Ring"
					deb.Material = hf.Material
					deb.Color = hf.Color
					deb.Size = vt(math.random(2,5),math.random(2,5),math.random(2,5))
					deb.Transparency = 0
					deb.TopSurface = 0
					deb.BottomSurface = 0
					deb.CFrame = root.CFrame*CFrame.new(math.random(-6,6),-4,math.random(-6,6))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
					local deb2 = Instance.new("Part", char)
					deb2.CanCollide = false
					deb2.FormFactor = 3
					deb2.Name = "Ring"
					deb2.Material = hf.Material
					deb2.Color = hf.Color
					deb2.Size = vt(math.random(1,2),math.random(1,2),math.random(1,2))
					deb2.Transparency = 0
					deb2.TopSurface = 0
					deb2.BottomSurface = 0
					deb2.Velocity = vt(math.random(-30,30),math.random(30,60),math.random(-30,30))
					deb2.RotVelocity = vt(math.random(-50,50),math.random(-50,50),math.random(-50,50))
					deb2.CFrame = root.CFrame*CFrame.new(math.random(-3,3),-4,math.random(-3,3))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
					local at1 = Instance.new('Attachment',deb2)
					at1.Position = vt(0,0.5,0)
					local at2 = Instance.new('Attachment',deb2)
					at2.Position = vt(0,-0.5,0)
					local tl = Instance.new('Trail',deb2)
					tl.Attachment0 = at1
					tl.Attachment1 = at2
					tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					tl.Color = ColorSequence.new(orgcl.Color)
					tl.LightEmission = 1
					tl.Lifetime = 1
					game:GetService("Debris"):AddItem(deb,15)
					game:GetService("Debris"):AddItem(deb2,15)
					coroutine.resume(coroutine.create(function()
						wait(5)
						for i = 0, 24 do
							swait()
							deb.Transparency = deb.Transparency + 0.04
						end
						deb:Destroy()
					end))
				end
			elseif OVERPOWER == true then
				shakes(0.3,1)
				CFuncs["Sound"].Create("rbxassetid://824687369", hbax, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://1259054947", hbax, 5, 0.75)
				MagniDamage(hbax, 25, 24,60, 0, "Normal")
				sphere2(3,"Add",hbax.CFrame,vt(0,1,0),1,0.01,1,orgcl,orgcl.Color)
				sphere2(4,"Add",hbax.CFrame,vt(0,1,0),1,0.01,1,orgcl,orgcl.Color)
				for i = 0, 39 do
					slash(math.random(30,100)/10,3,true,"Round","Add","Out",hbax.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.01,0.05),math.random(20,100)/250,BrickColor.new("White"))
				end
				for i = 0, 29 do
					local deb = Instance.new("Part", char)
					deb.Anchored = true
					deb.CanCollide = false
					deb.FormFactor = 3
					deb.Name = "Ring"
					deb.Material = hf.Material
					deb.Color = hf.Color
					deb.Size = vt(math.random(4,10),math.random(4,10),math.random(4,10))
					deb.Transparency = 0
					deb.TopSurface = 0
					deb.BottomSurface = 0
					deb.CFrame = root.CFrame*CFrame.new(math.random(-12,12),-4,math.random(-12,12))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
					local deb2 = Instance.new("Part", char)
					deb2.CanCollide = false
					deb2.FormFactor = 3
					deb2.Name = "Ring"
					deb2.Material = hf.Material
					deb2.Color = hf.Color
					deb2.Size = vt(math.random(2,4),math.random(2,4),math.random(2,4))
					deb2.Transparency = 0
					deb2.TopSurface = 0
					deb2.BottomSurface = 0
					deb2.Velocity = vt(math.random(-60,60),math.random(60,120),math.random(-60,60))
					deb2.RotVelocity = vt(math.random(-50,50),math.random(-50,50),math.random(-50,50))
					deb2.CFrame = root.CFrame*CFrame.new(math.random(-6,6),-4,math.random(-6,6))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
					local at1 = Instance.new('Attachment',deb2)
					at1.Position = vt(0,1,0)
					local at2 = Instance.new('Attachment',deb2)
					at2.Position = vt(0,-1,0)
					local tl = Instance.new('Trail',deb2)
					tl.Attachment0 = at1
					tl.Attachment1 = at2
					tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					tl.Color = ColorSequence.new(orgcl.Color)
					tl.LightEmission = 1
					tl.Lifetime = 1
					game:GetService("Debris"):AddItem(deb,15)
					game:GetService("Debris"):AddItem(deb2,15)
					coroutine.resume(coroutine.create(function()
						wait(5)
						for i = 0, 24 do
							swait()
							deb.Transparency = deb.Transparency + 0.04
						end
						deb:Destroy()
					end))
				end
			end
		end
		--CFuncs["Sound"].Create("rbxassetid://200632211", hbax, 1, 1)
		for i = 0, 1 ,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(20)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(5)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.4,-0.2)*angles(math.rad(20),math.rad(0),math.rad(0)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-47),math.rad(0),math.rad(14)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-52),math.rad(0),math.rad(-14)),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end
	--- abilities

	function bigjoke()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://459523787", char, 5, 1)
		for i = 0, 15 ,0.1 do
			swait()
			trailMK(math.random(2,5),-0.5*12,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))*CFrame.new(0,0,-25*12),50,-0.0025,Color3.fromRGB(255,255,255),0)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-40),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(0.8,0.75,-0.5)*angles(math.rad(170),math.rad(0),math.rad(-20)),.2)
			LW.C0=clerp(LW.C0,cf(-0.8,0.75,-0.5)*angles(math.rad(170),math.rad(0),math.rad(20)),.2)
		end
		MagniDamage(root, 800, 1000,60000, 0, "Normal", 0)
		shakes(8,10)
		CFuncs["Sound"].Create("rbxassetid://341301373", char, 5, 1.3)
		sphere2(1,"Add",root.CFrame,vt(1,1,1),6,6,6,bc("White"),Color3.new(1,1,1))
		sphere2(1,"Add",root.CFrame,vt(1,1,1),12,12,12,bc("White"),Color3.new(1,1,1))
		sphere2(1,"Add",root.CFrame,vt(1,1,1),24,24,24,bc("White"),Color3.new(1,1,1))
		sphere2(2,"Add",root.CFrame,vt(1,1,1),6,6,6,bc("White"),Color3.new(1,1,1))
		sphere2(2,"Add",root.CFrame,vt(1,1,1),12,12,12,bc("White"),Color3.new(1,1,1))
		sphere2(2,"Add",root.CFrame,vt(1,1,1),24,24,24,bc("White"),Color3.new(1,1,1))
		sphere2(3,"Add",root.CFrame,vt(1,1,1),6,6,6,bc("White"),Color3.new(1,1,1))
		sphere2(3,"Add",root.CFrame,vt(1,1,1),12,12,12,bc("White"),Color3.new(1,1,1))
		sphere2(3,"Add",root.CFrame,vt(1,1,1),24,24,24,bc("White"),Color3.new(1,1,1))
		sphere2(4,"Add",root.CFrame,vt(1,1,1),6,6,6,bc("White"),Color3.new(1,1,1))
		sphere2(4,"Add",root.CFrame,vt(1,1,1),12,12,12,bc("White"),Color3.new(1,1,1))
		sphere2(4,"Add",root.CFrame,vt(1,1,1),24,24,24,bc("White"),Color3.new(1,1,1))
		for i = 0, 99 do
			slash(math.random(5,20)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-2.8,0)*CFrame.Angles(math.rad(math.random(-2,2)),math.rad(math.random(-360,360)),math.rad(math.random(-2,2))),vt(0.05,0.001,0.05),math.random(1200,1800)/250,BrickColor.new("White"))
		end
		local hf,pf=rayCast(root.Position,(CFrame.new(root.Position,root.Position - vt(0,1,0))).lookVector,4,char)
		if hf ~= nil then
			local rotation = 0
			for i = 0, 35 do
				rotation = rotation + 10
				local deb = Instance.new("Part", char)
				deb.Anchored = true
				deb.CanCollide = false
				deb.FormFactor = 3
				deb.Name = "Ring"
				deb.Material = hf.Material
				deb.Color = hf.Color
				deb.Size = vt(math.random(50,60),math.random(25,35),math.random(50,60))
				deb.Transparency = 0
				deb.TopSurface = 0
				deb.BottomSurface = 0
				deb.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-3,150)*CFrame.Angles(math.rad(math.random(20,30)),math.rad(0),math.rad(0))*CFrame.new(0,math.random(-5,5),0)
				local debb = Instance.new("Part", char)
				debb.Anchored = true
				debb.CanCollide = false
				debb.FormFactor = 3
				debb.Name = "Ring"
				debb.Material = hf.Material
				debb.Color = hf.Color
				debb.Size = vt(math.random(40,50),math.random(19,25),math.random(40,50))
				debb.Transparency = 0
				debb.TopSurface = 0
				debb.BottomSurface = 0
				debb.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-6,175)*CFrame.Angles(math.rad(math.random(10,20)),math.rad(0),math.rad(0))*CFrame.new(0,math.random(-5,5),0)
				local debc = Instance.new("Part", char)
				debc.Anchored = true
				debc.CanCollide = false
				debc.FormFactor = 3
				debc.Name = "Ring"
				debc.Material = hf.Material
				debc.Color = hf.Color
				debc.Size = vt(math.random(35,40),math.random(14,18),math.random(35,40))
				debc.Transparency = 0
				debc.TopSurface = 0
				debc.BottomSurface = 0
				debc.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-6,200)*CFrame.Angles(math.rad(math.random(5,10)),math.rad(0),math.rad(0))*CFrame.new(0,math.random(-5,5),0)
				local deb2 = Instance.new("Part", char)
				deb2.CanCollide = false
				deb2.FormFactor = 3
				deb2.Name = "Ring"
				deb2.Material = hf.Material
				deb2.Color = hf.Color
				deb2.Size = vt(math.random(50,60),math.random(50,60),math.random(50,60))
				deb2.Transparency = 0
				deb2.TopSurface = 0
				deb2.BottomSurface = 0
				deb2.CFrame = root.CFrame
				deb2.Velocity = vt(math.random(-300,300),math.random(250,500),math.random(-300,300))
				deb2.RotVelocity = vt(math.random(-5,5),math.random(-5,5),math.random(-5,5))
				local at1 = Instance.new('Attachment',deb2)
				at1.Position = vt(0,20,0)
				local at2 = Instance.new('Attachment',deb2)
				at2.Position = vt(0,-20,0)
				local tl = Instance.new('Trail',deb2)
				tl.Attachment0 = at1
				tl.Attachment1 = at2
				tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
				tl.Color = ColorSequence.new(Color3.new(1,1,1))
				tl.LightEmission = 1
				tl.Lifetime = 1
				game:GetService("Debris"):AddItem(deb,30)
				game:GetService("Debris"):AddItem(debb,30)
				game:GetService("Debris"):AddItem(debc,30)
				game:GetService("Debris"):AddItem(deb2,30)
				coroutine.resume(coroutine.create(function()
					wait(15)
					for i = 0, 24 do
						swait()
						deb.Transparency = deb.Transparency + 0.04
						debb.Transparency = debb.Transparency + 0.04
						debc.Transparency = debc.Transparency + 0.04
					end
					deb:Destroy()
					debb:Destroy()
					debc:Destroy()
				end))
			end
		end
		for i = 0, 25 ,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.15,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(40)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,-0.3)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(30)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,-1)*angles(math.rad(40),math.rad(0),math.rad(0)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.6)
			RW.C0=clerp(RW.C0,cf(1,0.75,-0.75)*angles(math.rad(40),math.rad(0),math.rad(-20)),.6)
			LW.C0=clerp(LW.C0,cf(-1,0.75,-0.75)*angles(math.rad(40),math.rad(0),math.rad(20)),.6)
		end
		attack = false
		hum.WalkSpeed = 16
	end
	local chrged = false
	function test()
		attack = true
		for i = 0, 49 do
			slash(math.random(10,100)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.01,0.05),math.random(25,500)/250,BrickColor.new("White"))
		end
		shakes(0.25,0.25)
		CFuncs["Sound"].Create("rbxassetid://1295446488", root, 5, 1)
		for i = 0, 3 ,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(10)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,0)*angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(20),math.rad(0),math.rad(40)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(18),math.rad(0),math.rad(-45)),.3)
			root.Velocity = root.Velocity + vt(0,300,0)
		end
		for x = 0, 4 do
			for i = 0, 1 ,0.6 do
				swait()
				root.Velocity = vt(0,0,0)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.3)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(10)),.3)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.3)
				RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.25)*angles(math.rad(80),math.rad(0),math.rad(-90)),.3)
				LW.C0=clerp(LW.C0,cf(-1.25,0.5,-0.25)*angles(math.rad(67),math.rad(0),math.rad(87)),.3)
			end
			for i = 0, 1 ,0.6 do
				swait()
				root.Velocity = vt(0,0,0)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.3)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(10)),.3)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,0)*angles(math.rad(-90),math.rad(0),math.rad(0)),.3)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.3)
				RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.25)*angles(math.rad(80),math.rad(0),math.rad(-90)),.3)
				LW.C0=clerp(LW.C0,cf(-1.25,0.5,-0.25)*angles(math.rad(67),math.rad(0),math.rad(87)),.3)
			end
			for i = 0, 1 ,0.6 do
				swait()
				root.Velocity = vt(0,0,0)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.3)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(10)),.3)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,0)*angles(math.rad(-180),math.rad(0),math.rad(0)),.3)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.3)
				RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.25)*angles(math.rad(80),math.rad(0),math.rad(-90)),.3)
				LW.C0=clerp(LW.C0,cf(-1.25,0.5,-0.25)*angles(math.rad(67),math.rad(0),math.rad(87)),.3)
			end
			for i = 0, 1 ,0.6 do
				swait()
				root.Velocity = vt(0,0,0)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.3)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(10)),.3)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,0)*angles(math.rad(-270),math.rad(0),math.rad(0)),.3)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.3)
				RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.25)*angles(math.rad(80),math.rad(0),math.rad(-90)),.3)
				LW.C0=clerp(LW.C0,cf(-1.25,0.5,-0.25)*angles(math.rad(67),math.rad(0),math.rad(87)),.3)
			end
		end
		local hf,pf=rayCast(root.Position,(CFrame.new(root.Position,root.Position - vt(0,1,0))).lookVector,4,char)
		hum.WalkSpeed = 100
		while true do
			swait()
			sphere2(2,"Add",rarm.CFrame*CFrame.new(0,-1.5,0),vt(3,3,3),-0.03,-0.03,-0.03,orgcl,orgcl.Color)
			sphere2(2,"Add",larm.CFrame*CFrame.new(0,-1.5,0),vt(3,3,3),-0.03,-0.03,-0.03,orgcl,orgcl.Color)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-10)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(10)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(150),math.rad(0),math.rad(0)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.3)
			RW.C0=clerp(RW.C0,cf(1.15,0.85,0)*angles(math.rad(160),math.rad(0),math.rad(-10)),.3)
			LW.C0=clerp(LW.C0,cf(-1.15,0.85,0)*angles(math.rad(160),math.rad(0),math.rad(10)),.3)
			hf,pf=rayCast(root.Position,(CFrame.new(root.Position,root.Position - vt(0,1,0))).lookVector,4,char)
			if hf ~= nil then
				attack = false
				hum.WalkSpeed = storehumanoidWS
				if OVERPOWER == false then
					shakes(0.6,1)
					sphere2(3,"Add",root.CFrame*CFrame.new(0,-3,0),vt(0,0,0),1,1,1,orgcl,orgcl.Color)
					sphere2(4,"Add",root.CFrame*CFrame.new(0,-3,0),vt(0,0,0),1,1,1,orgcl,orgcl.Color)
					local hbax = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					hbax.CFrame = root.CFrame
					hbax.Anchored = true
					CFuncs["Sound"].Create("rbxassetid://1066991958", hbax, 4, 0.9)
					CFuncs["Sound"].Create("rbxassetid://2036839549", hbax, 2.75, 1)
					CFuncs["Sound"].Create("rbxassetid://1259054947", hbax, 3.5, 1)
					MagniDamage(hbax, 32, 21,32, 0, "Normal")
					game:GetService("Debris"):AddItem(hbax,15)
					for i = 0, 24 do
						slash(math.random(30,100)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.01,0.05),math.random(25,500)/250,BrickColor.new("White"))
					end
					for i = 0, 24 do
						local deb = Instance.new("Part", char)
						deb.Anchored = true
						deb.CanCollide = false
						deb.FormFactor = 3
						deb.Name = "Ring"
						deb.Material = hf.Material
						deb.Color = hf.Color
						deb.Size = vt(math.random(12,18),math.random(12,18),math.random(12,18))
						deb.Transparency = 0
						deb.TopSurface = 0
						deb.BottomSurface = 0
						deb.CFrame = root.CFrame*CFrame.new(math.random(-40,40),-5,math.random(-40,40))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
						local deb2 = Instance.new("Part", char)
						deb2.CanCollide = false
						deb2.FormFactor = 3
						deb2.Name = "Ring"
						deb2.Material = hf.Material
						deb2.Color = hf.Color
						deb2.Size = vt(math.random(2,6),math.random(2,6),math.random(2,6))
						deb2.Transparency = 0
						deb2.TopSurface = 0
						deb2.BottomSurface = 0
						deb2.Velocity = vt(math.random(-30,30),math.random(50,200),math.random(-30,30))
						deb2.RotVelocity = vt(math.random(-50,50),math.random(-50,50),math.random(-50,50))
						deb2.CFrame = root.CFrame*CFrame.new(math.random(-20,20),-5,math.random(-20,20))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
						local at1 = Instance.new('Attachment',deb2)
						at1.Position = vt(0,1,0)
						local at2 = Instance.new('Attachment',deb2)
						at2.Position = vt(0,-1,0)
						local tl = Instance.new('Trail',deb2)
						tl.Attachment0 = at1
						tl.Attachment1 = at2
						tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
						tl.Color = ColorSequence.new(orgcl.Color)
						tl.LightEmission = 1
						tl.Lifetime = 1
						game:GetService("Debris"):AddItem(deb,15)
						game:GetService("Debris"):AddItem(deb2,15)
						coroutine.resume(coroutine.create(function()
							wait(5)
							for i = 0, 24 do
								swait()
								deb.Transparency = deb.Transparency + 0.04
							end
							deb:Destroy()
						end))
					end
				elseif OVERPOWER == true then
					shakes(1.2,2)
					sphere2(1,"Add",root.CFrame*CFrame.new(0,-3,0),vt(0,0,0),3,3,3,orgcl,orgcl.Color)
					sphere2(2,"Add",root.CFrame*CFrame.new(0,-3,0),vt(0,0,0),3,3,3,orgcl,orgcl.Color)
					sphere2(3,"Add",root.CFrame*CFrame.new(0,-3,0),vt(0,0,0),3,3,3,orgcl,orgcl.Color)
					sphere2(4,"Add",root.CFrame*CFrame.new(0,-3,0),vt(0,0,0),3,3,3,orgcl,orgcl.Color)
					sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(0,0,0),3,3,3,orgcl,orgcl.Color)
					sphere2(6,"Add",root.CFrame*CFrame.new(0,-3,0),vt(0,0,0),3,3,3,orgcl,orgcl.Color)
					local hbax = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					hbax.CFrame = root.CFrame
					hbax.Anchored = true
					CFuncs["Sound"].Create("rbxassetid://1066991958", hbax, 10, 0.5)
					CFuncs["Sound"].Create("rbxassetid://2036839549", hbax, 10, 0.75)
					CFuncs["Sound"].Create("rbxassetid://1259054947", hbax, 10, 0.75)
					for i = 0, 2 do
						CFuncs["Sound"].Create("rbxassetid://782354021", hbax, 7, 0.75)
						CFuncs["Sound"].Create("rbxassetid://824687369", hbax, 10, 1)
					end
					MagniDamage(hbax, 64, 50,90, 0, "Normal")
					game:GetService("Debris"):AddItem(hbax,15)
					for i = 0, 49 do
						slash(math.random(30,100)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.01,0.05),math.random(50,750)/250,BrickColor.new("White"))
					end
					for i = 0, 49 do
						local deb = Instance.new("Part", char)
						deb.Anchored = true
						deb.CanCollide = false
						deb.FormFactor = 3
						deb.Name = "Ring"
						deb.Material = hf.Material
						deb.Color = hf.Color
						deb.Size = vt(math.random(24,36),math.random(24,36),math.random(24,36))
						deb.Transparency = 0
						deb.TopSurface = 0
						deb.BottomSurface = 0
						deb.CFrame = root.CFrame*CFrame.new(math.random(-80,80),-5,math.random(-80,80))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
						local deb2 = Instance.new("Part", char)
						deb2.CanCollide = false
						deb2.FormFactor = 3
						deb2.Name = "Ring"
						deb2.Material = hf.Material
						deb2.Color = hf.Color
						deb2.Size = vt(math.random(4,12),math.random(4,12),math.random(4,12))
						deb2.Transparency = 0
						deb2.TopSurface = 0
						deb2.BottomSurface = 0
						deb2.Velocity = vt(math.random(-60,60),math.random(100,400),math.random(-60,60))
						deb2.RotVelocity = vt(math.random(-50,50),math.random(-50,50),math.random(-50,50))
						deb2.CFrame = root.CFrame*CFrame.new(math.random(-40,40),-5,math.random(-40,40))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
						local at1 = Instance.new('Attachment',deb2)
						at1.Position = vt(0,2,0)
						local at2 = Instance.new('Attachment',deb2)
						at2.Position = vt(0,-2,0)
						local tl = Instance.new('Trail',deb2)
						tl.Attachment0 = at1
						tl.Attachment1 = at2
						tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
						tl.Color = ColorSequence.new(orgcl.Color)
						tl.LightEmission = 1
						tl.Lifetime = 1
						game:GetService("Debris"):AddItem(deb,15)
						game:GetService("Debris"):AddItem(deb2,15)
						coroutine.resume(coroutine.create(function()
							wait(5)
							for i = 0, 24 do
								swait()
								deb.Transparency = deb.Transparency + 0.04
							end
							deb:Destroy()
						end))
					end
				end
				break
			end
		end
	end

	function a()
		chrged = true
		attack = true
		hum.WalkSpeed = 1
		local clevel = 1
		effar.Color = ColorSequence.new(orgcl.Color)
		effar.Enabled = true
		local loopedboi = Instance.new("Sound",root)
		loopedboi.Volume = 0
		loopedboi.SoundId = "rbxassetid://2162238374"
		loopedboi.Looped = true
		loopedboi:Play()
		local chboi = Instance.new("Sound",root)
		chboi.Volume = 2
		chboi.Pitch = 0.2
		chboi.SoundId = "rbxassetid://136007472"
		chboi:Play()
		while true do
			swait()
			if OVERPOWER == false then
				clevel = clevel + 0.1
			elseif OVERPOWER == true then
				clevel = clevel + 1
			end
			chboi.Volume = 2+clevel/100
			loopedboi.Volume = 0+clevel/100
			loopedboi.Pitch = 1-clevel/1000
			--localshakes(clevel/10000,1)
			waveEff(10,"Add",root.CFrame*CFrame.new(0,-2.5,0),vt(0,1.25,0),0.125,orgcl)
			slash(math.random(30,100)/10,3,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01+clevel/2000,0.001,0.01+clevel/2000),math.random(-1,1)/250,orgcl)
			sphere2(3,"Add",rarm.CFrame*CFrame.new(0,-1,0),vt(0.5,0.5,0.5),clevel/1000,clevel/1000,clevel/1000,orgcl,orgcl.Color)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(13),math.rad(1)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(20),math.rad(-1)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,0 + 0.05 * math.cos(sine / 20))*angles(math.rad(1),math.rad(0),math.rad(-48)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(48)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.35,0)*angles(math.rad(160),math.rad(0),math.rad(12)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(-48)),.3)
			if chrged == false then
				effar.Enabled = false
				chboi:Destroy()
				loopedboi:Destroy()
				if OVERPOWER == false then
					shakes(0.05*clevel/2.5,1.5*clevel/75)
					for i = 0, 1+clevel/50 do
						CFuncs["Sound"].Create("rbxassetid://782354021", root, 1+clevel/2, 1-clevel/1500)
					end
					coroutine.resume(coroutine.create(function()
						local dist = 3
						for x = 0, 2 do
							local hbax = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
							hbax.CFrame = root.CFrame + root.CFrame.lookVector*dist*clevel/5
							hbax.Anchored = true
							for i = 0, 1+clevel/50 do
								CFuncs["Sound"].Create("rbxassetid://824687369", hbax, 0.5+clevel/2, 1-clevel/5000)
							end
							for i = 0, 9 do
								slash(math.random(30,100)/10,3,true,"Round","Add","Out",hbax.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01*clevel/2.5,0.001,0.01*clevel/2.5),math.random(10,25)/250*clevel/2.5,orgcl)
							end
							sphere2(3,"Add",hbax.CFrame,vt(2.5*clevel/2.5,2.5*clevel/2.5,2.5*clevel/2.5),0.1,0.1,0.1,orgcl,orgcl.Color)
							sphere2(3,"Add",hbax.CFrame,vt(1.5*clevel/2.5,1.5*clevel/2.5,1.5*clevel/2.5),0.1,0.1,0.1,bc("White"),Color3.new(1,1,1))
							MagniDamage(hbax, 4*clevel/3, 3*clevel/2.5,8*clevel/2.5, 0, "Normal")
							game:GetService("Debris"):AddItem(hbax,10)
							dist = dist + 3
							for i = 0, 1, 0.3 do
								swait()
								RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-15),math.rad(10)),.6)
								LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(20),math.rad(-1)),.6)
								RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,0)*angles(math.rad(10),math.rad(0),math.rad(70)),.6)
								Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(-70)),.6)
								RW.C0=clerp(RW.C0,cf(1.25,0.45,-0.25)*angles(math.rad(90),math.rad(0),math.rad(-24)),.6)
								LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-46)),.6)
							end
						end		
						attack = false
					end))
				elseif OVERPOWER == true then
					for n = 0, 4 do
						shakes(0.05*clevel/2.5,1.5*clevel/75)
						for i = 0, 1+clevel/50 do
							CFuncs["Sound"].Create("rbxassetid://782354021", root, 1+clevel/2, 1-clevel/1500)
						end
						coroutine.resume(coroutine.create(function()
							local dist = 3
							for x = 0, 2 do
								local hbax = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
								hbax.CFrame = root.CFrame + root.CFrame.lookVector*dist*clevel/5
								hbax.Anchored = true
								for i = 0, 1+clevel/50 do
									CFuncs["Sound"].Create("rbxassetid://824687369", hbax, 0.5+clevel/2, 1-clevel/5000)
								end
								for i = 0, 9 do
									slash(math.random(30,100)/10,3,true,"Round","Add","Out",hbax.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01*clevel/2.5,0.001,0.01*clevel/2.5),math.random(10,25)/250*clevel/2.5,orgcl)
								end
								sphere2(3,"Add",hbax.CFrame,vt(2.5*clevel/2.5,2.5*clevel/2.5,2.5*clevel/2.5),0.1,0.1,0.1,orgcl,orgcl.Color)
								sphere2(3,"Add",hbax.CFrame,vt(1.5*clevel/2.5,1.5*clevel/2.5,1.5*clevel/2.5),0.1,0.1,0.1,bc("White"),Color3.new(1,1,1))
								MagniDamage(hbax, 4*clevel/3, 3*clevel/2.5,8*clevel/2.5, 0, "Normal")
								game:GetService("Debris"):AddItem(hbax,10)
								dist = dist + 3
								for i = 0, 1, 0.3 do
									swait()
									RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-15),math.rad(10)),.6)
									LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(20),math.rad(-1)),.6)
									RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,0)*angles(math.rad(10),math.rad(0),math.rad(70)),.6)
									Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(-70)),.6)
									RW.C0=clerp(RW.C0,cf(1.25,0.45,-0.25)*angles(math.rad(90),math.rad(0),math.rad(-24)),.6)
									LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-46)),.6)
								end
							end
							attack = false
						end))
						swait(30)
					end
				end
				hum.WalkSpeed = storehumanoidWS
				break
			end
		end
	end

	local holden = false
	function hm()
		hum.WalkSpeed = 0
		attack = true
		CFuncs["Sound"].Create("rbxassetid://186234895", centerR, 3, 1)
		local SPD = 1
		local mult = 1
		local ratez = 1
		blink.Enabled = true
		hgwR0.C1=clerp(hgwR0.C1,cf(-10,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),1)
		hgwR1.C1=clerp(hgwR1.C1,cf(10,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),1)
		hgwR2.C1=clerp(hgwR2.C1,cf(10,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),1)
		hgwR3.C1=clerp(hgwR3.C1,cf(10,0,0)*angles(math.rad(60),math.rad(0),math.rad(90)),1)
		hgwR4.C1=clerp(hgwR4.C1,cf(10,0,0)*angles(math.rad(60),math.rad(0),math.rad(90)),1)
		hgwR5.C1=clerp(hgwR5.C1,cf(10,0,0)*angles(math.rad(-60),math.rad(0),math.rad(90)),1)
		hgwR6.C1=clerp(hgwR6.C1,cf(10,0,0)*angles(math.rad(-60),math.rad(0),math.rad(90)),1)
		hgwRA1.C1=clerp(hgwRA1.C1,cf(5,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),1)
		hgwRA2.C1=clerp(hgwRA2.C1,cf(5,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),1)
		hgwRA3.C1=clerp(hgwRA3.C1,cf(5,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),1)
		hgwRA4.C1=clerp(hgwRA4.C1,cf(5,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),1)
		hgwRA5.C1=clerp(hgwRA5.C1,cf(5,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),1)
		for a,part in pairs(gatlR:GetChildren()) do
			if part:IsA("Part") or part:IsA("UnionOperation") then
				part.Transparency = 1
			end
		end
		for i = 0, 14 ,0.1 do
			swait()
			SPD = SPD*mult
			mult = mult + 0.003
			blink.Rate = ratez
			ratez = ratez + 0.25*mult
			for a,part in pairs(gatlR:GetChildren()) do
				if part:IsA("Part") or part:IsA("UnionOperation") then
					part.Transparency = part.Transparency - 0.004
				end
			end
			hologrmgun.C0=clerp(hologrmgun.C0,cf(0,0,0)*angles(math.rad(0),math.rad(SPD),math.rad(0)),1)
			hgwR0.C1=clerp(hgwR0.C1,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
			hgwR1.C1=clerp(hgwR1.C1,cf(0,0.6,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
			hgwR2.C1=clerp(hgwR2.C1,cf(0,-0.6,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
			hgwR3.C1=clerp(hgwR3.C1,cf(0,0.6,0)*angles(math.rad(60),math.rad(0),math.rad(90)),.05)
			hgwR4.C1=clerp(hgwR4.C1,cf(0,-0.6,0)*angles(math.rad(60),math.rad(0),math.rad(90)),.05)
			hgwR5.C1=clerp(hgwR5.C1,cf(0,0.6,0)*angles(math.rad(-60),math.rad(0),math.rad(90)),.05)
			hgwR6.C1=clerp(hgwR6.C1,cf(0,-0.6,0)*angles(math.rad(-60),math.rad(0),math.rad(90)),.05)
			hgwRA1.C1=clerp(hgwRA1.C1,cf(2.5,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
			hgwRA2.C1=clerp(hgwRA2.C1,cf(2,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
			hgwRA3.C1=clerp(hgwRA3.C1,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
			hgwRA4.C1=clerp(hgwRA4.C1,cf(-3,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
			hgwRA5.C1=clerp(hgwRA5.C1,cf(-2,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
			RH.C0=clerp(RH.C0,cf(1,-0.8,-0.3)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-15),math.rad(0),math.rad(-25)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-0.6,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,-0.6)*angles(math.rad(5),math.rad(0),math.rad(80)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(-80)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,-0.4)*angles(math.rad(120),math.rad(0),math.rad(-30)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(60),math.rad(0),math.rad(-6)),.3)
		end
		blink.Rate = 0
		blink.Enabled = false
		fir.Enabled = true
		local halt = 0
		while true do
			if holden == true then
				CFuncs["Sound"].Create("rbxassetid://150305126", centerR, 0.65, 1)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,-0)*angles(math.rad(95),math.rad(0),math.rad(90)),1)
				local a = Instance.new("Part",Character)
				a.Name = "Direction"	
				a.Anchored = true
				a.BrickColor = bc("Bright red")
				a.Material = "Neon"
				a.Transparency = 1
				a.CanCollide = false
				local ray = Ray.new(
					centerR.CFrame.p,                           -- origin
					(mouse.Hit.p - centerR.CFrame.p).unit * 500 -- direction
				) 
				local ignore = Character
				local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
				a.BottomSurface = 10
				a.TopSurface = 10
				local distance = (centerR.CFrame.p - position).magnitude
				a.Size = Vector3.new(0.1, 0.1, 0.1)
				a.CFrame = CFrame.new(centerR.CFrame.p, position) * CFrame.new(0, 0, 0)
				local lb = Instance.new("Part")
				lb.Parent = char
				lb.Color = orgcl.Color
				lb.CanCollide = false
				lb.Material = "Neon"
				lb.Anchored = true
				lb.TopSurface = 0
				lb.BottomSurface = 0
				lb.Transparency = 1
				lb.Size = vt(0.25,0.25,0.25)
				lb.CFrame = a.CFrame*CFrame.new(math.random(-30,30)/60,math.random(-30,30)/60,0)
				lb.Anchored = false
				local thingery = Instance.new("SpecialMesh",lb)
				thingery.MeshType = "Sphere"
				local trl = Instance.new("Trail",lb)
				local a0 = Instance.new("Attachment",lb)
				a0.Position = Vector3.new(0.25,0,0)
				local a1 = Instance.new("Attachment",lb)
				a1.Position = Vector3.new(-0.25,0,0)
				trl.Attachment0 = a0
				trl.Attachment1 = a1
				trl.FaceCamera = true
				trl.Color = ColorSequence.new(orgcl.Color)
				trl.Lifetime = 0.25
				trl.LightEmission = 1
				trl.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)})
				trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
				game:GetService("Debris"):AddItem(lb, 10)
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = lb.CFrame.lookVector*300
				bv.Parent = lb
				local hitted = false
				game:GetService("Debris"):AddItem(a, 0.1)
				coroutine.resume(coroutine.create(function()
					swait(10)
					lb.Touched:connect(function(hit)
						if hitted == false and hit.Parent ~= char then
							local hbax = CreateParta(lb,1,1,"SmoothPlastic",BrickColor.random())
							hbax.CFrame = lb.CFrame
							hbax.Anchored = true
							sphere2(2.5,"Add",hbax.CFrame,vt(0,0,0),0.1,0.1,0.1,orgcl,orgcl.Color)
							sphere2(5,"Add",hbax.CFrame,vt(0,0,0),0.1,0.1,0.1,orgcl,orgcl.Color)
							coroutine.resume(coroutine.create(function()
								for i = 1, math.random(3,8) do
									trailMK(math.random(4,5),math.random(50,200)/1000,"Add",hbax.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,-0.0025,orgcl.Color,0)
								end
							end))
							MagniDamage(hbax,10,8,15,0,"Normal",153092227)
							hitted = true
							lb.Transparency = 1
							lb.Anchored = true
							trl.Disabled = false
							wait(1)
							lb:Destroy()
						end
					end)
				end))
				for i = 0, 1 ,0.2 do
					swait()
					halt = halt + 15
					trailMK(math.random(8,10),math.random(25,50)/50,"Add",centerR.CFrame*CFrame.Angles(math.rad(-90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.25,0,orgcl.Color,0,1)
					hologrmgun.C0=clerp(hologrmgun.C0,cf(0,0,0)*angles(math.rad(0),math.rad(halt),math.rad(0)),1)
					hgwR0.C1=clerp(hgwR0.C1,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
					hgwR1.C1=clerp(hgwR1.C1,cf(0,0.6,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
					hgwR2.C1=clerp(hgwR2.C1,cf(0,-0.6,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
					hgwR3.C1=clerp(hgwR3.C1,cf(0,0.6,0)*angles(math.rad(60),math.rad(0),math.rad(90)),.05)
					hgwR4.C1=clerp(hgwR4.C1,cf(0,-0.6,0)*angles(math.rad(60),math.rad(0),math.rad(90)),.05)
					hgwR5.C1=clerp(hgwR5.C1,cf(0,0.6,0)*angles(math.rad(-60),math.rad(0),math.rad(90)),.05)
					hgwR6.C1=clerp(hgwR6.C1,cf(0,-0.6,0)*angles(math.rad(-60),math.rad(0),math.rad(90)),.05)
					RH.C0=clerp(RH.C0,cf(1,-0.8,-0.3)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-15),math.rad(0),math.rad(-25)),.5)
					LH.C0=clerp(LH.C0,cf(-1,-0.6,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20)),.5)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.025,-0.6)*angles(math.rad(0),math.rad(0),math.rad(90)),.5)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5),math.rad(0),math.rad(-90)),.5)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,-0)*angles(math.rad(90),math.rad(0),math.rad(90)),.5)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(60),math.rad(0),math.rad(-60)),.5)
				end
			elseif holden == false then
				attack = false
				fir.Enabled = false
				coroutine.resume(coroutine.create(function()
					for i = 0, 4 ,0.1 do
						swait()
						halt = halt + 15
						for a,part in pairs(gatlR:GetChildren()) do
							if part:IsA("Part") or part:IsA("UnionOperation") then
								part.Transparency = part.Transparency + 0.016
							end
						end
						hologrmgun.C0=clerp(hologrmgun.C0,cf(0,0,0)*angles(math.rad(0),math.rad(halt),math.rad(0)),1)
						hgwR0.C1=clerp(hgwR0.C1,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
						hgwR1.C1=clerp(hgwR1.C1,cf(0,0.6,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
						hgwR2.C1=clerp(hgwR2.C1,cf(0,-0.6,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
						hgwR3.C1=clerp(hgwR3.C1,cf(0,0.6,0)*angles(math.rad(60),math.rad(0),math.rad(90)),.05)
						hgwR4.C1=clerp(hgwR4.C1,cf(0,-0.6,0)*angles(math.rad(60),math.rad(0),math.rad(90)),.05)
						hgwR5.C1=clerp(hgwR5.C1,cf(0,0.6,0)*angles(math.rad(-60),math.rad(0),math.rad(90)),.05)
						hgwR6.C1=clerp(hgwR6.C1,cf(0,-0.6,0)*angles(math.rad(-60),math.rad(0),math.rad(90)),.05)
						hgwRA1.C1=clerp(hgwRA1.C1,cf(2.5,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
						hgwRA2.C1=clerp(hgwRA2.C1,cf(2,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
						hgwRA3.C1=clerp(hgwRA3.C1,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
						hgwRA4.C1=clerp(hgwRA4.C1,cf(-3,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
						hgwRA5.C1=clerp(hgwRA5.C1,cf(-2,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.05)
					end
					for a,part in pairs(gatlR:GetChildren()) do
						if part:IsA("Part") or part:IsA("UnionOperation") then
							part.Transparency = 1
						end
					end
				end))
				hum.WalkSpeed = 16
				break
			end
		end
	end
	local holdingRocc = false
	local truerock = nil
	function rocc()
		attack = true
		hum.WalkSpeed = 0
		hum.JumpPower = 0
		for i = 0, 3 ,0.15 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-10),math.rad(0),math.rad(5)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1.2,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(60),math.rad(-10)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.2,0)*angles(math.rad(-5),math.rad(0),math.rad(-60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(10),math.rad(60)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0.6)*angles(math.rad(140),math.rad(0),math.rad(10)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(-20)),.3)
		end
		CFuncs["Sound"].Create("rbxassetid://2295409459", rarm, 2, 0.8)
		local hf,pf=rayCast(root.Position,(CFrame.new(root.Position,root.Position - vt(0,1,0))).lookVector,4,char)
		if hf ~= nil then
			localshakes(0.2,1)
			CFuncs["Sound"].Create("rbxassetid://199145477", root, 1, 0.9)
			sphere2(5,"Add",root.CFrame*CFrame.new(0,0,-3),vt(3,0,3),0,0.7,0,bc("White"),Color3.new(1,1,1))
			sphere2(5,"Add",root.CFrame*CFrame.new(0,0,-3),vt(3,0,3),0.05,0.7,0.05,bc("White"),Color3.new(1,1,1))
			local rotation = 0
			for i = 0, 35 do
				rotation = rotation + 10
				local deb = Instance.new("Part", char)
				deb.Anchored = true
				deb.CanCollide = false
				deb.FormFactor = 3
				deb.Name = "Ring"
				deb.Material = hf.Material
				deb.Color = hf.Color
				deb.Size = vt(math.random(2,3),math.random(2,3),math.random(2,3))
				deb.Transparency = 0
				deb.TopSurface = 0
				deb.BottomSurface = 0
				deb.CFrame = root.CFrame*CFrame.new(0,0,-3)*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-5,2)*CFrame.Angles(math.rad(math.random(20,30)),math.rad(0),math.rad(0))*CFrame.new(0,math.random(-1,1),0)
				local debb = Instance.new("Part", char)
				debb.Anchored = true
				debb.CanCollide = false
				debb.FormFactor = 3
				debb.Name = "Ring"
				debb.Material = hf.Material
				debb.Color = hf.Color
				debb.Size = vt(math.random(3,4),math.random(2,3),math.random(3,4))
				debb.Transparency = 0
				debb.TopSurface = 0
				debb.BottomSurface = 0
				debb.CFrame = root.CFrame*CFrame.new(0,0,-3)*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-5.5,3.5)*CFrame.Angles(math.rad(math.random(10,20)),math.rad(0),math.rad(0))*CFrame.new(0,math.random(-1,1),0)
				local deb2 = Instance.new("Part", char)
				deb2.CanCollide = false
				deb2.FormFactor = 3
				deb2.Name = "Ring"
				deb2.Material = hf.Material
				deb2.Color = hf.Color
				deb2.Size = vt(math.random(1,2),math.random(1,2),math.random(1,2))
				deb2.Transparency = 0
				deb2.TopSurface = 0
				deb2.BottomSurface = 0
				deb2.CFrame = root.CFrame*CFrame.new(0,-3,-3)
				deb2.Velocity = vt(math.random(-20,20),math.random(30,60),math.random(-20,20))
				deb2.RotVelocity = vt(math.random(-5,5),math.random(-5,5),math.random(-5,5))
				local at1 = Instance.new('Attachment',deb2)
				at1.Position = vt(0,0.5,0)
				local at2 = Instance.new('Attachment',deb2)
				at2.Position = vt(0,-0.5,0)
				local tl = Instance.new('Trail',deb2)
				tl.Attachment0 = at1
				tl.Attachment1 = at2
				tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
				tl.Color = ColorSequence.new(Color3.new(1,1,1))
				tl.LightEmission = 1
				tl.Lifetime = 0.5
				game:GetService("Debris"):AddItem(deb,30)
				game:GetService("Debris"):AddItem(debb,30)
				game:GetService("Debris"):AddItem(deb2,5)
				coroutine.resume(coroutine.create(function()
					wait(0.5)
					deb2.CanCollide = true
					wait(5)
					for i = 0, 24 do
						swait()
						deb.Transparency = deb.Transparency + 0.04
						debb.Transparency = debb.Transparency + 0.04
					end
					deb:Destroy()
					debb:Destroy()
				end))
			end
		end
		for i = 0, 6 ,0.2 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.2,-0.3)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-30),math.rad(0),math.rad(30)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.5)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.6,-0.8)*angles(math.rad(40),math.rad(0),math.rad(30)),.5)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(-20),math.rad(-30)),.5)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,-1.1)*angles(math.rad(40),math.rad(0),math.rad(30)),.5)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(20),math.rad(0),math.rad(-60)),.5)
		end
		if hf ~= nil then
			holdingRocc = true
			local rockz = CreateParta(char,0,0,"Plastic",BrickColor.random())
			rockz.Color = hf.Color
			rockz.Material = hf.Material
			rockz.Transparency = hf.Transparency
			rockz.Reflectance = hf.Reflectance
			CreateMesha(rockz,"Brick",3,3,3)
			CreateWelda(rockz,sorb,rockz,0,0,0,math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),0,0,0,math.rad(0),math.rad(0),math.rad(0))
			truerock = rockz
		end
		attack = false
		hum.WalkSpeed = 16
		hum.JumpPower = 50
	end
	function throwRocc()
		hum.WalkSpeed = 2
		attack = true
		for i = 0, 4 ,0.2 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.8,-0.3)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-15),math.rad(0),math.rad(-25)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(6),math.rad(0),math.rad(8)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.6,-0.5)*angles(math.rad(-20),math.rad(0),math.rad(-40)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(20),math.rad(40)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,1.2,-0.4)*angles(math.rad(210),math.rad(0),math.rad(20)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(30),math.rad(0),math.rad(-40)),.3)
		end
		CFuncs["Sound"].Create("rbxassetid://2295409459", rarm, 3, 0.7)
		holdingRocc = false
		local a = Instance.new("Part",Character)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			centerR.CFrame.p,                           -- origin
			(mouse.Hit.p - centerR.CFrame.p).unit * 500 -- direction
		) 
		local ignore = Character
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (centerR.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(centerR.CFrame.p, position) * CFrame.new(0, 0, 0)
		local lb = Instance.new("Part")
		lb.Parent = char
		lb.Color = truerock.Color
		lb.CanCollide = false
		lb.Material = truerock.Material
		lb.Anchored = true
		lb.TopSurface = 0
		lb.BottomSurface = 0
		lb.Transparency = truerock.Transparency
		lb.Reflectance = truerock.Reflectance
		lb.Size = vt(0.5,0.5,0.5)
		lb.CFrame = a.CFrame
		lb.Anchored = false
		lb.RotVelocity = vt(math.random(-10,10),math.random(-10,10),math.random(-10,10))
		local thingery = Instance.new("SpecialMesh",lb)
		thingery.MeshType = "Brick"
		thingery.Scale = vt(6,6,6)
		local trl = Instance.new("Trail",lb)
		local a0 = Instance.new("Attachment",lb)
		a0.Position = Vector3.new(1.5,0,0)
		local a1 = Instance.new("Attachment",lb)
		a1.Position = Vector3.new(-1.5,0,0)
		trl.Attachment0 = a0
		trl.Attachment1 = a1
		trl.FaceCamera = true
		trl.Color = ColorSequence.new(orgcl.Color)
		trl.Lifetime = 0.25
		trl.LightEmission = 1
		trl.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)})
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
		game:GetService("Debris"):AddItem(lb, 10)
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = lb.CFrame.lookVector*150
		bv.Parent = lb
		local hitted = false
		game:GetService("Debris"):AddItem(a, 0.1)
		coroutine.resume(coroutine.create(function()
			swait(10)
			lb.Touched:connect(function(hit)
				if hitted == false and hit.Parent ~= char then
					local hbax = CreateParta(lb,1,1,"SmoothPlastic",BrickColor.random())
					hbax.CFrame = lb.CFrame
					hbax.Anchored = true
					sphere2(2.5,"Add",hbax.CFrame,vt(0,0,0),0.2,0.2,0.2,bc("White"),Color3.new(1,1,1))
					sphere2(5,"Add",hbax.CFrame,vt(0,0,0),0.2,0.2,0.2,bc("White"),Color3.new(1,1,1))
					CFuncs["Sound"].Create("rbxassetid://199145477", hbax, 1, 0.75)
					coroutine.resume(coroutine.create(function()
						for i = 1, math.random(6,12) do
							trailMK(math.random(2,5),math.random(50,400)/1000,"Add",hbax.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,-0.0025,Color3.new(1,1,1),0)
						end
						for i = 0, math.random(14,24) do
							local deb2 = Instance.new("Part", char)
							deb2.CanCollide = false
							deb2.FormFactor = 3
							deb2.Name = "Ring"
							deb2.Material = lb.Material
							deb2.Color = lb.Color
							deb2.Size = vt(math.random(1,2),math.random(1,2),math.random(1,2))
							deb2.Transparency = 0
							deb2.TopSurface = 0
							deb2.BottomSurface = 0
							deb2.CFrame = lb.CFrame
							deb2.Velocity = vt(math.random(-40,40),math.random(30,60),math.random(-40,40))
							deb2.RotVelocity = vt(math.random(-5,5),math.random(-5,5),math.random(-5,5))
							local at1 = Instance.new('Attachment',deb2)
							at1.Position = vt(0,0.5,0)
							local at2 = Instance.new('Attachment',deb2)
							at2.Position = vt(0,-0.5,0)
							local tl = Instance.new('Trail',deb2)
							tl.Attachment0 = at1
							tl.Attachment1 = at2
							tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
							tl.Color = ColorSequence.new(Color3.new(1,1,1))
							tl.LightEmission = 1
							tl.Lifetime = 0.5
							game:GetService("Debris"):AddItem(deb2,5)
							coroutine.resume(coroutine.create(function()
								wait(0.5)
								deb2.CanCollide = true
							end))
						end
					end))
					MagniDamage(hbax,18,15,25,0,"Normal",153092227)
					hitted = true
					lb.Transparency = 1
					lb.Anchored = true
					trl.Disabled = false
					wait(1)
					lb:Destroy()
				end
			end)
		end))
		truerock:Destroy()
		for i = 0, 5 ,0.2 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.6,-0.3)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-45),math.rad(0),math.rad(-25)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(15),math.rad(0),math.rad(8)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.6,-0.6)*angles(math.rad(20),math.rad(0),math.rad(60)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(-10),math.rad(-60)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,-0.6)*angles(math.rad(60),math.rad(0),math.rad(-10)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(40),math.rad(0),math.rad(-60)),.4)
		end
		attack = false
		hum.WalkSpeed = 16
	end
	function VErupt()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://2923164079", root, 4, 1)
		for i = 0, 9 ,0.2 do
			swait()
			sphere2(4,"Add",rarm.CFrame*CFrame.new(0,-2,0),vt(0,0,0),0.035,0.035,0.035,bc("Neon orange"),Color3.new(1,0.3,0))
			sphere2(4,"Add",larm.CFrame*CFrame.new(0,-2,0),vt(0,0,0),0.035,0.035,0.035,bc("Neon orange"),Color3.new(1,0.3,0))
			RH.C0=clerp(RH.C0,cf(1,-1,-0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(5),math.rad(-10)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,-0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(5),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.4,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(-0),math.rad(-0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(60),math.rad(0),math.rad(110)),.2)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(60),math.rad(0),math.rad(-110)),.2)
		end
		CFuncs["Sound"].Create("rbxassetid://2923152577", root, 4, 1)
		CFuncs["Sound"].Create("rbxassetid://824687369", root, 3, 1)
		CFuncs["Sound"].Create("rbxassetid://153092227", root, 2, 0.8)
		localshakes(0.5,0.75)
		MagniDamage(root,25,20,30,0,"Normal",153092227)
		sphere2(1,"Add",root.CFrame*CFrame.new(0,-2.8,0),vt(0,0,0),1,1,1,bc("Neon orange"),Color3.new(1,0.3,0))
		sphere2(2,"Add",root.CFrame*CFrame.new(0,-2.8,0),vt(0,0,0),1,1,1,bc("Neon orange"),Color3.new(1,0.3,0))
		sphere2(3,"Add",root.CFrame*CFrame.new(0,-2.8,0),vt(0,0,0),1,1,1,bc("Neon orange"),Color3.new(1,0.3,0))
		sphere2(4,"Add",root.CFrame*CFrame.new(0,-2.8,0),vt(0,0,0),1,1,1,bc("Neon orange"),Color3.new(1,0.3,0))
		local hf,pf=rayCast(root.Position,(CFrame.new(root.Position,root.Position - vt(0,1,0))).lookVector,4,char)
		if hf ~= nil then
			for i = 0, 49 do
				slash(math.random(10,20)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-2.9,0)*CFrame.Angles(math.rad(math.random(-4,4)),math.rad(math.random(-360,360)),math.rad(math.random(-4,4))),vt(0.01,0.001,0.01),math.random(125,250)/250,BrickColor.new("Neon orange"))
			end
			local rotation = 0
			for i = 0, 35 do
				rotation = rotation + 10
				local deb = Instance.new("Part", char)
				deb.Anchored = true
				deb.CanCollide = false
				deb.FormFactor = 3
				deb.Name = "Ring"
				deb.Material = hf.Material
				deb.Color = hf.Color
				deb.Size = vt(math.random(50,60)/4,math.random(25,35)/4,math.random(50,60)/4)
				deb.Transparency = 0
				deb.TopSurface = 0
				deb.BottomSurface = 0
				deb.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-6,100/4)*CFrame.Angles(math.rad(math.random(20,30)),math.rad(0),math.rad(0))*CFrame.new(0,math.random(-5,5),0)
				local debb = Instance.new("Part", char)
				debb.Anchored = true
				debb.CanCollide = false
				debb.FormFactor = 3
				debb.Name = "Ring"
				debb.Material = hf.Material
				debb.Color = hf.Color
				debb.Size = vt(math.random(40,50)/4,math.random(19,25)/4,math.random(40,50)/4)
				debb.Transparency = 0
				debb.TopSurface = 0
				debb.BottomSurface = 0
				debb.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-7,125/4)*CFrame.Angles(math.rad(math.random(10,20)),math.rad(0),math.rad(0))*CFrame.new(0,math.random(-5,5),0)
				local debc = Instance.new("Part", char)
				debc.Anchored = true
				debc.CanCollide = false
				debc.FormFactor = 3
				debc.Name = "Ring"
				debc.Material = hf.Material
				debc.Color = hf.Color
				debc.Size = vt(math.random(35,40)/4,math.random(14,18)/4,math.random(35,40)/4)
				debc.Transparency = 0
				debc.TopSurface = 0
				debc.BottomSurface = 0
				debc.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-7,150/4)*CFrame.Angles(math.rad(math.random(5,10)),math.rad(0),math.rad(0))*CFrame.new(0,math.random(-5,5),0)
				local deb2 = Instance.new("Part", char)
				deb2.CanCollide = false
				deb2.FormFactor = 3
				deb2.Name = "Ring"
				deb2.Material = hf.Material
				deb2.Color = hf.Color
				deb2.Size = vt(math.random(50,60)/16,math.random(50,60)/16,math.random(50,60)/16)
				deb2.Transparency = 0
				deb2.TopSurface = 0
				deb2.BottomSurface = 0
				deb2.CFrame = root.CFrame
				deb2.Velocity = vt(math.random(-300,300)/4,math.random(250,500)/4,math.random(-300,300)/4)
				deb2.RotVelocity = vt(math.random(-5,5),math.random(-5,5),math.random(-5,5))
				local at1 = Instance.new('Attachment',deb2)
				at1.Position = vt(0,20/16,0)
				local at2 = Instance.new('Attachment',deb2)
				at2.Position = vt(0,-20/16,0)
				local tl = Instance.new('Trail',deb2)
				tl.Attachment0 = at1
				tl.Attachment1 = at2
				tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
				tl.Color = ColorSequence.new(Color3.new(1,1,1))
				tl.LightEmission = 1
				tl.Lifetime = 1
				game:GetService("Debris"):AddItem(deb,30)
				game:GetService("Debris"):AddItem(debb,30)
				game:GetService("Debris"):AddItem(debc,30)
				game:GetService("Debris"):AddItem(deb2,30)
				coroutine.resume(coroutine.create(function()
					wait(15)
					for i = 0, 24 do
						swait()
						deb.Transparency = deb.Transparency + 0.04
						debb.Transparency = debb.Transparency + 0.04
						debc.Transparency = debc.Transparency + 0.04
					end
					deb:Destroy()
					debb:Destroy()
					debc:Destroy()
				end))
			end
		end
		for i = 0, math.random(6,16) do
			local lb = Instance.new("Part")
			lb.Parent = char
			lb.Color = orgcl.Color
			lb.CanCollide = false
			lb.Material = "Neon"
			lb.Anchored = true
			lb.TopSurface = 0
			lb.BottomSurface = 0
			lb.Transparency = 0
			lb.Size = vt(0.5,0.5,0.5)
			lb.CFrame = root.CFrame*CFrame.new(math.random(-10,10),-3,math.random(-10,10))
			lb.Anchored = false
			lb.Velocity = Vector3.new(math.random(-60,60),math.random(75,150),math.random(-60,60))
			lb.RotVelocity = vt(math.random(-10,10),math.random(-10,10),math.random(-10,10))
			local thingery = Instance.new("SpecialMesh",lb)
			thingery.MeshType = "Sphere"
			thingery.Scale = vt(4,4,4)
			local trl = Instance.new("Trail",lb)
			local a0 = Instance.new("Attachment",lb)
			a0.Position = Vector3.new(1,0,0)
			local a1 = Instance.new("Attachment",lb)
			a1.Position = Vector3.new(-1,0,0)
			trl.Attachment0 = a0
			trl.Attachment1 = a1
			trl.FaceCamera = true
			trl.Color = ColorSequence.new(orgcl.Color)
			trl.Lifetime = 0.25
			trl.LightEmission = 1
			trl.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)})
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
			game:GetService("Debris"):AddItem(lb, 10)
			local hitted = false
			coroutine.resume(coroutine.create(function()
				swait(25)
				lb.CanCollide = true
				lb.Touched:connect(function(hit)
					if hitted == false and hit.Parent ~= char then
						local hbax = CreateParta(lb,1,1,"SmoothPlastic",BrickColor.random())
						hbax.CFrame = lb.CFrame
						hbax.Anchored = true
						sphere2(2,"Add",hbax.CFrame,vt(0,0,0),0.2,0.2,0.2,bc("Neon orange"),Color3.new(1,0.3,0))
						sphere2(4,"Add",hbax.CFrame,vt(0,0,0),0.2,0.2,0.2,bc("Neon orange"),Color3.new(1,0.3,0))
						sphere2(6,"Add",hbax.CFrame,vt(0,0,0),0.2,0.2,0.2,bc("Neon orange"),Color3.new(1,0.3,0))
						CFuncs["Sound"].Create("rbxassetid://782353443", hbax, 1, 1)
						CFuncs["Sound"].Create("rbxassetid://2295409845", hbax, 0.75, 1.25)
						for i = 1, math.random(4,9) do
							trailMK(math.random(1,2),math.random(50,1000)/1000,"Add",hbax.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,-0.0025,Color3.new(1,0.3,0),0)
						end
						coroutine.resume(coroutine.create(function()
							for i = 0, math.random(2,4) do
								local deb2 = Instance.new("Part", char)
								deb2.CanCollide = false
								deb2.FormFactor = 3
								deb2.Name = "Ring"
								deb2.Material = lb.Material
								deb2.Color = lb.Color
								deb2.Size = vt(math.random(1,2),math.random(1,2),math.random(1,2))
								deb2.Transparency = 0
								deb2.TopSurface = 0
								deb2.BottomSurface = 0
								deb2.CFrame = lb.CFrame
								deb2.Velocity = vt(math.random(-20,20),math.random(20,40),math.random(-20,20))
								deb2.RotVelocity = vt(math.random(-5,5),math.random(-5,5),math.random(-5,5))
								local at1 = Instance.new('Attachment',deb2)
								at1.Position = vt(0,0.5,0)
								local at2 = Instance.new('Attachment',deb2)
								at2.Position = vt(0,-0.5,0)
								local tl = Instance.new('Trail',deb2)
								tl.Attachment0 = at1
								tl.Attachment1 = at2
								tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
								tl.Color = ColorSequence.new(Color3.new(1,0.3,0))
								tl.LightEmission = 1
								tl.Lifetime = 0.5
								game:GetService("Debris"):AddItem(deb2,5)
								coroutine.resume(coroutine.create(function()
									wait(0.5)
									deb2.CanCollide = true
								end))
							end
						end))
						MagniDamage(hbax,16,10,40,0,"Normal",153092227)
						hitted = true
						lb.Transparency = 1
						lb.Anchored = true
						trl.Disabled = false
						wait(1)
						lb:Destroy()
					end
				end)
			end))
		end
		for i = 0, 4 ,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.3,-0.2)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(5),math.rad(-10)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,-0.1)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(5),math.rad(20)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-1.4,-1.8)*angles(math.rad(60),math.rad(0),math.rad(0)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(-0),math.rad(-0)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,-0.4)*angles(math.rad(60),math.rad(0),math.rad(-10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,-0.4)*angles(math.rad(60),math.rad(0),math.rad(10)),.6)
		end
		hum.WalkSpeed = 16
		attack = false
	end
	----
	function visibgaunt(a)
		for i,v in pairs(a:GetDescendants()) do
			if v:IsA("Part") or v:IsA("UnionOperation") then
				v.Transparency = 0
			end
		end
	end
	function invisibgaunt(a)
		for i,v in pairs(a:GetDescendants()) do
			if v:IsA("Part") or v:IsA("UnionOperation") then
				v.Transparency = 1
			end
		end
	end
	-------------------------------------
	function LUL()
		hum.WalkSpeed = 0
		attack = true
		orgcl = BrickColor.new("Really red")
		local bp = Instance.new("BodyPosition",tors)
		bp.Position = root.Position + Vector3.new(0,35,0)
		bp.MaxForce = Vector3.new(50000,100000,50000)
		bp.P = 50000
		local siz = 0
		CFuncs["Sound"].Create("rbxassetid://1895411681", tors, 2,1)
		for i = 0, 29 do
			sphereMK(math.random(1,2),math.random(5,15)/15,"Add",root.CFrame*CFrame.new(math.random(-10,10),-3,math.random(-10,10))*CFrame.Angles(math.rad(90),0,0),0.5,0.5,math.random(1,2),0,Color3.fromRGB(255,0,0),0,1)
		end
		for i = 0, 3 ,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.3,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1,0.75,-0.4)*angles(math.rad(160),math.rad(0),math.rad(-30)),.2)
			LW.C0=clerp(LW.C0,cf(-1,0.75,-0.4)*angles(math.rad(160),math.rad(0),math.rad(30)),.2)
		end
		CFuncs["Sound"].Create("rbxassetid://2374026404", tors, 1.5,0.8)
		for i = 0, 5 ,0.1 do
			swait()
			siz = siz + 0.005
			localshakes(siz/2,0.2)
			sphere2(2.5,"Add",tors.CFrame,vt(0,0,0),siz,siz,siz,bc("Really red"),Color3.new(1,0,0))
			trailMK(math.random(2,5),-0.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))*CFrame.new(0,0,-25),2,-0.0025,Color3.fromRGB(255,0,0),0)
			RH.C0=clerp(RH.C0,cf(1,-0.3,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1,0.75,-0.4)*angles(math.rad(160),math.rad(0),math.rad(-30)),.2)
			LW.C0=clerp(LW.C0,cf(-1,0.75,-0.4)*angles(math.rad(160),math.rad(0),math.rad(30)),.2)
		end
		localshakes(2,2)
		invisibgaunt(gntl.StrobeGauntlet)
		invisibgaunt(gntl2.StrobeGauntlet)
		visibgaunt(gntl.TemperGauntlet)
		visibgaunt(gntl2.TemperGauntlet)
		invisibgaunt(gntl.AbyssGauntlet)
		invisibgaunt(gntl2.AbyssGauntlet)
		invisibgaunt(gntl.IgneusGauntlet)
		invisibgaunt(gntl2.IgneusGauntlet)
		for a,part in pairs(gatlR:GetChildren()) do
			if part:IsA("Part") or part:IsA("UnionOperation") then
				part.Color = orgcl.Color
			end
		end
		for i,v in pairs(tg:GetDescendants()) do
			if v:IsA("Frame") then
				v.BackgroundColor3 = orgcl.Color
			elseif v:IsA("TextLabel") then
				v.TextColor3 = orgcl.Color
			end
		end
		blink.Color = ColorSequence.new(orgcl.Color)
		fir.Color = ColorSequence.new(orgcl.Color)
		sphere2(2.5,"Add",tors.CFrame,vt(1,1,1),0.3,0.3,0.3,bc("Really red"),Color3.new(1,0,0))
		sphere2(2.5,"Add",tors.CFrame,vt(1,1,1),0.6,0.6,0.6,bc("Really red"),Color3.new(1,0,0))
		sphere2(5,"Add",tors.CFrame,vt(1,1,1),0.3,0.3,0.3,bc("Really red"),Color3.new(1,0,0))
		sphere2(5,"Add",tors.CFrame,vt(1,1,1),0.6,0.6,0.6,bc("Really red"),Color3.new(1,0,0))
		CFuncs["Sound"].Create("rbxassetid://2295409845", tors, 3,0.9)
		CFuncs["Sound"].Create("rbxassetid://3041462242", tors, 2,1)
		CFuncs["Sound"].Create("rbxassetid://3190948728", tors, 4,0.5)
		ModeType = "R"
		newTheme("rbxassetid://1751171913",0,1.01,0.5)
		for i = 0, 49 do
			sphereMK(math.random(1,2),math.random(5,25)/15,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.85,0.85,3,0,Color3.fromRGB(255,0,0),0,1)
		end
		for i = 0, 9 ,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-20),math.rad(0),math.rad(-35)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-20),math.rad(0),math.rad(35)),.5)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-40),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-25),math.rad(0),math.rad(0)),.5)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-40),math.rad(0),math.rad(60)),.5)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-40),math.rad(0),math.rad(-60)),.5)
		end
		bp:Destroy()
		attack = false
		storehumanoidWS = 16
		hum.WalkSpeed = 16
	end
	-------------------------------------

	function h()
		attack = true
		local dist = 1000
		hum.WalkSpeed = 0
		hum.JumpPower = 0
	--[[CFuncs["Sound"].Create("rbxassetid://3028505295", char, 0.5,1.3)
	CFuncs["LongSound"].Create("rbxassetid://1177785010", char, 1, 1)
	sphere2(6,"Add",root.CFrame,vt(20,800000,20),-0.1,0.25,-0.1,MAINRUINCOLOR)
	sphere2(8,"Add",root.CFrame,vt(35,800000,35),-0.25,0.25,-0.25,MAINRUINCOLOR)]]--
		for i = 0, 7, 0.1 do
			swait()
			dist = dist - 12.5
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,dist)*angles(math.rad(-20),math.rad(0),math.rad(0)),1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(60),math.rad(0),math.rad(80)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(60),math.rad(0),math.rad(-80)),.3)
		end
		CFuncs["Sound"].Create("rbxassetid://824687369", root, 8, 1)
		CFuncs["Sound"].Create("rbxassetid://438666141", root, 6, 0.75)
		sphere2(2,"Add",root.CFrame,vt(8,8,8),2,2,2,bc("White"),Color3.new(1,1,1))
		sphere2(3,"Add",root.CFrame,vt(8,8,8),2,2,2,bc("White"),Color3.new(1,1,1))
		sphere2(4,"Add",root.CFrame,vt(8,8,8),2,2,2,bc("White"),Color3.new(1,1,1))
		sphere2(2,"Add",root.CFrame,vt(8,8,8),4,4,4,bc("White"),Color3.new(1,1,1))
		sphere2(3,"Add",root.CFrame,vt(8,8,8),4,4,4,bc("White"),Color3.new(1,1,1))
		sphere2(4,"Add",root.CFrame,vt(8,8,8),4,4,4,bc("White"),Color3.new(1,1,1))
		for i = 0, 49 do
			slash(math.random(10,20)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-2.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.001,0.05),math.random(5,1500)/250,BrickColor.new("White"))
			slash(math.random(10,20)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-2.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.001,0.05),math.random(5,150)/250,BrickColor.new("White"))
		end
		local hf,pf=rayCast(root.Position,(CFrame.new(root.Position,root.Position - vt(0,1,0))).lookVector,4,char)
		if hf ~= nil then
			local rotation = 0
			for i = 0, 35 do
				rotation = rotation + 10
				local deb = Instance.new("Part", char)
				deb.Anchored = true
				deb.CanCollide = false
				deb.FormFactor = 3
				deb.Name = "Ring"
				deb.Material = hf.Material
				deb.Color = hf.Color
				deb.Size = vt(math.random(50,60)/4,math.random(25,35)/4,math.random(50,60)/4)
				deb.Transparency = 0
				deb.TopSurface = 0
				deb.BottomSurface = 0
				deb.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-5,150/4)*CFrame.Angles(math.rad(math.random(20,30)),math.rad(0),math.rad(0))*CFrame.new(0,math.random(-5,5),0)
				local debb = Instance.new("Part", char)
				debb.Anchored = true
				debb.CanCollide = false
				debb.FormFactor = 3
				debb.Name = "Ring"
				debb.Material = hf.Material
				debb.Color = hf.Color
				debb.Size = vt(math.random(40,50)/4,math.random(19,25)/4,math.random(40,50)/4)
				debb.Transparency = 0
				debb.TopSurface = 0
				debb.BottomSurface = 0
				debb.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-7,175/4)*CFrame.Angles(math.rad(math.random(10,20)),math.rad(0),math.rad(0))*CFrame.new(0,math.random(-5,5),0)
				local debc = Instance.new("Part", char)
				debc.Anchored = true
				debc.CanCollide = false
				debc.FormFactor = 3
				debc.Name = "Ring"
				debc.Material = hf.Material
				debc.Color = hf.Color
				debc.Size = vt(math.random(35,40)/4,math.random(14,18)/4,math.random(35,40)/4)
				debc.Transparency = 0
				debc.TopSurface = 0
				debc.BottomSurface = 0
				debc.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-7,200/4)*CFrame.Angles(math.rad(math.random(5,10)),math.rad(0),math.rad(0))*CFrame.new(0,math.random(-5,5),0)
				local deb2 = Instance.new("Part", char)
				deb2.CanCollide = false
				deb2.FormFactor = 3
				deb2.Name = "Ring"
				deb2.Material = hf.Material
				deb2.Color = hf.Color
				deb2.Size = vt(math.random(50,60)/4,math.random(50,60)/4,math.random(50,60)/4)
				deb2.Transparency = 0
				deb2.TopSurface = 0
				deb2.BottomSurface = 0
				deb2.CFrame = root.CFrame
				deb2.Velocity = vt(math.random(-300,300)/4,math.random(250,500)/2,math.random(-300,300)/4)
				deb2.RotVelocity = vt(math.random(-5,5),math.random(-5,5),math.random(-5,5))
				local at1 = Instance.new('Attachment',deb2)
				at1.Position = vt(0,20/4,0)
				local at2 = Instance.new('Attachment',deb2)
				at2.Position = vt(0,-20/4,0)
				local tl = Instance.new('Trail',deb2)
				tl.Attachment0 = at1
				tl.Attachment1 = at2
				tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
				tl.Color = ColorSequence.new(Color3.new(1,1,1))
				tl.LightEmission = 1
				tl.Lifetime = 1
				game:GetService("Debris"):AddItem(deb,30)
				game:GetService("Debris"):AddItem(debb,30)
				game:GetService("Debris"):AddItem(debc,30)
				game:GetService("Debris"):AddItem(deb2,30)
				coroutine.resume(coroutine.create(function()
					wait(15)
					for i = 0, 24 do
						swait()
						deb.Transparency = deb.Transparency + 0.04
						debb.Transparency = debb.Transparency + 0.04
						debc.Transparency = debc.Transparency + 0.04
					end
					deb:Destroy()
					debb:Destroy()
					debc:Destroy()
				end))
			end
		end
		for i = 0, 15, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(40)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,-0.125)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.2,-0.75)*angles(math.rad(45),math.rad(0),math.rad(0)),.9)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(0)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(20),math.rad(0),math.rad(10)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(20),math.rad(0),math.rad(-10)),.3)
		end
		attack = false
		hum.WalkSpeed = 16
		hum.JumpPower = 50
	end
	--h()
	-------------------------------------

	local attacktype = 1
	Humanoid.Animator.Parent = nil
	mouse = game.Players.LocalPlayer:GetMouse()
	mouse.Button1Down:connect(function()
		if holdingRocc == false then
			if attack == false and attacktype == 1 then
				attacktype = 2
				aone()
			elseif attack == false and attacktype == 2 then
				attacktype = 3
				atwo()
			elseif attack == false and attacktype == 3 then
				attacktype = 1
				athree()
			elseif attack == false and attacktype == 4 then
				attacktype = 5
				--afour()
			elseif attack == false and attacktype == 5 then
				attacktype = 1
				--afive()
			end
		elseif holdingRocc == true then
			if attack == false then
				throwRocc()
			end
		end
	end)
	mouse.KeyDown:connect(function(k)
		if k == "q" and attack == false and ModeType ~= "N" and holdingRocc == false then
			ModeType = "N"
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			visibgaunt(gntl.StrobeGauntlet)
			visibgaunt(gntl2.StrobeGauntlet)
			invisibgaunt(gntl.TemperGauntlet)
			invisibgaunt(gntl2.TemperGauntlet)
			invisibgaunt(gntl.AbyssGauntlet)
			invisibgaunt(gntl2.AbyssGauntlet)
			invisibgaunt(gntl.IgneusGauntlet)
			invisibgaunt(gntl2.IgneusGauntlet)
			newTheme("rbxassetid://1882656833",0,1.01,0.5) -- 2485070323, Original: 2026469207
			orgcl = BrickColor.new("White")
			for a,part in pairs(gatlR:GetChildren()) do
				if part:IsA("Part") or part:IsA("UnionOperation") then
					part.Color = orgcl.Color
				end
			end
			for i,v in pairs(tg:GetDescendants()) do
				if v:IsA("Frame") then
					v.BackgroundColor3 = orgcl.Color
				elseif v:IsA("TextLabel") then
					v.TextColor3 = orgcl.Color
				end
			end
			blink.Color = ColorSequence.new(orgcl.Color)
			fir.Color = ColorSequence.new(orgcl.Color)
		end
		if k == "e" and attack == false and ModeType ~= "A" and holdingRocc == false then
			ModeType = "A"
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			newTheme("rbxassetid://2606277947",0,1.01,0.5)
			orgcl = BrickColor.new("Royal purple")
			invisibgaunt(gntl.StrobeGauntlet)
			invisibgaunt(gntl2.StrobeGauntlet)
			invisibgaunt(gntl.TemperGauntlet)
			invisibgaunt(gntl2.TemperGauntlet)
			invisibgaunt(gntl.IgneusGauntlet)
			invisibgaunt(gntl2.IgneusGauntlet)
			visibgaunt(gntl.AbyssGauntlet)
			visibgaunt(gntl2.AbyssGauntlet)
			blink.Color = ColorSequence.new(orgcl.Color)
			fir.Color = ColorSequence.new(orgcl.Color)
			for a,part in pairs(gatlR:GetChildren()) do
				if part:IsA("Part") or part:IsA("UnionOperation") then
					part.Color = orgcl.Color
				end
			end
			for i,v in pairs(tg:GetDescendants()) do
				if v:IsA("Frame") then
					v.BackgroundColor3 = orgcl.Color
				elseif v:IsA("TextLabel") then
					v.TextColor3 = orgcl.Color
				end
			end
		end
		if k == "r" and attack == false and ModeType ~= "R" and holdingRocc == false then
			LUL()
		end
		if k == "t" and attack == false and ModeType ~= "S" and holdingRocc == false then
			ModeType = "S"
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			newTheme("rbxassetid://1492179112",0,1.01,0.5)
			orgcl = BrickColor.new("Neon orange")
			invisibgaunt(gntl.StrobeGauntlet)
			invisibgaunt(gntl2.StrobeGauntlet)
			invisibgaunt(gntl.TemperGauntlet)
			invisibgaunt(gntl2.TemperGauntlet)
			visibgaunt(gntl.IgneusGauntlet)
			visibgaunt(gntl2.IgneusGauntlet)
			invisibgaunt(gntl.AbyssGauntlet)
			invisibgaunt(gntl2.AbyssGauntlet)
			blink.Color = ColorSequence.new(orgcl.Color)
			fir.Color = ColorSequence.new(orgcl.Color)
			for a,part in pairs(gatlR:GetChildren()) do
				if part:IsA("Part") or part:IsA("UnionOperation") then
					part.Color = orgcl.Color
				end
			end
			for i,v in pairs(tg:GetDescendants()) do
				if v:IsA("Frame") then
					v.BackgroundColor3 = orgcl.Color
				elseif v:IsA("TextLabel") then
					v.TextColor3 = orgcl.Color
				end
			end
		end
		if k == "l" and mutedtog == false then
			mutedtog = true
			kan.Volume = 0
		elseif k == "l" and mutedtog == true then
			mutedtog = false
			kan.Volume = 1.25
		end
		if k == "p" and toggleTag == false then
			toggleTag = true
			tg.Enabled = true
		elseif k == "p" and toggleTag == true then
			toggleTag = false
			tg.Enabled = false
		end
		if holdingRocc == false then
			if k == "z" and attack == false then
				rocc()
			end
			if k == "x" and attack == false then
				if ModeType == "S" then
					VErupt()
				end
			end
			if k == "c" and attack == false and holden == false then
				holden = true
				hm()
			end
			if k == "v" and attack == false then
				bigjoke()
			end
			if k == "b" and attack == false then
				--uberult()
			end
		end
--[[if k == "m" and attack == false and OVERPOWER == false and plr.UserId == 98888707 then ---- dont customize this or anything else
OVERPOWER = true
elseif k == "m" and attack == false and OVERPOWER == true and plr.UserId == 98888707 then
OVERPOWER = false
end]]--
	end)
	mouse.KeyUp:connect(function(k)
		if k == "c" and attack == true and holden == true then
			holden = false
		end
	end)


	local rotationa = 0
	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeType == "A" then
				slash(math.random(6,8),1,true,"Round","Add","Out",larm.CFrame*CFrame.new(0,-0.8 + 0.1 * math.cos(sine / 125),0)*CFrame.Angles(math.rad(math.random(-3,3)),math.rad(math.random(-360,360)),math.rad(math.random(-3,3))),vt(0.0075 - 0.0025 * math.cos(sine / 125),0.0001,0.0075 - 0.0025 * math.cos(sine / 125)),math.random(1,2)/250,BrickColor.new("Royal purple"))
				slash(math.random(6,8),1,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-0.8 + 0.1 * math.cos(sine / 125),0)*CFrame.Angles(math.rad(math.random(-3,3)),math.rad(math.random(-360,360)),math.rad(math.random(-3,3))),vt(0.0075 - 0.0025 * math.cos(sine / 125),0.0001,0.0075 - 0.0025 * math.cos(sine / 125)),math.random(1,2)/250,BrickColor.new("Royal purple"))
				slash(math.random(6,8),1,true,"Round","Add","Out",larm.CFrame*CFrame.new(0,-0.8 - 0.1 * math.cos(sine / 125),0)*CFrame.Angles(math.rad(math.random(-3,3)),math.rad(math.random(-360,360)),math.rad(math.random(-3,3))),vt(0.0075 + 0.0025 * math.cos(sine / 125),0.0001,0.0075 + 0.0025 * math.cos(sine / 125)),math.random(1,2)/250,BrickColor.new("Royal purple"))
				slash(math.random(6,8),1,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-0.8 - 0.1 * math.cos(sine / 125),0)*CFrame.Angles(math.rad(math.random(-3,3)),math.rad(math.random(-360,360)),math.rad(math.random(-3,3))),vt(0.0075 + 0.0025 * math.cos(sine / 125),0.0001,0.0075 + 0.0025 * math.cos(sine / 125)),math.random(1,2)/250,BrickColor.new("Royal purple"))
			elseif ModeType == "R" then
				rotationa = rotationa + 10
				slash(math.random(5,8),2,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-2.9,0)*CFrame.Angles(math.rad(math.random(-3,3)),math.rad(math.random(-360,360)),math.rad(math.random(-3,3))),vt(0.01,0.0001,0.01),math.random(20,25)/250,BrickColor.new("Really red"))
				trailMK(math.random(4,6),math.random(1,500)/1000,"Add",root.CFrame*CFrame.Angles(0,math.rad(0+rotationa),0)*CFrame.new(math.random(-15,15),-3,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-6,6)),math.rad(math.random(-6,6)),math.rad(math.random(-6,6))),1,-0.0025,Color3.fromRGB(255,0,0),0)
			elseif ModeType == "S" then
				sphereMKn(math.random(4,8),math.random(2,8)/100,"Add",rarm.CFrame*CFrame.new(math.random(-6,6)/10,-0.5 + math.random(-10,10)/10,math.random(-6,6)/10)*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),1,1,1,-0.01,Color3.fromRGB(255,100,0),0,1)
				sphereMKn(math.random(4,8),math.random(2,8)/100,"Add",larm.CFrame*CFrame.new(math.random(-6,6)/10,-0.5 + math.random(-10,10)/10,math.random(-6,6)/10)*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),1,1,1,-0.01,Color3.fromRGB(255,100,0),0,1)
				slash(math.random(5,8),2,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-2.9,0)*CFrame.Angles(math.rad(math.random(-3,3)),math.rad(math.random(-360,360)),math.rad(math.random(-3,3))),vt(0.01,0.0001,0.01),math.random(10,15)/250,BrickColor.new("Neon orange"))
			end
		end
	end))
	Instance.new("ForceField",char).Visible = false
	idleanim=.4
	while true do
		if mutedtog == false then
			kan.Volume = currentVol
		elseif mutedtog == true then
			kan.Volume = 0
		end
		CameraManager()
		swait()
		sine = sine + change
		local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
		local velderp=RootPart.Velocity.y
		hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
		if equipped==true or equipped==false then
			if attack==false then
				idle=idle+1
			else
				idle=0
			end
			if idle>=500 then
				if attack==false then
					--Sheath()
				end
			end
			if RootPart.Velocity.y > 1 and hitfloor==nil then 
				Anim="Jump"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
				end
			elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
				Anim="Fall"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(10),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(55)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-55)),.1)
				end
			elseif torvel<1 and hitfloor~=nil then
				Anim="Idle"
				if attack==false then
					if ModeType == "N" then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10)),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-10),math.rad(20 - 1 * math.cos(sine / 56)),math.rad(-1)),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01,0 + 0.1 * math.cos(sine / 20))*angles(math.rad(1),math.rad(0),math.rad(-40)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 5 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 58)),math.rad(40)),.1)
						if holdingRocc == false then
							RW.C0=clerp(RW.C0,cf(1.5,-0.1 + 0.025 * math.cos(sine / 20),0)*angles(math.rad(140 + 3 * math.cos(sine / 20)),math.rad(2 - 1 * math.cos(sine / 58)),math.rad(4 + 3 * math.cos(sine / 45))),.1)
						elseif holdingRocc == true then
							RW.C0=clerp(RW.C0,cf(1.5,0.75 + 0.025 * math.cos(sine / 20),0)*angles(math.rad(160 + 3 * math.cos(sine / 20)),math.rad(2 - 1 * math.cos(sine / 58)),math.rad(4 + 3 * math.cos(sine / 45))),.1)
						end
						LW.C0=clerp(LW.C0,cf(-1.5,0.15 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(120 + 3 * math.cos(sine / 20)),math.rad(3 - 1 * math.cos(sine / 59)),math.rad(-21 - 3 * math.cos(sine / 45))),.1)
					elseif ModeType == "A" then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(5),math.rad(-10)),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(50),math.rad(-1)),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 20))*angles(math.rad(1),math.rad(0),math.rad(-50)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2 * math.cos(sine / 37)),math.rad(0),math.rad(50)),.1)
						if holdingRocc == false then
							RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),-0.1)*angles(math.rad(70 + 1 * math.cos(sine / 72)),math.rad(2 - 1 * math.cos(sine / 58)),math.rad(-10 + 1 * math.cos(sine / 45))),.1)
						elseif holdingRocc == true then
							RW.C0=clerp(RW.C0,cf(1.5,0.75 + 0.025 * math.cos(sine / 20),0)*angles(math.rad(160 + 3 * math.cos(sine / 20)),math.rad(2 - 1 * math.cos(sine / 58)),math.rad(4 + 3 * math.cos(sine / 45))),.1)
						end
						LW.C0=clerp(LW.C0,cf(-1.5,0.25 + 0.025 * math.cos(sine / 45),-0.3)*angles(math.rad(120 - 1 * math.cos(sine / 66)),math.rad(1 - 1 * math.cos(sine / 59)),math.rad(-40 - 1 * math.cos(sine / 45))),.1)
					elseif ModeType == "R" then
						local rtwi = math.random(1,30)
						if rtwi == 1 then
							if holdingRocc == false then
								RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.075 * math.cos(sine / 20),0)*angles(math.rad(0 + math.random(-5,5)),math.rad(2 + math.random(-5,5)),math.rad(15 + math.random(-5,5))),1)
							end
							LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.075 * math.cos(sine / 20),0)*angles(math.rad(0 + math.random(-5,5)),math.rad(2 + math.random(-5,5)),math.rad(-15 + math.random(-5,5))),1)
						end
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0)),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0)),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 20))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20 - 3 * math.cos(sine / 0.05)),math.rad(0 - 3 * math.cos(sine / 0.06)),math.rad(0 + 8 * math.cos(sine / 0.05))),.1)
						if holdingRocc == false then
							RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.075 * math.cos(sine / 20),0)*angles(math.rad(0 + 5 * math.cos(sine / 50)),math.rad(2 - 3 * math.cos(sine / 52)),math.rad(15 + 5 * math.cos(sine / 20))),.1)
						elseif holdingRocc == true then
							RW.C0=clerp(RW.C0,cf(1.5,0.75 + 0.025 * math.cos(sine / 20),0)*angles(math.rad(160 + 3 * math.cos(sine / 20)),math.rad(2 - 1 * math.cos(sine / 58)),math.rad(4 + 3 * math.cos(sine / 45))),.1)
						end
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.075 * math.cos(sine / 20),0)*angles(math.rad(0 + 5 * math.cos(sine / 50)),math.rad(2 - 3 * math.cos(sine / 52)),math.rad(-15 - 5 * math.cos(sine / 20))),.1)
					elseif ModeType == "S" then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-40),math.rad(1)),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(10),math.rad(5)),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 20))*angles(math.rad(1),math.rad(0),math.rad(50)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0),math.rad(-50)),.1)
						if holdingRocc == false then
							RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(10 + 1 * math.cos(sine / 72)),math.rad(15 - 1 * math.cos(sine / 58)),math.rad(30 + 1 * math.cos(sine / 45))),.1)
						elseif holdingRocc == true then
							RW.C0=clerp(RW.C0,cf(1.5,0.75 + 0.025 * math.cos(sine / 20),0)*angles(math.rad(160 + 3 * math.cos(sine / 20)),math.rad(2 - 1 * math.cos(sine / 58)),math.rad(4 + 3 * math.cos(sine / 45))),.1)
						end
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(10 - 1 * math.cos(sine / 66)),math.rad(20 - 1 * math.cos(sine / 59)),math.rad(-10 - 1 * math.cos(sine / 45))),.1)
					end
				end
			elseif torvel>2 and torvel<22 and hitfloor~=nil then
				Anim="Walk"
				if attack==false then
					if ModeType == "N" then
						RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 6)),math.rad(0 + 70 * math.cos(sine / 6))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 6)),math.rad(0 + 70 * math.cos(sine / 6))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.15,-0.05 - 0.05 * math.cos(sine / 3))*angles(math.rad(10 + 3 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 6))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 5 * math.cos(sine / 6))),.1)
						if holdingRocc == false then
							RW.C0=clerp(RW.C0,cf(1.5,0 + 0.025 * math.cos(sine / 20),-0.2)*angles(math.rad(135 + 3 * math.cos(sine / 20)),math.rad(8 - 1 * math.cos(sine / 58)),math.rad(-10 + 1 * math.cos(sine / 45))),.1)
						elseif holdingRocc == true then
							RW.C0=clerp(RW.C0,cf(1.5,0.75 + 0.025 * math.cos(sine / 20),0)*angles(math.rad(160 + 3 * math.cos(sine / 20)),math.rad(2 - 1 * math.cos(sine / 58)),math.rad(4 + 3 * math.cos(sine / 45))),.1)
						end
						LW.C0=clerp(LW.C0,cf(-1.5,0 + 0.025 * math.cos(sine / 45),-0.2)*angles(math.rad(135 + 3 * math.cos(sine / 20)),math.rad(-8 - 1 * math.cos(sine / 59)),math.rad(10 - 1 * math.cos(sine / 45))),.1)
					elseif ModeType ~= "N" then
						RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 6)),math.rad(0 + 55 * math.cos(sine / 6))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 6)),math.rad(0 + 55 * math.cos(sine / 6))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 - 0.05 * math.cos(sine / 3))*angles(math.rad(5 + 3 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 5 * math.cos(sine / 6))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 5 * math.cos(sine / 6))),.1)
						if holdingRocc == false then
							RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 6))*angles(math.rad(0 - 60 * math.cos(sine / 6)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 3))),.1)
						elseif holdingRocc == true then
							RW.C0=clerp(RW.C0,cf(1.5,0.75 + 0.025 * math.cos(sine / 20),0)*angles(math.rad(160 + 3 * math.cos(sine / 20)),math.rad(2 - 1 * math.cos(sine / 58)),math.rad(4 + 3 * math.cos(sine / 45))),.1)
						end
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 6))*angles(math.rad(0 + 60 * math.cos(sine / 6)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 3))),.1)
					end
				end
			elseif torvel>=22 and hitfloor~=nil then
				Anim="Run"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 95 * math.cos(sine / 6))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 95 * math.cos(sine / 6))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sine / 3))*angles(math.rad(25 - 4 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 1 * math.cos(sine / 6))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-6 + 2 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 1 * math.cos(sine / 6))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0.3)*angles(math.rad(-50 + 10 * math.cos(sine / 3)),math.rad(-10),math.rad(7 + 5 * math.cos(sine / 6))),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.3)*angles(math.rad(-50 + 10 * math.cos(sine / 3)),math.rad(10),math.rad(-7 - 5 * math.cos(sine / 6))),.1)
				end
			end
		end
	end

end)

Button_5.MouseButton1Down:Connect(function()
	local script = game:GetObjects("rbxassetid://5981366588")[1]

	print("Players killing players for no reason..")

--[[
	Kickisher X (10)
	
	Date of creation: 09/21/2019
	
	This is the END of all kickishers.
	
	Made by CodedTheForgotten
	
	Song: Change The Formality
	
	Enjoy, you skiddy mc skid skid you..
]]

	wait(0.2)
	local msgs = {"You are the weakest player I've ever met.", "I have got you now.", "You'll die as your dreams fade into nothingness.", "You'll learn to regret what you did in time."}
	local FXFolder = script.Effects
	--Okay, let's start with the simple stuff, variables!
	local banned = {} --Players who are banned.
	Player = game:GetService("Players").LocalPlayer --The player
	PlayerGui = Player.PlayerGui --Player's GUI
	Cam = workspace.CurrentCamera --workspace camera
	Backpack = Player.Backpack --Player's backpack
	Character = Player.Character["Dummy"] --the player's character.
	Humanoid = Character.Humanoid --the humanoid
	Mouse = Player:GetMouse()-- player mouse
	RootPart = Character["HumanoidRootPart"]
	Torso = Character["Torso"]
	Head = Character["Head"]
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	local TIME = 0
	local sick = Instance.new("Sound",Torso)

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor
	SIZE = 1

	--//=================================\\
	--|| 	      USEFUL VALUES
	--\\=================================//

	Animation_Speed = 3
	local FORCERESET = false
	Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
	local Speed = 16
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local DAMAGEMULTIPLIER = 1
	local ANIM = "Idle"
	local ATTACK = false
	local EQUIPPED = false
	local HOLD = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local KEYHOLD = false
	local CHANGE = 2 / Animation_Speed
	local WALKINGANIM = false
	local VALUE1 = false
	local VALUE2 = false
	local ROBLOXIDLEANIMATION = IT("Animation")
	ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
	ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
	--ROBLOXIDLEANIMATION.Parent = Humanoid
	local WEAPONGUI = IT("ScreenGui", PlayerGui)
	WEAPONGUI.Name = "BanishV3Gui"
	local Weapon = IT("Model")
	Weapon.Name = "Adds"
	local Effects = IT("Folder", Weapon)
	Effects.Name = "Effects"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character:FindFirstChild("Animate")
	local UNANCHOR = true
	local TOBANISH = {}
	script.Parent = PlayerGui


	--//=================================\\
	--\\=================================//
	ff = Instance.new("ForceField",Character)
	ff.Visible = false
	Humanoid.Name = "Humanoid"
	Humanoid.MaxHealth = 1.0E298
	Humanoid.Health = 1.0E298
	game:GetService("RunService"):BindToRenderStep("Bbae", 0, function()
		if Humanoid.Health > 0.1 and Humanoid.Health < 1.0E298 then
			Humanoid.MaxHealth = 1.0E298
			Humanoid.Health = 1.0E298
		end
	end)
	local naeeym = IT("BillboardGui",Character)
	naeeym.AlwaysOnTop = true
	naeeym.Size = UDim2.new(5,35,2,15)
	naeeym.StudsOffset = Vector3.new(0,5,0)
	naeeym.MaxDistance = 75
	naeeym.Adornee = Character.Head
	naeeym.Name = "Name"
	local tecks = IT("TextLabel",naeeym)
	tecks.BackgroundTransparency = 1
	tecks.TextScaled = true
	tecks.BorderSizePixel = 0
	tecks.Text = ""
	tecks.Font = "Fantasy"
	tecks.TextSize = 30
	tecks.TextTransparency = 0.5
	tecks.TextStrokeTransparency = 0.5
	tecks.TextColor3 = C3(0,0,0)
	tecks.TextStrokeColor3 = C3(BRICKC"White".Color)
	tecks.Size = UDim2.new(1,0,0.5,0)
	tecks.Parent = naeeym
	local naeeym2 = IT("BillboardGui",Character)
	naeeym2.AlwaysOnTop = true
	naeeym2.Size = UDim2.new(7,35,3,15)
	naeeym2.StudsOffset = Vector3.new(0,5,0)
	naeeym2.MaxDistance = 75
	naeeym2.Adornee = Character.Head
	naeeym2.Name = "Name2"
	local tecks2 = IT("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = "Kickisher X"
	tecks2.Font = "Fantasy"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = C3(BRICKC"Dark indigo".Color)
	tecks2.TextStrokeColor3 = (BRICKC"Black".Color)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym

	--//=================================\\
	--|| SAZERENOS' ARTIFICIAL HEARTBEAT
	--\\=================================//

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	--//=================================\\
	--\\=================================//

	--//=================================\\
	--|| 	      SOME FUNCTIONS
	--\\=================================//

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then 
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	function newbosschatfunc(text,color1,color2,delay)
		for _,v in next, game:service'Players':players() do
			coroutine.wrap(function()
				if(FXFolder:FindFirstChild'BossChat' and v.Character)then
					local cha = FXFolder.BossChat:Clone()
					cha.Color1.Value=color1
					cha.Color2.Value=color2
					cha.Text.Value=text
					cha.Ghghghghgh.Value=delay
					cha.Mode.Value=1
					cha.ModeName.Value="Kickisher X"
					cha.Music.Value=sick
					cha.Parent=v.Character
					wait()
					cha.Disabled = false
					game:service'Debris':AddItem(cha,(delay/60)*4)
				end
			end)()
		end
	end

	function bosschatfunc(text,color,watval)
		newbosschatfunc(text,BrickColor.new("Institutional white").Color,color,watval)
	end
	bosschatfunc("Last version of Coded's Kickishers loaded.",BRICKC"Really red".Color,120)
	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
		local frame = IT("Frame")
		frame.BackgroundTransparency = TRANSPARENCY
		frame.BorderSizePixel = BORDERSIZEPIXEL
		frame.Position = POSITION
		frame.Size = SIZE
		frame.BackgroundColor3 = COLOR
		frame.BorderColor3 = BORDERCOLOR
		frame.Name = NAME
		frame.Parent = PARENT
		return frame
	end

	function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
		local label = IT("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UD2(1, 0, 1, 0)
		label.Position = UD2(0, 0, 0, 0)
		label.TextColor3 = TEXTCOLOR
		label.TextStrokeTransparency = STROKETRANSPARENCY
		label.TextTransparency = TRANSPARENCY
		label.FontSize = TEXTFONTSIZE
		label.Font = TEXTFONT
		label.BorderSizePixel = BORDERSIZEPIXEL
		label.TextScaled = false
		label.Text = TEXT
		label.Name = NAME
		label.Parent = PARENT
		return label
	end

	function NoOutlines(PART)
		PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
	end

	function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
		local NEWWELD = IT(TYPE)
		NEWWELD.Part0 = PART0
		NEWWELD.Part1 = PART1
		NEWWELD.C0 = C0
		NEWWELD.C1 = C1
		NEWWELD.Parent = PARENT
		return NEWWELD
	end

	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
	end

	--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	function WACKYEFFECT(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or VT(1,1,1))
		local ENDSIZE = (Table.Size2 or VT(0,0,0))
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local MOVEDIRECTION = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLOR = (Table.Color or C3(1,1,1))
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
			elseif TYPE == "Block" then
				MSH = IT("BlockMesh",EFFECT)
				MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
			end
			if MSH ~= nil then
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
				end
				local GROWTH = SIZE - ENDSIZE
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.X/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					SOUND.Stopped:Connect(function()
						EFFECT:remove()
					end)
				end
			else
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until SOUND.Playing == false
					EFFECT:remove()
				end
			end
		end))
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	Debris = game:GetService("Debris")

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end

	function turnto(position)
		RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
	end

	--//=================================\\
	--||	     WEAPON CREATION
	--\\=================================//

	local Particle = IT("ParticleEmitter",nil)
	Particle.Enabled = false
	Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
	Particle.LightEmission = 0.5
	Particle.Rate = 150
	Particle.ZOffset = 0.2
	Particle.Rotation = NumberRange.new(-180, 180)
	Particle.RotSpeed = NumberRange.new(-180, 180)
	Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
	Particle.Color = ColorSequence.new(C3(1,0,0),C3(0.4,0,0))

	--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
	function ParticleEmitter(Table)
		local PRTCL = Particle:Clone()
		local Speed = Table.Speed or 5
		local Drag = Table.Drag or 0
		local Size1 = Table.Size1 or 1
		local Size2 = Table.Size2 or 5
		local Lifetime1 = Table.Lifetime1 or 1
		local Lifetime2 = Table.Lifetime2 or 1.5
		local Parent = Table.Parent or Torso
		local Emit = Table.Emit or 100
		local Offset = Table.Offset or 360
		local Acel = Table.Acel or VT(0,0,0)
		local Enabled = Table.Enabled or false
		PRTCL.Parent = Parent
		PRTCL.Size = NumberSequence.new(Size1,Size2)
		PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
		PRTCL.Speed = NumberRange.new(Speed)
		PRTCL.VelocitySpread = Offset
		PRTCL.Drag = Drag
		PRTCL.Acceleration = Acel
		if Enabled == false then
			PRTCL:Emit(Emit)
			Debris:AddItem(PRTCL,Lifetime2)
		else
			PRTCL.Enabled = true
		end
		return PRTCL
	end

	local Handle = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.6,0.2),false)
	local RightArmGrasp = CreateWeldOrSnapOrMotor("Weld", Handle, RightArm, Handle, CF(0,-1, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0.21, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.3, 0.2) * ANGLES(RAD(0), RAD(180), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.3,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.4, 0) * ANGLES(RAD(0), RAD(0), RAD(180)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.3,0.3),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.5, 0.2) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.5,0.5),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.4,0.4,0.4),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	for i = 1, 8 do
		local Piece = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Eye", VT(0,0.35,0.41),false)
		CreateWeldOrSnapOrMotor("Weld", Handle, Part, Piece, CF(0, 0, 0) * ANGLES(RAD(0), RAD((360/8)*i), RAD(0)), CF(0, 0, 0))
	end
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Eye", VT(0.38,0.41,0.38),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.37,0.5,0.37),false)
	MakeForm(Part,"Ball")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.3) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.7,0.4),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.7, 0.5) * ANGLES(RAD(90), RAD(180), RAD(180)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.4,0.2),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.35,0.35,0.35),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.5),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.45),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1.1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.55, 0.2) * ANGLES(RAD(-135), RAD(0), RAD(0)), CF(0, -0.3, 0))
	local LASTPART = Handle
	for i = 1, 10 do
		if LASTPART == Handle then
			local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.1,0.2,0),false)
			LASTPART = Part
			CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.1, 0.2) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
		else
			local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.1,0.05,0),false)
			CreateWeldOrSnapOrMotor("Weld", Handle, LASTPART, Part, CF(0, 0.025, 0) * ANGLES(RAD(8), RAD(0), RAD(0)), CF(0, -0.025, 0))
			LASTPART = Part
		end
	end

	local hat = game:GetService("Players").LocalPlayer.Character["Type-49 Abomindation Back Accessory"]

	hat.Handle.AccessoryWeld:Destroy()

	local function align(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		if part0 == hat.Handle then
			attachment0.Position = Vector3.new(0.3, -0.1, -0.4) --Custom Positioning Values Here
			attachment0.Orientation = Vector3.new(50, -100, 160) --Custom Rotationing Values here
		end
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = true
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	hat.Handle.Size = Vector3.new(1,1,1)

	align(hat.Handle, Handle)

	local Barrel = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.15,2,0.15),false)
	MakeForm(Barrel,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Barrel, CF(0, -0.6, 1.8) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.25,1,0.25),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, -0.6, 0), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0,0.1,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, 0.945, 0.1) * ANGLES(RAD(180), RAD(0), RAD(0)), CF(0, 0, 0))
	local Hole = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Eye", VT(0.125,0,0.125),false)
	MakeForm(Hole,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Hole, CF(0, 0.98, 0), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0,0,0),false)
	local GEARWELD = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
	CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.8,0.8,1.5), VT(0,0,0.2))
	local Part = CreatePart(3, Weapon, "Metal", 0, 0.5, "Mid gray", "Eye", VT(0,0,0),false)
	local GEARWELD2 = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
	CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.9,0.9,0.3), VT(0,0,0.2))
	local BODY = {}
	for _, c in pairs(Character:GetDescendants()) do
		if c:IsA("BasePart") and c.Name ~= "Handle" then
			if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
				c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
			end
			table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency,c.Size,c.Name})
		elseif c:IsA("JointInstance") then
			table.insert(BODY,{c,c.Parent,nil,nil,nil,nil,nil})
		end
	end

	function refit()
		Character.Parent = workspace
		for e = 1, #BODY do
			if BODY[e] ~= nil then
				local STUFF = BODY[e]
				local PART = STUFF[1]
				local PARENT = STUFF[2]
				local MATERIAL = STUFF[3]
				local COLOR = STUFF[4]
				local TRANSPARENCY = STUFF[5]
				--local SIZE = STUFF[6]
				local NAME = STUFF[7]
				if PART.ClassName == "Part" and PART ~= RootPart then
					PART.Material = MATERIAL
					PART.Transparency = TRANSPARENCY
					PART.Name = NAME
				end
				if PART.Parent ~= PARENT then
					Humanoid:remove()
					PART.Parent = PARENT
					Humanoid = IT("Humanoid",Character)
				end
			end
		end
	end




	coroutine.resume(coroutine.create(function()
		while wait() do
			GEARWELD.C0 = GEARWELD.C0 * ANGLES(RAD(0), RAD(0), RAD(5))
			GEARWELD2.C0 = GEARWELD2.C0 * ANGLES(RAD(0), RAD(0), RAD(-5))
		end
	end))

	ParticleEmitter({Speed = 0.2, Drag = 0, Size1 = 0.1, Size2 = 0, Lifetime1 = 0.3, Lifetime2 = 0.5, Parent = Hole, Emit = 100, Offset = 360, Enabled = true, Acel = VT(0,5,0)})
	--ParticleEmitter({Speed = 0.5, Drag = 0, Size1 = 0.2, Size2 = 0, Lifetime1 = 0.3, Lifetime2 = 0.7, Parent = Dangle, Emit = 100, Offset = 360, Enabled = true, Acel = VT(0,5,0)})

	for _, c in pairs(Weapon:GetDescendants()) do
		if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
			c.Material = "Glass"
			c.Color = C3(0,0,0)
		elseif c.ClassName == "Part" and c.Name == "Eye" then
			c.Color = C3(1,0,0)
			c.Material = "Neon"
		end
	end

	Weapon.Parent = Character
	for _, c in pairs(Weapon:GetChildren()) do
		if c.ClassName == "Part" then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
	end

	local SKILLTEXTCOLOR = C3(1,0,0)
	local SKILLFONT = "Antique"
	local SKILLTEXTSIZE = 7


	Weapon.Parent = Character
	Humanoid.Parent = Character


	Humanoid.Died:connect(function()
		refit()
	end)

	local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.1, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
	local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.63, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
	local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.215, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
	local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.525, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
	local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")

	local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Banish Bullet", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 1")
	local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[X] Kickisher Shot", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 2")
	local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Ban Shot", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 3")
	local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Free", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 4")
	local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[B] Credits", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 5")

	function printbye(Name)
	end

	workspace.ChildAdded:connect(function(instance)
		for BANISH = 1, #TOBANISH do
			if TOBANISH[BANISH] ~= nil then
				if instance.Name == TOBANISH[BANISH] then
					coroutine.resume(coroutine.create(function()
						printbye(instance.Name)
						instance:ClearAllChildren()
						Debris:AddItem(instance,0.0005)
					end))
				end
			end
		end
	end)

	--//=================================\\
	--||			DAMAGING
	--\\=================================//
	function StatLabel(CFRAME, TEXT, COLOR)
		local STATPART = CreatePart(3, Effects, "SmoothPlastic", 0, 1, "Really black", "Effect", VT())
		STATPART.CFrame = CF(CFRAME.p,CFRAME.p+VT(MRANDOM(-5,5),MRANDOM(0,5),MRANDOM(-5,5)))
		local BODYGYRO = IT("BodyGyro", STATPART)
		game:GetService("Debris"):AddItem(STATPART ,5)
		local BILLBOARDGUI = Instance.new("BillboardGui", STATPART)
		BILLBOARDGUI.Adornee = STATPART
		BILLBOARDGUI.Size = UD2(2.5, 0, 2.5 ,0)
		BILLBOARDGUI.StudsOffset = VT(-2, 2, 0)
		BILLBOARDGUI.AlwaysOnTop = false
		local TEXTLABEL = Instance.new("TextLabel", BILLBOARDGUI)
		TEXTLABEL.BackgroundTransparency = 1
		TEXTLABEL.Size = UD2(2.5, 0, 2.5, 0)
		TEXTLABEL.Text = TEXT
		TEXTLABEL.Font = SKILLFONT
		TEXTLABEL.FontSize="Size42"
		TEXTLABEL.TextColor3 = COLOR
		TEXTLABEL.TextStrokeTransparency = 0
		TEXTLABEL.TextScaled = true
		TEXTLABEL.TextWrapped = true
		coroutine.resume(coroutine.create(function(THEPART, THEBODYPOSITION, THETEXTLABEL)
			for i = 1, 10 do
				Swait()
				STATPART.CFrame = STATPART.CFrame * CF(0,0,-0.2)
				TEXTLABEL.TextTransparency = TEXTLABEL.TextTransparency + (1/10)
				TEXTLABEL.TextStrokeTransparency = TEXTLABEL.TextTransparency
			end
			THEPART.Parent = nil
		end),STATPART, TEXTLABEL)
	end

	local cR=255
	local cG=0
	local cB=0
	local flg5=1 local omgidk=1
	local add=15
	game:GetService("RunService").Heartbeat:Connect(function()
		if omgidk>10000 then omgidk=0 end
		omgidk=omgidk+1
		if cR>=255 then flg5=1 end
		if cG>=255 then flg5=2 end
		if cB>=255 then flg5=3 end
		if flg5==1 then cR=cR-add cG=cG+add end
		if flg5==2 then cG=cG-add cB=cB+add end
		if flg5==3 then cB=cB-add cR=cR+add end
		color=Color3.fromRGB(cR,cG,cB)
		for _, c in pairs(Weapon:GetDescendants()) do
			if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
				c.Material = "Neon"
				c.Color = color
			elseif c.ClassName == "Part" and c.Name == "Eye" then
				c.Color = color
				c.Material = "Neon"
			end
		end
	end)
	local spine = 0
	local spind = 0
	local spinc=0
	local spinb = 0
	local spina = 0
	coroutine.resume(coroutine.create(function()
		while wait() do
			spinc=spinc+5
			spinb=spinb+2
			spinb=spinb+12
			spind=spinb+12
			spine=spinb+12
			WACKYEFFECT({Time = 12.5, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-2.9,0)*CFrame.Angles(RAD(0),RAD(spinc),RAD(0)), RotationX = 0, RotationY = 0--[[sick.PlaybackLoudness/50]], RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 12.5, EffectType = "Wave", Size = VT(10,1,10), Size2 = VT(10,1,10), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-2.9,0)*CFrame.Angles(RAD(0),RAD(spinb),RAD(0)), RotationX = 0, RotationY = 0--[[sick.PlaybackLoudness/50]], RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			--WACKYEFFECT({Time = 12.5, EffectType = "Wave", Size = VT(1,1,1), Size2 = VT(2,1,2), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CFrame.new(0,-1.3,0)*CFrame.Angles(RAD(180),RAD(spina),RAD(0)), RotationX = 0, RotationY = 0--[[sick.PlaybackLoudness/50]], RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
			WACKYEFFECT({Time = 12.5, EffectType = "Wave", Size = VT(1,1,1), Size2 = VT(2,1,2), Transparency = 0, Transparency2 = 1, CFrame = LeftLeg.CFrame*CFrame.new(0,-1.3,0)*CFrame.Angles(RAD(180),RAD(spina),RAD(0)), RotationX = 0, RotationY = 0--[[sick.PlaybackLoudness/50]], RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
			WACKYEFFECT({Time = 12.5, EffectType = "Wave", Size = VT(1,1,1), Size2 = VT(2,1,2), Transparency = 0, Transparency2 = 1, CFrame = RightLeg.CFrame*CFrame.new(0,-1.3,0)*CFrame.Angles(RAD(180),RAD(spina),RAD(0)), RotationX = 0, RotationY = 0--[[sick.PlaybackLoudness/50]], RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		end
	end))

	function ApplyDamage(Humanoid,Damage,TorsoPart)
		local defence = Instance.new("BoolValue",Humanoid.Parent)
		defence.Name = ("HitBy"..Player.Name)
		game:GetService("Debris"):AddItem(defence, 0.001)
		Damage = Damage * DAMAGEMULTIPLIER
		if Humanoid.Health ~= 0 then
			local CritChance = MRANDOM(1,100)
			if Damage > Humanoid.Health then
				Damage = math.ceil(Humanoid.Health)
				if Damage == 0 then
					Damage = 0.1
				end
			end
			Humanoid.Health = Humanoid.Health - Damage
			StatLabel(TorsoPart.CFrame * CF(0, 0 + (TorsoPart.Size.z - 1), 0), Damage, C3(0, 0, 0))
		end
	end

	function SpawnTrail(FROM,TO,BIG)
		local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, color, "Trail", VT(0,0,0))
		MakeForm(TRAIL,"Cyl")
		local DIST = (FROM - TO).Magnitude
		if BIG == true then
			TRAIL.Size = VT(0.5,DIST,0.5)
		else
			TRAIL.Size = VT(0.25,DIST,0.25)
		end
		TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
		coroutine.resume(coroutine.create(function()
			for i = 1, 5 do
				Swait()
				TRAIL.Transparency = TRAIL.Transparency + 0.1
			end
			TRAIL:remove()
		end))
	end

	function Banish(Foe)
		print(Foe)
	end





	function ApplyAoE(POSITION,RANGE,ISBANISH)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if ISBANISH == true then
								Banish(CHILD)
							else
								if ISBANISH == "Gravity" then
									HUM.PlatformStand = true
									if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
										local grav = Instance.new("BodyPosition",TORSO)
										grav.D = 15
										grav.P = 20000
										grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
										grav.position = TORSO.Position
										grav.Name = "V3BanishForce"..Player.Name
									else
										TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
										TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
									end
								else
									HUM.PlatformStand = false
								end
							end
						elseif ISBANISH == "Gravity" then
							if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
								TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
								HUM.PlatformStand = false
							end
						end
					end
				end
			end
		end
	end

	--//=================================\\
	--||	ATTACK FUNCTIONS AND STUFF
	--\\=================================//

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	v.Anchored = false

	local Outline = Instance.new("SelectionBox", v)
	Outline.LineThickness = 0.1
	Outline.Color3 = Color3.fromRGB(195, 130, 0)
	Outline.Adornee = v

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if ATTACK == false then
				bp.Position = game.Players.LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)



	function Banisher_Bullet()
		ATTACK = true
		Rooted = false
		for i=0, 0, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		repeat
			for i=0, 0, 0.1 / Animation_Speed do
				Swait()
				turnto(Mouse.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(-20), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.3) * ANGLES(RAD(70), RAD(20), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.3, 0.2) * ANGLES(RAD(-15), RAD(10), RAD(-10)) * LEFTSHOULDERC0, 2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
			SpawnTrail(Hole.Position,POS)
			if HIT ~= nil then
				if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
					Banish(HIT.Parent)
					bosschatfunc(msgs[MRANDOM(1,#msgs)],color,120)
				end
			end
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = Hole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = color, SoundID = 904440937, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
			for i=0, 0, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(-20), RAD(0)), 0.25 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.3) * ANGLES(RAD(70), RAD(20), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.3, 0.2) * ANGLES(RAD(-10), RAD(10), RAD(-10)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		until KEYHOLD == false
		ATTACK = false
		Rooted = false
		repeat wait() until ATTACK == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if ATTACK == true then
				bp.Position = Mouse.Hit.p
			end
		until ATTACK == false
	end

	function Kickisher_Bullet()
		ATTACK = true
		Rooted = false
		for i=0, 0, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		repeat
			for i=0, 0, 0.1 / Animation_Speed do
				Swait()
				turnto(Mouse.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(-20), RAD(0)), 0.25 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.3) * ANGLES(RAD(70), RAD(20), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.3, 0.2) * ANGLES(RAD(-10), RAD(10), RAD(-10)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
			SpawnTrail(Hole.Position,POS)
			if HIT ~= nil then
				local plr = game.Players:GetPlayerFromCharacter(HIT.Parent)
				bosschatfunc(msgs[MRANDOM(1,#msgs)],color,120)
				if plr then
					plr:Kick("Kickisher X | Kicked")
				end
			end
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = Hole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = color, SoundID = 904440937, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
			for i=0, 0, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(-20), RAD(0)), 0.25 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.3) * ANGLES(RAD(70), RAD(20), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.3, 0.2) * ANGLES(RAD(-10), RAD(10), RAD(-10)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		until KEYHOLD == false
		ATTACK = false
		Rooted = false
		repeat wait() until ATTACK == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if ATTACK == true then
				bp.Position = Mouse.Hit.p
			end
		until ATTACK == false
	end

	function Banning_Bullet()
		ATTACK = true
		Rooted = false
		for i=0, 0, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		repeat
			for i=0, 0, 0.1 / Animation_Speed do
				Swait()
				turnto(Mouse.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(-20), RAD(0)), 0.25 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.3) * ANGLES(RAD(70), RAD(20), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.3, 0.2) * ANGLES(RAD(-10), RAD(10), RAD(-10)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
			SpawnTrail(Hole.Position,POS)
			if HIT ~= nil then
				if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
					table.insert(banned,HIT.Parent.Name)
					--chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..HIT.Parent.Name..".")
					bosschatfunc(msgs[MRANDOM(1,#msgs)],color,120)
					printbye(HIT.Parent.Name)
					table.insert(banned,HIT.Parent.Name)
					local bannedplr = game.Players:GetPlayerFromCharacter(HIT.Parent)
					if bannedplr then
						bannedplr:Kick("Kickisher X | Banned | Note: You've been serverbanned by Kickisher X because you did a bad.")
					else
					end
				end
			end
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = Hole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = color, SoundID = 904440937, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
			for i=0, 0, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(-20), RAD(0)), 0.25 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.3) * ANGLES(RAD(70), RAD(20), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.3, 0.2) * ANGLES(RAD(-10), RAD(10), RAD(-10)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		until KEYHOLD == false
		ATTACK = false
		Rooted = false
		repeat wait() until ATTACK == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if ATTACK == true then
				bp.Position = Mouse.Hit.p
			end
		until ATTACK == false
	end

	function Taunt()
		bosschatfunc("You players kill eachother for no reason.",color,220)
	end

	function credit()
		bosschatfunc("Kickisher X | Made by CodedTheForgotten | This is coded's last kickisher project. | Enjoy! | Depressed_File#8484",color,320)
	end



	--//=================================\\
	--||	  ASSIGN THINGS TO KEYS
	--\\=================================//

	function MouseDown(Mouse)
		if ATTACK == false then
		end
	end

	function MouseUp(Mouse)
		HOLD = false
	end

	function KeyDown(Key)
		KEYHOLD = true
		if Key == "z" and ATTACK == false then
			Banisher_Bullet()
		end

		if Key == "t" and ATTACK == false then
			Taunt()
		end
		if Key == "b" and ATTACK == false then
			credit()
		end

		if Key == "c" and ATTACK == false then
			Banning_Bullet()
		end

		if Key == "v" and ATTACK == false then
			TOBANISH = {}
			banned = {}
		end

		if Key == "x" and ATTACK == false then
			Kickisher_Bullet()
		end
	end

	function KeyUp(Key)
		KEYHOLD = false
	end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

	--//=================================\\
	--\\=================================//


	function unanchor()
		if UNANCHOR == true then
			g = Character:GetChildren()
			for i = 1, #g do
				if g[i].ClassName == "Part" then
					g[i].Anchored = false
				end
			end
		end
	end


	--//=================================\\
	--||	WRAP THE WHOLE SCRIPT UP
	--\\=================================//

	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)

	local CONNECT = nil

	while true do
		Swait()
		ANIMATE.Parent = nil
		if Character:FindFirstChildOfClass("Humanoid") == nil then
			Humanoid = IT("Humanoid",Character)
		end
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		SINE = SINE + CHANGE
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
		if ANIM == "Walk" and TORSOVELOCITY > 1 then
			--RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			--Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			--RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			--LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
			--RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			--Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			--RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			--LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		end
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(25))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(25))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			ANIM = "Idle"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20 - 2.5 * SIN(SINE / 12)), RAD(-5), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(20), RAD(-20), RAD(30))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(20), RAD(-30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(90), RAD(25+10*COS(SINE/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-10-10*COS(SINE/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.6 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(30))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(90), RAD(-25+10*COS(SINE/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(20-10*COS(SINE/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		end


		unanchor()
		Humanoid.MaxHealth = "inf"
		Humanoid.Health = "inf"
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		tecks2.Rotation = MRANDOM(-43,42)/8
		SKILL1FRAME.Rotation = MRANDOM(-4,4)/2

		sick.Parent = Torso
		sick:resume()
		sick.Volume = 6
		sick.Pitch = 1
		sick.SoundId = "rbxassetid://2930553110"
		sick.Name = "KickisherGoneMAD"
		refit()
	end

	--//=================================\\
	--\\=================================//





	--//====================================================\\--
	--||			  		 END OF SCRIPT
	--\\====================================================//--
end)

Button_6.MouseButton1Down:Connect(function()
	workspace.FallenPartsDestroyHeight = -1000000000

	local Player = game.Players.LocalPlayer
	Mouse = Player:GetMouse()
	Player = Player
	PlayerGui = Player.PlayerGui
	Cam = workspace.CurrentCamera
	Backpack = Player.Backpack
	Character = Player.Character["Dummy"]
	Humanoid = Character.Humanoid
	RootPart = Character["HumanoidRootPart"]
	Torso = Character["Torso"]
	Head = Character["Head"]
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	print('User: '..Player.Name)
	print('Enjoy this Edit ;D')
	local sick = Instance.new("Sound",Character)
	sick.Parent = Character
	sick:resume()
	sick.Volume = 5
	sick.Pitch = 1
	sick.Looped = true
	sick.SoundId = "rbxassetid://1695752879"
	sick.Name = ""
	-------------Name Tag Stuff.------------------------
	local naeeym = Instance.new("BillboardGui",Character)
	naeeym.Size = UDim2.new(0,100,0,40)
	naeeym.StudsOffset = Vector3.new(0,2,0)
	naeeym.Adornee = Character.Head
	local tecks = Instance.new("TextLabel",naeeym)
	tecks.BackgroundTransparency = 1
	tecks.BorderSizePixel = 0
	tecks.Text = ""
	tecks.Font = "Fantasy"
	tecks.FontSize = "Size24"
	tecks.TextStrokeTransparency = 0
	tecks.TextStrokeColor3 = Color3.new(1,1,1)
	tecks.TextColor3 = Color3.new(1,1,1)
	tecks.Size = UDim2.new(1,0,0.5,0)
	----------------------------------------------------

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor


	--//=================================\\
	--|| 	      USEFUL VALUES
	--\\=================================//

	Player_Size = 1
	Animation_Speed = 3
	local FORCERESET = false
	local Effects2 = {}
	Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local DAMAGEMULTIPLIER = 1
	local SIZE = 1
	local ANIM = "Idle"
	local ATTACK = false
	local EQUIPPED = false
	local HOLD = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local KEYHOLD = false
	local CHANGE = 2 / Animation_Speed
	local WALKINGANIM = false
	local VALUE1 = false
	local VALUE2 = false
	local ROBLOXIDLEANIMATION = IT("Animation")
	ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
	ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
	--ROBLOXIDLEANIMATION.Parent = Humanoid
	local WEAPONGUI = IT("ScreenGui", PlayerGui)
	WEAPONGUI.Name = "BanishV3Gui"
	local Gun = IT("Model")
	Gun.Name = "Adds"
	local Gun2 = IT("Model")
	Gun2.Name = "Adds"
	local Weapon = IT("Model")
	Weapon.Name = "Adds"
	local dog = IT("Model")
	dog.Name = "Adds"
	local Effects = IT("Folder", Weapon)
	Effects.Name = "Effects"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character:FindFirstChild("Animate")
	local UNANCHOR = true
	local TOBANISH = {}
	local ROAR = {528589078,528589175,528589274,528589382}
	script.Parent = PlayerGui

	--//=================================\\
	--\\=================================//

	local Speed = 18

	--//=================================\\
	--|| SAZERENOS' ARTIFICIAL HEARTBEAT
	--\\=================================//

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	--//=================================\\
	--\\=================================//

	--//=================================\\
	--|| 	      SOME FUNCTIONS
	--\\=================================//

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then 
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
		local frame = IT("Frame")
		frame.BackgroundTransparency = TRANSPARENCY
		frame.BorderSizePixel = BORDERSIZEPIXEL
		frame.Position = POSITION
		frame.Size = SIZE
		frame.BackgroundColor3 = COLOR
		frame.BorderColor3 = BORDERCOLOR
		frame.Name = NAME
		frame.Parent = PARENT
		return frame
	end

	coroutine.resume(coroutine.create(function()
		while true do
			wait(2)
			--Outlines(game.Players.LocalPlayer.Character)
		end
	end))

	function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
		local label = IT("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UD2(1, 0, 1, 0)
		label.Position = UD2(0, 0, 0, 0)
		label.TextColor3 = TEXTCOLOR
		label.TextStrokeTransparency = STROKETRANSPARENCY
		label.TextTransparency = TRANSPARENCY
		label.FontSize = TEXTFONTSIZE
		label.Font = TEXTFONT
		label.BorderSizePixel = BORDERSIZEPIXEL
		label.TextScaled = false
		label.Text = TEXT
		label.Name = NAME
		label.Parent = PARENT
		return label
	end

	function NoOutlines(PART)
		PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
	end

	function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
		local NEWWELD = IT(TYPE)
		NEWWELD.Part0 = PART0
		NEWWELD.Part1 = PART1
		NEWWELD.C0 = C0
		NEWWELD.C1 = C1
		NEWWELD.Parent = PARENT
		return NEWWELD
	end
	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
	end

	--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	function WACKYEFFECT(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or VT(1,1,1))
		local ENDSIZE = (Table.Size2 or VT(0,0,0))
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local MOVEDIRECTION = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLOR = (Table.Color or C3(1,1,1))
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
			elseif TYPE == "Block" then
				MSH = IT("BlockMesh",EFFECT)
				MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
			end
			if MSH ~= nil then
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
				end
				local GROWTH = SIZE - ENDSIZE
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.X/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					SOUND.Stopped:Connect(function()
						EFFECT:remove()
					end)
				end
			else
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until SOUND.Playing == false
					EFFECT:remove()
				end
			end
		end))
	end

	function CreateWave(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0,0,0))
		local mesh = IT("SpecialMesh",wave)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
		mesh.Scale = SIZE
		mesh.Offset = VT(0,0,-SIZE.X/8)
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
				if DOESROT == true then
					wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
				end
				wave.Transparency = wave.Transparency + (0.5/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	function SpawnTrail(FROM,TO,BIG)
		local TRAIL = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "Trail", VT(3,3,3))
		MakeForm(TRAIL,"Cyl")
		local cR=255
		local cG=0
		local cB=0
		local flg5=1 local omgidk=1
		local add=15
		game:GetService("RunService").Heartbeat:Connect(function()
			if omgidk>10000 then omgidk=0 end
			omgidk=omgidk+1
			if cR>=255 then flg5=1 end
			if cG>=255 then flg5=2 end
			if cB>=255 then flg5=3 end
			if flg5==1 then cR=cR-add cG=cG+add end
			if flg5==2 then cG=cG-add cB=cB+add end
			if flg5==3 then cB=cB-add cR=cR+add end
			color=Color3.fromRGB(cR,cG,cB)
			TRAIL.Color = color
		end)
		local DIST = (FROM - TO).Magnitude
		if BIG == true then
			TRAIL.Size = VT(3,DIST,3)
		else
			coroutine.resume(coroutine.create(function()
				local x = 3
				for i = 1, 100 do  
					wait(0.05)
					x = x + 0.2
					TRAIL.Size = VT(x,DIST,x)
				end
			end))
		end
		TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
		coroutine.resume(coroutine.create(function()
			for i = 1, 100 do
				Swait()
				TRAIL.Transparency = TRAIL.Transparency + 0.01
			end
			TRAIL:remove()
		end))
	end

	function SpawnBruh(FROM,TO,BIG)
		local TRAIL = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "Trail", VT(3,3,3))
		MakeForm(TRAIL,"Cyl")
		local cR=255
		local cG=0
		local cB=0
		local flg5=1 local omgidk=1
		local add=15
		game:GetService("RunService").Heartbeat:Connect(function()
			if omgidk>10000 then omgidk=0 end
			omgidk=omgidk+1
			if cR>=255 then flg5=1 end
			if cG>=255 then flg5=2 end
			if cB>=255 then flg5=3 end
			if flg5==1 then cR=cR-add cG=cG+add end
			if flg5==2 then cG=cG-add cB=cB+add end
			if flg5==3 then cB=cB-add cR=cR+add end
			color=Color3.fromRGB(cR,cG,cB)
			wait(0.05)	
			TRAIL.Color = C3(MRANDOM(1,360),MRANDOM(1,360),MRANDOM(1,360))
		end)
		local DIST = (FROM - TO).Magnitude
		if BIG == true then
			TRAIL.Size = VT(2,DIST,2)
		else
			coroutine.resume(coroutine.create(function()
				local x = 3
				for i = 1, 200 do  
					wait(0.02)
					TRAIL.Size = VT(MRANDOM(1,5),DIST,MRANDOM(1,5))
				end
			end))
		end
		TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
		coroutine.resume(coroutine.create(function()
			for i = 1, 50 do
				Swait()
				TRAIL.Transparency = TRAIL.Transparency + 0.02
			end
			TRAIL:remove()
		end))
	end

	Debris = game:GetService("Debris")

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end

	function turnto(position)
		RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
	end

	function swait(num)
		if num == 0 or num == nil then
			ArtificialHB.Event:wait()
		else
			for i = 0, num do
				ArtificialHB.Event:wait()
			end
		end
	end

	function CreateRing2(SIZE,DOESROT,ROT,WAIT,CFRAME,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0,0,0))
		local mesh = IT("SpecialMesh",wave)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = "http://www.roblox.com/asset/?id=3270017"
		mesh.Scale = SIZE
		mesh.Offset = VT(0,0,0)
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				if DOESROT == true then
					wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
				end
				wave.Transparency = wave.Transparency + (0.5/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function MagicSphere3(SIZE,WAIT,CFRAME,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
		local mesh = IT("SpecialMesh",wave)
		mesh.MeshType = "Sphere"
		mesh.Scale = SIZE
		mesh.Offset = VT(0,0,0)
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				wave.Transparency = wave.Transparency + (1/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function chatfunc(text)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard")~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end
			local Bill = Instance.new("BillboardGui",Character)
			Bill.Size = UDim2.new(0,100,0,40)
			Bill.StudsOffset = Vector3.new(0,3,0)
			Bill.Adornee = Character.Head
			Bill.Name = "TalkingBillBoard"
			local Hehe = Instance.new("TextLabel",Bill)
			Hehe.BackgroundTransparency = 1
			Hehe.BorderSizePixel = 0
			Hehe.Text = ""
			Hehe.Font = "Fantasy"
			Hehe.TextSize = 40
			Hehe.TextStrokeTransparency = 0
			Hehe.Size = UDim2.new(1,0,0.5,0)
			coroutine.resume(coroutine.create(function()
				while Hehe ~= nil do
					local cR=255
					local cG=0
					local cB=0
					local flg5=1 local omgidk=1
					local add=15
					game:GetService("RunService").Heartbeat:Connect(function()
						if omgidk>10000 then omgidk=0 end
						omgidk=omgidk+1
						if cR>=255 then flg5=1 end
						if cG>=255 then flg5=2 end
						if cB>=255 then flg5=3 end
						if flg5==1 then cR=cR-add cG=cG+add end
						if flg5==2 then cG=cG-add cB=cB+add end
						if flg5==3 then cB=cB-add cR=cR+add end
						color=Color3.fromRGB(cR,cG,cB)
					end)
					swait()	
					Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
					Hehe.Rotation = math.random(-5,5)
					Hehe.TextColor3 = Color3.new(color)
					Hehe.TextStrokeColor3 = Color3.new(color)
				end
			end))
			for i = 1,string.len(text),1 do
				swait()
				Hehe.Text = string.sub(text,1,i)
			end
			swait(90)--Re[math.random(1, 93)]
			for i = 0, 1, .025 do
				swait()
				Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
				Hehe.TextStrokeTransparency = i
				Hehe.TextTransparency = i
			end
			Bill:Destroy()
		end)
		chat()
	end

	function CheckTableForString(Table, String)
		for i, v in pairs(Table) do
			if string.find(string.lower(String), string.lower(v)) then
				return true
			end
		end
		return false
	end

	function CheckIntangible(Hit)
		local ProjectileNames = {
			"Water",
			"Arrow",
			"Projectile",
			"Effect",
			"Rail",
			"Lightning",
			"Bullet"
		}
		if Hit and Hit.Parent and (not Hit.CanCollide or CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild("Humanoid") then
			return true
		end
		return false
	end

	function CreateSwirl(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0,0,0))
		local mesh = IT("SpecialMesh",wave)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = "http://www.roblox.com/asset/?id=1051557"
		mesh.Scale = SIZE
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
				if DOESROT == true then
					wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
				end
				wave.Transparency = wave.Transparency + (0.5/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	--//=================================\\
	--||	     WEAPON CREATION
	--\\=================================//
	CreateWeldOrSnapOrMotor("Weld", Torso, Torso, PRT, CF(0.05,0.4,-0.1) * ANGLES(RAD(-3), RAD(0), RAD(0)), CF(0, 0, 0))
	CreateMesh("SpecialMesh", PRT, "FileMesh", "99856331", "", VT(1.1,1,1.1), VT(0,0,0))

	function CreateDebreeRing(FLOOR, POSITION, SIZE, BLOCKSIZE, SWAIT)
		if FLOOR ~= nil then
			coroutine.resume(coroutine.create(function()
				local PART = CreatePart(3, Effects, "Plastic", 0, 1, "Pearl", "DebreeCenter", VT(0, 0, 0))
				PART.CFrame = CF(POSITION)
				for i = 1, 45 do
					local RingPiece = CreatePart(3, Effects, "Plastic", 0, 0, "Pearl", "DebreePart", BLOCKSIZE)
					RingPiece.Material = FLOOR.Material
					RingPiece.Color = FLOOR.Color
					RingPiece.CFrame = PART.CFrame * ANGLES(RAD(0), RAD(i * 8), RAD(0)) * CF(SIZE * 4, 0, 0) * ANGLES(RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)))
					Debris:AddItem(RingPiece, SWAIT)
				end
				PART:remove()
			end))
		end
	end
	function CreateFlyingDebree(FLOOR, POSITION, AMOUNT, BLOCKSIZE, SWAIT, STRENGTH)
		if FLOOR ~= nil then
			for i = 1, AMOUNT do
				do
					local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, FLOOR.Transparency, "Peal", "Debree", BLOCKSIZE, false)
					DEBREE.Material = FLOOR.Material
					DEBREE.Color = FLOOR.Color
					DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)))
					DEBREE.Velocity = VT(MRANDOM(-STRENGTH, STRENGTH), MRANDOM(-STRENGTH, STRENGTH), MRANDOM(-STRENGTH, STRENGTH))
					coroutine.resume(coroutine.create(function()
						Swait(15)
						DEBREE.Parent = workspace
						DEBREE.CanCollide = true
						Debris:AddItem(DEBREE, SWAIT)
					end))
				end
			end
		end
	end

	local LASTPART = Head
	for i = 1, 20 do
		local MATH = (1-(i/25))
		if LASTPART == Head then
			local Horn = CreatePart(3, Character, "Neon", 0, 0, "White", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(15), RAD(-15)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i*3-3)/0,0,0)
		else
			local Horn = CreatePart(3, Character, "Neon", 0, 0, "White", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(-0.3), RAD(0)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i*3-3)/0,0,0)
		end
	end
	local LASTPART = Head
	for i = 1, 20 do
		local MATH = (1-(i/25))
		if LASTPART == Head then
			local Horn = CreatePart(3, Character, "Neon", 0, 0, "Really White", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(-0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(-15), RAD(15)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i*3-3)/0,0,0)
		else
			local Horn = CreatePart(3, Character, "Neon", 0, 0, "Really White", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(0.3), RAD(0)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i*3-3)/0,0,0)
		end
	end

	for i = 1, 10 do
		local FACE = CreatePart(3, Character, "Fabric", 0, 0 + (i - 1) / 10.2, "Dark stone grey", "FaceGradient", VT(1.01, 0.65, 1.01), false)
		FACE.Color = C3(0, 0, 0)
		Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
		CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0, 0.28 - (i - 1) / 30, 0), CF(0, 0, 0))
	end

	local Particle = IT("ParticleEmitter",nil)
	Particle.Enabled = false
	Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
	Particle.LightEmission = 0.88
	Particle.Rate = 250
	Particle.ZOffset = 0.2
	Particle.Rotation = NumberRange.new(-180, 180)
	Particle.RotSpeed = NumberRange.new(-180, 180)
	Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
	Particle.Color = ColorSequence.new(C3(255,255,255),C3(255,255,255))

	--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
	function ParticleEmitter(Table)
		local PRTCL = Particle:Clone()
		local Speed = Table.Speed or 5
		local Drag = Table.Drag or 0
		local Size1 = Table.Size1 or 1
		local Size2 = Table.Size2 or 5
		local Lifetime1 = Table.Lifetime1 or 1
		local Lifetime2 = Table.Lifetime2 or 1.5
		local Parent = Table.Parent or Torso
		local Emit = Table.Emit or 100
		local Offset = Table.Offset or 360
		local Acel = Table.Acel or VT(0,0,0)
		local Enabled = Table.Enabled or false
		PRTCL.Parent = Parent
		PRTCL.Size = NumberSequence.new(Size1,Size2)
		PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
		PRTCL.Speed = NumberRange.new(Speed)
		PRTCL.VelocitySpread = Offset
		PRTCL.Drag = Drag
		PRTCL.Acceleration = Acel
		if Enabled == false then
			PRTCL:Emit(Emit)
			Debris:AddItem(PRTCL,Lifetime2)
		else
			PRTCL.Enabled = true
		end
		return PRTCL
	end


	local Handle = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.6,0.2),false)

	local LeftArmGrasp = CreateWeldOrSnapOrMotor("Weld", Handle, RightLeg, Handle, CF(0,-1, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0.21, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.3, 0.2) * ANGLES(RAD(0), RAD(180), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.3,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.4, 0) * ANGLES(RAD(0), RAD(0), RAD(180)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.3,0.3),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.5, 0.2) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.5,0.5),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.4,0.4,0.4),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	for i = 1, 8 do
		local Piece = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Eye", VT(0,0.35,0.41),false)
		CreateWeldOrSnapOrMotor("Weld", Handle, Part, Piece, CF(0, 0, 0) * ANGLES(RAD(0), RAD((360/8)*i), RAD(0)), CF(0, 0, 0))
	end

	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Eye", VT(0.38,0.41,0.38),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.37,0.5,0.37),false)
	MakeForm(Part,"Ball")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.3) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.7,0.4),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.7, 0.5) * ANGLES(RAD(90), RAD(180), RAD(180)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.4,0.2),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.35,0.35,0.35),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.5),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.45),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1.1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.55, 0.2) * ANGLES(RAD(-135), RAD(0), RAD(0)), CF(0, -0.3, 0))
	local LASTPART = Handle
	for i = 1, 10 do
		if LASTPART == Handle then
			local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.1,0.2,0),false)
			LASTPART = Part
			CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.1, 0.2) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
		else
			local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.1,0.05,0),false)
			CreateWeldOrSnapOrMotor("Weld", Handle, LASTPART, Part, CF(0, 0.025, 0) * ANGLES(RAD(8), RAD(0), RAD(0)), CF(0, -0.025, 0))
			LASTPART = Part
		end
	end

	Weapon.Parent = Character
	local Barrel = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.15,4,0.15),false)
	MakeForm(Barrel,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Barrel, CF(0, -0.6, 1.85) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0.25,2,0.25),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, -0.2, 0), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0,0.1,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, 0.945, 0.1) * ANGLES(RAD(180), RAD(0), RAD(0)), CF(0, 0, 0))
	local Hole2 = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Eye", VT(0.125,0,0.125),false)
	MakeForm(Hole2,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Hole2, CF(0, 2, 0), CF(0, 0, 0))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Part", VT(0,0,0),false)
	local GEARWELD = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
	CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.8,0.8,1.5), VT(0,0,0.2))
	local Part = CreatePart(3, Gun2, "Metal", 0, 0.5, "Mid gray", "Eye", VT(0,0,0),false)
	local GEARWELD2 = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
	CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.9,0.9,0.3), VT(0,0,0.2))
	coroutine.resume(coroutine.create(function()
		while wait() do
			GEARWELD.C0 = GEARWELD.C0 * ANGLES(RAD(0), RAD(0), RAD(5))
			GEARWELD2.C0 = GEARWELD2.C0 * ANGLES(RAD(0), RAD(0), RAD(-5))
		end
	end))

	Gun2.Parent = nil

	local Handle = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.6,0.2),false)
	local RightArmGrasp = CreateWeldOrSnapOrMotor("Weld", Handle, RightArm, Handle, CF(0,-1, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0.21, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.3, 0.2) * ANGLES(RAD(0), RAD(180), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.3,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.4, 0) * ANGLES(RAD(0), RAD(0), RAD(180)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.3,0.3),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.5, 0.2) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.5,0.5),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.4,0.4,0.4),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	for i = 1, 8 do
		local Piece = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Eye", VT(0,0.35,0.41),false)
		CreateWeldOrSnapOrMotor("Weld", Handle, Part, Piece, CF(0, 0, 0) * ANGLES(RAD(0), RAD((360/8)*i), RAD(0)), CF(0, 0, 0))
	end
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Eye", VT(0.38,0.41,0.38),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.37,0.5,0.37),false)
	MakeForm(Part,"Ball")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.3) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.7,0.4),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.7, 0.5) * ANGLES(RAD(90), RAD(180), RAD(180)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.4,0.2),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.35,0.35,0.35),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.5),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.45),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1.1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.55, 0.2) * ANGLES(RAD(-135), RAD(0), RAD(0)), CF(0, -0.3, 0))
	local LASTPART = Handle
	for i = 1, 10 do
		if LASTPART == Handle then
			local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.1,0.2,0),false)
			LASTPART = Part
			CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.1, 0.2) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
		else
			local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.1,0.05,0),false)
			CreateWeldOrSnapOrMotor("Weld", Handle, LASTPART, Part, CF(0, 0.025, 0) * ANGLES(RAD(8), RAD(0), RAD(0)), CF(0, -0.025, 0))
			LASTPART = Part
		end
	end

	local hat = game:GetService("Players").LocalPlayer.Character["Type-49 Abomindation Back Accessory"]

	hat.Handle.AccessoryWeld:Destroy()

	local function align(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		if part0 == hat.Handle then
			attachment0.Position = Vector3.new(0.4, 0.05, -0.5) --Custom Positioning Values Here
			attachment0.Orientation = Vector3.new(52, -90, 180) --Custom Rotationing Values here
		end
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = true
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	hat.Handle.Size = Vector3.new(1,1,1)

	align(hat.Handle, Handle)

	if not Handle then
		hat.Handle["AlignPosition"].Enabled = false
		hat.Handle["AlignOrientation"].Enabled = false
	else
		hat.Handle["AlignPosition"].Enabled = true
		hat.Handle["AlignOrientation"].Enabled = true
	end

	Weapon.Parent = Character
	local Barrel = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.15,4,0.15),false)
	MakeForm(Barrel,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Barrel, CF(0, -0.6, 1.85) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0.25,2,0.25),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, -0.2, 0), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0,0.1,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, 0.945, 0.1) * ANGLES(RAD(180), RAD(0), RAD(0)), CF(0, 0, 0))
	local Hole = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Eye", VT(0.125,0,0.125),false)
	MakeForm(Hole,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Hole, CF(0, 2, 0), CF(0, 0, 0))
	local Part = CreatePart(3, Gun, "Metal", 0, 0, "Mid gray", "Part", VT(0,0,0),false)
	local GEARWELD = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
	CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.8,0.8,1.5), VT(0,0,0.2))
	local Part = CreatePart(3, Gun, "Metal", 0, 0.5, "Mid gray", "Eye", VT(0,0,0),false)
	local GEARWELD2 = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
	CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.9,0.9,0.3), VT(0,0,0.2))
	coroutine.resume(coroutine.create(function()
		while wait() do
			GEARWELD.C0 = GEARWELD.C0 * ANGLES(RAD(0), RAD(0), RAD(5))
			GEARWELD2.C0 = GEARWELD2.C0 * ANGLES(RAD(0), RAD(0), RAD(-5))
		end
	end))



	--ParticleEmitter({Speed = 0.5, Drag = 0, Size1 = 0.2, Size2 = 0, Lifetime1 = 0.3, Lifetime2 = 0.7, Parent = Dangle, Emit = 100, Offset = 360, Enabled = true, Acel = VT(0,5,0)})

	local BEANED = {}

	function BEAN(bitch)	
		if bitch then	
			g = game.Players:GetPlayers()
			local kickfolder = IT("Folder",Effects)
			local naeeym2 = Instance.new("BillboardGui",kickfolder)
			naeeym2.AlwaysOnTop = false
			naeeym2.Size = UDim2.new(5,35,2,35)
			naeeym2.StudsOffset = Vector3.new(0,1,0)
			naeeym2.Name = "Mark"
			local tecks2 = Instance.new("TextLabel",naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.TextScaled = true
			tecks2.BorderSizePixel = 0
			tecks2.Text = "BANNED"
			tecks2.Font = "Arcade"
			tecks2.TextSize = 30
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = Color3.fromRGB(0,0,0)
			tecks2.TextStrokeColor3 = Color3.fromRGB(0,0,0)
			tecks2.Size = UDim2.new(1,0,0.5,0)
			tecks2.Parent = naeeym2
			-- CreateSound("2570187601", bitch, 600, 1, false)
			local Players = game:GetService("Players")
			local fag = Players:FindFirstChild(bitch.Name)
			--faggut:Kick()
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick("fat")
			end
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick("fat")
			end
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick("fat")
			end
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick("fat")
			end
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick("fat")
			end
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick("fat")
			end
			table.insert(BEANED,bitch.name)
			--]]
			--CreateSound("527749592", game.Workspace, 700, 1, false)
			--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
			coroutine.resume(coroutine.create(function()
				for i = 1, 50 do
					Swait()
					for i,v in ipairs(kickfolder:GetChildren()) do
						if v.ClassName == "Part" or v.ClassName == "MeshPart" then
							v.Transparency = 1
						end
						naeeym2.Enabled = false
					end
					Swait()
					for i,v in ipairs(kickfolder:GetChildren()) do
						if v.ClassName == "Part" or v.ClassName == "MeshPart" then
							v.Transparency = 0
						end
						naeeym2.Enabled = true
					end
				end
				kickfolder:remove()
			end))
			--wait(6)
			--bitch:Remove()
		end
	end      	

	local function CheckForBan(player)
		for i = 1, #BEANED do
			if player.Name == BEANED[i] then
				player:Kick() --Ban Reason Change between the '' to change the reason!
			end
		end
	end

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	v.Anchored = false

	v.AccessoryWeld:Destroy()

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if ATTACK == false then
				bp.Position = game.Players.LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)

	function E()
		ATTACK = true
		Rooted = false
		for i=0, 0.05, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		repeat
			for i=0, 0.05, 0.1 / Animation_Speed do
				Swait()
				turnto(Mouse.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
			local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
			SpawnTrail(Hole.Position,POS)
			if HIT ~= nil then
				if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
					Banish(HIT.Parent)
				end
			end
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(1,0,1), Size2 = VT(6,6.5,6), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = color, SoundID = 904440937, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
			for i=0, 0.05, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(130), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
		until KEYHOLD == false
		ATTACK = false
		Rooted = false
		repeat wait() until ATTACK == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if ATTACK == true then
				bp.Position = game.Players.LocalPlayer:GetMouse().Hit.p
			end
		until ATTACK == false
	end

	game.Players.PlayerAdded:connect(function()
		for i,v in pairs(game.Players:GetPlayers())do
			CheckForBan(v)
		end  
	end)

	local cR=255
	local cG=0
	local cB=0
	local flg5=1 local omgidk=1
	local add=10.5
	game:GetService('RunService').Heartbeat:connect(function()
		if omgidk>10000 then omgidk=0 end
		omgidk=omgidk+1
		if cR>=255 then flg5=1 end
		if cG>=255 then flg5=2 end
		if cB>=255 then flg5=3 end
		if flg5==1 then cR=cR-add cG=cG+add end
		if flg5==2 then cG=cG-add cB=cB+add end
		if flg5==3 then cB=cB-add cR=cR+add end
		color=Color3.fromRGB(cR,cG,cB)
		for _, c in pairs(Gun2:GetDescendants()) do
			if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
				c.Material = "Glass"
				c.Color = C3(0,0,0)
			elseif c.ClassName == "Part" and c.Name == "Eye" then
				RightArm.BrickColor = BrickColor.new(color)
				c.Color = color
				c.Material = "Neon"
			end
		end

		for _, c in pairs(dog:GetDescendants()) do
			if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
				c.Material = "Glass"
				c.Color = C3(0,0,0)
			elseif c.ClassName == "Part" and c.Name == "Eye" then
				RightArm.BrickColor = BrickColor.new(color)
				c.Color = color
				c.Material = "Neon"
			end
		end

		for _, c in pairs(Gun:GetDescendants()) do
			if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
				c.Material = "Glass"
				c.Color = C3(0,0,0)
			elseif c.ClassName == "Part" and c.Name == "Eye" then
				RightArm.BrickColor = BrickColor.new(color)
				c.Color = color
				c.Material = "Neon"
			end
		end
	end)
	Weapon.Parent = Character
	local SKILLTEXTCOLOR = C3(1,1,1)
	local SKILLFONT = "Bodoni"
	local SKILLTEXTSIZE = 5

	Humanoid.Died:connect(function()
		ATTACK = true
	end)
	Humanoid.Died:connect(function()
		Humanoid.Parent = nil
		chatfunc("I'll take revenge, mark my word.")
		ApplyAoE(RootPart, 955, 9999, 9999, 9999, true)
		Humanoid.Name = "Humanoid"
		Humanoid.MaxHealth = 16e+16
		Humanoid.Health = 16e+16
		CreateRing2(VT(0,0,0),false,0,45,RootPart.CFrame*ANGLES(RAD(90),RAD(0),RAD(0)),"Really white",VT(10,10,10))
		CreateSound("178452217", Effects, 10, 1)
		MagicSphere3(VT(0,0,0),45,Torso.CFrame,color,VT(500,500,500))
	end)

	local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
	local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.86, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
	local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.82, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
	local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.78, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
	local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.20, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")
	local SKILL6FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.03, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 6 Frame")

	local SKILL1TEXT = CreateLabel(SKILL1FRAME, "Edit by Zombienoff and extended by ebicgamermolment", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 1")
	local SKILL2TEXT = CreateLabel(SKILL2FRAME, "", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 2")
	local SKILL3TEXT = CreateLabel(SKILL3FRAME, "", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 3")
	local SKILL4TEXT = CreateLabel(SKILL4FRAME, "", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 4")
	local SKILL5TEXT = CreateLabel(SKILL5FRAME, "", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 5")
	local SKILL6TEXT = CreateLabel(SKILL6FRAME, "", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 6")

	workspace.ChildAdded:connect(function(instance)
		for BANISH = 1, #TOBANISH do
			if TOBANISH[BANISH] ~= nil then
				if instance.Name == TOBANISH[BANISH] then
					coroutine.resume(coroutine.create(function()
						printbye(instance.Name)
						instance:ClearAllChildren()
						Debris:AddItem(instance,0.0005)
					end))
				end
			end
		end
	end)

	--//=================================\\
	--||			DAMAGING
	--\\=================================//


	function killnearest(position,range,maxstrength,direction)

	end



	function Banish(Foe)
		-- hm
	end


	function Banisheff(Foe)
		--local lk = game.Players:FindFirstChild(Foe.name)
		--Ragdoll(lk,MRANDOM(1,360),true)
	end

	function ApplyAoE(POSITION,RANGE,ISBANISH)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if ISBANISH == true then
								Banish(CHILD)
							else
								if ISBANISH == "Gravity" then
									HUM.PlatformStand = true
									if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
										local grav = Instance.new("BodyPosition",TORSO)
										grav.D = 15
										grav.P = 20000
										grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
										grav.position = TORSO.Position
										grav.Name = "V3BanishForce"..Player.Name
									else
										TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
										TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
									end
								else
									HUM.PlatformStand = false
								end
							end
						elseif ISBANISH == "Gravity" then
							if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
								TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
								HUM.PlatformStand = false
							end
						end
					end
				end
			end
		end
	end		
	function recurse(root,callback,i)
		i= i or 0
		for _,v in pairs(root:GetChildren()) do
			i = i + 1
			callback(i,v)

			if #v:GetChildren() > 0 then
				i = recurse(v,callback,i)
			end
		end

		return i
	end
	function ragdollJoint(character, part0, part1, attachmentName, className, properties)
		attachmentName = attachmentName.."RigAttachment"
		local constraint = Instance.new(className.."Constraint")
		constraint.Attachment0 = part0:FindFirstChild(attachmentName)
		constraint.Attachment1 = part1:FindFirstChild(attachmentName)
		constraint.Name = "RagdollConstraint"..part1.Name

		for _,propertyData in next,properties or {} do
			constraint[propertyData[1]] = propertyData[2]
		end

		constraint.Parent = character
	end
	function getAttachment0(character, attachmentName)
		for _,child in next,character:GetChildren() do
			local attachment = child:FindFirstChild(attachmentName)
			if attachment then
				return attachment
			end
		end
	end


	function ArtificialHitbox(Part)
		local HITBOX = CreatePart(3, Part, "Metal", 0, 1, "Really black", "Hitbox", Part.Size/2, false)
		HITBOX.CanCollide = true
		HITBOX.CFrame = Part.CFrame
		weldBetween(Part,HITBOX)
	end
	function R15Ragdoll(character,KeepArms)
		character:BreakJoints()
		coroutine.resume(coroutine.create(function()
			recurse(character, function(_,v)
				if v:IsA("Attachment") then
					v.Axis = Vector3.new(0, 1, 0)
					v.SecondaryAxis = Vector3.new(0, 0, 1)
					v.Rotation = Vector3.new(0, 0, 0)
				end
			end)
			for _,child in next,character:GetChildren() do
				if child:IsA("Accoutrement") then
					for _,part in next,child:GetChildren() do
						if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
							local attachment1 = part:FindFirstChildOfClass("Attachment")
							local attachment0 = getAttachment0(character,attachment1.Name)
							if attachment0 and attachment1 then
								local constraint = Instance.new("HingeConstraint")
								constraint.Attachment0 = attachment0
								constraint.Attachment1 = attachment1
								constraint.LimitsEnabled = true
								constraint.UpperAngle = 0
								constraint.LowerAngle = 0
								constraint.Parent = character
							end
							ArtificialHitbox(part)
						elseif part.Name == "HumanoidRootPart" then
							part:remove()
						end
					end
				end
			end

			ragdollJoint(character,character.LowerTorso, character.UpperTorso, "Waist", "BallSocket", {
				{"LimitsEnabled",true};
				{"UpperAngle",5};
			})
			if character:FindFirstChild("Head") then
				ragdollJoint(character,character.UpperTorso, character.Head, "Neck", "BallSocket", {
					{"LimitsEnabled",true};
					{"UpperAngle",15};
				})
			end

			local handProperties = {
				{"LimitsEnabled", true};
				{"UpperAngle",0};
				{"LowerAngle",0};
			}
			ragdollJoint(character,character.LeftLowerArm, character.LeftHand, "LeftWrist", "Hinge", handProperties)
			ragdollJoint(character,character.RightLowerArm, character.RightHand, "RightWrist", "Hinge", handProperties)

			local shinProperties = {
				{"LimitsEnabled", true};
				{"UpperAngle", 0};
				{"LowerAngle", -75};
			}
			ragdollJoint(character,character.LeftUpperLeg, character.LeftLowerLeg, "LeftKnee", "Hinge", shinProperties)
			ragdollJoint(character,character.RightUpperLeg, character.RightLowerLeg, "RightKnee", "Hinge", shinProperties)

			local footProperties = {
				{"LimitsEnabled", true};
				{"UpperAngle", 15};
				{"LowerAngle", -45};
			}
			ragdollJoint(character,character.LeftLowerLeg, character.LeftFoot, "LeftAnkle", "Hinge", footProperties)
			ragdollJoint(character,character.RightLowerLeg, character.RightFoot, "RightAnkle", "Hinge", footProperties)
			if KeepArms == true then
				ragdollJoint(character,character.UpperTorso, character.RightUpperArm, "RightShoulder", "BallSocket")
				ragdollJoint(character,character.RightUpperArm, character.RightLowerArm, "RightElbow", "BallSocket")
				ragdollJoint(character,character.UpperTorso, character.LeftUpperArm, "LeftShoulder", "BallSocket")
				ragdollJoint(character,character.LeftUpperArm, character.LeftLowerArm, "LeftElbow", "BallSocket")
			end
			ragdollJoint(character,character.LowerTorso, character.LeftUpperLeg, "LeftHip", "BallSocket")
			ragdollJoint(character,character.LowerTorso, character.RightUpperLeg, "RightHip", "BallSocket")
			Debris:AddItem(character,5)
		end))
	end

	function Ragdoll(Character2,CharTorso,KeepArms)
		coroutine.resume(coroutine.create(function()
			Character2:BreakJoints()
			local hum = Character2:findFirstChild("Humanoid")
			hum:remove()
			local function Scan(ch)
				local e
				for e = 1,#ch do
					Scan(ch[e]:GetChildren())
					if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
						ch[e]:remove()
					end
				end
			end
			local NEWHUM = IT("Humanoid")
			NEWHUM.Name = "Corpse"
			NEWHUM.Health = 0
			NEWHUM.MaxHealth = 0
			NEWHUM.PlatformStand = true
			NEWHUM.Parent = Character2
			NEWHUM.DisplayDistanceType = "None"

			local ch = Character2:GetChildren()
			local i
			for i = 1,#ch do
				if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
					ch[i]:remove()
				end
			end

			local Torso2 = Character2.Torso
			local movevector = Vector3.new()

			if Torso2 then
				movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
				local Head = Character2:FindFirstChild("Head")
				if Head then
					local Neck = Instance.new("Weld")
					Neck.Name = "Neck"
					Neck.Part0 = Torso2
					Neck.Part1 = Head
					Neck.C0 = CFrame.new(0, 1.5, 0)
					Neck.C1 = CFrame.new()
					Neck.Parent = Torso2

				end
				local Limb = Character2:FindFirstChild("Right Arm")
				if Limb and KeepArms == true then

					Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
					local Joint = Instance.new("Glue")
					Joint.Name = "RightShoulder"
					Joint.Part0 = Torso2
					Joint.Part1 = Limb
					Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					Joint.Parent = Torso2

					local B = Instance.new("Part")
					B.TopSurface = 0
					B.BottomSurface = 0
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1
					B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = Character2
					local W = Instance.new("Weld")
					W.Part0 = Limb
					W.Part1 = B
					W.C0 = CFrame.new(0, -0.5, 0)
					W.Parent = Limb

				end
				local Limb = Character2:FindFirstChild("Left Arm")
				if Limb and KeepArms == true then

					Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
					local Joint = Instance.new("Glue")
					Joint.Name = "LeftShoulder"
					Joint.Part0 = Torso2
					Joint.Part1 = Limb
					Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					Joint.Parent = Torso2

					local B = Instance.new("Part")
					B.TopSurface = 0
					B.BottomSurface = 0
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1
					B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = Character2
					local W = Instance.new("Weld")
					W.Part0 = Limb
					W.Part1 = B
					W.C0 = CFrame.new(0, -0.5, 0)
					W.Parent = Limb

				end
				local Limb = Character2:FindFirstChild("Right Leg")
				if Limb then

					Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
					local Joint = Instance.new("Glue")
					Joint.Name = "RightHip"
					Joint.Part0 = Torso2
					Joint.Part1 = Limb
					Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					Joint.Parent = Torso2

					local B = Instance.new("Part")
					B.TopSurface = 0
					B.BottomSurface = 0
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1
					B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = Character2
					local W = Instance.new("Weld")
					W.Part0 = Limb
					W.Part1 = B
					W.C0 = CFrame.new(0, -0.5, 0)
					W.Parent = Limb

				end
				local Limb = Character2:FindFirstChild("Left Leg")
				if Limb then

					Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
					local Joint = Instance.new("Glue")
					Joint.Name = "LeftHip"
					Joint.Part0 = Torso2
					Joint.Part1 = Limb
					Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					Joint.Parent = Torso2

					local B = Instance.new("Part")
					B.TopSurface = 0
					B.BottomSurface = 0
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1
					B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = Character2
					local W = Instance.new("Weld")
					W.Part0 = Limb
					W.Part1 = B
					W.C0 = CFrame.new(0, -0.5, 0)
					W.Parent = Limb

				end
				--[
				local Bar = Instance.new("Part")
				Bar.TopSurface = 0
				Bar.BottomSurface = 0
				Bar.formFactor = "Symmetric"
				Bar.Size = Vector3.new(1, 1, 1)
				Bar.Transparency = 1
				Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
				Bar.Parent = Character2
				local Weld = Instance.new("Weld")
				Weld.Part0 = Torso2
				Weld.Part1 = Bar
				Weld.C0 = CFrame.new(0, 0.5, 0)
				Weld.Parent = Torso2
				--]]
			end
			Character2.Parent = workspace
			Debris:AddItem(Character2,5)

			return Character2,Torso2
		end))
	end

	--//=================================\\
	--||	ATTACK FUNCTIONS AND STUFF
	--\\=================================//
	coroutine.resume(coroutine.create(function()
		while wait(0.1) do
			Swait()
			local Int = 0
			local Colours = {Color3.fromRGB(255,0,0),Color3.fromRGB(255,128,0),Color3.fromRGB(255,255,0),Color3.fromRGB(0,255,0),Color3.fromRGB(0,255,255),Color3.fromRGB(0,0,255),Color3.fromRGB(191,0,255),Color3.fromRGB(255,0,191)}
			if Int == #Colours then Int = 0 end
			Int = Int + 1
			for _, c in pairs(Weapon:GetDescendants()) do
				if c.ClassName == "Part" and c.Name == "Eye" then
					c.Color = color
				elseif c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
					c.Color = color

				end
			end
		end
	end))

	function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
		local mesh = IT("SpecialMesh",wave)
		mesh.MeshType = "Sphere"
		mesh.Scale = SIZE
		mesh.Offset = VT(0,0,0)
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				wave.Transparency = wave.Transparency + (1/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end
	function Roar()
		MagicSphere(VT(0,0,0),15,Head.CFrame,"Pearl",VT(5,5,5))
	end
	function Shot()
		ATTACK = true
		Rooted = false
		for i=0, 0.5, 0.22 / Animation_Speed do
			turnto(Mouse.Hit.p)
			Swait()
			local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
			RootJoint.C0 = Clerp(RootJoint.C0,RootCF * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.25 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5 - 2.5 * COS(SINE / 12)), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
		repeat
			for i=0, 0.5, 0.22 / Animation_Speed do
				turnto(Mouse.Hit.p)
				Swait()
				local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
				RootJoint.C0 = Clerp(RootJoint.C0,RootCF * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.25 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5 - 2.5 * COS(SINE / 12)), RAD(0), RAD(-45)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 287142895, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 2})
			local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
			SpawnTrail(Hole.Position,POS)
			if HIT ~= nil then
				if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
					Banish(HIT.Parent)
				end
			end
			local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
			for i=0, 0.5, 0.22 / Animation_Speed do
				turnto(Mouse.Hit.p)
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.25 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5 - 2.5 * COS(SINE / 12)), RAD(0), RAD(-45)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		until KEYHOLD == false
		ATTACK = false
		Rooted = false
		repeat wait() until ATTACK == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if ATTACK == true then
				bp.Position = game.Players.LocalPlayer:GetMouse().Hit.p
			end
		until ATTACK == false
	end

	function wa()
		ATTACK = true
		Rooted = false
		Gun2.Parent = Character
		local x = 0
		for i=0, 0.5, 0.22 / Animation_Speed do
			turnto(Mouse.Hit.p)
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.25 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(90), RAD(90)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
		repeat
			for i=0, 0.5, 0.22 / Animation_Speed do
				turnto(Mouse.Hit.p)
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.25 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(90), RAD(90)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			local Hole2 = CreatePart(3, Gun2, "Metal", 0, 0, "Mid gray", "Eye", VT(0.125,0,0.125),false)
			local HIT,POS = CastProperRay(Hole2.Position, Mouse.Hit.p, 1000, Character)
			SpawnTrail(Hole2.Position,POS)
			if HIT ~= nil then
				if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
					Banish(HIT.Parent)
				end
			end
			local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
			for i=0, 0.5, 0.22 / Animation_Speed do
				turnto(Mouse.Hit.p)
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.25 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(90), RAD(90)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		until KEYHOLD == false
		local Hspin = false
		ATTACK = false
		Rooted = false
		repeat wait() until ATTACK == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if ATTACK == true then
				bp.Position = game.Players.LocalPlayer:GetMouse().Hit.p
			end
		until ATTACK == false
	end

	function shootem()
		ATTACK = true
		Rooted = false
		for i=0, 0.5, 0.22 / Animation_Speed do
			turnto(Mouse.Hit.p)
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.25 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(5)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
		repeat
			for i=0, 0.5, 0.22 / Animation_Speed do
				turnto(Mouse.Hit.p)
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.25 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(5)), 0.25 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 1906350651, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 2})
			local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
			SpawnBruh(Hole.Position,POS)
			local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
			if HIT ~= nil then
				if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
					--BEAN(HIT.Parent)
					CreateSound(2487714799, HIT, 10, 1, false)
					--Outlines(HIT.Parent)
				end
			end
			local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
			for i=0, 0.5, 0.22 / Animation_Speed do
				turnto(Mouse.Hit.p)
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.25 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(5)), 0.25 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		until KEYHOLD == false
		ATTACK = false
		Rooted = false
		repeat wait() until ATTACK == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if ATTACK == true then
				bp.Position = game.Players.LocalPlayer:GetMouse().Hit.p
			end
		until ATTACK == false
	end


	function CreateDebreeRing2(FLOOR,POSITION,SIZE,BLOCKSIZE,SWAIT)
		if FLOOR ~= nil then
			coroutine.resume(coroutine.create(function()
				local PART = CreatePart(3, Effects, "Plastic", 0, 1, "Really black", "DebreeCenter", VT(0,0,0))
				PART.CFrame = CF(POSITION)
				for i = 1, 45 do
					local RingPiece = CreatePart(3, Effects, "Plastic", 0, 0, "Really black", "DebreePart", BLOCKSIZE)
					RingPiece.Material = FLOOR.Material
					RingPiece.Color = FLOOR.Color
					RingPiece.CFrame = PART.CFrame * ANGLES(RAD(0), RAD(i*8), RAD(0)) * CF(SIZE*4, 0, 0) * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
					Debris:AddItem(RingPiece,SWAIT)
				end
				PART:remove()
			end))
		end
	end

	function CreateFlyingDebree2(FLOOR,POSITION,AMOUNT,BLOCKSIZE,SWAIT,STRENGTH)
		if FLOOR ~= nil then
			for i = 1, AMOUNT do
				local DEBREE = CreatePart(3, Effects, "Neon", 0, 0, "Really black", "Debree", BLOCKSIZE, false)
				DEBREE.Material = FLOOR.Material
				DEBREE.Color = FLOOR.Color
				DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
				DEBREE.Velocity = VT(MRANDOM(-STRENGTH,STRENGTH),STRENGTH,MRANDOM(-STRENGTH,STRENGTH))
				coroutine.resume(coroutine.create(function()
					Swait(15)
					DEBREE.Parent = workspace
					DEBREE.CanCollide = true
					Debris:AddItem(DEBREE,SWAIT)
				end))
			end
		end
	end
	function Pure_Heaven()
		chatfunc("The Light of Heaven will make sense!")
		ATTACK = true
		Rooted = true
		for i = 1, 15 do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(25 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-25 - 2.5 * SIN(SINE / 12))), 0.1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
		for i=0, 0.5, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(65 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-65 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
		coroutine.resume(coroutine.create(function()
			local POS = Mouse.Hit.p
			local RAY = CreatePart(3, Effects, "Neon", 0, 0, "Really black", "Strike", VT(0,0,0))
			MakeForm(RAY,"Cyl")
			local SPHERE = CreatePart(3, Effects, "Neon", 0, 0, "Really black", "Strike", VT(0,0,0))
			MakeForm(SPHERE,"Ball")
			local SHIELD = CreatePart(3, Effects, "Neon", 0, 0.5, "Really white", "Strike", VT(0,0,0))
			MakeForm(SHIELD,"Ball")
			SHIELD.CFrame = CF(POS)
			RAY.CFrame = CF(POS)
			SPHERE.CFrame = CF(POS)
			CreateSound(440145570, SPHERE, 15, 0.5, false)
			CreateSound(415700134, SPHERE, 15, 0.5, false)
			for i = 1, 200 do
				Swait()
				WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(SPHERE.Size.X*1.2,5+(i),SPHERE.Size.X*1.2), Transparency = 0, Transparency2 = 1, CFrame = SPHERE.CFrame*ANGLES(RAD(0), RAD(i), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = i, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				RAY.Size = RAY.Size + VT(0.5,0,0.5)
				SPHERE.Size = SPHERE.Size + VT(1.5,1.5,1.5)
				SHIELD.Size = SPHERE.Size + VT(2.5,2.5,2.5)
				ApplyAoE(SPHERE.Position,SPHERE.Size.X/2,true)
			end	
			for i = 1, 45 do
				Swait()
				RAY.Transparency = RAY.Transparency + 1/45
				SPHERE.Transparency = RAY.Transparency 
				SHIELD.Transparency = SPHERE.Transparency + 1/45
			end
			RAY:remove()
			SHIELD:remove()
			SPHERE:remove()
		end))
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0  + 0.25 * COS(SINE / 12)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.15) * ANGLES(RAD(65), RAD(-45), RAD(85)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.15) * ANGLES(RAD(65), RAD(45), RAD(-85)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		ATTACK = false
		Rooted = false
	end
	function printbye(Name)
		local MESSAGES = {"YOU NOT WORTH TO BE ON HEAVEN, ","God don't like Criminal, ","Go to hell Heaven is not a Place you want to go, ","YOU CAN GO TO HEAVEN BUT IT'S SILENT, "}
		chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
	end
	local RightHole = CreatePart(3, Character, "Metal", 0, 0, "Mid gray", "Eye", VT(0.2,0,0.2),false)
	MakeForm(RightHole,"Cyl")
	local LeftHole = CreatePart(3, Character, "Metal", 0, 0, "Mid gray", "Eye", VT(0.2,0,0.2),false)
	MakeForm(LeftHole,"Cyl")

	function Bullet_Rain()
		ATTACK = true
		Rooted = true
		Weapon.Parent = Character
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(5,5,5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame =  Barrel.CFrame, ANGLES(RAD(0), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = colorhehe, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*SIZE) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.6*SIZE, 0.75*SIZE, -0.5*SIZE) * ANGLES(RAD(0), RAD(-25), RAD(12)) * ANGLES(RAD(125 - 2.5 * COS(SINE / 12) + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1.5 / Animation_Speed)
		end
		local DONE = false
		local GATE = nil
		local GATESPIN = true
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0.01 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0.01, 0, 0 + ((1*SIZE) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.3*SIZE, 0.75*SIZE, -0.5*SIZE) * ANGLES(RAD(0), RAD(-180), RAD(12)) * ANGLES(RAD(175 - 2.5 * COS(SINE / 12) + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 2.5 / Animation_Speed)
			until DONE == true
			Swait(10)
			for i = 1, 75 do
				Swait(1.5)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = 1712117848, SoundPitch = 1.5, SoundVolume = 3})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
									ApplyAoE(CFRAME.p,3,0.25,1,2,false)	
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = 213603013, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							ApplyAoE(HITBOD,3,0.25,1,0,false)
						end
					end
				end
			end
			for i = 1, 45 do
				Swait()
				GATE.Size = GATE.Size - VT(3,0,3)
			end
			GATESPIN = false
			GATE:remove()
		end))
		Swait(5)
		local HITFLOOR,HITPOS = Raycast(Mouse.Hit.p, (CF(Mouse.Hit.p, Mouse.Hit.p + VT(0, -1, 0))).lookVector, 15, Character)
		GATE = CreatePart(3, Effects, "Neon", 0, 1, "New Yeller", "Gate", VT(0,0,0))
		local DECAL = IT("Decal",GATE)
		DECAL.Texture = "http://www.roblox.com/asset/?id=1258741631"
		DECAL.Face = "Top"
		GATE.CFrame = CF(HITPOS)
		CreateSound(160772554, GATE, 7, 1.3, false)
		for i = 1, 45 do
			Swait()
			GATE.Size = GATE.Size + VT(3,0,3)
		end
		CreateSound(145080998, Hole, 7, 1, false)
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,2,2), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame*CF(0,-1,0) * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(5,5,5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame =  Barrel.CFrame, ANGLES(RAD(0), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(5,5,5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame =  Barrel.CFrame, ANGLES(RAD(0), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		ATTACK = false
		Rooted = false
		DONE = true
	end

	function DUAL()
		if Mode == "N" then
			for i = 1, 15 do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(25 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-25 - 2.5 * SIN(SINE / 12))), 0.1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			for i=0, 0.5, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(65 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-65 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			sick:Stop()
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.SoundId = "rbxassetid://2372056506"
			sick.TimePosition = 0
			sick:resume()
			Mode = "D" 
			local RightArmGrasp = CreateWeldOrSnapOrMotor("Weld", Handle, RightArm, Handle, CF(0,-1, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0.21, 0))
			Gun2.Parent = nil
			Gun.Parent = nil
		elseif Mode == "S" then
			print("lmao")
		elseif Mode == "D" then	
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			Gun.Parent = Character
			Gun2.Parent = nil
			Mode = "N"
			sick.SoundId = "rbxassetid://1695752879"
		end
	end

	function Shot2()
		ATTACK = true
		Rooted = false
		repeat
			for i=0, 0.08, 0.1 / Animation_Speed do
				Swait()
				turnto(Mouse.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(MRANDOM(-25,25)), RAD(MRANDOM(-25,25)), RAD(MRANDOM(-25,25))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(15)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.5, -0.7) * ANGLES(RAD(90), RAD(90), RAD(MRANDOM(-25,25))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(MRANDOM(-25,25)), RAD(-15)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(MRANDOM(-25,25)), RAD(75), RAD(MRANDOM(-25,25))) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(MRANDOM(-25,25)), RAD(-90), RAD(MRANDOM(-25,25))) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
			SpawnTrail(Hole.Position,POS)
			if HIT ~= nil then
				if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
					Banish(HIT.Parent)
				end
			end
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = Hole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 904440937, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
			local HIT,POS = CastProperRay(Holee.Position, Mouse.Hit.p, 1000, Character)
			SpawnTrail(Holee.Position,POS)
			if HIT ~= nil then
				if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
					Banish(HIT.Parent)
				end
			end
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = Holee.CFrame, MoveToPos = Holee.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = Holee.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 904440937, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Holee.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Holee.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})

			for i=0, 0.08, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(MRANDOM(-25,25)), RAD(MRANDOM(-25,25)),RAD(MRANDOM(-25,25))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(15)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.5, -0.6) * ANGLES(RAD(110), RAD(90), RAD(MRANDOM(-25,25))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.2) * ANGLES(RAD(110), RAD(MRANDOM(-25,25)), RAD(-15)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(MRANDOM(-25,25)), RAD(75), RAD(MRANDOM(-25,25))) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(MRANDOM(-25,25)), RAD(-90), RAD(MRANDOM(-25,25))) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		until KEYHOLD == false
		ATTACK = false
		Rooted = false
	end


	function Shot3()
		ATTACK = true
		Rooted = false
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
		repeat
			for i=0, 0.1, 0.1 / Animation_Speed do
				Swait()
				turnto(Mouse.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			local HIT,POS = CastProperRay(LeftHole.Position, Mouse.Hit.p, 1000, Character)
			if HIT ~= nil then
				if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
					Banish(HIT.Parent)
				end
			end
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = LeftHole2.CFrame, MoveToPos = LeftHole2.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = LeftHole2.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 145080998, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,LeftHole2.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,LeftHole2.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
			local HIT,POS = CastProperRay(LeftHole.Position, Mouse.Hit.p, 1000, Character)
			if HIT ~= nil then
				if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
					Banish(HIT.Parent)
				end
			end
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = LeftHole.CFrame, MoveToPos = LeftHole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = LeftHole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 145080998, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,LeftHole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
			WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,LeftHole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})

			for i=0, 0.1, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0.8) * ANGLES(RAD(90), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0.8) * ANGLES(RAD(90), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		until KEYHOLD == false
		ATTACK = false
		Rooted = false
	end

	function Outlines(TARGET)
		coroutine.resume(coroutine.create(function()
			local T = TARGET:GetChildren()
			for i = 1, #T do
				local child = T[i]
				if child.ClassName == "Part" or child.ClassName == "MeshPart" then
					do
						local clone = child:Clone()
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								clone.Color = color
							end
						end))
						clone.Transparency = 0.5
						clone.Parent = Effects
						clone.Anchored = true
						clone.CanCollide = false
						clone:ClearAllChildren()
						clone.CFrame = child.CFrame
						if clone.Name == "Head" then
							clone.Size = VT(clone.Size.Y, clone.Size.Y, clone.Size.Y)
						end
						if clone.ClassName == "MeshPart" then
							clone.TextureID = ""
						end
						clone.Material = "Neon"
						coroutine.resume(coroutine.create(function()
							for i = 1, 100 do
								Swait()
								clone.Transparency = clone.Transparency + 0.01
								clone.Size = clone.Size + VT(0.001, 0.001, 0.001)
							end
							clone:remove()
						end))
					end
				end
			end
		end))
	end



	function Gates_Of_Darkness()
		chatfunc("Be Darker...")
		CreateSound(0, Torso, 10, 1, false)
		ATTACK = true
		Rooted = true
		for i=0, 0.5, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 1, 0) * ANGLES(RAD(15), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 1, 0) * ANGLES(RAD(15), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		local DONE = false
		local GATE = nil
		local GATESPIN = true
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				if GATE ~= nil then
					GATE.CFrame = GATE.CFrame * ANGLES(RAD(0), RAD(-3), RAD(0))
				end
			until GATESPIN == false
		end))
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.2 - 0.25 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(15), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(15), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			until DONE == true
			Swait(50)
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 35 do
				Swait(4)
				local FIRED = false
				local CHILDREN = workspace:GetDescendants()
				for index, CHILD in pairs(CHILDREN) do
					if CHILD.ClassName == "Model" and CHILD ~= Character then
						local HUM = CHILD:FindFirstChildOfClass("Humanoid")
						if HUM then
							local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							if TORSO then
								if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
									local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
									local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
									WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
									SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
									Banish(CHILD)
									FIRED = true
									break
								end
							end
						end
					end
				end
				if FIRED == false then
					local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 1486538358, SoundPitch = 1, SoundVolume = 6})
					WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(16,8,16), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					SpawnTrail(CFRAME.p,CFRAME*CF(1,1000,1).p)
					local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
					if HITBOD ~= nil then
						if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
							Banish(HITBOD.Parent)
						end
					end
				end
			end
			for i = 1, 45 do
				Swait()
				GATE.Size = GATE.Size - VT(10,0,10)
			end
			GATESPIN = false
			GATE:remove()
		end))
		Swait(15)
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 15, Character)
		GATE = CreatePart(3, Effects, "Neon", 0, 1, "Black", "Gate", VT(0,0,0))
		local DECAL = IT("Decal",GATE)
		DECAL.Texture = "http://www.roblox.com/asset/?id=1258741631"
		DECAL.Face = "Top"
		GATE.CFrame = CF(HITPOS)
		CreateSound(0, GATE, 7, 1.3, false)
		for i = 1, 45 do
			Swait()
			GATE.Size = GATE.Size + VT(10,0,10)
		end
		CreateSound(213603013, RightHole, 7, 1, false)
		CreateSound(213603013, LeftHole, 7, 1, false)
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(8,8,8), Transparency = 0, Transparency2 = 1, CFrame = RightHole.CFrame*CF(0,-1,0) * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(16,0,16), Size2 = VT(8,8,8), Transparency = 0, Transparency2 = 1, CFrame = LeftHole.CFrame*CF(0,-1,0) * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		ATTACK = false
		Rooted = false
		DONE = true
	end

	function kool()
		if Mode == "N" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 15
			sick.SoundId = "rbxassetid://3164389653"
			dog.Parent = Character
			Mode = "K"
		elseif Mode == "K" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 0
			sick.SoundId = "rbxassetid://1695752879"
			dog.Parent = nil
			Mode = "N"
		else
			print("asd")
		end
	end

	function Toxic()
		if Mode == "N" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 15
			sick.SoundId = "rbxassetid://347151332"
			dog.Parent = Character
			Mode = "T"
		elseif Mode == "T" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 0
			sick.SoundId = "rbxassetid://1695752879"
			dog.Parent = nil
			Mode = "N"
		else
			print("asd")
		end
	end

	function Broken()
		if Mode == "N" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 15
			sick.SoundId = "rbxassetid://885996042"
			dog.Parent = Character
			Mode = "B"
		elseif Mode == "B" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 0
			sick.SoundId = "rbxassetid://1695752879"
			dog.Parent = nil
			Mode = "N"
		else
			print("asd")
		end
	end

	function SuperRainbow()
		if Mode == "N" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 15
			sick.SoundId = "rbxassetid://1076836481"
			dog.Parent = Character
			Mode = "SR"
		elseif Mode == "SR" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 0
			sick.SoundId = "rbxassetid://1695752879"
			dog.Parent = nil
			Mode = "N"
		else
			print("asd")
		end
	end


	function Cream()
		if Mode == "N" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 15
			sick.SoundId = "rbxassetid://1138145518"
			dog.Parent = Character
			Mode = "C"
		elseif Mode == "C" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 0
			sick.SoundId = "rbxassetid://1695752879"
			dog.Parent = nil
			Mode = "N"
		else
			print("asd")
		end
	end

	function Eror()
		if Mode == "N" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 15
			sick.SoundId = "rbxassetid://481104377"
			dog.Parent = Character
			Mode = "ER"
		elseif Mode == "ER" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 0
			sick.SoundId = "rbxassetid://1695752879"
			dog.Parent = nil
			Mode = "N"
		else
			print("asd")
		end
	end

	function BadTime()
		if Mode == "N" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 15
			sick.SoundId = "rbxassetid://1334822627"
			dog.Parent = Character
			Mode = "SANS"
		elseif Mode == "SANS" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			sick.TimePosition = 0
			sick.SoundId = "rbxassetid://1695752879"
			dog.Parent = nil
			Mode = "N"
		else
			print("asd")
		end
	end

	function GoldenPunch()
		ATTACK = true
		Rooted = false
		local SPEED = Speed
		Speed = 8
		chatfunc("DIE NUB EZ LMFAO")
		CreateSound("169445572", RightArm, 10, 1.1)
		for i=0, 0.01, 0.01 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			MagicSphere(VT(1,1,1),15,RightArm.CFrame * CF(MRANDOM(-3,3),MRANDOM(-3,3),MRANDOM(-3,3)),"Deep orange",VT(-1/15,-1/15,-1/15))
			MagicSphere(VT(2,2,2),15,RightArm.CFrame * CF(MRANDOM(-3,3),MRANDOM(-3,3),MRANDOM(-3,3)),"Gold",VT(-2/15,-2/15,-2/15))
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(-85)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(85)), 0.2 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90+(MRANDOM(-45,45)/10)), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 3 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(-85)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
		for i=0, 0.01, 0.01 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(65)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(25), RAD(0), RAD(35)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(65)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-20), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		local PART = CreatePart(3, Effects, "Neon", 0, 0.8, "Gold", "Punch", VT(50,50,50),false)
		PART.CFrame = RootPart.CFrame * CF(0,0,-25)
		PART.Shape = "Ball"
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = RootPart.CFrame.lookVector*600
		bv.Parent = PART
		bv.Name = "PROJECTILEVELOCITY"
		CreateWave(VT(1,5,1),55,RootPart.CFrame * CF(0,0,-6)*ANGLES(RAD(-90),RAD(0),RAD(0)),true,-1,"Gold",VT(2.5,0.2,2.5))
		CreateWave(VT(1,5,1),55,RootPart.CFrame * CF(0,0,-6)*ANGLES(RAD(-90),RAD(0),RAD(0)),true,1,"Gold",VT(3,0.2,3))
		CreateSwirl(VT(3,5,3),75,RootPart.CFrame * CF(0,0,-15)*ANGLES(RAD(-90),RAD(0),RAD(0)),true,-1,"Gold",VT(2,0.6,2))
		CreateSwirl(VT(3,5,3),75,RootPart.CFrame * CF(0,0,-15)*ANGLES(RAD(-90),RAD(0),RAD(0)),true,1,"Gold",VT(2.2,0.6,2.2))
		CreateSound("414517163", Effects, 10, MRANDOM(7, 12) / 10)
		coroutine.resume(coroutine.create(function()
			for i = 1, 10 do
				Swait()
				PART.Transparency = PART.Transparency + 0.2/10
				PART.Size = PART.Size + VT(5,5,5)
				killnearest(PART.Position,PART.Size.Y/2+15,100,RootPart.CFrame)
			end
			PART:Destroy()
		end))
		for i=0, 0.01, 0.01 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(15), RAD(0), RAD(95)), 2 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(25), RAD(0), RAD(35)), 3 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 3 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-70), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 3 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.8 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 3 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 3 / Animation_Speed)
		end
		Speed = SPEED
		ATTACK = false
		Rooted = false
	end


	function Taunt()
		ATTACK = true
		Rooted = true
		Weapon.Parent = nil
		for i = 1, 3 do
			for i = 0, 0.7, 0.14 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(15)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(145)) * ANGLES(RAD(0), RAD(90), RAD(0)) * RIGHTSHOULDERC0, 0.5)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-145)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * LEFTSHOULDERC0, 0.5)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.25 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.25 / Animation_Speed)
			end
			for i = 0, 0.7, 0.14 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-15)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(145)) * ANGLES(RAD(0), RAD(90), RAD(0)) * RIGHTSHOULDERC0, 0.5)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-145)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * LEFTSHOULDERC0, 0.5)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.25 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.25 / Animation_Speed)
			end
		end
		chatfunc("Just go away.")
		Weapon.Parent = Character
		ATTACK = false
		Rooted = false
	end

	Mode = "N"
	function Modechange()
		if Mode == "N" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			Mode = "S"
			sick.SoundId = "rbxassetid://3341449550"
			sick.TimePosition = 0
			sick:resume()
			Roar()
		elseif Mode == "D" then
			print("wjh")
		elseif Mode == "S" then
			WACKYEFFECT({TIME = 30 ,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 743499393, SoundPitch = 1.05, SoundVolume = 15})
			Mode = "N"
			sick.SoundId = "rbxassetid://1695752879"
		end
	end

	--//=================================\\
	--||	  ASSIGN THINGS TO KEYS
	--\\=================================//

	function MouseDown(Mouse)
		if ATTACK == false then
		end
	end

	function MouseUp(Mouse)
		HOLD = false
	end



	function KeyDown(Key)
		KEYHOLD = true
		if Key == "z" and ATTACK == false then
			if Mode == "N" then
				Shot()
			elseif Mode == "D" then
				wa()
			elseif Mode == "K" then
				E()
			elseif Mode == "S" then
				shootem()
			elseif Mode == "T" then
				E()
			elseif Mode == "C" then
				shootem()
			elseif Mode == "SR" then
				E()
			elseif Mode == "B" then
				shootem()
			elseif Mode == "SANS" then
				E()
			elseif Mode == "ER" then
				Shot()
			end
		end

		if Key == "f" and ATTACK == false then
			DUAL()
		end

		if Key == "r" and ATTACK == false and Mode == "D" then
			GoldenPunch()
		end

		if Key == "j" and ATTACK == false then
			SuperRainbow()
		end

		if Key == "h" and ATTACK == false then
			Eror()
		end

		if Key == "k" and ATTACK == false then
			Broken()
		end

		if Key == "e" and ATTACK == false then
			BadTime()
		end

		if Key == "t" and ATTACK == false then
			Taunt()
		end

		if Key == "c" and ATTACK == false then
			Bullet_Rain()
		end

		if Key == "q" and ATTACK == false then
			Modechange()
		end

		if Key == "x" and ATTACK == false then
			Pure_Heaven()
		end

		if Key == "g" and ATTACK == false then
			kool()	
		end

		if Key == "y" and ATTACK == false then
			Toxic()
		end
		if Key == "u" and ATTACK == false then
			Cream()
		end

		if Key == "v" and ATTACK == false then
			Gates_Of_Darkness()
		end
	end

	function KeyUp(Key)
		KEYHOLD = false
	end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

	--//=================================\\
	--\\=================================//


	Gun.Parent = Character
	function unanchor()
		if UNANCHOR == true then
			g = Character:GetChildren()
			for i = 1, #g do
				if g[i].ClassName == "Part" then
					g[i].Anchored = false
				end
			end
		end
	end


	--//=================================\\
	--||	WRAP THE WHOLE SCRIPT UP
	--\\=================================//

	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)

	sick.AncestryChanged:Connect(function()
		sick.Parent = Character
	end)

	local FF = IT("ForceField", Character)
	FF.Visible = false


	local spinc=0
	coroutine.resume(coroutine.create(function()
		while wait() do
			spinc=spinc+1+sick.PlaybackLoudness/50
			WACKYEFFECT({Time = 12.5, EffectType = "Wave", Size = VT(5,1,5), Size2 = VT(5,1,5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-2.9,0)*CFrame.Angles(RAD(0),RAD(spinc),RAD(0)), RotationX = 0, RotationY = 0--[[sick.PlaybackLoudness/50]], RotationZ = 0, Material = "Neon", Color = color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			GEARWELD.C0 = GEARWELD.C0 * ANGLES(RAD(0), RAD(0), RAD(0.1+sick.PlaybackLoudness/40))
			GEARWELD2.C0 = GEARWELD2.C0 * ANGLES(RAD(0), RAD(0), RAD(-0.1-sick.PlaybackLoudness/40))
		end
	end))



	while true do
		Swait()
		script.Parent = WEAPONGUI
		ANIMATE.Parent = nil
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		SINE = SINE + CHANGE
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
		if ANIM == "Walk" and TORSOVELOCITY > 1 then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		end
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(25))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(25))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			ANIM = "Idle"
			if ATTACK == false then
				if Mode == "N" then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5 - 2.5 * COS(SINE / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.5, -0.80) * ANGLES(RAD(90), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				elseif Mode == "K" then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 15)), RAD(0), RAD(20)), 3 / Animation_Speed)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0- 0.1 * COS(SINE / 30), 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0+ 5 * COS(SINE / 30)), RAD(0), RAD(-20)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(-15))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(30), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4+2.5 * COS(SINE / 30)), RAD(0), RAD(0+ 5 * COS(SINE / 30))), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4-2.5 * COS(SINE / 30)), RAD(0), RAD(0- 5 * COS(SINE / 30))), 1 / Animation_Speed)
				elseif Mode == "D" then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 4.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 22), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 22), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				elseif Mode == "S" then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5 - 2.5 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.60) * ANGLES(RAD(180), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(75), RAD(0)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.8, 0.4, -0.7) * ANGLES(RAD(90), RAD(0), RAD(86)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				elseif Mode== "C" then
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -1 + 0.1 * COS(SINE / 24)) * ANGLES(RAD(45), RAD(0), RAD(0)), 0.2 / Animation_Speed*3)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / Animation_Speed)
					if MRANDOM(1,7) == 1 then
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
					end					
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.35, 0) * ANGLES(RAD(90), RAD(25), RAD(45)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, -0.1 * Player_Size) * ANGLES(RAD(95), RAD(25), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3 - 0.1 * COS(SINE / 24), -1 - 0.1 * COS(SINE / 24)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.2, 0.2 - 0.1 * COS(SINE / 24), -0.4 - 0.1 * COS(SINE / 24)) * ANGLES(RAD(45), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
				elseif Mode == "SANS" then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				elseif Mode== "SR" then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2* SIN(SINE / 40)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(30), RAD(-1), RAD(23+4* SIN(SINE / 73))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(30), RAD(1), RAD(-23+4* SIN(SINE / 73))) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0+0.25* SIN(SINE / 71), -0.35+0.25* SIN(SINE / 68), 5.5+1* SIN(SINE / 51)) * ANGLES(RAD(35-2.5* SIN(SINE / 46)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(80+10* SIN(SINE / 78)), RAD(0)) * ANGLES(RAD(-3+1* SIN(SINE / 58)), RAD(0), RAD(2.5+8 * SIN(SINE / 43))), 0.8 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(0), RAD(-80-10* SIN(SINE / 81)), RAD(0)) * ANGLES(RAD(-3+1* SIN(SINE / 63)), RAD(0), RAD(0+15 * SIN(SINE / 49))), 0.8 / Animation_Speed)
				elseif Mode == "B" then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 45) + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(-10 + MRANDOM(-4,4))), 3 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-15+ 5 * COS(SINE / 30) + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(12 + MRANDOM(-4,4))) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.15 + 0.12 * COS(SINE / 45), -0.05 + 0.1 * COS(SINE / 45)) * ANGLES(RAD(-15 - 6 * COS(SINE / 45)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4, 0.8, 0) * ANGLES(RAD(165 + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(25 + MRANDOM(-4,4))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 45), -0.01) * ANGLES(RAD(-15- 6 * COS(SINE / 45)), RAD(80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 0.8 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 45), -0.01) * ANGLES(RAD(-15- 6 * COS(SINE / 45)), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				elseif Mode == "ER" then
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 1.3 + 0.5 * COS(SINE / 24)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.4 / Animation_Speed*3)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-5.5,5.5)), RAD(MRANDOM(-5.5,5.5)), RAD(MRANDOM(-5.5,5.5))), 0.2)			
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.3, 0.5 + 0.15 * COS(SINE / 24), 0.2) * ANGLES(RAD(-45), RAD(0), RAD(-30))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.75 + 0.15 * COS(SINE / 24), 0) * ANGLES(RAD(180), RAD(0), RAD(27)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 24), 0) * ANGLES(RAD(-25), RAD(78), RAD(0)) * ANGLES(RAD(-5 * SIN(SINE / 24)), RAD(0), RAD(0)), 0.4 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.3 - 0.1 * COS(SINE / 24), -0.5) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(-5 * SIN(SINE / 24)), RAD(0), RAD(0)), 0.4 / Animation_Speed)
				elseif Mode == "T" then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20+ 5 * COS(SINE / 77)), RAD(0+ 5 * COS(SINE / 74)), RAD(-50+ 5 * COS(SINE / 59))), 0.6 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180+ 5 * COS(SINE / 68)), RAD(35+ 7.5 * COS(SINE / 83)), RAD(0+ 5 * COS(SINE / 67))) * RIGHTSHOULDERC0, 0.6 / Animation_Speed)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 35)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.6 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, 0.3) * ANGLES(RAD(-25+ 7.5 * COS(SINE / 55)), RAD(0+ 5 * COS(SINE / 73)), RAD(32+ 7.5 * COS(SINE / 61))) * LEFTSHOULDERC0, 0.6 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 35), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.6 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 35), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.6 / Animation_Speed)
				end
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				if Mode == "D" or Mode == "K" then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
				elseif Mode == "SANS" then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, -0.1*SIZE) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(15 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 1/ Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / WALKSPEEDVALUE)), RAD(-55 + 2.5 * SIN(SINE / WALKSPEEDVALUE))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / WALKSPEEDVALUE)), RAD(55 - 2.5 * SIN(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
				else
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.5, -0.80) * ANGLES(RAD(90), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				end
			end
		end
		unanchor()
		Humanoid.MaxHealth = 16e+16
		Humanoid.Health = 16e+16
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
	end

	--//=================================\\
	--\\=================================//






	--//====================================================\\--
	--||			  		 END OF SCRIPT
	--\\====================================================//--

	-------------------------------------------------
	print("Done!")


end)

Button_7.MouseButton1Down:Connect(function()
	--//====================================================\\--
	--||                       BASIS
	--\\====================================================//--

	local script = game:GetObjects("rbxassetid://6027608605")[1]

	local MODULE = script
	local CHARACTER = game.Players.LocalPlayer.Character["Dummy"]
	local PLAYER = game:GetService("Players").LocalPlayer
	local HUM = CHARACTER.Humanoid
	--local REMOTE = MODULE.Event

	local ROOT = HUM.Torso
	local HEAD = CHARACTER.Head
	local TORSO = CHARACTER.Torso
	local RIGHTARM = CHARACTER["Right Arm"]
	local LEFTARM = CHARACTER["Left Arm"]
	local RIGHTLEG = CHARACTER["Right Leg"]
	local LEFTLEG = CHARACTER["Left Leg"]
	local ROOTJOINT = ROOT["RootJoint"]
	local NECK = TORSO["Neck"]
	local RIGHTSHOULDER = TORSO["Right Shoulder"]
	local LEFTSHOULDER = TORSO["Left Shoulder"]
	local RIGHTHIP = TORSO["Right Hip"]
	local LEFTHIP = TORSO["Left Hip"]
	local MOUSEPOS = ROOT.Position

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor

	--//====================================================\\--
	--||                       FE CODE
	--\\====================================================//--



	--//====================================================\\--
	--||                  BACKGROUND VALUES
	--\\====================================================//--

	local ANIM_SPEED = 3
	local MOUSE = PLAYER:GetMouse()
	local MOUSEPOS = MOUSE.Hit.p
	local FRAME_SPEED = 1 / 60 -- (1 / 30) OR (1 / 60)
	local CHANGE = 2 / ANIM_SPEED
	local DAMAGEMULTIPLIER = 1
	local ANIM = "Idle"
	local KEYHOLD = false
	local MOUSEHOLD = false
	local SINE = 0
	local ATTACKING = false
	local Debris = game:GetService("Debris")
	local Effects = IT("Folder",CHARACTER)
	Effects.Name = "FXFolder"
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local BGM = 213546066
	local BOMB = 2671146857
	local STORED = 1000000000000

	--//====================================================\\--
	--||                     HEARTBEAT
	--\\====================================================//--

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = FRAME_SPEED
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	--//====================================================\\--
	--||                       CLERP
	--\\====================================================//--

	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then 
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	--//====================================================\\--
	--||                     FUNCTIONS
	--\\====================================================//--

	function WeldParts(A,B)
		local WLD = IT("ManualWeld")
		WLD.Part0 = A
		WLD.Part1 = B
		WLD.C1 = B.CFrame:inverse() * A.CFrame
		WLD.Parent = A
		return WLD
	end

	--NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
	function NewSound(TABLE)
		local ID = "rbxassetid://"..(TABLE.ID or 0)
		local PARENT = (TABLE.PARENT or ROOT)
		local VOLUME = (TABLE.VOLUME or 0.5)
		local PITCH = (TABLE.PITCH or 1)
		local LOOP = (TABLE.LOOP or false)
		local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
		local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
		local PLAYING = (TABLE.PLAYING or true)
		local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
		local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
		if ID ~= "rbxassetid://0" then
			local SOUND = IT("Sound",PARENT)
			SOUND.SoundId = ID
			SOUND.Volume = VOLUME
			SOUND.Pitch = PITCH
			SOUND.Looped = LOOP
			SOUND.MaxDistance = MAXDISTANCE
			SOUND.EmitterSize = EMITTERSIZE
			SOUND.PlayOnRemove = PLAYONREMOVE
			if DOESDEBRIS == true and PLAYING == true and LOOP == false then
				Debris:AddItem(SOUND,SOUND.TimeLength+5)
			end
			if PLAYING == true then
				SOUND:Play()
			end
			return SOUND
		end
	end

	function ManSlaughter(MAN)

	end

	function AreaOfEffect(AREA,RANGE,FLING,RETURN)
		local HIT = {}
		for index, CHILD in pairs(workspace:GetChildren()) do
			if CHILD:FindFirstChildOfClass("Humanoid") then
				local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
				local ROOT = HUMAN.Torso
				if ROOT then
					if (ROOT.Position - AREA).Magnitude <= RANGE then
						if RETURN == true then
							if CHILD ~= CHARACTER then
								table.insert(HIT,{CHILD,HUMAN,ROOT})
							end
						else
							if CHILD ~= CHARACTER then
								ManSlaughter(CHILD)
							end
							Debris:AddItem(BV,0.05)
						end
					end
				end
			end
		end
		if RETURN == true then
			return HIT
		end
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = ROOT.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function CameraShake(AREA,RANGE,SHAKE,TIMER)
		for index, CHILD in pairs(workspace:GetChildren()) do
			if CHILD:FindFirstChildOfClass("Humanoid") then
				local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
				local ROOT = HUMAN.Torso
				if ROOT and game.Players:GetPlayerFromCharacter(CHILD) then
					if (ROOT.Position - AREA).Magnitude <= RANGE then
						if CHILD:FindFirstChild("CamShake") then
							Debris:AddItem(CHILD:FindFirstChild("CamShake"),0.05)
						end
						local CAMSHAKE = script.CamShake:Clone()
						CAMSHAKE.Parent = CHILD
						local TIMER_V = IT("NumberValue",CAMSHAKE)
						TIMER_V.Name = "Timer"
						TIMER_V.Value = TIMER
						local SHAKE_V = IT("NumberValue",CAMSHAKE)
						SHAKE_V.Name = "Shake"
						SHAKE_V.Value = SHAKE
						CAMSHAKE.Disabled = false
						Debris:AddItem(CAMSHAKE,15)
					end
				end
			end
		end
	end

	--//====================================================\\--
	--||                     CHARACTER
	--\\====================================================//--

	local HELMET = MODULE.Helmet
	HELMET.Parent = CHARACTER
	for index, CHILD in pairs(CHARACTER:GetChildren()) do
		if CHILD ~= ROOT then
			if CHILD:IsA("Accessory") then
				CHILD:Remove()
			end
		end
	end
	local FACE = HEAD.face
	FACE.Texture = "rbxassetid://559113097"
	HELMET.CFrame = HEAD.CFrame*CF(0,0.5,0)
	HELMET.Anchored = false
	WeldParts(HEAD,HELMET)
	local BAZOOKA = MODULE.Bazooka
	BAZOOKA.Parent = CHARACTER
	BAZOOKA.Anchored = false
	local GRIP = IT("Motor6D")
	GRIP.Part0 = RIGHTARM
	GRIP.Part1 = BAZOOKA
	GRIP.C0 = CF(0,-1,-0.5)*ANGLES(RAD(-90),0,0)*CF(0,0,1.85)
	local G_C0 = GRIP.C0
	GRIP.Parent = RIGHTARM
	for i = 1, 15 do
		local FACE = CreatePart(3, CHARACTER, "Fabric", 0, 0+(i-1)/15.2, "Dark stone grey", "FaceGradient", VT(1.01,0.58,1.01),false)
		FACE.Color = C3(0,0,0)
		HEAD:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
		FACE.CFrame = HEAD.CFrame*CF(0,0.3-(i-1)/35,0)
		WeldParts(HEAD,FACE)
	end
	local MISSILE = MODULE.Missile
	MISSILE.Parent = nil
	local GUI = MODULE.ControlsGUI
	GUI.Parent = PLAYER.PlayerGui
	GUI.ToggleButton.MouseButton1Click:Connect(function()
		if GUI.ToggleButton.Controls.Visible == false then
			GUI.ToggleButton.Controls.Visible = true
		elseif GUI.ToggleButton.Controls.Visible == true then
			GUI.ToggleButton.Controls.Visible = false
		end
	end)
	local STOREDGUI = GUI.ToggleButton.Stored
	STOREDGUI.Text = "STORED: "..STORED
	function AddTo(ADD)
		STORED = STORED + ADD
		STOREDGUI.Text = "STORED: "..STORED
	end

	local hat = game:GetService("Players").LocalPlayer.Character["Back Attack Missle Launcher"]

	hat.Handle.AccessoryWeld:Destroy()

	local function align(part0, part1)
		part1.Transparency = 1
		part0.Size = Vector3.new(1,1,1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0.5, 0.1, 0) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(-43, 90, 0) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	align(hat.Handle,BAZOOKA)

	--//====================================================\\--
	--||                     ABILITIES
	--\\====================================================//--

	function Fire_in_the_hole()
		if STORED > 0 then
			ATTACKING = true
			repeat
				for i=0, 0.06, 0.1 / ANIM_SPEED do
					Swait()
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				end
				AddTo(-1)
				coroutine.resume(coroutine.create(function()
					local GOTO = MOUSE.Hit.p
					local ROCKET = MISSILE:Clone()
					ROCKET.Parent = Effects
					ROCKET.CFrame = CF(BAZOOKA.CFrame*CF(0,0,-2).p,GOTO)
					NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
					NewSound({ID = 440145223,PARENT = ROCKET,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
					for i = 1, 200 do
						Swait()
						local HIT,POS = Raycast(ROCKET.Position,ROCKET.CFrame.lookVector,5,CHARACTER)
						if HIT then
							ROCKET.CFrame = CF(POS)
							break
						end
						ROCKET.CFrame = ROCKET.CFrame*CF(0,0,-4)
					end
					ROCKET.Transparency = 1
					ROCKET.Hind:Remove()
					ROCKET.CFrame = CF(ROCKET.Position)
					ROCKET.Size = VT(0,0,0)
					NewSound({ID = 142070127,PARENT = ROCKET,VOLUME = 7,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 300,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
					for index, CHILD in pairs(script.Grenade:GetChildren()) do
						local C = CHILD:Clone()
						C.Parent = ROCKET
						C:Emit(125)
					end
					CameraShake(ROCKET.Position,50,125,70)
					AreaOfEffect(ROCKET.Position,35,200,false)
					Debris:AddItem(ROCKET,2)
				end))
				for i=0, 0.025, 0.1 / ANIM_SPEED do
					Swait()
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(200), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				end
			until MOUSEHOLD == false or STORED <= 0
			if STORED <= 0 then
				STORED = 0
				STOREDGUI.Text = "STORED: 0"
			end
			ATTACKING = false
		end
	end
	function Store()
		HUM.WalkSpeed = 0
		HUM.JumpPower = 0
		ATTACKING = true
		repeat
			for i=0, 0.01, 0.1 / ANIM_SPEED do
				Swait()
				GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			end
			local ROCKET = MISSILE:Clone()
			ROCKET.Anchored = false
			ROCKET:ClearAllChildren()
			ROCKET.CFrame = LEFTARM.CFrame*CF(0,-1,0) * ANGLES(RAD(0), RAD(90), RAD(0))
			ROCKET.Parent = CHARACTER
			WeldParts(ROCKET,LEFTARM)
			for i=0, 0.02, 0.1 / ANIM_SPEED do
				Swait()
				GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.675, 0.45, 0.3) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			end
			for i=0, 0.02, 0.1 / ANIM_SPEED do
				Swait()
				GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			end
			NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 1,PITCH = MRANDOM(9,11)/6,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
			for i=0, 0.05, 0.1 / ANIM_SPEED do
				Swait()
				GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-15)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.75, 0.45, -0.1) * ANGLES(RAD(45), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-0.9, 0.5, -0.75) * ANGLES(RAD(60), RAD(0), RAD(37.5)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
			end
			ROCKET:Remove()
			BAZOOKA.Face.Pop:Emit(5)
			AddTo(1)
		until KEYHOLD == false
		ATTACKING = false
		HUM.WalkSpeed = 100
		HUM.JumpPower = 50
	end

	function Dance()
		HUM.WalkSpeed = 0
		HUM.JumpPower = 0
		ATTACKING = true
		local REMOVETRACK = false
		local TRACK = nil
		if ROOT:FindFirstChild("BGM_MUSIC") then
			TRACK = ROOT:FindFirstChild("BGM_MUSIC")
			TRACK.Volume = 5
		else
			TRACK = NewSound({ID = BOMB,PARENT = ROOT,VOLUME = 5,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
			REMOVETRACK = true
		end
		TRACK.SoundId = "rbxassetid://"..BOMB
		TRACK:Play()
		local DONEWITHDANCING = false
		local NC = mouse.KeyDown:connect(function(key)
			key=key:lower()
			local V2 = key
			if V2 == "m" then
				DONEWITHDANCING = true
				ATTACKING = false
				if REMOVETRACK == true then
					TRACK:Remove()
				else
					TRACK:Play()
					TRACK.Volume = 1.25
					TRACK.SoundId = "rbxassetid://"..BGM
				end
			end
		end)
		local I = 0
		local RAVE = IT("PointLight",ROOT)
		RAVE.Brightness = 25
		RAVE.Color = BrickColor.random().Color
		repeat
			I = I + 2
			Swait()
			RAVE.Color = BrickColor.random().Color
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0 - 0.32 * SIN(I / 10), 0, -0.55 - 0.05 * COS(I / 5)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(170), RAD(10), RAD(-35 * COS(I/10)))  *CF(0,-1,0) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(170), RAD(-10), RAD(-35 * COS(I/10))) * CF(0,-1,0) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1.35, -0.475 + 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-12 - 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.35, -0.475 - 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-12 + 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
		until DONEWITHDANCING == true
		RAVE:Remove()
		NC:Disconnect()
		if REMOVETRACK == true then
			TRACK:Remove()
		else
			TRACK:Play()
			TRACK.Volume = 1.25
			TRACK.SoundId = "rbxassetid://"..BGM
		end
		ATTACKING = false
		HUM.WalkSpeed = 100
		HUM.JumpPower = 50
	end

	--//====================================================\\--
	--||                       WRAP
	--\\====================================================//--

	MOUSE.Button1Down:connect(function()
		MOUSEHOLD = true
		if ATTACKING == false then
			Fire_in_the_hole()
		end
	end)

	MOUSE.Button1Up:connect(function()
		MOUSEHOLD = false
	end)

	MOUSE.KeyDown:connect(function(key)
		key=key:lower()
		local V2 = key
		KEYHOLD = true
		if V2 == "z" then
			Store()
		elseif V2 == "m" then
			Dance()
		elseif V2 == "t" then
			NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		elseif V2 == "e" then
			if ROOT:FindFirstChild("BGM_MUSIC") then
				ROOT:FindFirstChild("BGM_MUSIC"):Remove()
			else
				local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				M.Name = "BGM_MUSIC"
			end
		end
	end)

	MOUSE.KeyUp:connect(function()
		KEYHOLD = false
	end)

--[[
REMOTE.OnServerEvent:Connect(function(PLR,V1,V2)
	if PLR == PLAYER and ANIM ~= "Sit" then
		--if V1 == "MousePositionUpdate" then
			--MOUSEPOS = V2
		if V1 == "KeyUp" then
			KEYHOLD = false
		elseif V1 == "MouseUp" then
			MOUSEHOLD = false
		end
		if ATTACKING == false then
			if V1 == "MouseDown" then
				MOUSEHOLD = true
				Fire_in_the_hole()
			elseif V1 == "KeyDown" then
				KEYHOLD = true
				if V2 == "z" then
					Store()
				elseif V2 == "m" then
					Dance()
				elseif V2 == "t" then
					NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif V2 == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
			end
		end
	end
end)
]]--

	local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
	M.Name = "BGM_MUSIC"
	HUM.WalkSpeed = 100
	while true do
		Swait()
		local MOUSEPOS = MOUSE.Hit.p
		SINE = SINE + CHANGE
		if CHARACTER:FindFirstChild("Animate") then
			CHARACTER:FindFirstChild("Animate"):Destroy()
		end
		if CHARACTER:FindFirstChild("Sound") then
			CHARACTER:FindFirstChild("Sound"):Destroy()
		end
		for _,v in next, HUM:GetPlayingAnimationTracks() do
			v:Stop();
		end
		local TORSOVELOCITY = (ROOT.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = ROOT.Velocity.y
		local HITFLOOR = Raycast(ROOT.Position, (CF(ROOT.Position, ROOT.Position + VT(0, -1, 0))).lookVector, 4+HUM.HipHeight, CHARACTER)
		local WALKSPEEDVALUE = 0.5
		local SITTING = HUM.Sit
		if ANIM == "Walk" and TORSOVELOCITY > 1 and SITTING == false then
			RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 0.875 - 0.3 * SIN(SINE / WALKSPEEDVALUE), -0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RIGHTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
			LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 0.875 + 0.3 * SIN(SINE / WALKSPEEDVALUE), 0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LEFTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
		elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) or SITTING == true then
			RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
			LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
		end
		if ATTACKING == false then
			GRIP.C0 = Clerp(GRIP.C0, G_C0, 1.5 / ANIM_SPEED)
		end
		if SITTING == false then
			if HITFLOOR then
				if TORSOVELOCITY < 1 and HITFLOOR ~= nil then
					ANIM = "Idle"
					if ATTACKING == false then
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 6)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(100), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25 - 2.5 * COS(SINE / 6))) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					end
				elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
					ANIM = "Walk"
					if ATTACKING == false then
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.05 + 0.05 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(135), RAD(0), RAD(5 + 2.5 * COS(SINE / WALKSPEEDVALUE))) * RIGHTSHOULDERC0, 2 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(-25 - 2.5 * COS(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 2 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1 , -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-15)), 2 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(15)), 2 / ANIM_SPEED)
					end
				end
			else
				if TORSOVERTICALVELOCITY > 0 then
					ANIM = "Jump"
					if ATTACKING == false then
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(10)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 1 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
					end
				else
					ANIM = "Fall"
					if ATTACKING == false then
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / ANIM_SPEED)
					end
				end
			end
		else
			ANIM = "Sit"
			if ATTACKING == false then
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.65, 0) * ANGLES(RAD(50), RAD(-10), RAD(45))*CF(0,-0.25,0) * LEFTSHOULDERC0, 1.25 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.25, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.25 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.25, -1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.25 / ANIM_SPEED)
			end
		end
	end
end)

Button_8.MouseButton1Down:Connect(function()
	plr = game.Players.LocalPlayer
	char = plr.Character["Dummy"]
	hum = char:FindFirstChildOfClass'Humanoid'
	local cam = game.Workspace.CurrentCamera
	Camera = cam
	local CamInterrupt = false
	local TwoD = false
	local TargetInfo = {nil, nil}
	cam.CameraType = "Custom"
	t = char.Torso
	h = char.Head
	ra = char["Right Arm"]
	la = char["Left Arm"]
	rl = char["Right Leg"]
	ll = char["Left Leg"]
	tors = char.Torso
	lleg = char["Left Leg"]
	root = char.HumanoidRootPart
	hed = char.Head
	rleg = char["Right Leg"]
	rarm = char["Right Arm"]
	larm = char["Left Arm"]
	radian = math.rad
	random = math.random
	Vec3 = Vector3.new
	Inst = Instance.new
	cFrame = CFrame.new
	Euler = CFrame.fromEulerAnglesXYZ
	vt = Vector3.new
	bc = BrickColor.new
	br = BrickColor.random
	it = Instance.new
	cf = CFrame.new
	local mouse = plr:GetMouse()

	local ODers = {}

	local AllowRape = true;
	local AllowCata = true;

	local Booleans = {
		CamFollow = true,
		GyroUse = true
	}

	function lerp(object, newCFrame, alpha)
		return object:lerp(newCFrame, alpha)
	end

	local Directer = Inst("BodyGyro", root)
	Directer.MaxTorque = Vec3(0, 0, 0)
	Directer.P = 600000
	local CPart = Inst("Part")
	CPart.Anchored = true
	CPart.CanCollide = false
	CPart.Locked = true
	CPart.Transparency = 1

	local rainbowmode = false
	local chaosmode = false
	local glitchymode = false
	kan = Instance.new("Sound",char)
	kan.Volume = 1.25
	kan.TimePosition = 0
	kan.PlaybackSpeed = 1
	kan.Pitch = 1
	kan.SoundId = "rbxassetid://1564523997"
	kan.Name = "wrecked"
	kan.Looped = true
	kan:Play()

	local MID = "rbxassetid://1564523997";
	local Pitch = 1;

	function newTheme(ID,timepos,pitch,vol)
		local kanz = kan
		--kanz:Stop()
		--kanz.Volume = vol
		--kanz.TimePosition = timepos
		kanz.PlaybackSpeed = pitch
		kanz.Pitch = pitch
		kanz.SoundId = ID
		kanz.Name = "wrecked"
		kanz.Looped = true
		Pitch = pitch
		MID = ID
		--kanz:Play()
		--coroutine.resume(coroutine.create(function()
		--wait(0.05)
		--end))
	end

	function newThemeCust(ID,timepos,pitch,vol)
		local kanz = kan
		kanz:Stop()
		kanz.Volume = vol
		kanz.TimePosition = timepos
		kanz.PlaybackSpeed = pitch
		kanz.Pitch = pitch
		MID = ID
		kanz.SoundId = ID
		kanz.Name = "wrecked"
		kanz.Looped = true
		kanz:Play()
		coroutine.resume(coroutine.create(function()
			wait(0.05)
		end))
	end



	function CameraShake(Times, Power, PlayerTarget)
		coroutine.resume(coroutine.create(function()
			FV = Instance.new("BoolValue", PlayerTarget)
			FV.Name = "CameraShake"
			for ShakeNum=1,Times do
				swait()
				local ef=Power
				if ef>=1 then
					Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
				else
					ef=Power*10
					Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
				end  
			end
			Humanoid.CameraOffset = Vector3.new(0,0,0)
			FV:Destroy()
		end))
	end

	function CameraEnshaking(Length,Intensity)
		coroutine.resume(coroutine.create(function()
			local intensity = 1*Intensity
			local rotM = 0.01*Intensity
			for i = 0, Length, 0.1 do
				swait()
				intensity = intensity - 0.05*Intensity/Length
				rotM = rotM - 0.0005*Intensity/Length
				hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
				cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
			end
			Humanoid.CameraOffset = Vec3(0, 0, 0)
		end))
	end
	CamShake=function(Part,Distan,Power,Times)
		local de=Part.Position
		for i,v in pairs(workspace:children()) do
			if v:IsA("Model") and v:findFirstChild("Humanoid") then
				for _,c in pairs(v:children()) do
					if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
						local Noob=game.Players.LocalPlayer.Character["Dummy"]:FindFirstChildOfClass'Humanoid'
						if Noob~=nil then
							coroutine.resume(coroutine.create(function()
								FV = Instance.new("BoolValue", Noob)
								FV.Name = "CameraShake"
								for ShakeNum=1,Times do
									swait()
									local ef=Power
									if ef>=1 then
										Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
									else
										ef=Power*10
										Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
									end  
								end
								Humanoid.CameraOffset = Vector3.new(0,0,0)
								FV:Destroy()
							end))
							CameraShake(Times, Power, Noob)
						end
					end
				end
			end
		end
	end

	function chatfunc(text,color)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard")~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end
			local naeeym2 = Instance.new("BillboardGui",Character)
			naeeym2.Size = UDim2.new(0,100,0,40)
			naeeym2.StudsOffset = Vector3.new(0,3,0)
			naeeym2.Adornee = Character.Head
			naeeym2.Name = "TalkingBillBoard"
			local tecks2 = Instance.new("TextLabel",naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.BorderSizePixel = 0
			tecks2.Text = ""
			tecks2.Font = "SciFi"
			tecks2.TextSize = 30
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = color
			tecks2.TextStrokeColor3 = Color3.new(0,0,0)
			tecks2.Size = UDim2.new(1,0,0.5,0)
			local tecks3 = Instance.new("TextLabel",naeeym2)
			tecks3.BackgroundTransparency = 1
			tecks3.BorderSizePixel = 0
			tecks3.Text = ""
			tecks3.Font = "SciFi"
			tecks3.TextSize = 30
			tecks3.TextStrokeTransparency = 0
			tecks3.TextColor3 = Color3.new(0,0,0)
			tecks3.TextStrokeColor3 = color
			tecks3.Size = UDim2.new(1,0,0.5,0)
			coroutine.resume(coroutine.create(function()
				while true do
					swait(1)
					if chaosmode == true then
						tecks2.TextColor3 = BrickColor.random().Color
						tecks3.TextStrokeColor3 = BrickColor.random().Color
					end
					if(glitchymode)then
						local val = math.random(1,255)
						local color = Color3.fromRGB(val,val,val)
						tecks2.TextColor3 = color
						tecks3.TextStrokeColor3 = color
					end
					tecks2.Position = UDim2.new(0,math.random(-5,5),0,math.random(-5,5))
					tecks3.Position = UDim2.new(0,math.random(-5,5),0,math.random(-5,5))
					tecks2.Rotation = math.random(-5,5)
					tecks3.Rotation = math.random(-5,5)
				end
			end))
			for i = 1,string.len(text),1 do
				CFuncs["Sound"].Create("rbxassetid://274118116", char, 0.25, 0.115)
				tecks2.Text = string.sub(text,1,i)
				tecks3.Text = string.sub(text,1,i)
				swait(1)
			end
			wait(1)
			local randomrot = math.random(1,2)
			if randomrot == 1 then
				for i = 1, 50 do
					swait()
					tecks2.Rotation = tecks2.Rotation - .75
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.Rotation = tecks2.Rotation + .75
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			elseif randomrot == 2 then
				for i = 1, 50 do
					swait()
					tecks2.Rotation = tecks2.Rotation + .75
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.Rotation = tecks2.Rotation - .75
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			end
			naeeym2:Destroy()
		end)
		chat()
	end

	loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()
	local RbxUtility = LoadLibrary("RbxUtility")
	local Create = RbxUtility.Create

	CFuncs = { 
		["Part"] = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part"){
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material,
				}
				RemoveOutlines(Part)
				return Part
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Weld"] = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld"){
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1,
				}
				return Weld
			end;
		};

		["Sound"] = {
			Create = function(id, par, vol, pit)
				return coroutine.wrap(function()
					local S = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					S:Play()
					S.Ended:connect(function()
						S:Destroy()
					end)
					return S;
				end)()
			end;
		};

		["LongSound"] = {
			Create = function(id, par, vol, pit)
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					wait()
					S:play()
					game:GetService("Debris"):AddItem(S, 30)
				end))
			end;
		};

		["ParticleEmitter"] = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter"){
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread,
				}
				return fp
			end;
		};

		CreateTemplate = {

		};
	}



	New = function(Object, Parent, Name, Data)
		local Object = Instance.new(Object)
		for Index, Value in pairs(Data or {}) do
			Object[Index] = Value
		end
		Object.Parent = Parent
		Object.Name = Name
		return Object
	end
	local halocolor = BrickColor.new("Pastel light blue")
	local halocolor2 = BrickColor.new("Cool yellow")
	local starcolor = BrickColor.new("Bright yellow")
	local lunacolor = BrickColor.new("Navy blue")
	local lunacolor2 = BrickColor.new("Bright blue")
	local wepcolor = BrickColor.new("Really black")
	local maincolor = BrickColor.new("Really black")
	local m = Instance.new("Model",char)
	local m2 = Instance.new("Model",char)
	local m3 = Instance.new("Model",char)
	local mw1 = Instance.new("Model",char)
	local mw2 = Instance.new("Model",char)

	local extrawingmod1 = Instance.new("Model",char)
	local extrawingmod2 = Instance.new("Model",char)

	function CreateParta(parent,transparency,reflectance,material,brickcolor)
		local p = Instance.new("Part")
		p.TopSurface = 0
		p.BottomSurface = 0
		p.Parent = parent
		p.Size = Vector3.new(0.1,0.1,0.1)
		p.Transparency = transparency
		p.Reflectance = reflectance
		p.CanCollide = false
		p.Locked = true
		p.BrickColor = brickcolor
		p.Material = material
		return p
	end

	function CreateMesh(parent,meshtype,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = meshtype
		mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
		return mesh
	end

	function CreateSpecialMesh(parent,meshid,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.Scale = Vector3.new(x1,y1,z1)
		return mesh
	end


	function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
		mesh.Scale = Vector3.new(x1,y1,z1)
		mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
		return mesh
	end

	function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
		local weld = Instance.new("Weld")
		weld.Parent = parent
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
		weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
		return weld
	end

	local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWeld(sorb,rarm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWeld(sorb2,larm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local handlex = CreateParta(mw2,1,1,"Neon",maincolor)
	CreateMesh(handlex,"Brick",0,0,0)
	local handlexweld = CreateWeld(handlex,tors,handlex,0,-1.5,-1.05,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local valuaring = 10
	for i = 0, 49 do
		valuaring = valuaring + 10
		rn = CreateParta(mw2,0,0,"Neon",halocolor)
		CreateMesh(rn,"Brick",0.25,0.1,0.1)
		CreateWeld(rn,handlex,rn,0,1,0,math.rad(0),math.rad(0),math.rad(valuaring),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	end

	handlex = CreateParta(mw2,1,1,"Neon",maincolor)
	CreateMesh(handlex,"Brick",0,0,0)
	CreateWeld(handlex,tors,handlex,0,-3,-2.1,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local valuaring = 10
	for i = 0, 49 do
		valuaring = valuaring + 10
		rn = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
		CreateMesh(rn,"Brick",0.5,0.2,0.2)
		CreateWeld(rn,handlex,rn,0,2,0,math.rad(0),math.rad(0),math.rad(valuaring),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	end

	local MPASword = {}
	for _,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
		if v:IsA("Accessory") and v.Name:find("MeshPartAccessory") and v.Handle.Size == Vector3.new(4,4,1) then
			table.insert(MPASword,v)
		end
	end

	local handle = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local handleweld = CreateWeld(handle,tors,handle,0,-1.5,-1.05,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	--- Left wing.

	local lwing1 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing1weld = CreateWeld(lwing1,handle,lwing1,3,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))



	local function align(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0,0,0) --Custom Positioning Values Here
		attachment0.Rotation = Vector3.new(0,0,-55) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = true
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end



	if MPASword[1] then

		local HatChoice = MPASword[1]

		align(HatChoice.Handle, lwing1)

		table.remove(MPASword,1)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing1,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing1,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,lwing1,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,lwing1,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	tl1 = Instance.new('Trail',wed)
	tl1.Attachment0 = A0
	tl1.Attachment1 = A1
	--tl1.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tl1.LightEmission = 1
	tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl1.Color = ColorSequence.new(BrickColor.new('Black').Color)
	tl1.Lifetime = 0.6


	local lwing2 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing2weld = CreateWeld(lwing2,handle,lwing2,4,1,0,math.rad(10),math.rad(0),math.rad(25),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if MPASword[1] then
		local HatChoice = MPASword[1]

		align(HatChoice.Handle, lwing2)

		table.remove(MPASword,1)
		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing2,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing2,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,lwing2,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,lwing2,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	tl2 = Instance.new('Trail',wed)
	tl2.Attachment0 = A0
	tl2.Attachment1 = A1
	--tl2.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tl2.LightEmission = 1
	tl2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl2.Color = ColorSequence.new(BrickColor.new('Black').Color)
	tl2.Lifetime = 0.6

	local lwing3 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing3weld = CreateWeld(lwing3,handle,lwing3,4.75,2,0,math.rad(15),math.rad(0),math.rad(37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if game.Players.LocalPlayer.Character:FindFirstChild("BladeMasterAccessory") then

		local HatChoice = game.Players.LocalPlayer.Character:FindFirstChild("BladeMasterAccessory")

		align(HatChoice.Handle, lwing3)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing3,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing3,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,lwing3,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,lwing3,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	tl3 = Instance.new('Trail',wed)
	tl3.Attachment0 = A0
	tl3.Attachment1 = A1
	--tl3.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tl3.LightEmission = 1
	tl3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl3.Color = ColorSequence.new(BrickColor.new('Black').Color)
	tl3.Lifetime = 0.6

	tl1.Enabled = false
	tl2.Enabled = false
	tl3.Enabled = false
	local lwing4 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing4weld = CreateWeld(lwing4,handle,lwing4,5.75,3,0,math.rad(20),math.rad(0),math.rad(50),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing4,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing4,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,lwing4,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,lwing4,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local lwing5 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing5weld = CreateWeld(lwing5,handle,lwing5,6.75,4,0,math.rad(25),math.rad(0),math.rad(62.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing5,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing5,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,lwing5,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,lwing5,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local lwing6 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing6weld = CreateWeld(lwing6,handle,lwing6,7.75,5,0,math.rad(30),math.rad(0),math.rad(75),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing6,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing6,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,lwing6,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,lwing6,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	-- Right wing.

	local rwing1 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing1weld = CreateWeld(rwing1,handle,rwing1,-3,0,0,math.rad(5),math.rad(0),math.rad(-12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if MPASword[1] then
		local HatChoice = MPASword[1]

		align(HatChoice.Handle, rwing1)


		table.remove(MPASword,1)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)

	end

	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing1,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing1,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,rwing1,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,rwing1,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)

	tr1 = Instance.new('Trail',wed)
	tr1.Attachment0 = A0
	tr1.Attachment1 = A1
	--tr1.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tr1.LightEmission = 1
	tr1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr1.Color = ColorSequence.new(BrickColor.new('Black').Color)
	tr1.Lifetime = 0.6

	local rwing2 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing2weld = CreateWeld(rwing2,handle,rwing2,-4,1,0,math.rad(10),math.rad(0),math.rad(-25),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if MPASword[1] then
		local HatChoice = MPASword[1]

		align(HatChoice.Handle, rwing2)

		table.remove(MPASword,1)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)

	end

	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing2,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing2,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,rwing2,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,rwing2,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)

	tr2 = Instance.new('Trail',wed)
	tr2.Attachment0 = A0
	tr2.Attachment1 = A1
	--tr2.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tr2.LightEmission = 1
	tr2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr2.Color = ColorSequence.new(BrickColor.new('Black').Color)
	tr2.Lifetime = 0.6

	local rwing3 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing3weld = CreateWeld(rwing3,handle,rwing3,-4.75,2,0,math.rad(15),math.rad(0),math.rad(-37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if game.Players.LocalPlayer.Character:FindFirstChild("ShadowBladeMasterAccessory") then

		local HatChoice = game.Players.LocalPlayer.Character:FindFirstChild("ShadowBladeMasterAccessory")

		align(HatChoice.Handle, rwing3)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing3,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing3,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,rwing3,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,rwing3,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)

	tr3 = Instance.new('Trail',wed)
	tr3.Attachment0 = A0
	tr3.Attachment1 = A1
	--tr3.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tr3.LightEmission = 1
	tr3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr3.Color = ColorSequence.new(BrickColor.new('Black').Color)
	tr3.Lifetime = 0.6


	local rwing4 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing4weld = CreateWeld(rwing4,handle,rwing4,-5.75,3,0,math.rad(20),math.rad(0),math.rad(-50),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing4,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing4,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,rwing4,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,rwing4,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local rwing5 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing5weld = CreateWeld(rwing5,handle,rwing5,-6.75,4,0,math.rad(25),math.rad(0),math.rad(-62.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing5,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing5,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,rwing5,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,rwing5,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local rwing6 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing6weld = CreateWeld(rwing6,handle,rwing6,-7.75,3,0,math.rad(30),math.rad(0),math.rad(-75),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing6,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing6,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,rwing6,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,rwing6,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	---- HERES THE RING


--[[ran = CreateParta(m2,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.02,1.02,1.02)
CreateWeld(ran,larm,ran,0,0.15,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",0.9,0.9,1.025)
CreateWeld(ran,larm,ran,0,0.155,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.025,0.9,0.9)
CreateWeld(ran,larm,ran,0,0.155,-0.025,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
 
gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
 
 
gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
CreateMesh(gane,"Brick",1.0625,0.2,1.0625)
CreateWeld(gane,larm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateSpecialMesh(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
CreateWeld(star,larm,star,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
CreateSpecialMesh(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
CreateWeld(starl,larm,starl,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
-- S section A
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,larm,dotsec,0,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,larm,dotseca,0,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,larm,dotsecb,0,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,larm,dotsec,0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,larm,dotseca,0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,larm,dotsecb,0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,larm,dotsec,0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,larm,dotseca,0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,larm,dotsecb,0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,larm,dotsec,-0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,larm,dotseca,-0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,larm,dotsecb,-0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,larm,dotsec,-0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,larm,dotseca,-0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,larm,dotsecb,-0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
-- S section B
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,larm,dotsec,0,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,larm,dotseca,0,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,larm,dotsecb,0,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,larm,dotsec,0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,larm,dotseca,0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,larm,dotsecb,0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,larm,dotsec,0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,larm,dotseca,0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,larm,dotsecb,0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,larm,dotsec,-0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,larm,dotseca,-0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,larm,dotsecb,-0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,larm,dotsec,-0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,larm,dotseca,-0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,larm,dotsecb,-0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
--- second ring
 
ran = CreateParta(m2,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.02,1.02,1.02)
CreateWeld(ran,rarm,ran,0,0.15,0,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",0.9,0.9,1.025)
CreateWeld(ran,rarm,ran,0,0.155,0,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.025,0.9,0.9)
CreateWeld(ran,rarm,ran,0,0.155,-0.025,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
 
 
gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
CreateMesh(gane,"Brick",1.0625,0.2,1.0625)
CreateWeld(gane,rarm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateSpecialMesh(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
CreateWeld(star,rarm,star,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
CreateSpecialMesh(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
CreateWeld(starl,rarm,starl,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
-- S section A
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,rarm,dotsec,0,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,rarm,dotseca,0,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,rarm,dotsecb,0,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,rarm,dotsec,0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,rarm,dotseca,0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,rarm,dotsecb,0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,rarm,dotsec,0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,rarm,dotseca,0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,rarm,dotsecb,0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,rarm,dotsec,-0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,rarm,dotseca,-0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,rarm,dotsecb,-0.2,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,rarm,dotsec,-0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,rarm,dotseca,-0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,rarm,dotsecb,-0.4,0.635,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
-- S section B
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,rarm,dotsec,0,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,rarm,dotseca,0,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,rarm,dotsecb,0,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,rarm,dotsec,0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,rarm,dotseca,0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,rarm,dotsecb,0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,rarm,dotsec,0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,rarm,dotseca,0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,rarm,dotsecb,0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,rarm,dotsec,-0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,rarm,dotseca,-0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,rarm,dotsecb,-0.2,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
 
dotsec = CreateParta(m3,0,0,"Neon",halocolor)
CreateMesh(dotsec,"Sphere",0.1,0.1,0.15)
CreateWeld(dotsec,rarm,dotsec,-0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotseca = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(dotseca,"Sphere",0.2,0.2,0.1)
CreateWeld(dotseca,rarm,dotseca,-0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
dotsecb = CreateParta(m2,0,0,"SmoothPlastic",lunacolor)
CreateMesh(dotsecb,"Sphere",0.15,0.15,0.125)
CreateWeld(dotsecb,rarm,dotsecb,-0.4,0.635,0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))]]--


	for i, v in pairs(m:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Really black")
			v.Material = "Glass"
		end
	end
	for i, v in pairs(m2:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Dark stone grey")
			v.Material = "Granite"
		end
	end
	for i, v in pairs(m3:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Really black")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(mw2:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Really black")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(mw1:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("Really black")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(extrawingmod1:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("White")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(extrawingmod2:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("White")
			v.Material = "Neon"
		end
	end
	local MAINRUINCOLOR = BrickColor.new("Really black")
	------


	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part")({
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material
		})
		Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
		RemoveOutlines(Part)
		return Part
	end
	function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
		local Msh = Create(Mesh)({
			Parent = Part,
			Offset = OffSet,
			Scale = Scale
		})
		if Mesh == "SpecialMesh" then
			Msh.MeshType = MeshType
			Msh.MeshId = MeshId
		end
		return Msh
	end
	function CreateWeld(Parent, Part0, Part1, C0, C1)
		local Weld = Create("Weld")({
			Parent = Parent,
			Part0 = Part0,
			Part1 = Part1,
			C0 = C0,
			C1 = C1
		})
		return Weld
	end

	Player=game.Players.LocalPlayer
	Character=Player.Character["Dummy"]
	PlayerGui=Player.PlayerGui
	Backpack=Player.Backpack
	Torso=Character.Torso
	Head=Character.Head
	Humanoid=Character:FindFirstChildOfClass'Humanoid'
	m=Instance.new('Model',Character)
	LeftArm=Character["Left Arm"]
	LeftLeg=Character["Left Leg"]
	RightArm=Character["Right Arm"]
	RightLeg=Character["Right Leg"]
	LS=Torso["Left Shoulder"]
	LH=Torso["Left Hip"]
	RS=Torso["Right Shoulder"]
	RH=Torso["Right Hip"]
	Face = Head.face
	Neck=Torso.Neck
	it=Instance.new
	attacktype=1
	vt=Vector3.new
	cf=CFrame.new
	euler=CFrame.fromEulerAnglesXYZ
	angles=CFrame.Angles
	cloaked=false
	necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
	LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
	RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
	RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
	RootPart=Character.HumanoidRootPart
	RootJoint=RootPart.RootJoint
	RootCF=euler(-1.57,0,3.14)
	attack = false
	attackdebounce = false
	deb=false
	equipped=true
	hand=false
	MMouse=nil
	combo=0
	mana=0
	trispeed=.2
	attackmode='none'
	local idle=0
	local Anim="Idle"
	local Effects={}
	local gun=false
	local shoot=false
	local sine = 0
	local change = 1
	player=nil
	pcall(function()char.LeftWing:destroy()end)
	pcall(function()char.Halo:destroy()end)
	local toggleTag = true
	local txt = Instance.new("BillboardGui", Head)
	txt.Adornee = nil
	txt.Name = "NameDetect"
	txt.Size = UDim2.new(4, 0, 1.2, 0)
	txt.StudsOffset = Vector3.new(-8, 8/1.5, 0)
	local text = Instance.new("TextLabel", txt)
	text.Size = UDim2.new(10/2, 0, 7/2, 0)
	text.FontSize = "Size8"
	text.TextScaled = true
	text.TextTransparency = 0
	text.BackgroundTransparency = 1
	text.TextTransparency = 0
	text.TextStrokeTransparency = 0
	text.Font = "Fantasy"
	text.TextStrokeColor3 = Color3.new(1,1,1)
	text.TextColor3 = Color3.new(0,0,0)
	text.Text = "Solitude"

	pcall(function() Character.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'Really red' end)
	pcall(function() Character.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'Really red' end)

	function RecolorTextAndRename(name,col1,col2)
		text.TextStrokeColor3 = col2
		text.TextColor3 = col1
		text.Text = name
	end
	--save shoulders
	RSH, LSH=nil, nil
	--welds
	RW, LW=Instance.new("Weld"), Instance.new("Weld")
	RW.Name="Right Shoulder" LW.Name="Left Shoulder"
	LH=Torso["Left Hip"]
	RH=Torso["Right Hip"]
	TorsoColor=Torso.BrickColor
	function NoOutline(Part)
		Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
	end
	player=Player
	ch=Character
	RSH=ch.Torso["Right Shoulder"]
	LSH=ch.Torso["Left Shoulder"]
	--
	RSH.Parent=nil
	LSH.Parent=nil
	--
	RW.Name="Right Shoulder"
	RW.Part0=ch.Torso
	RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5)
	RW.C1=cf(0, 0.5, 0)
	RW.Part1=ch["Right Arm"]
	RW.Parent=ch.Torso
	--
	LW.Name="Left Shoulder"
	LW.Part0=ch.Torso
	LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8)
	LW.C1=cf(0, 0.5, 0)
	LW.Part1=ch["Left Arm"]
	LW.Parent=ch.Torso

	local Stats=Instance.new("BoolValue")
	Stats.Name="Stats"
	Stats.Parent=Character
	local Atk=Instance.new("NumberValue")
	Atk.Name="Damage"
	Atk.Parent=Stats
	Atk.Value=1
	local Def=Instance.new("NumberValue")
	Def.Name="Defense"
	Def.Parent=Stats
	Def.Value=1
	local Speed=Instance.new("NumberValue")
	Speed.Name="Speed"
	Speed.Parent=Stats
	Speed.Value=1
	local Mvmt=Instance.new("NumberValue")
	Mvmt.Name="Movement"
	Mvmt.Parent=Stats
	Mvmt.Value=1

	local donum=0


	function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
		local fp=it("Part")
		fp.formFactor=formfactor
		fp.Parent=parent
		fp.Reflectance=reflectance
		fp.Transparency=transparency
		fp.CanCollide=false
		fp.Locked=true
		fp.BrickColor=brickcolor
		fp.Name=name
		fp.Size=size
		fp.Position=Torso.Position
		NoOutline(fp)
		fp.Material="SmoothPlastic"
		fp:BreakJoints()
		return fp
	end

	function mesh(Mesh,part,meshtype,meshid,offset,scale)
		local mesh=it(Mesh)
		mesh.Parent=part
		if Mesh=="SpecialMesh" then
			mesh.MeshType=meshtype
			if meshid~="nil" then
				mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
			end
		end
		mesh.Offset=offset
		mesh.Scale=scale
		return mesh
	end

	function weld(parent,part0,part1,c0)
		local weld=it("Weld")
		weld.Parent=parent
		weld.Part0=part0
		weld.Part1=part1
		weld.C0=c0
		return weld
	end

	local Color1=Torso.BrickColor

	local bodvel=Instance.new("BodyVelocity")
	local bg=Instance.new("BodyGyro")

	--// Artificial HB \\--

	local ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"

	script:WaitForChild("Heartbeat")

	local tf = 0
	local allowframeloss = false
	local tossremainder = false
	local lastframe = tick()
	local frame = 1/60
	ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function swait(num)
		if num == 0 or num == nil then
			ArtificialHB.Event:wait()
		else
			for i = 0, num do
				ArtificialHB.Event:wait()
			end
		end
	end

	-------- RAINBOW LEAVE IT TO ME
	local r = 255
	local g = 0
	local b = 0
	coroutine.resume(coroutine.create(function()
		while wait() do
			for i = 0, 254/5 do
				swait()
				g = g + 5
			end
			for i = 0, 254/5 do
				swait()
				r = r - 5
			end
			for i = 0, 254/5 do
				swait()
				b = b + 5
			end
			for i = 0, 254/5 do
				swait()
				g = g - 5
			end
			for i = 0, 254/5 do
				swait()
				r = r + 5
			end
			for i = 0, 254/5 do
				swait()
				b = b - 5
			end
		end
	end))


	so = function(id,par,vol,pit)
		coroutine.resume(coroutine.create(function()
			local sou = Instance.new("Sound",par or workspace)
			sou.Volume=vol
			sou.Pitch=pit or 1
			sou.SoundId=id
			swait()
			sou:play()
			game:GetService("Debris"):AddItem(sou,6)
		end))
	end

	function clerp(a,b,t)
		return a:lerp(b,t)
	end

	local function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CFrame.new(at.x, at.y, at.z,
			right.x, top.x, back.x,
			right.y, top.y, back.y,
			right.z, top.z, back.z)
	end

	function Triangle(a, b, c)
		local edg1 = (c-a):Dot((b-a).unit)
		local edg2 = (a-b):Dot((c-b).unit)
		local edg3 = (b-c):Dot((a-c).unit)
		if edg1 <= (b-a).magnitude and edg1 >= 0 then
			a, b, c = a, b, c
		elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
			a, b, c = b, c, a
		elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
			a, b, c = c, a, b
		else
			assert(false, "unreachable")
		end

		local len1 = (c-a):Dot((b-a).unit)
		local len2 = (b-a).magnitude - len1
		local width = (a + (b-a).unit*len1 - c).magnitude

		local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)

		local list = {}

		if len1 > 0.01 then
			local w1 = Instance.new('WedgePart', m)
			game:GetService("Debris"):AddItem(w1,5)
			w1.Material = "SmoothPlastic"
			w1.FormFactor = 'Custom'
			w1.BrickColor = BrickColor.new("Really black")
			w1.Transparency = 0
			w1.Reflectance = 0
			w1.Material = "SmoothPlastic"
			w1.CanCollide = false
			local l1 = Instance.new("PointLight",w1)
			l1.Color = Color3.new(170,0,0)
			NoOutline(w1)
			local sz = Vector3.new(0.2, width, len1)
			w1.Size = sz
			local sp = Instance.new("SpecialMesh",w1)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
			w1:BreakJoints()
			w1.Anchored = true
			w1.Parent = workspace
			w1.Transparency = 0.7
			table.insert(Effects,{w1,"Disappear",.01})
			w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
			table.insert(list,w1)
		end

		if len2 > 0.01 then
			local w2 = Instance.new('WedgePart', m)
			game:GetService("Debris"):AddItem(w2,5)
			w2.Material = "SmoothPlastic"
			w2.FormFactor = 'Custom'
			w2.BrickColor = BrickColor.new("Really black")
			w2.Transparency = 0
			w2.Reflectance = 0
			w2.Material = "SmoothPlastic"
			w2.CanCollide = false
			local l2 = Instance.new("PointLight",w2)
			l2.Color = Color3.new(170,0,0)
			NoOutline(w2)
			local sz = Vector3.new(0.2, width, len2)
			w2.Size = sz
			local sp = Instance.new("SpecialMesh",w2)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
			w2:BreakJoints()
			w2.Anchored = true
			w2.Parent = workspace
			w2.Transparency = 0.7
			table.insert(Effects,{w2,"Disappear",.01})
			w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
			table.insert(list,w2)
		end
		return unpack(list)
	end


	function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
		if hit.Parent == nil then
			return
		end
		local h = hit.Parent:FindFirstChildOfClass("Humanoid")
		for _, v in pairs(hit.Parent:children()) do
			if v:IsA("Humanoid") then
				h = v
			end
		end
		if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Head") ~= nil then
			if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
				return
			end
			local c = Create("ObjectValue")({
				Name = "creator",
				Value = game.Players.LocalPlayer,
				Parent = h
			})
			game:GetService("Debris"):AddItem(c, 0.5)
			if HitSound ~= nil and HitPitch ~= nil then
				CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
			end
			local Damage = math.random(minim, maxim)
			local blocked = false
			local block = hit.Parent:findFirstChild("Block")
			if block ~= nil and block.className == "IntValue" and block.Value > 0 then
				blocked = true
				block.Value = block.Value - 1
				print(block.Value)
			end
			if blocked == false then
				HitHealth = h.Health
				h.Health = h.Health - Damage
				if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
					print("gained kill")
				end
				ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
			else
				h.Health = h.Health - Damage / 2
				ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
			end
			if Type == "Knockdown" then
				local hum = hit.Parent:FindFirstChildOfClass'Humanoid'
				hum.PlatformStand = true
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(1)
					HHumanoid.PlatformStand = false
				end), hum)
				local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
				local bodvol = Create("BodyVelocity")({
					velocity = angle * knockback,
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				local rl = Create("BodyAngularVelocity")({
					P = 3000,
					maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
					angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodvol, 0.5)
				game:GetService("Debris"):AddItem(rl, 0.5)
			elseif Type == "Normal" then
				local vp = Create("BodyVelocity")({
					P = 500,
					maxForce = Vector3.new(math.huge, 0, math.huge),
					velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
				})
				if knockback > 0 then
					vp.Parent = hit.Parent.Head
				end
				game:GetService("Debris"):AddItem(vp, 0.5)
			elseif Type == "Up" then
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Leech" then
				local hum = hit.Parent:FindFirstChildOfClass'Humanoid'
				if hum ~= nil then
					for i = 0, 2 do
						Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
					end
					Humanoid.Health = Humanoid.Health + 10
				end
			elseif Type == "UpKnock" then
				local hum = hit.Parent:FindFirstChildOfClass'Humanoid'
				hum.PlatformStand = true
				if hum ~= nil then
					hitr = true
				end
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(5)
					HHumanoid.PlatformStand = false
					hitr = false
				end), hum)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Snare" then
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Slashnare" then
				Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
				for i = 1, math.random(4, 5) do
					Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
				end
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Spike" then
				CreateBigIceSword(hit.Parent.Torso.CFrame)
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Freeze" then
				local BodPos = Create("BodyPosition")({
					P = 50000,
					D = 1000,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				local BodGy = Create("BodyGyro")({
					maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
					P = 20000,
					Parent = hit.Parent.Torso,
					cframe = hit.Parent.Torso.CFrame
				})
				hit.Parent.Torso.Anchored = true
				coroutine.resume(coroutine.create(function(Part)
					swait(1.5)
					Part.Anchored = false
				end), hit.Parent.Torso)
				game:GetService("Debris"):AddItem(BodPos, 3)
				game:GetService("Debris"):AddItem(BodGy, 3)
			end
			local debounce = Create("BoolValue")({
				Name = "DebounceHit",
				Parent = hit.Parent,
				Value = true
			})
			game:GetService("Debris"):AddItem(debounce, Delay)
			c = Instance.new("ObjectValue")
			c.Name = "creator"
			c.Value = Player
			c.Parent = h
			game:GetService("Debris"):AddItem(c, 0.5)
		end
	end
	function ShowDamage(Pos, Text, Time, Color)
		local Rate = 0.03333333333333333
		local Pos = Pos or Vector3.new(0, 0, 0)
		local Text = Text or ""
		local Time = Time or 2
		local Color = Color or Color3.new(1, 0, 1)
		local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
		EffectPart.Anchored = true
		local BillboardGui = Create("BillboardGui")({
			Size = UDim2.new(3, 0, 3, 0),
			Adornee = EffectPart,
			Parent = EffectPart
		})
		local TextLabel = Create("TextLabel")({
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			TextColor3 = Color,
			TextScaled = true,
			Font = Enum.Font.ArialBold,
			Parent = BillboardGui
		})
		game.Debris:AddItem(EffectPart, Time + 0.1)
		EffectPart.Parent = game:GetService("Workspace")
		delay(0, function()
			local Frames = Time / Rate
			for Frame = 1, Frames do
				wait(Rate)
				local Percent = Frame / Frames
				EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
				TextLabel.TextTransparency = Percent
			end
			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end)
	end
	function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChildOfClass("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Head")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						--Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
					end
				end
			end
		end
	end

	function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChild("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Torso")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
						Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
					end
				end
			end
		end
	end

	function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
	end

	function SkullEffect(brickcolor,cframe,x1,y1,z1,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=4770583",vt(0,0,0),vt(x1,y1,z1))
		--http://www.roblox.com/asset/?id=4770560
		game:GetService("Debris"):AddItem(prt,2)
		CF=prt.CFrame
		coroutine.resume(coroutine.create(function(Part,Mesh,TehCF)
			for i=0,1,0.2 do
				wait()
				Part.CFrame=CF*cf(0,0,-0.4)
			end
			for i=0,1,delay do
				wait()
				--Part.CFrame=CF*cf((math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5)
				Mesh.Scale=Mesh.Scale
			end
			for i=0,1,0.1 do
				wait()
				Part.Transparency=i
			end
			Part.Parent=nil
		end),prt,msh,CF)
	end

	function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			for i=0,1,delay do
				swait()
				Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicSphere(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			for i=0,1,delay do
				wait()
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShock(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
		local prt=part(3,char,1,1,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		local dec = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
		local dec2 = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				dec.Transparency=i
				dec2.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockAlt(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockAltCircle(brickcolor,cframe,x1,z1,x3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0.1,0)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,-0.1,0)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,0,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockTrailAlt(brickcolor,cframe,x1,y1,z1,x3,y3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockTrailAlt2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlock2(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=false
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		local wld=weld(prt,prt,Parent,cframe)
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,Weld)
			for i=0,1,delay do
				wait()
				Weld.C0=euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))*cframe
				--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,wld)
	end

	function MagicBlock3(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=false
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		local wld=weld(prt,prt,Parent,euler(0,0,0)*cf(0,0,0))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,Weld)
			for i=0,1,delay do
				wait()
				Weld.C0=euler(i*20,0,0)
				--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,wld)
	end

	function MagicCircle2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("CylinderMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
				local prt2=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
				prt2.Anchored=true
				prt2.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				local msh2=mesh("SpecialMesh",prt2,"Sphere","",vt(0,0,0),vt(0.5,0.5,0.5))
				game:GetService("Debris"):AddItem(prt2,2)
				coroutine.resume(coroutine.create(function(Part,Mesh)
					for i=0,1,0.1 do
						wait()
						Part.CFrame=Part.CFrame*cf(0,0.5,0)
					end
					Part.Parent=nil
				end),prt2,msh2)
			end
			for i=0,1,delay*2 do
				wait()
				Part.CFrame=Part.CFrame
				Mesh.Scale=vt((x1+x3)-(x1+x3)*i,(y1+y3)-(y1+y3)*i,(z1+z3)-(z1+z3)*i)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function BreakEffect(brickcolor,cframe,x1,y1,z1)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,CF,Numbb,randnumb)
			CF=Part.CFrame
			Numbb=0
			randnumb=math.random()/10
			rand1=math.random()/10
			for i=0,1,rand1 do
				wait()
				CF=CF*cf(0,math.random()/2,0)
				--Part.CFrame=Part.CFrame*euler(0.5,0,0)*cf(0,1,0)
				Part.CFrame=CF*euler(Numbb,0,0)
				Part.Transparency=i
				Numbb=Numbb+randnumb
			end
			Part.Parent=nil
		end),prt,CF,Numbb,randnumb)
	end

	function MagicWaveThing(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=1051557",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame*euler(0,0.7,0)
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function WaveEffect(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=20329976",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh)
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame*cf(0,y3/2,0)
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function StravEffect(brickcolor,cframe,x,y,z,x1,y1,z1,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe*cf(x,y,z)
		msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://168892363",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,ex,why,zee)
			local num=math.random()
			local num2=math.random(-3,2)+math.random()
			local numm=0
			for i=0,1,delay*2 do
				swait()
				Part.CFrame=cframe*euler(0,numm*num*10,0)*cf(ex,why,zee)*cf(-i*10,num2,0)
				Part.Transparency=i
				numm=numm+0.01
			end
			Part.Parent=nil
			Mesh.Parent=nil
		end),prt,msh,x,y,z)
	end

	function dmgstart(dmg,what)
		hitcon = what.Touched:connect(function(hit)
			local hum = hit.Parent:FindFirstChild("Humanoid")
			if hum and not hum:IsDescendantOf(Character) then
				hum:TakeDamage(dmg)
			end
		end)
	end

	function dmgstop()
		hitcon:disconnect()
	end

	function Cloak()
		Face.Parent=nil
		cloaked=true
		for _,v in pairs(Torso.Parent:children()) do
			if v.className=="Part" and v.Name~="HumanoidRootPart" then
				coroutine.resume(coroutine.create(function()
					for i=0,1,0.2 do
						wait()
						v.Transparency=i
					end
					v.Transparency=1
				end))
			end
			if v.className=="Hat" then
				hatp=v.Handle
				coroutine.resume(coroutine.create(function(derp)
					for i=0,1,0.2 do
						wait()
						derp.Transparency=i
					end
					derp.Transparency=1
				end),hatp)
			end
		end
		for _,v in pairs(m:children()) do
			if v.className=="Part" then
				coroutine.resume(coroutine.create(function()
					for i=0,1,0.2 do
						wait()
						v.Transparency=i
					end
					v.Transparency=1
				end))
			end
		end
	end

	function UnCloak()
		so("http://roblox.com/asset/?id=2767090",Torso,1,1.1)
		Face.Parent=Head
		cloaked=false
		for _,v in pairs(Torso.Parent:children()) do
			if v.className=="Part" and v.Name~="HumanoidRootPart" then
				coroutine.resume(coroutine.create(function()
					for i=0,1,0.1 do
						wait()
						v.Transparency=v.Transparency-0.1
					end
					v.Transparency=0
				end))
			end
			if v.className=="Hat" then
				hatp=v.Handle
				coroutine.resume(coroutine.create(function(derp)
					for i=0,1,0.1 do
						wait()
						derp.Transparency=derp.Transparency-0.1
					end
					derp.Transparency=0
				end),hatp)
			end
		end
		for _,v in pairs(m:children()) do
			if v.className=="Part" and v.Name~="hitbox" and v.Name~='tip' then
				coroutine.resume(coroutine.create(function()
					for i=0,1,0.1 do
						wait()
						v.Transparency=v.Transparency-0.1
					end
					v.Transparency=0
				end))
				v.Transparency=0
			end
		end
	end

	local origcolor = BrickColor.new("Pastel light blue")
	---- This section of explosions.
	function Explode(rad,par,pitch,vol,mindam,maxdam)
		local expart = Instance.new("Part",char)
		local expart2 = Instance.new("Part",char)
		local rin = Instance.new("Part",char)
		local rin2 = Instance.new("Part",char)
		local partMesh = Instance.new("SpecialMesh",expart)
		partMesh.MeshType = "Sphere"
		local partMesh2 = Instance.new("SpecialMesh",expart2)
		partMesh2.MeshType = "Sphere"
		local partMesh3 = Instance.new("SpecialMesh",rin)
		partMesh3.MeshType = "Brick"
		local partMesh4 = Instance.new("SpecialMesh",rin2)
		partMesh4.MeshType = "Brick"
		CFuncs["Sound"].Create("rbxassetid://165970126", expart,vol, pitch)
		partMesh.Scale = vt(rad,rad,rad)
		expart.Size = vt(1,1,1)
		expart.Transparency = 0
		expart.Anchored = true
		expart.Material = "Neon"
		expart.BrickColor = bc("White")
		expart.CFrame = par.CFrame
		partMesh2.Scale = vt(rad,rad,rad)
		expart2.Size = vt(1.15,1.15,1.15)
		expart2.Transparency = 0.5
		expart2.Anchored = true
		expart2.Material = "Neon"
		expart2.BrickColor = par.BrickColor
		expart2.CFrame = par.CFrame
		rin.Size = vt(1.15,1.15,1.15)
		rin.Transparency = 1
		rin.Anchored = true
		rin.Material = "Neon"
		rin.BrickColor = par.BrickColor
		rin.CFrame = par.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
		rin2.Size = vt(1.15,1.15,1.15)
		rin2.Transparency = 1
		rin2.Anchored = true
		rin2.Material = "Neon"
		rin2.BrickColor = par.BrickColor
		rin2.CFrame = par.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
		partMesh3.Scale = vt(0,1,0)
		partMesh4.Scale = vt(0,1,0)
		local dec2 = Instance.new("Decal", rin)
		dec2.Face = "Top"
		dec2.Texture = "http://www.roblox.com/asset/?id=874580939"
		dec2.Parent = rin
		local dec2b = dec2:Clone()
		dec2b.Face = "Bottom"
		dec2b.Parent = rin

		local dec2a = Instance.new("Decal", rin2)
		dec2a.Face = "Top"
		dec2a.Texture = "http://www.roblox.com/asset/?id=874580939"
		dec2a.Parent = rin2
		local dec2ab = dec2a:Clone()
		dec2ab.Face = "Bottom"
		dec2ab.Parent = rin2
		expart.CanCollide = false
		expart2.CanCollide = false
		rin.CanCollide = false
		rin2.CanCollide = false
		MagniDamage(par, rad*5, mindam, maxdam, 0, "Normal")
		local value = 1*rad/6.5
		for i = 0, 199 do
			partMesh.Scale = partMesh.Scale + vt(value,value,value)
			expart.CFrame = expart.CFrame
			partMesh2.Scale = partMesh2.Scale + vt(value,value,value)
			expart2.CFrame = expart.CFrame
			value = value - 0.035*rad/30
			if value < 7.5 then
				partMesh3.Scale = partMesh3.Scale + vt(rad/5,0,rad/5)
				rin.CFrame = rin.CFrame*CFrame.Angles(0,math.rad(1),0)
				partMesh4.Scale = partMesh4.Scale + vt(rad/7.5,0,rad/7.5)
				rin2.CFrame = rin2.CFrame*CFrame.Angles(0,math.rad(-1),0)
			end
			if value < 0 then
				dec2.Transparency = dec2.Transparency + 0.025
				dec2a.Transparency = dec2a.Transparency + 0.025
				dec2b.Transparency = dec2b.Transparency + 0.025
				dec2ab.Transparency = dec2ab.Transparency + 0.025
				expart.Transparency = expart.Transparency + 0.025
				expart2.Transparency = expart2.Transparency + 0.025
				rin.Transparency = rin.Transparency + 0.025
				rin2.Transparency = rin2.Transparency + 0.025
			end
			swait()
		end
		game:GetService("Debris"):AddItem(expart, 1)
		game:GetService("Debris"):AddItem(expart2, 1)
		game:GetService("Debris"):AddItem(rin, 1)
		game:GetService("Debris"):AddItem(rin2, 1)
	end

	function ExplodeShort(rad,par,pitch,vol,mindam,maxdam)
		local expart = Instance.new("Part",char)
		local expart2 = Instance.new("Part",char)
		local partMesh = Instance.new("SpecialMesh",expart)
		partMesh.MeshType = "Sphere"
		local partMesh2 = Instance.new("SpecialMesh",expart2)
		partMesh2.MeshType = "Sphere"
		CFuncs["Sound"].Create("http://www.roblox.com/asset/?id=142070127", expart,vol, pitch)
		partMesh.Scale = vt(rad,rad,rad)
		expart.Size = vt(1,1,1)
		expart.Transparency = 0
		expart.Anchored = true
		expart.Material = "Neon"
		expart.BrickColor = bc("White")
		expart.CFrame = par.CFrame
		partMesh2.Scale = vt(rad,rad,rad)
		expart2.Size = vt(1.15,1.15,1.15)
		expart2.Transparency = 0.5
		expart2.Anchored = true
		expart2.Material = "Neon"
		expart2.BrickColor = par.BrickColor
		expart2.CFrame = par.CFrame
		expart.CanCollide = false
		expart2.CanCollide = false
		MagniDamage(par, rad*2.5, mindam, maxdam, 0, "Normal")
		local value = 1*rad/6.5
		for i = 0, 75 do
			partMesh.Scale = partMesh.Scale + vt(value,value,value)
			expart.CFrame = expart.CFrame
			partMesh2.Scale = partMesh2.Scale + vt(value,value,value)
			expart2.CFrame = expart.CFrame
			value = value - 0.035*rad/5
			if value < 0 then
				value = 0
				expart.Transparency = expart.Transparency + 0.05
				expart2.Transparency = expart2.Transparency + 0.05
			end
			swait()
		end
		game:GetService("Debris"):AddItem(expart, 1)
		game:GetService("Debris"):AddItem(expart2, 1)
	end

	function AreaDanger(rad,par,mindam,maxdam)
		local expart = Instance.new("Part",char)
		local partMesh = Instance.new("SpecialMesh",expart)
		CFuncs["Sound"].Create("rbxassetid://231917784", expart,1.5,1.15)
		partMesh.MeshType = "Sphere"
		partMesh.Scale = vt(rad,rad,rad)
		expart.Size = vt(1,1,1)
		expart.Transparency = 0.5
		expart.Anchored = true
		expart.Material = "Neon"
		expart.CanCollide = false
		expart.BrickColor = par.BrickColor
		expart.CFrame = par.CFrame
		local value = 1*rad/5
		MagicBlock(origcolor,expart.CFrame,0,0,0,rad/2,rad/2,rad/2,0.1)
		for i = 0, 14 do
			wait()
			partMesh.Scale = partMesh.Scale + vt(value,value,value)
			expart.CFrame = expart.CFrame
			value = value - 0.035*rad
			if value < 0 then
				value = 0
			end
		end
		wait(0.25)
		CFuncs["Sound"].Create("rbxassetid://588738544", expart,1.5,1)
		wait(0.5)
		CFuncs["Sound"].Create("rbxassetid://588737825", expart,1.5,1)
		CFuncs["Sound"].Create("rbxassetid://231917784", expart,1.5,0.75)
		MagniDamageWithEffect(par, rad, mindam, maxdam, 0, "Normal")
		MagicBlock(origcolor,expart.CFrame,rad*2,rad*2,rad*2,0.1,0.1,0.1,0.025)
		for i = 0, 14 do
			wait()
			partMesh.Scale = partMesh.Scale + vt(value,value,value)
			expart.CFrame = expart.CFrame
			value = value - 0.035*rad/2
		end
		expart.Transparency = 1
		game:GetService("Debris"):AddItem(expart, 5)
	end

	function Swarmsplosions(negrad,rad,par,mindam,maxdam)
		CFuncs["Sound"].Create("rbxassetid://588737825", par, 2.5, 2)
		CFuncs["Sound"].Create("rbxassetid://231917784", par, 2.5,1)
		CFuncs["Sound"].Create("rbxassetid://231917744", par, 2.5,1)
		CFuncs["Sound"].Create("rbxassetid://233856106", par, 2.5, 1)
		MagniDamageWithEffect(par, 25, 5,10, 0, "Normal")
		MagicBlock(origcolor,par.CFrame,5,5,5,5,5,5,0.025)
		for i = 0, 24 do
			MagicShockTrailAlt2(origcolor,par.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10/5,10/5,5,-0.05/5,-0.05/5,25,0.005,math.random(1,2))
		end
		for i = 0, 24 do
			local expart = Instance.new("Part",char)
			expart.Transparency = 1
			expart.Anchored = true
			expart.CanCollide = false
			expart.CFrame = par.CFrame*CFrame.new(math.random(negrad,rad),math.random(negrad,rad),math.random(negrad,rad))
			CFuncs["Sound"].Create("rbxassetid://588737825", expart,1,2)
			CFuncs["Sound"].Create("rbxassetid://231917784", expart,1.5,1.15)
			MagniDamage(expart, rad/2, mindam, maxdam, 0, "Normal")
			MagicBlock(origcolor,expart.CFrame,rad,rad,rad,0.1,0.1,0.1,0.025)
			for i = 0, 9 do
				MagicShockTrailAlt2(origcolor,expart.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10/5,10/5,5,-0.05/5,-0.05/5,5,0.05,math.random(1,2))
			end
			game:GetService("Debris"):AddItem(expart, 2)
			wait(0.1)
		end
	end

	function EXterPlosion(par)
		CFuncs["Sound"].Create("rbxassetid://919941001", par, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://138213851", par, 5,0.85)
		CFuncs["Sound"].Create("rbxassetid://157878578", par, 5,0.2)
		CFuncs["Sound"].Create("rbxassetid://233856106", par, 2.5, 1)
		MagniDamageWithEffect(par, 500, 80,99, 0, "Normal")
		MagicBlock(origcolor,par.CFrame,5,5,5,5,5,5,0.005)
		MagicBlock(origcolor,par.CFrame,0,0,0,150,150,150,0.1)
		for i = 0, 24 do
			MagicShockTrailAlt2(origcolor,par.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10*5,10*5,5,-0.05*10,-0.05*10,500,0.1,math.random(1,2))
		end
		for i = 0, 24 do
			MagicShockTrailAlt2(origcolor,par.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10*5,10*5,5,-0.05*5,-0.05*5,50,0.005,math.random(1,2))
		end
	end
	----


	function ring(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
			end
			rng:Destroy()
		end))
	end


	function wave(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function wind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function groundwind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
			end
			rng:Destroy()
		end))
	end

	function CameraManager()
		if TwoD and not CamInterrupt then
			if Humanoid.Health > 0 then
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Scriptable"
				Humanoid.AutoRotate = false
				if Booleans.GyroUse then
					Directer.MaxTorque = Vec3(0, huge, 0)
				else
					Directer.MaxTorque = Vec3(0, 0, 0)
				end
				if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
					if Booleans.CamFollow then
						CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
						Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
					else
						CPart.Position = RootPart.Position
					end
				else
					local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
					CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
				end
				Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
			else
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Custom"
				Controller.Disabled = false
			end
		end
	end

	function sphere(bonuspeed,type,pos,scale,value,color,heart,invert,notaffectbychaosrainbow)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"


		if(heart)then
			rngm.MeshType = Enum.MeshType.FileMesh
			rngm.MeshId = "rbxassetid://105992239"
			rngm.Offset = Vector3.new(0,0,-.25)
		end
		rngm.Scale = scale
		if rainbowmode == true and not notaffectbychaosrainbow then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true and not notaffectbychaosrainbow then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true and not notaffectbychaosrainbow then
					rng.BrickColor = BrickColor.random()
				end
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					rng.Color = color
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				if(invert)then
					if(heart)then
						rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
					else
						rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
					end
				else
					if(heart)then
						rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
					else
						rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
					end
				end
				rng.CFrame = pos
			end
			rng:Destroy()
		end))
	end

	function newBezier(startpos, pos2, pos3, endpos, t)
		local A = clerp(startpos, pos2, t)
		local B = clerp(pos2, pos3, t)
		local C = clerp(pos3, endpos, t)
		local lerp1 = clerp(A, B, t)
		local lerp2 = clerp(B, C, t)
		local cubic = clerp(lerp1, lerp2, t)
		return cubic
	end


	function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,heart,invert)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		if(heart)then
			rngm.MeshType = Enum.MeshType.FileMesh
			rngm.MeshId = "rbxassetid://105992239"
			rngm.Offset = Vector3.new(0,0,-.25)
		end
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					rng.Color = color
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed/10
				if(invert)then rng.CFrame = rng.CFrame - rng.CFrame.lookVector*speeder*bonuspeed else rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed end
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end


	function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,heart,invert)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		if(heart)then
			rngm.MeshType = Enum.MeshType.FileMesh
			rngm.MeshId = "rbxassetid://105992239"
			rngm.Offset = Vector3.new(0,0,-.25)
		end
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 0
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					rng.Color = color
				end
				speeder = speeder + 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				if(invert)then rng.CFrame = rng.CFrame - rng.CFrame.lookVector*speeder*bonuspeed else rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed end
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					rng.Color = color
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end


	function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 1
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					rng.Color = color
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end

	function dmg(dude)
		if dude.Name ~= Character then
			local bgf = Instance.new("BodyGyro",dude.Head)
			bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
			local val = Instance.new("BoolValue",dude)
			val.Name = "IsHit"
			local ds = coroutine.wrap(function()
				local torso = dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso'
				for i = 1, 10 do
					sphereMK(1.5,2,"Add",torso.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,25,-.01,BrickColor.new("White"),0,true)
				end
				dude:WaitForChild("Head"):BreakJoints()
				wait(0.5)
				targetted = nil
				CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.5, 0.3)

				coroutine.resume(coroutine.create(function()
					for i, v in pairs(dude:GetChildren()) do
						if v:IsA("Accessory") then
							v:Destroy()
						end
						if v:IsA("Humanoid") then
							v:Destroy()
						end
						if v:IsA("CharacterMesh") then
							v:Destroy()
						end
						if v:IsA("Model") then
							v:Destroy()
						end
						if v:IsA("Part") or v:IsA("MeshPart") then
							for x, o in pairs(v:GetChildren()) do
								if o:IsA("Decal") then
									o:Destroy()
								end
							end
							coroutine.resume(coroutine.create(function()
								v.Material = "Neon"
								v.CanCollide = false
								local bld = Instance.new("ParticleEmitter",v)
								bld.LightEmission = 1
								bld.Texture = "rbxassetid://284205403"
								bld.Color = ColorSequence.new(Color3.new(1,1,1))
								bld.Rate = 50
								bld.Lifetime = NumberRange.new(1)
								bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.75,0),NumberSequenceKeypoint.new(1,0,0)})
								bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
								bld.Speed = NumberRange.new(0,0)
								bld.VelocitySpread = 50000
								bld.Rotation = NumberRange.new(-500,500)
								bld.RotSpeed = NumberRange.new(-500,500)
								local sbs = Instance.new("BodyPosition", v)
								sbs.P = 3000
								sbs.D = 1000
								sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
								sbs.position = v.Position + Vector3.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))
								v.Color = Color3.new(1,1,1)
								coroutine.resume(coroutine.create(function()
									for i = 0, 49 do
										swait(1)
										v.Transparency = v.Transparency + 0.02
									end
									CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.25, 1)
									bld.Speed = NumberRange.new(1,5)
									bld.Acceleration = vt(0,10,0)
									wait(0.5)
									bld.Enabled = false
									wait(3)
									v:Destroy()
									dude:Destroy()
								end))
							end))
						end
					end
				end))
			end)
			ds()
		end
	end


	function FindNearestHead(Position, Distance, SinglePlayer)
		if SinglePlayer then
			return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
		end
		local List = {}
		for i, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") then
				if v:findFirstChild("Head") then
					if v ~= Character then
						if (v.Head.Position - Position).magnitude <= Distance then
							table.insert(List, v)
						end
					end
				end
			end
		end
		return List
	end

	function FaceMouse()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end

	function FaceMouse2()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end

	local ModeOfGlitch = 1
	-- Functions are ready.
	local storehumanoidWS = 16

	function CorruptBlink()
		for i = 0, 14 do
			PixelBlock(3,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.03,MAINRUINCOLOR,0)
		end
		sphere(10,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		CFuncs["Sound"].Create("rbxassetid://1177785010", root, 10,1)
		RootPart.CFrame = mouse.Hit *CFrame.new(0,2,0)
		CameraEnshaking(2,10)
		if(ModeOfGlitch == 1 or ModeOfGlitch == 3 or ModeOfGlitch == 4 or ModeOfGlitch == 666666)then for i, v in pairs(FindNearestHead(Torso.CFrame.p, 20)) do
				if v:FindFirstChild('Head') then
					dmg(v)
				end
			end end
		for i = 0, 14 do
			PixelBlock(3,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.03,MAINRUINCOLOR,0)
		end
		sphere(10,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
	end

	function ExtinctiveHeartbreak()
		local targetted = nil
		if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			targetted = mouse.Target.Parent
		end
		if targetted ~= nil then
			attack = true
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really black"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really black"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really black"))
			local originalpos = root.CFrame
			RootPart.CFrame = targetted.Head.CFrame * CFrame.new(0,-2,2)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really black"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really black"),0)
			end
			hum.WalkSpeed = 0
			targetted.Head.Anchored = true
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really black"))
			for i = 0,2,0.1 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.4)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.4)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(80)),.4)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(10)),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(10)),.4)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(90),math.rad(0),math.rad(60)),.4)
			end
			coroutine.resume(coroutine.create(function()
				bld = Instance.new("ParticleEmitter",targetted:WaitForChild("Torso"))
				bld.LightEmission = 0.1
				bld.Texture = "rbxassetid://284205403"
				bld.Color = ColorSequence.new(Color3.new(0.5,0,0))
				bld.Rate = 500
				bld.Lifetime = NumberRange.new(1)
				bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Acceleration = vt(0,-25,0)
				bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Speed = NumberRange.new(10,50)
				bld.EmissionDirection = "Front"
				bld.VelocitySpread = 25
				bld.Rotation = NumberRange.new(-500,500)
				bld.RotSpeed = NumberRange.new(-500,500)
			end))
			coroutine.resume(coroutine.create(function()
				bld = Instance.new("ParticleEmitter",targetted:WaitForChild("UpperTorso"))
				bld.LightEmission = 0.1
				bld.Texture = "rbxassetid://284205403"
				bld.Color = ColorSequence.new(Color3.new(0.5,0,0))
				bld.Rate = 500
				bld.Lifetime = NumberRange.new(1)
				bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Acceleration = vt(0,-25,0)
				bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Speed = NumberRange.new(10,50)
				bld.EmissionDirection = "Front"
				bld.VelocitySpread = 25
				bld.Rotation = NumberRange.new(-500,500)
				bld.RotSpeed = NumberRange.new(-500,500)
			end))
			CameraEnshaking(5,5)
			game:GetService("Debris"):AddItem(bld,3)
			dmg(targetted)
			CFuncs["Sound"].Create("rbxassetid://429400881", targetted.Head, 1,1)
			for i = 0,1,0.1 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.8)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.8)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(-80)),.8)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(80)),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(10)),.8)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(90),math.rad(0),math.rad(-80)),.8)
			end
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really black"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really black"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really black"))
			root.CFrame = originalpos
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really black"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really black"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really black"))
			bld.Enabled = false
			attack = false
			hum.WalkSpeed = storehumanoidWS
		end
	end
	function PureBomb()
		attack = true

		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = BrickColor.new("Toothpaste")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(0,0,0)
		local scaled = 0.1
		local posid = 0
		CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1,1)
		for i = 0, 5, 0.1 do
			swait()
			scaled = scaled - 0.001
			posid = posid - scaled
			orb.CFrame = rarm.CFrame*CFrame.new(0,-0.1+posid/1.05,0)
			orbm.Scale = orbm.Scale + vt(scaled,scaled,scaled)
			sphereMKCharge(5,-0.25,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.5,0.5,5,-0.005,BrickColor.new("Toothpaste"),10)
			PixelBlockNeg(2,1,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,BrickColor.new("Toothpaste"),0)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(180),math.rad(20),math.rad(0)),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.1)
		end
		for i = 0, 2, 0.1 do
			swait()
			orb.CFrame = rarm.CFrame*CFrame.new(0,-0.1+posid/1.05,0)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(-50)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(20)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(220),math.rad(20),math.rad(0)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.4)
		end
		coroutine.resume(coroutine.create(function()
			orb.Anchored = false
			CFuncs["Sound"].Create("rbxassetid://260433768", root, 1.25,1)
			local a = Instance.new("Part",workspace)
			a.Name = "Direction"   
			a.Anchored = true
			a.BrickColor = bc("Bright red")
			a.Material = "Neon"
			a.Transparency = 1
			a.CanCollide = false
			local ray = Ray.new(
				orb.CFrame.p,                           -- origin
				(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
			)
			local ignore = orb
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			local distance = (orb.CFrame.p - position).magnitude
			a.Size = Vector3.new(0.1, 0.1, 0.1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
			orb.CFrame = a.CFrame
			a:Destroy()
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = orb.CFrame.lookVector*125
			bv.Parent = orb
			local hitted = false
			game:GetService("Debris"):AddItem(orb, 15)
			wait()
			local hit =orb.Touched:connect(function(hit)
				if hitted == false then
					hitted = true
					CameraEnshaking(10,2.5)
					CFuncs["Sound"].Create("rbxassetid://151304356", orb, 5,1)
					MagniDamage(orb, 65, 65,90, 0, "Normal")
					sphere(1,"Add",orb.CFrame,vt(orbm.Scale.x,orbm.Scale.y,orbm.Scale.z),1,BrickColor.new("Toothpaste"))
					sphere(2,"Add",orb.CFrame,vt(orbm.Scale.x,orbm.Scale.y,orbm.Scale.z),2,BrickColor.new("Toothpaste"))
					for i = 0, 49 do
						PixelBlock(1,math.random(1,30),"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),4,4,4,0.08,BrickColor.new("Toothpaste"),0)
					end
					for i = 0, 9 do
						sphereMK(1,2.5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,50,-0.05,BrickColor.new("Toothpaste"),0)
						sphereMK(2,5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,50,-0.05,BrickColor.new("Toothpaste"),0)
					end
					orb.Anchored = true
					orb.Transparency = 1
					wait(8)
					orb:Destroy()
				end
			end)
		end))
		for i = 0, 1, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(50)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-50)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(60),math.rad(20),math.rad(50)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.4)
		end
		attack = false
	end

	function ChaosGroundStrike()
		attack = true
		for i = 0, 2, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(140),math.rad(0),math.rad(-20)),.2)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(140),math.rad(0),math.rad(20)),.2)
		end
		CFuncs["Sound"].Create("rbxassetid://438666141", root, 7.5,1)
		CFuncs["Sound"].Create("rbxassetid://1208650519", root, 7.5, 1)
		CameraEnshaking(4,12)
		for i, v in pairs(FindNearestHead(Torso.CFrame.p, 52.5)) do
			if v:FindFirstChild('Head') then
				dmg(v)
			end
		end
		sphere(5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0,0,0),1,BrickColor.random())
		sphere(10,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0,0,0),2,BrickColor.random())
		sphere(1,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(100,0.1,100),0.01,BrickColor.random())
		for i = 0, 2, 0.1 do
			swait()
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5,52.5),-5,math.random(-52.5,52.5))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5,52.5),-5,math.random(-52.5,52.5))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
			RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(0)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(30)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-30)),.4)
		end
		attack = false
	end

	function InsaneGroundStrike()
		attack = true
		chatfunc("Succumb to the insanity!",Color3.new(0,0,0))
		for i = 0, 8, 0.1 do
			swait()
			PixelBlockNeg(2,1,"Add",RightLeg.CFrame*cf(0,-1.35,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,BrickColor.new("Toothpaste"),0)

			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(140),math.rad(0),math.rad(-20)),.2)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(140),math.rad(0),math.rad(20)),.2)
		end
		CFuncs["Sound"].Create("rbxassetid://438666141", root, 7.5,1)
		CFuncs["Sound"].Create("rbxassetid://1208650519", root, 7.5, 1)
		CameraEnshaking(8,24)
		for i, v in pairs(FindNearestHead(Torso.CFrame.p, 105)) do
			if v:FindFirstChild('Head') then
				dmg(v)
			end
		end
		sphere(5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0,0,0),1,BrickColor.random())
		sphere(10,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0,0,0),2,BrickColor.random())
		sphere(1,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(200,0.1,200),0.01,BrickColor.random())
		CFuncs["Sound"].Create("rbxassetid://907329669", root, 10, 1)
		chatfunc("Leave the dead where they fall!",Color3.new(0,0,0))
		for i = 0, 2, 0.1 do
			swait()
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-105,105),-5,math.random(-105,105))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-105,105),-5,math.random(-105,105))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
			RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(0)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(30)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-30)),.4)
		end
		attack = false
	end

	function Starfall()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 5, 1)
		for i = 0, 5, 0.1 do
			swait()
			PixelBlockNeg(1,math.random(1,2),"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			PixelBlockNeg(1,math.random(1,2),"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(-5 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(130),math.rad(0),math.rad(70 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(130),math.rad(0),math.rad(-70 - 2.5 * math.cos(sine / 28))),.1)
		end
		local Overed = false
		CameraEnshaking(2,20)
		sphere(1.5,"Add",sorb.CFrame,vt(0,0,0),0.25,MAINRUINCOLOR)
		sphere(1.5,"Add",sorb2.CFrame,vt(0,0,0),0.25,MAINRUINCOLOR)
		sphere(5,"Add",root.CFrame,vt(0,0,0),12.5,MAINRUINCOLOR)
		CFuncs["Sound"].Create("rbxassetid://1177785010", char, 1, 1)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = BrickColor.new("Toothpaste")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Remenant"
		orb.Material = "Neon"
		orb.CFrame = root.CFrame*CFrame.new(0,150,0)
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 1
		orb.TopSurface = 0
		orb.BottomSurface = 0
		hum.WalkSpeed = storehumanoidWS
		coroutine.resume(coroutine.create(function()
			for i = 0, 9 do
				swait(10)
				local lb = Instance.new("Part")
				lb.Color = MAINRUINCOLOR.Color
				lb.CanCollide = false
				lb.Material = "Neon"
				lb.Anchored = true
				lb.TopSurface = 0
				lb.BottomSurface = 0
				lb.Transparency = 0
				lb.Size = vt(1,1,1)
				lb.CFrame = orb.CFrame*CFrame.new(math.random(-150,150),0,math.random(-150,150))*CFrame.Angles(math.rad(-90 + math.random(-15,15)),0,math.rad(math.random(-15,15)))
				lb.Anchored = false
				lb.Parent = char
				local thingery = Instance.new("SpecialMesh",lb)
				thingery.MeshType = "Sphere"
				thingery.Scale = vt(20,20,20)
				game:GetService("Debris"):AddItem(lb, 10)
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = lb.CFrame.lookVector*math.random(75,250)
				bv.Parent = lb
				sphere(2.5,"Add",lb.CFrame,vt(50,50,0),0.25,MAINRUINCOLOR)
				sphere(5,"Add",lb.CFrame,vt(50,50,0),0.5,MAINRUINCOLOR)
				CFuncs["Sound"].Create("rbxassetid://633627961",lb, 5, 1)
				CFuncs["Sound"].Create("rbxassetid://1002081188", lb, 5, 1)
				CFuncs["Sound"].Create("rbxassetid://741272936", lb, 5, 1)
				CFuncs["Sound"].Create("rbxassetid://1192402877", lb, 5, 1)
				local hitted = false
				coroutine.resume(coroutine.create(function()
					while true do
						swait(1)
						if lb.Parent ~= nil and hitted == false then
							PixelBlockNeg(5,math.random(1,2),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),10,10,10,0.1,MAINRUINCOLOR,-2)
						elseif lb.Parent == nil then
							break
						end
					end
				end))

				game:GetService("Debris"):AddItem(a, 0.1)

				coroutine.resume(coroutine.create(function()
					swait(1)
					lb.Touched:connect(function(hit)
						if hitted == false then
							hitted = true
							lb.Transparency = 1
							lb.Anchored = true
							CFuncs["Sound"].Create("rbxassetid://1177785010", lb, 5, 1)
							CFuncs["Sound"].Create("rbxassetid://192410089", lb, 5, 0.7)
							CFuncs["Sound"].Create("rbxassetid://579687077", lb, 2.5, 0.75)
							CFuncs["Sound"].Create("rbxassetid://1060191237", lb, 3, 0.75)
							CFuncs["Sound"].Create("rbxassetid://164881112", lb, 5, 1)
							CFuncs["Sound"].Create("rbxassetid://429123896", lb, 3.5, 0.85)
							MagniDamage(lb, 45, 45,85, 0, "Normal")
							CameraEnshaking(1,5)
							sphere(8,"Add",lb.CFrame,vt(20,20,20),1,MAINRUINCOLOR)
							sphere(16,"Add",lb.CFrame,vt(20,20,20),2,MAINRUINCOLOR)
							for i = 0, 9 do
								sphereMK(1,math.random(1,3),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,50,-0.1,MAINRUINCOLOR,0)
							end
							for i = 0, 49 do
								swait()
								MagniDamage(lb, 30, 2,4, 0, "Normal")
								PixelBlock(4,math.random(1,30),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),16,16,16,0.16,MAINRUINCOLOR,0)
							end
						end
					end)
				end))
			end
			Overed = true
			orb:Destroy()
		end))

		attack = false
	end

	function StarfallEX()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 5, 1)
		for i = 0, 5, 0.1 do
			swait()
			PixelBlockNeg(1,math.random(1,2),"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			PixelBlockNeg(1,math.random(1,2),"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(-5 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(130),math.rad(0),math.rad(70 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(130),math.rad(0),math.rad(-70 - 2.5 * math.cos(sine / 28))),.1)
		end
		local Overed = false
		CameraEnshaking(2,20)
		sphere(1.5,"Add",sorb.CFrame,vt(0,0,0),0.25,MAINRUINCOLOR)
		sphere(1.5,"Add",sorb2.CFrame,vt(0,0,0),0.25,MAINRUINCOLOR)
		sphere(5,"Add",root.CFrame,vt(0,0,0),12.5,MAINRUINCOLOR)
		CFuncs["Sound"].Create("rbxassetid://1177785010", char, 1, 1)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = BrickColor.new("Toothpaste")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Remenant"
		orb.Material = "Neon"
		orb.CFrame = root.CFrame*CFrame.new(0,150,0)
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 1
		orb.TopSurface = 0
		orb.BottomSurface = 0
		hum.WalkSpeed = storehumanoidWS
		coroutine.resume(coroutine.create(function()
			for i = 1, 5 do
				swait(10)
				local lb = Instance.new("Part")
				lb.Color = MAINRUINCOLOR.Color
				lb.CanCollide = false
				lb.Material = "Neon"
				lb.Anchored = true
				lb.TopSurface = 0
				lb.BottomSurface = 0
				lb.Transparency = 0
				lb.Size = vt(1,1,1)
				lb.CFrame = orb.CFrame*CFrame.new(math.random(-75,75),0,math.random(-75,75))*CFrame.Angles(math.rad(-90 + math.random(-15,15)),0,math.rad(math.random(-15,15)))
				lb.Anchored = false
				lb.Parent = char
				local thingery = Instance.new("SpecialMesh",lb)
				thingery.MeshType = "Sphere"
				thingery.Scale = vt(20,20,20)
				game:GetService("Debris"):AddItem(lb, 10)
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = lb.CFrame.lookVector*math.random(75,250)
				bv.Parent = lb
				sphere(2.5,"Add",lb.CFrame,vt(50,50,0),0.25,MAINRUINCOLOR)
				sphere(5,"Add",lb.CFrame,vt(50,50,0),0.5,MAINRUINCOLOR)
				CFuncs["Sound"].Create("rbxassetid://633627961",lb, 5, 1)
				CFuncs["Sound"].Create("rbxassetid://1002081188", lb, 5, 1)
				CFuncs["Sound"].Create("rbxassetid://741272936", lb, 5, 1)
				CFuncs["Sound"].Create("rbxassetid://1192402877", lb, 5, 1)
				local hitted = false
				coroutine.resume(coroutine.create(function()
					while true do
						swait(1)
						if lb.Parent ~= nil and hitted == false then
							PixelBlockNeg(5,math.random(1,2),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),10,10,10,0.1,MAINRUINCOLOR,-2)
						elseif lb.Parent == nil then
							break
						end
					end
				end))

				game:GetService("Debris"):AddItem(a, 0.1)

				coroutine.resume(coroutine.create(function()
					swait(5)
					lb.Touched:connect(function(hit)
						if hitted == false and not hit:IsDescendantOf(Character) then
							hitted = true
							lb.Transparency = 1
							lb.Anchored = true
							CFuncs["Sound"].Create("rbxassetid://1177785010", lb, 5, 1)
							CFuncs["Sound"].Create("rbxassetid://192410089", lb, 5, 0.7)
							CFuncs["Sound"].Create("rbxassetid://579687077", lb, 2.5, 0.75)
							CFuncs["Sound"].Create("rbxassetid://1060191237", lb, 3, 0.75)
							CFuncs["Sound"].Create("rbxassetid://164881112", lb, 5, 1)
							CFuncs["Sound"].Create("rbxassetid://429123896", lb, 3.5, 0.85)
							MagniDamage(lb, 45, 90,170, 0, "Normal")
							CameraEnshaking(1,5)
							sphere(8,"Add",lb.CFrame,vt(20,20,20),1,MAINRUINCOLOR)
							sphere(16,"Add",lb.CFrame,vt(20,20,20),2,MAINRUINCOLOR)
							for i = 0, 9 do
								sphereMK(1,math.random(1,3),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,50,-0.1,MAINRUINCOLOR,0)
							end
							for i = 0, 49 do
								swait()
								MagniDamage(lb, 60, 20,40, 0, "Normal")
								PixelBlock(4,math.random(1,30),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),16,16,16,0.16,MAINRUINCOLOR,0)
							end
						end
					end)
				end))
			end
			Overed = true
			orb:Destroy()
		end))

		attack = false
	end


	function StarDivision()
		attack = true
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 2, 1.5)
		for i = 0, 2, 0.1 do
			swait()
			PixelBlockNeg(1,math.random(1,2),"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(90)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(-90)),.6)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.6)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.6)
		end
		local orb = Instance.new("Part", char)
		orb.BrickColor = MAINRUINCOLOR
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(2,2,2)
		local a = Instance.new("Part",workspace)
		a.Name = "Direction"   
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			sorb.CFrame.p,                           -- origin
			(mouse.Hit.p - sorb.CFrame.p).unit * 500 -- direction
		)
		local ignore = sorb
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (sorb.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(sorb.CFrame.p, position) * CFrame.new(0, 0, 0)
		orb.CFrame = a.CFrame
		a:Destroy()
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = orb.CFrame.lookVector*100
		bv.Parent = orb
		local hitted = false
		game:GetService("Debris"):AddItem(orb, 10)
		CFuncs["Sound"].Create("rbxassetid://376970418",orb, 1.5, 1.15)
		CFuncs["Sound"].Create("rbxassetid://633627961",orb, 1, 1.15)
		CFuncs["Sound"].Create("rbxassetid://1002081188", orb, 1, 1.15)
		CFuncs["Sound"].Create("rbxassetid://741272936", orb, 1, 1.15)
		CFuncs["Sound"].Create("rbxassetid://1192402877", orb, 1, 1.15)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				if orb.Parent ~= nil and hitted == false then
					PixelBlockNeg(1,math.random(1,2),"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1,1,1,0.02,MAINRUINCOLOR,-2)
				elseif orb.Parent == nil then
					break
				end
			end
		end))
		coroutine.resume(coroutine.create(function()
			swait(1)
			orb.Touched:connect(function(hit)
				if hitted == false then
					hitted = true
					game:GetService("Debris"):AddItem(orb, 5)
					orb.Transparency = 1
					orb.Anchored = true
					local elocacenter = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					elocacenter.Anchored = true
					elocacenter.CFrame = orb.CFrame
					elocacenter.Orientation = vt(0,0,0)
					local eloca1 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					eloca1.Anchored = true
					eloca1.CFrame = elocacenter.CFrame
					local eloca2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					eloca2.Anchored = true
					eloca2.CFrame = elocacenter.CFrame
					local eloca3 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					eloca3.Anchored = true
					eloca3.CFrame = elocacenter.CFrame
					local eloca4 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					eloca4.Anchored = true
					eloca4.CFrame = elocacenter.CFrame
					local lookavec = 0
					local speeds = 0
					CameraEnshaking(1,1)
					CFuncs["Sound"].Create("rbxassetid://419447292", elocacenter, 10,1)
					sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
					sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
					sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
					sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
					sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
					for i = 0, 99 do
						swait()
						lookavec = lookavec + 1
						speeds = speeds + 0.1
						elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
						eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)
					end

					for i = 0, 149 do
						swait()
						speeds = speeds + 0.1
						elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
						eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)
					end
					for i, v in pairs(FindNearestHead(elocacenter.CFrame.p, 125)) do
						if v:FindFirstChild('Head') then
							dmg(v)
						end
					end
					CameraEnshaking(7,30)
					MagniDamage(elocacenter, 225, 50,75, 0, "Normal")
					CFuncs["Sound"].Create("rbxassetid://468991944", char, 4, 1)
					CFuncs["Sound"].Create("rbxassetid://533636230", char, 5, 0.75)
					CFuncs["Sound"].Create("rbxassetid://419447292", char, 1,1)
					CFuncs["Sound"].Create("rbxassetid://421328847", char, 1,1)
					sphere(1,"Add",elocacenter.CFrame,vt(125,90000,125),-0.25,MAINRUINCOLOR)
					sphere(1,"Add",elocacenter.CFrame,vt(125,90000,125),0.5,MAINRUINCOLOR)
					sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					for i = 0, 24 do
						sphereMK(1,2,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,100,-0.5,MAINRUINCOLOR,0)
						sphereMK(2,4,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,75,-0.25,MAINRUINCOLOR,0)
						sphereMK(3,6,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,50,-0.25,MAINRUINCOLOR,0)
						sphereMK(4,8,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,25,-0.25,MAINRUINCOLOR,0)
					end
					coroutine.resume(coroutine.create(function()
						for i = 0, 499 do
							swait(1)
							MagniDamage(elocacenter, 90, 1,5, 0, "Normal")
							PixelBlockNeg(2,math.random(1,10),"Add",elocacenter.CFrame*CFrame.new(math.random(-75,75),0,math.random(-75,75))*CFrame.Angles(math.rad(90 + math.random(-30,30)),math.rad(math.random(-30,30)),math.rad(math.random(-30,30))),15,15,15,0.15,MAINRUINCOLOR,-5)
						end
						elocacenter:Destroy()
						eloca1:Destroy()
						eloca2:Destroy()
						eloca3:Destroy()
						eloca4:Destroy()
					end))
				end
			end)
		end))
		attack = false
	end


	function UniversalCollapse()
		attack = true
		local speedearn = 0
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://1208650519", char, 10, 1)
		for i = 0, 10, 0.1 do
			swait()
			speedearn = speedearn + 0.1
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
		end
		CameraEnshaking(5,45)
		sphere(5,"Add",root.CFrame,vt(0,0,0),25,MAINRUINCOLOR)
		CFuncs["Sound"].Create("rbxassetid://1177785010", char, 10, 1)
		for i, v in pairs(FindNearestHead(Torso.CFrame.p, 1234567890)) do
			if v:FindFirstChild('Head') then
				dmg(v)
			end
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end
	function ChaosBegone()
		attack = true
		local speedearn = 0
		CFuncs["Sound"].Create("rbxassetid://2545008459", char, 10, 1)
		for i = 0, 10, 0.1 do
			swait()
			speedearn = speedearn + 0.1
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(140),math.rad(0),math.rad(-20)),.2)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(140),math.rad(0),math.rad(20)),.2)
		end
		CFuncs["Sound"].Create("rbxassetid://438666141", char, 7.5,1)
		CFuncs["Sound"].Create("rbxassetid://1208650519", char, 7.5, 1)
		CameraEnshaking(5,25)
		for i, v in pairs(FindNearestHead(Torso.CFrame.p, 1234567890)) do
			if v:FindFirstChild('Head') then
				dmg(v)
			end
		end
		sphere(5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0,0,0),1*1000,BrickColor.random())
		sphere(10,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0,0,0),2*1000,BrickColor.random())
		sphere(1,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(100*1000,0.1,100*1000),0.01,BrickColor.random())
		for i = 0, 3, 0.1 do
			swait()
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5*10,52.5*10),-5,math.random(-52.5*10,52.5*10))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5*10,52.5*10),-5,math.random(-52.5*10,52.5*10))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5*10,52.5*10),-5,math.random(-52.5*10,52.5*10))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5*10,52.5*10),-5,math.random(-52.5*10,52.5*10))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
			RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(0)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(30)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-30)),.4)
		end
		attack = false
	end

	function orb_spawn_norm(positted,timer,color,MagniBoost,min,max,volEx,ShakePower,volSummon)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = color
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orb.CFrame = positted
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(1,1,1)
		coroutine.wrap(function()
			while orb and orb.Parent do
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					orb.Color = color
				end
				swait()
			end
		end)()
		CFuncs["Sound"].Create("rbxassetid://183763506", orb, volSummon, 1)
		sphere(2.5,"Add",orb.CFrame,vt(1,1,1),0.05,orb.BrickColor)
--[[for i = 0, 2 do
sphereMK(5,0.15,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1.5,1.5,7.5,-0.015,orb.BrickColor,0)
end]]--
		coroutine.resume(coroutine.create(function()
			wait(timer)
			CameraEnshaking(3,ShakePower)
			orb.Transparency = 1
			MagniDamage(orb, 3.5*MagniBoost, min,max, 0, "Normal")
			sphere(5,"Add",orb.CFrame,vt(1,1,1),0.1*MagniBoost,orb.BrickColor)
--[[for i = 0, 4 do
sphereMK(5,0.15*MagniBoost,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,orb.BrickColor,0)
end]]--
			CFuncs["Sound"].Create("rbxassetid://192410089", orb, volEx, 0.7)
			wait(3)
			orb:Destroy()
		end))
	end

	function orb_spawn(positted,timer)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = BrickColor.new("White")

		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orb.CFrame = positted
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(1,1,1)
		CFuncs["Sound"].Create("rbxassetid://183763506", orb, 1.5, 1)
		sphere(2.5,"Add",orb.CFrame,vt(1,1,1),0.025,orb.BrickColor)
		coroutine.wrap(function()
			while orb and orb.Parent do
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					orb.Color = color
				end
				swait()
			end
		end)()
		for i = 0, 2 do
			sphereMK(5,0.15,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1.5,1.5,7.5,-0.015,orb.BrickColor,0)
		end

		coroutine.resume(coroutine.create(function()
			wait(timer)
			CameraEnshaking(3,2)
			orb.Transparency = 1
			MagniDamage(orb, 17.5, 10,50, 0, "Normal")
			sphere(5,"Add",orb.CFrame,vt(1,1,1),0.5,orb.BrickColor)
			for i = 0, 4 do
				sphereMK(5,0.65,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,orb.BrickColor,0)
			end
			CFuncs["Sound"].Create("rbxassetid://192410089", orb, 2, 0.7)
			wait(3)
			orb:Destroy()
		end))
	end

	function scattercorrupt()
		attack = true
		local rot = 0
		local randomrotations = math.random(1,2)
		local lookv = 2.5
		local power = 5
		sphere(1,"Add",root.CFrame,vt(1,100000,1),0.5,BrickColor.new("Royal purple"))
		sphere(1,"Add",root.CFrame,vt(1,1,1),0.75,BrickColor.new("Royal purple"))
		for i = 0, 9 do
			sphereMK(1,1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10,10,45,-0.1,BrickColor.new("Royal purple"),0)
		end
		CFuncs["Sound"].Create("rbxassetid://180204650", char, 2.5, 0.6)
		CFuncs["Sound"].Create("rbxassetid://233856079", char, 1, 0.5)
		CFuncs["Sound"].Create("rbxassetid://1208650519", char, 2.5, 1)
		CFuncs["Sound"].Create("rbxassetid://239000203", char, 0.5,0.75)
		CFuncs["Sound"].Create("rbxassetid://579687077", char, 0.5,0.5)
		local hite = Instance.new("Part", char)
		hite.Anchored = true
		hite.CanCollide = false
		hite.FormFactor = 3
		hite.Name = "Ring"
		hite.Material = "Neon"
		hite.Size = Vector3.new(1, 1, 1)
		hite.Transparency = 1
		hite.TopSurface = 0
		hite.BottomSurface = 0
		hite.CFrame = root.CFrame*CFrame.new(0,-2.5,0)
		local rem = Instance.new("Part", char)
		rem.Anchored = true
		rem.CanCollide = false
		rem.FormFactor = 3
		rem.Name = "Ring"
		rem.Material = "Neon"
		rem.Size = Vector3.new(1, 1, 1)
		rem.Transparency = 1
		rem.TopSurface = 0
		rem.BottomSurface = 0
		rem.CFrame = hite.CFrame
		local rem2 = rem:Clone()
		rem2.Parent = char
		rem2.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(90),0)
		local rem3 = rem:Clone()
		rem3.Parent = char
		rem3.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(180),0)
		local rem4 = rem:Clone()
		rem4.Parent = char
		rem4.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(270),0)
		hite:Destroy()
		coroutine.resume(coroutine.create(function()
			for i = 0, 24 do
				swait(1)
				if randomrotations == 1 then
					rot = rot + 1
				elseif randomrotations == 2 then
					rot = rot - 1
				end
				power = power + 0.5
				lookv = lookv + 7.5
				rem.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(rot),0)
				rem2.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(90),0)
				rem3.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(180),0)
				rem4.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(270),0)
				orb_spawn_norm(rem.CFrame + rem.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,power/5,7.5)
				orb_spawn_norm(rem2.CFrame + rem2.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,power/5,7.5)
				orb_spawn_norm(rem3.CFrame + rem3.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,power/5,7.5)
				orb_spawn_norm(rem4.CFrame + rem4.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,power/5,7.5)
			end
		end))
		attack = false
	end
	function yinyangi()
		attack = true
		for i = 0, 2, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(75),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.2)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.2)
		end
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = root.CFrame.lookVector*175
		bv.Parent = root
		for Rotations = 0, 9 do

			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector*175
				RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.5)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.5)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(90),math.rad(0),math.rad(90)),.5)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.5)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.5)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.5)
			end

			orb_spawn(rarm.CFrame*CFrame.new(0,-1,0),2.5)
			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector*175
				RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.5)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.5)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(90),math.rad(0),math.rad(180)),.5)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.5)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.5)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.5)
			end

			orb_spawn(rarm.CFrame*CFrame.new(0,-1,0),2.5)
			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector*175
				RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.5)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.5)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(90),math.rad(0),math.rad(270)),.5)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.5)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.5)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.5)
			end

			orb_spawn(rarm.CFrame*CFrame.new(0,-1,0),2.5)
			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector*175
				RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.5)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.5)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(90),math.rad(0),math.rad(360)),.5)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.5)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.5)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.5)
			end

			orb_spawn(rarm.CFrame*CFrame.new(0,-1,0),2.5)
		end
		bv:Destroy()
		attack = false
	end

	function JusticeBeam()
		attack = true

		local rngb = Instance.new("Part", char)
		rngb.Anchored = true
		rngb.BrickColor = origcolor
		rngb.CanCollide = false
		rngb.FormFactor = 3
		rngb.Name = "Ring"
		rngb.Material = "Neon"
		rngb.Size = Vector3.new(1, 0.05, 1)
		rngb.Transparency = 1
		rngb.TopSurface = 0
		rngb.BottomSurface = 0
		local rngmb = Instance.new("SpecialMesh", rngb)
		rngmb.MeshType = "Brick"
		rngmb.Name = "SizeMesh"
		rngmb.Scale = vt(0,1,0)

		local orb = rngb:Clone()
		orb.Parent = char
		orb.Transparency = 0
		orb.BrickColor = BrickColor.new("White")
		orb.Size = vt(1,1,1)
		local orbmish = orb.SizeMesh
		orbmish.Scale = vt(0,0,0)
		orbmish.MeshType = "Sphere"

		local orbe = rngb:Clone()
		orbe.Parent = char
		orbe.Transparency = 0.5
		orbe.BrickColor = BrickColor.new("New Yeller")
		orbe.Size = vt(1,1,1)
		local orbmish2 = orbe.SizeMesh
		orbmish2.Scale = vt(0,0,0)
		orbmish2.MeshType = "Sphere"
		orbe.Color = Color3.new(1,1,1)

		rngb:Destroy()
--[[CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1.5, 1)
local scaled = 1
for i = 0,5,0.1 do
swait()
scaled = scaled - 0.02
if rainbowmode == true then
orbe.Color = Color3.new(r/255,g/255,b/255)
end
orbmish.Scale = orbmish.Scale + vt(scaled/1.5,scaled/1.5,scaled/1.5)
orbmish2.Scale = orbmish2.Scale + vt(scaled*1.1/1.5,scaled*1.1/1.5,scaled*1.1/1.5)
orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
sphereMKCharge(2.5,-0.5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MAINRUINCOLOR,25)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)
RootPart.CFrame = FaceMouse()[1]
end]]--
		for i = 0,5,0.1 do
			swait()
			if rainbowmode == true then
				orbe.Color = Color3.new(r/255,g/255,b/255)
			end
			if glitchymode then
				local val = math.random(1,255)
				local color = Color3.fromRGB(val,val,val)
				orbe.Color = color
			end
			orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
			orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(90),0,math.rad(20 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(90),0,math.rad(-20 - 2.5 * math.cos(sine / 28))),.1)
		end
		orbe.Transparency = 1
		orb.Transparency = 1
		orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*5
		CFuncs["Sound"].Create("rbxassetid://294188875", char, 1, 1)
		local a2 = Instance.new("Part",Character)
		a2.Name = "Direction"  
		a2.Anchored = true
		a2.BrickColor = bc("New Yeller")
		a2.Color = Color3.new(1,1,1)
		a2.Material = "Neon"
		a2.Transparency = 0.5
		a2.Shape = "Cylinder"
		a2.CanCollide = false
		local ba = Instance.new("Part",Character)
		ba.Name = "HitDirect"  
		ba.Anchored = true
		ba.BrickColor = bc("Cool yellow")
		ba.Material = "Neon"
		ba.Transparency = 1
		ba.CanCollide = false
		local ray = Ray.new(
			orb.CFrame.p,                           -- origin
			root.CFrame.lookVector.unit * 1000 -- direction
		)
		local ignore = Character
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a2.Transparency = .75
		a2.BottomSurface = 10
		a2.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a2.Size = Vector3.new(distance, 1, 1)
		a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
		a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
		game:GetService("Debris"):AddItem(a2, 20)
		game:GetService("Debris"):AddItem(ba, 20)
		local msh2 = Instance.new("SpecialMesh",a2)
		msh2.MeshType = "Cylinder"
		msh2.Scale = vt(1,6*5,6*5)

		local snd = CFuncs.Sound.Create("rbxassetid://294188875", Torso, 10, 1)
		for i = 1, 80*2 do
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(90),0,math.rad(20 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(90),0,math.rad(-20 - 2.5 * math.cos(sine / 28))),.1)
			swait()
			CameraEnshaking(1,5)
			a2.Color = Color3.new(1,1,1)
			a2.Transparency = .25
			orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
			orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
			ray = Ray.new(
				orb.CFrame.p,                           -- origin
				root.CFrame.lookVector.unit * 1000 -- direction
			)
			hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			distance = (orb.CFrame.p - position).magnitude
			if typrot == 1 then
				rotation = rotation + 2.5
			elseif typrot == 2 then
				rotation = rotation - 2.5
			end
			a2.Size = Vector3.new(distance, 1, 1)
			a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
			a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
			msh2.Scale = msh2.Scale - vt(0,.19,.19)
			sphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,MAINRUINCOLOR,0)
			sphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,MAINRUINCOLOR,0)
			MagniDamage(ba, 30, 5,25, 0, "Normal")
		end
		a2:Destroy()
		ba:Destroy()
		orb:Destroy()
		orbe:Destroy()
		attack = false
	end

	function Wip()
		attack = true

		local rngb = Instance.new("Part", char)
		rngb.Anchored = true
		rngb.BrickColor = origcolor
		rngb.CanCollide = false
		rngb.FormFactor = 3
		rngb.Name = "Ring"
		rngb.Material = "Neon"
		rngb.Size = Vector3.new(1, 0.05, 1)
		rngb.Transparency = 1
		rngb.TopSurface = 0
		rngb.BottomSurface = 0
		local rngmb = Instance.new("SpecialMesh", rngb)
		rngmb.MeshType = "Brick"
		rngmb.Name = "SizeMesh"
		rngmb.Scale = vt(0,1,0)

		local orb = rngb:Clone()
		orb.Parent = char
		orb.Transparency = 0
		orb.BrickColor = BrickColor.new("White")
		orb.Size = vt(1,1,1)
		local orbmish = orb.SizeMesh
		orbmish.Scale = vt(0,0,0)
		orbmish.MeshType = "Sphere"

		local orbe = rngb:Clone()
		orbe.Parent = char
		orbe.Transparency = 0.5
		orbe.BrickColor = BrickColor.new("New Yeller")
		orbe.Size = vt(1,1,1)
		local orbmish2 = orbe.SizeMesh
		orbmish2.Scale = vt(0,0,0)
		orbmish2.MeshType = "Sphere"
		orbe.Color = Color3.new(r/255,g/255,b/255)

		hum.AutoRotate = false
		rngb:Destroy()
--[[CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1.5, 1)
local scaled = 1
for i = 0,5,0.1 do
swait()
scaled = scaled - 0.02
if rainbowmode == true then
orbe.Color = Color3.new(r/255,g/255,b/255)
end
orbmish.Scale = orbmish.Scale + vt(scaled/1.5,scaled/1.5,scaled/1.5)
orbmish2.Scale = orbmish2.Scale + vt(scaled*1.1/1.5,scaled*1.1/1.5,scaled*1.1/1.5)
orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
sphereMKCharge(2.5,-0.5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MAINRUINCOLOR,25)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)
RootPart.CFrame = FaceMouse()[1]
end]]--
		for i = 0,5,0.1 do
			swait()
			if rainbowmode == true then
				orbe.Color = Color3.new(r/255,g/255,b/255)
			end
			if glitchymode then
				local val = math.random(1,255)
				local color = Color3.fromRGB(val,val,val)
				orbe.Color = color
			end
			orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
			orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)
			RootPart.CFrame = FaceMouse()[1]
		end
		orbe.Transparency = 1
		orb.Transparency = 1
		orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*5
		CFuncs["Sound"].Create("rbxassetid://294188875", char, 1, 1)
		local a = Instance.new("Part",Character)
		a.Name = "Direction"   
		a.Anchored = true
		a.BrickColor = bc("White")
		a.Material = "Neon"
		a.Transparency = 0
		a.Shape = "Cylinder"
		a.CanCollide = false
		local a2 = Instance.new("Part",Character)
		a2.Name = "Direction"  
		a2.Anchored = true
		a2.BrickColor = bc("New Yeller")
		a2.Color = Color3.new(r/255,g/255,b/255)
		a2.Material = "Neon"
		a2.Transparency = 0.5
		a2.Shape = "Cylinder"
		a2.CanCollide = false
		local ba = Instance.new("Part",Character)
		ba.Name = "HitDirect"  
		ba.Anchored = true
		ba.BrickColor = bc("Cool yellow")
		ba.Material = "Neon"
		ba.Transparency = 1
		ba.CanCollide = false
		local ray = Ray.new(
			orb.CFrame.p,                           -- origin
			(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
		)
		local ignore = Character
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		a2.BottomSurface = 10
		a2.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance, 1, 1)
		a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		a2.Size = Vector3.new(distance, 1, 1)
		a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
		a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
		a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
		game:GetService("Debris"):AddItem(a, 20)
		game:GetService("Debris"):AddItem(a2, 20)
		game:GetService("Debris"):AddItem(ba, 20)
		local msh = Instance.new("SpecialMesh",a)
		msh.MeshType = "Cylinder"
		msh.Scale = vt(1,5*5,5*5)
		local msh2 = Instance.new("SpecialMesh",a2)
		msh2.MeshType = "Cylinder"
		msh2.Scale = vt(1,6*5,6*5)

		for i = 0,10,0.1 do
			swait()
			CameraEnshaking(1,5)
			a2.Color = Color3.new(r/255,g/255,b/255)
			orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
			orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
			ray = Ray.new(
				orb.CFrame.p,                           -- origin
				(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
			)
			hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			distance = (orb.CFrame.p - position).magnitude
			if typrot == 1 then
				rotation = rotation + 2.5
			elseif typrot == 2 then
				rotation = rotation - 2.5
			end
			RootPart.CFrame = FaceMouse()[1]
			a.Size = Vector3.new(distance, 1, 1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			a2.Size = Vector3.new(distance, 1, 1)
			a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
			a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
			a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
			msh.Scale = msh.Scale - vt(0,0.05*5,0.05*5)
			msh2.Scale = msh2.Scale - vt(0,0.06*5,0.06*5)
			sphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,MAINRUINCOLOR,0)
			sphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,MAINRUINCOLOR,0)
			MagniDamage(ba, 30, 5,25, 0, "Normal")
		end
		a:Destroy()
		a2:Destroy()
		ba:Destroy()
		orb:Destroy()
		orbe:Destroy()
		hum.AutoRotate = true
		attack = false
	end


	function UniversalSpark()
		attack = true

		local rngb = Instance.new("Part", char)
		rngb.Anchored = true
		rngb.BrickColor = origcolor
		rngb.CanCollide = false
		rngb.FormFactor = 3
		rngb.Name = "Ring"
		rngb.Material = "Neon"
		rngb.Size = Vector3.new(1, 0.05, 1)
		rngb.Transparency = 1
		rngb.TopSurface = 0
		rngb.BottomSurface = 0
		local rngmb = Instance.new("SpecialMesh", rngb)
		rngmb.MeshType = "Brick"
		rngmb.Name = "SizeMesh"
		rngmb.Scale = vt(0,1,0)

		local orb = rngb:Clone()
		orb.Parent = char
		orb.Transparency = 0
		orb.BrickColor = BrickColor.new("White")
		orb.Size = vt(1,1,1)
		local orbmish = orb.SizeMesh
		orbmish.Scale = vt(0,0,0)
		orbmish.MeshType = "Sphere"

		local orbe = rngb:Clone()
		orbe.Parent = char
		orbe.Transparency = 0.5
		orbe.BrickColor = BrickColor.new("New Yeller")
		orbe.Size = vt(1,1,1)
		local orbmish2 = orbe.SizeMesh
		orbmish2.Scale = vt(0,0,0)
		orbmish2.MeshType = "Sphere"
		orbe.Color = Color3.new(r/255,g/255,b/255)

		rngb:Destroy()
--[[CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1.5, 1)
local scaled = 1
for i = 0,5,0.1 do
swait()
scaled = scaled - 0.02
if rainbowmode == true then
orbe.Color = Color3.new(r/255,g/255,b/255)
end
orbmish.Scale = orbmish.Scale + vt(scaled/1.5,scaled/1.5,scaled/1.5)
orbmish2.Scale = orbmish2.Scale + vt(scaled*1.1/1.5,scaled*1.1/1.5,scaled*1.1/1.5)
orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
sphereMKCharge(2.5,-0.5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MAINRUINCOLOR,25)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)
RootPart.CFrame = FaceMouse()[1]
end]]--
		for i = 0,5,0.1 do
			swait()
			if rainbowmode == true then
				orbe.Color = Color3.new(r/255,g/255,b/255)
			end
			if glitchymode then
				local val = math.random(1,255)
				local color = Color3.fromRGB(val,val,val)
				orbe.Color = color
			end
			orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
			orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)
			RootPart.CFrame = FaceMouse()[1]
		end
		orbe.Transparency = 1
		orb.Transparency = 1
		orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*5
		CFuncs["Sound"].Create("rbxassetid://741272936", char, 1, 1)
		CFuncs["Sound"].Create("rbxassetid://164881112", char, 1, 1)
		CFuncs["Sound"].Create("rbxassetid://1192402877", char, 1, 1)

		CFuncs["Sound"].Create("rbxassetid://294188875", char, 1, 1)
		CFuncs["Sound"].Create("rbxassetid://741272936", char, 0.75, 1)
		CFuncs["Sound"].Create("rbxassetid://1192402877", char, 1, 1)
		CFuncs["Sound"].Create("rbxassetid://1208650519", char, 0.75, 1)
		CFuncs["Sound"].Create("rbxassetid://164881112", char, 0.75, 1)
		CFuncs["Sound"].Create("rbxassetid://429123896", char, 1, 0.85)
		CFuncs["Sound"].Create("rbxassetid://164178927", char, 1, 1)
		local xd= Instance.new("Sound",char)
		xd.SoundId = "rbxassetid://445796828"
		xd.Pitch = 0.75
		xd.Looped = true
		xd.Volume = 1.25
		xd:Play()
		local a = Instance.new("Part",Character)
		a.Name = "Direction"   
		a.Anchored = true
		a.BrickColor = bc("Alder")
		a.Color = MAINRUINCOLOR.Color
		a.Material = "Neon"
		a.Transparency = 0.5
		a.Shape = "Cylinder"
		a.CanCollide = false
		local a2 = Instance.new("Part",Character)
		a2.Name = "Direction"  
		a2.Anchored = true
		a2.BrickColor = bc("New Yeller")
		a2.Color = MAINRUINCOLOR.Color
		a2.Material = "Neon"
		a2.Transparency = 0.5
		a2.Shape = "Cylinder"
		a2.CanCollide = false
		local ba = Instance.new("Part",Character)
		ba.Name = "HitDirect"  
		ba.Anchored = true
		ba.BrickColor = bc("Cool yellow")
		ba.Material = "Neon"
		ba.Transparency = 1
		ba.CanCollide = false
		local ray = Ray.new(
			orb.CFrame.p,                           -- origin
			(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
		)
		local ignore = Character
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		a2.BottomSurface = 10
		a2.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance, 1, 1)
		a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		a2.Size = Vector3.new(distance, 1, 1)
		a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
		a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
		a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
		game:GetService("Debris"):AddItem(a, 60)
		game:GetService("Debris"):AddItem(a2, 60)
		game:GetService("Debris"):AddItem(ba, 60)
		local outerscale = 0
		local msh = Instance.new("SpecialMesh",a)
		msh.MeshType = "Cylinder"
		msh.Scale = vt(1,0,0)
		local msh2 = Instance.new("SpecialMesh",a2)
		msh2.MeshType = "Cylinder"
		msh2.Scale = vt(1,0,0)
		for i = 0,2,0.1 do
			swait()
			CameraEnshaking(1,1)
			msh2.Scale = msh2.Scale + vt(0,outerscale*20,outerscale*20)
			msh.Scale = msh.Scale + vt(0,outerscale*15,outerscale*15)
			outerscale = outerscale - 0.015
			orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
			orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
			ray = Ray.new(
				orb.CFrame.p,                           -- origin
				(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
			)
			hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			distance = (orb.CFrame.p - position).magnitude
			if typrot == 1 then
				rotation = rotation + 2.5
			elseif typrot == 2 then
				rotation = rotation - 2.5
			end
			RootPart.CFrame = FaceMouse()[1]
			a.Size = Vector3.new(distance, 1, 1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			a2.Size = Vector3.new(distance, 1, 1)
			a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
			a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
			a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
			sphereMK(5,5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25*3,25*3,75*3,-0.25*3,MAINRUINCOLOR,0)
			sphereMK(5,5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25*3,25*3,75*3,-0.25*3,MAINRUINCOLOR,0)
			MagniDamage(ba, 100, 500,60000, 0, "Normal")
		end
		for z = 0, 2 do
			for i = 0,4,0.1 do
				swait()
				CameraEnshaking(1,1)
				msh2.Scale = msh2.Scale + vt(0,outerscale,outerscale)
				msh.Scale = msh.Scale - vt(0,outerscale,outerscale)
				outerscale = outerscale + 0.015
				orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
				orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
				ray = Ray.new(
					orb.CFrame.p,                           -- origin
					(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
				)
				hit, position, normal = workspace:FindPartOnRay(ray, ignore)
				distance = (orb.CFrame.p - position).magnitude
				if typrot == 1 then
					rotation = rotation + 2.5
				elseif typrot == 2 then
					rotation = rotation - 2.5
				end
				RootPart.CFrame = FaceMouse()[1]
				a.Size = Vector3.new(distance, 1, 1)
				a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
				a2.Size = Vector3.new(distance, 1, 1)
				a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
				ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
				a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
				a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
				sphereMK(5,5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25*3,25*3,75*3,-0.25*3,MAINRUINCOLOR,0)
				sphereMK(5,5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25*3,25*3,75*3,-0.25*3,MAINRUINCOLOR,0)
				MagniDamage(ba, 100, 500,60000, 0, "Normal")
			end
			for i = 0,4,0.1 do
				swait()
				CameraEnshaking(1,1)
				msh2.Scale = msh2.Scale + vt(0,outerscale,outerscale)
				msh.Scale = msh.Scale - vt(0,outerscale,outerscale)
				outerscale = outerscale - 0.015
				orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
				orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
				ray = Ray.new(
					orb.CFrame.p,                           -- origin
					(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
				)
				hit, position, normal = workspace:FindPartOnRay(ray, ignore)
				distance = (orb.CFrame.p - position).magnitude
				if typrot == 1 then
					rotation = rotation + 2.5
				elseif typrot == 2 then
					rotation = rotation - 2.5
				end
				RootPart.CFrame = FaceMouse()[1]
				a.Size = Vector3.new(distance, 1, 1)
				a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
				a2.Size = Vector3.new(distance, 1, 1)
				a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
				ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
				a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
				a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
				sphereMK(5,5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25*3,25*3,75*3,-0.25*3,MAINRUINCOLOR,0)
				sphereMK(5,5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25*3,25*3,75*3,-0.25*3,MAINRUINCOLOR,0)
				MagniDamage(ba, 100, 500,60000, 0, "Normal")
			end
		end
		for i = 0,4,0.1 do
			swait()
			CameraEnshaking(1,1)
			msh2.Scale = msh2.Scale + vt(0,outerscale,outerscale)
			msh.Scale = msh.Scale - vt(0,outerscale,outerscale)
			xd.Volume = xd.Volume - 0.025
			a.Transparency = a.Transparency + 0.025
			a2.Transparency = a2.Transparency + 0.025
			outerscale = outerscale - 0.015
			orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
			orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
			ray = Ray.new(
				orb.CFrame.p,                           -- origin
				(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
			)
			hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			distance = (orb.CFrame.p - position).magnitude
			if typrot == 1 then
				rotation = rotation + 2.5
			elseif typrot == 2 then
				rotation = rotation - 2.5
			end
			RootPart.CFrame = FaceMouse()[1]
			a.Size = Vector3.new(distance, 1, 1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			a2.Size = Vector3.new(distance, 1, 1)
			a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
			a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
			a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
			sphereMK(5,5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25*3,25*3,75*3,-0.25*3,MAINRUINCOLOR,0)
			sphereMK(5,5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25*3,25*3,75*3,-0.25*3,MAINRUINCOLOR,0)
			MagniDamage(ba, 100, 500,60000, 0, "Normal")
		end
		xd:Destroy()
		a:Destroy()
		a2:Destroy()
		ba:Destroy()
		orb:Destroy()
		orbe:Destroy()
		attack = false
	end



	function attackone()
		attack = true
		for i = 0,1,0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(20),math.rad(0),math.rad(-40)),0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(40)),.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-40)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-40)), 0.2)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(10)),.2)
		end
		CFuncs["Sound"].Create("rbxassetid://200632136", root, 1, 1.1)

		local hitb = Instance.new("Part", char)
		hitb.Anchored = true
		hitb.CanCollide = false
		hitb.FormFactor = 3
		hitb.Name = "Ring"
		hitb.Material = "Neon"
		hitb.Size = Vector3.new(1, 1, 1)
		hitb.Transparency = 1
		hitb.TopSurface = 0
		hitb.BottomSurface = 0
		hitb.CFrame = root.CFrame + root.CFrame.lookVector*2
		MagniDamage(hitb, 3, 10,30, 0, "Normal")
		hitb:Destroy()
		for i = 0,1,0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(-5),math.rad(0),math.rad(70)),0.4)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(-70)),.4)
			RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(70)), 0.4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(40)), 0.4)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-40)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-10)),.4)
		end

		attack = false
	end

	function attacktwo()
		attack = true
		for i = 0,1,0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(20),math.rad(0),math.rad(40)),0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-40)),.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(40)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(40)), 0.2)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(10)),.2)
		end
		CFuncs["Sound"].Create("rbxassetid://200632136", root, 1, 1)
		local hitb = Instance.new("Part", char)
		hitb.Anchored = true
		hitb.CanCollide = false
		hitb.FormFactor = 3
		hitb.Name = "Ring"
		hitb.Material = "Neon"
		hitb.Size = Vector3.new(1, 1, 1)
		hitb.Transparency = 1
		hitb.TopSurface = 0
		hitb.BottomSurface = 0
		hitb.CFrame = root.CFrame + root.CFrame.lookVector*2
		MagniDamage(hitb, 3, 10,30, 0, "Normal")
		hitb:Destroy()
		for i = 0,1,0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(-5),math.rad(0),math.rad(-70)),0.4)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(70)),.4)
			RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-40)), 0.4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-70)), 0.4)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-40)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-10)),.4)
		end
		attack = false
	end

	function attackthree()
		attack = true
		for i = 0,1,0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(80)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(-80)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(80)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)
		end
		local distlook = 5
		for i = 0, 4 do
			swait(2)
			CameraEnshaking(2,3)
			local hite = Instance.new("Part", char)
			hite.Anchored = true
			hite.CanCollide = false
			hite.FormFactor = 3
			hite.Name = "Ring"
			hite.Material = "Neon"
			hite.Size = Vector3.new(1, 1, 1)
			hite.Transparency = 1
			hite.TopSurface = 0
			hite.BottomSurface = 0
			hite.CFrame = root.CFrame + root.CFrame.lookVector*distlook
			sphere(3,"Add",hite.CFrame,vt(0,0,0),0.15,MAINRUINCOLOR)
			sphere(6,"Add",hite.CFrame,vt(0,0,0),0.3,MAINRUINCOLOR)
			MagniDamage(hite, 10, 15,35, 0, "Normal")
			for i = 0, 2 do
				sphereMK(2,0.2,"Add",rarm.CFrame*CFrame.Angles(math.rad(-90+math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.5,0.5,5,-0.005,MAINRUINCOLOR,0)
				sphereMK(3,0.2,"Add",hite.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.5,0.5,5,-0.005,MAINRUINCOLOR,0)
				sphereMK(6,0.35,"Add",hite.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.5,0.5,5,-0.005,MAINRUINCOLOR,0)
			end
			CFuncs["Sound"].Create("rbxassetid://183763506", hite, 2.5, 1)
			CFuncs["Sound"].Create("rbxassetid://178452221", hite, 0.25, 0.6)
			game:GetService("Debris"):AddItem(hite, 5)
			distlook = distlook + 10
		end
		attack = false
	end

	function FinalCalamity()
	end

	function resetmode()
		rainbowmode = false
		chaosmode = false
		glitchymode = false
		tl1.Enabled = false
		tl2.Enabled = false
		tl3.Enabled = false
		local lust = ModeOfGlitch == 69
		ModeOfGlitch = 1
		storehumanoidWS = 16
		if(not lust)then
			newTheme("rbxassetid://1564523997",48.6,1,1)
		end
		coroutine.resume(coroutine.create(function()
			attack = true
			hum.WalkSpeed = 0
			CFuncs["Sound"].Create("rbxassetid://136007472", root, 2.5, 1.25)
			for i = 0,4,0.1 do
				swait()
				sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0 - 5 * math.cos(sine / 0.2))),.2)
				RW.C0=clerp(RW.C0,cf(1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(-50)),.2)
				LW.C0=clerp(LW.C0,cf(-1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(50)),.2)
			end
			if(lust)then
				CFuncs["Sound"].Create("rbxassetid://847061203", root, 5,1)
				sphere(2.5,"Add",root.CFrame*angles(0,0,0),vt(100,100,2),1.25,BrickColor.new'Pink',true,true)
				for i = 0, 49 do
					PixelBlock(1,15,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))*cf(0,0,-80),6,6,6,0.12,BrickColor.new("Pink"),0,true,true)
				end

				for i = 0,4,0.05 do
					swait()
					Pitch = 1-i/4
					sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0 - 5 * math.cos(sine / 0.2))),.2)
					RW.C0=clerp(RW.C0,cf(1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(-50)),.2)
					LW.C0=clerp(LW.C0,cf(-1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(50)),.2)
				end
				for i = 0,3,0.1 do
					swait()
					sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0 - 5 * math.cos(sine / 0.2))),.2)
					RW.C0=clerp(RW.C0,cf(1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(-50)),.2)
					LW.C0=clerp(LW.C0,cf(-1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(50)),.2)
				end
				newTheme("rbxassetid://1564523997",48.6,1,1)
			end
			CFuncs["Sound"].Create("rbxassetid://206082327", root, 2.5,1)
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 5,1)
			CFuncs["Sound"].Create("rbxassetid://239000203", root, 2.5,1)
			CFuncs["Sound"].Create("rbxassetid://579687077", root, 2.5,0.75)
			pcall(function() Character.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'Really red' end)
			pcall(function() Character.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'Really red' end)
			RecolorTextAndRename("Solitude",Color3.new(0,0,0),Color3.new(1,1,1))
			CameraEnshaking(5,2.5)
			MAINRUINCOLOR = BrickColor.new("Really black")
			sphere(2.5,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
			for i = 0, 49 do
				PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2,2,2,0.04,MAINRUINCOLOR,0)
			end
			for i = 0,3,0.1 do
				sphereMK(2.5,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,MAINRUINCOLOR,0)
			end
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Really black")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("Really black")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Really black")
					v.Material = "Glass"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Dark stone grey")
					v.Material = "Granite"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Really black")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i = 0,2,0.1 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(-30),math.rad(0),math.rad(0)),.2)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0 - 2.5 * math.cos(sine / 0.2))),.2)
				RW.C0=clerp(RW.C0,cf(1.45,0.4,0)*angles(math.rad(-20),math.rad(0 - 2 * math.cos(sine / 0.2)),math.rad(80 + 2 * math.cos(sine / 0.2))),.2)
				LW.C0=clerp(LW.C0,cf(-1.45,0.4,0)*angles(math.rad(-20),math.rad(0 + 2 * math.cos(sine / 0.2)),math.rad(-80 - 2 * math.cos(sine / 0.2))),.2)
			end
			hum.WalkSpeed = storehumanoidWS
			attack = false
		end))
	end

	function lustmode()

		ModeOfGlitch = 69
		storehumanoidWS = 16
		rainbowmode = false
		chaosmode = false
		glitchymode = false
		tl1.Enabled = false
		tl2.Enabled = false
		tl3.Enabled = false
		newTheme("rbxassetid://1292453759",0,1,1)
		coroutine.wrap(function()
			attack = true
			hum.WalkSpeed = 0
			CFuncs["Sound"].Create("rbxassetid://136007472", root, 2.5, 1.25)
			for i = 0,4,0.1 do
				swait()
				sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0 - 5 * math.cos(sine / 0.2))),.2)
				RW.C0=clerp(RW.C0,cf(1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(-50)),.2)
				LW.C0=clerp(LW.C0,cf(-1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(50)),.2)
			end
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 5,1)
			sphere(2.5,"Add",root.CFrame*cf(0,0,0),vt(0,0,2),1.5,BrickColor.new'Pink',true)

			for i = 0,4,0.1 do
				swait()
				sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0 - 5 * math.cos(sine / 0.2))),.2)
				RW.C0=clerp(RW.C0,cf(1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(-50)),.2)
				LW.C0=clerp(LW.C0,cf(-1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(50)),.2)
			end
			CFuncs["Sound"].Create("rbxassetid://885160580", root, 2.5,1)
			CFuncs["Sound"].Create("rbxassetid://885160580", root, 5,1)
			CFuncs["Sound"].Create("rbxassetid://885160580", root, 2.5,1)
			CFuncs["Sound"].Create("rbxassetid://885160580", root, 2.5,0.75)
			pcall(function() Character.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'Pink' end)
			pcall(function() Character.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'Pink' end)
			CameraEnshaking(5,2.5)
			MAINRUINCOLOR = BrickColor.new("Pink")
			sphere(2.5,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
			for i = 0, 49 do
				PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),6,6,6,0.12,MAINRUINCOLOR,0,true)
			end
			for i = 0,3,0.1 do
				sphereMK(2.5,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,MAINRUINCOLOR,0,true)
			end
			RecolorTextAndRename("Loost",Color3.new(1,1,1),BrickColor.new'Pink'.Color)
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Pink")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Pink")
					v.Material = "Glass"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Pink")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("Pink")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("Pink")
					v.Material = "Neon"
				end
			end
			for i = 0,2,0.1 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(-30),math.rad(0),math.rad(0)),.2)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0 - 2.5 * math.cos(sine / 0.2))),.2)
				RW.C0=clerp(RW.C0,cf(1.45,0.4,0)*angles(math.rad(-20),math.rad(0 - 2 * math.cos(sine / 0.2)),math.rad(80 + 2 * math.cos(sine / 0.2))),.2)
				LW.C0=clerp(LW.C0,cf(-1.45,0.4,0)*angles(math.rad(-20),math.rad(0 + 2 * math.cos(sine / 0.2)),math.rad(-80 - 2 * math.cos(sine / 0.2))),.2)
			end
			hum.WalkSpeed = storehumanoidWS
			attack = false
		end)()
	end

	function insanitymode()
		storehumanoidWS = 16
		hum.WalkSpeed = 0
		rainbowmode = false
		glitchymode = false
		chaosmode = true
		tl1.Enabled = true 
		tl2.Enabled = true
		tl3.Enabled = true
		local lust = ModeOfGlitch == 69
		newTheme("rbxassetid://919231299",0,1,1)
		coroutine.resume(coroutine.create(function()
			tr1.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tr2.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tr3.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			attack = true
			hum.WalkSpeed = 0
			CFuncs["Sound"].Create("rbxassetid://136007472", root, 2.5, 1.25)
			for i = 0,4,0.1 do
				swait()
				sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0 - 5 * math.cos(sine / 0.2))),.2)
				RW.C0=clerp(RW.C0,cf(1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(-50)),.2)
				LW.C0=clerp(LW.C0,cf(-1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(50)),.2)
			end
			for i = 0,8,0.1 do
				swait()
				sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
				sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,.035,MAINRUINCOLOR,0)
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0 - 5 * math.cos(sine / 0.2))),.2)
				RW.C0=clerp(RW.C0,cf(1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(-50)),.2)
				LW.C0=clerp(LW.C0,cf(-1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(50)),.2)
			end

			for i = 0,3,0.1 do
				swait()
				sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0 - 5 * math.cos(sine / 0.2))),.2)
				RW.C0=clerp(RW.C0,cf(1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(-50)),.2)
				LW.C0=clerp(LW.C0,cf(-1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(50)),.2)
			end
			CFuncs["Sound"].Create("rbxassetid://206082327", root, 2.5,1)
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 5,1)
			CFuncs["Sound"].Create("rbxassetid://239000203", root, 2.5,1)
			CFuncs["Sound"].Create("rbxassetid://579687077", root, 2.5,0.75)
			CameraEnshaking(5,2.5)
			MAINRUINCOLOR = BrickColor.new("Black")
			sphere(2.5,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
			for i = 0, 49 do
				PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2,2,2,0.04,MAINRUINCOLOR,0)
			end
			for i = 0,3,0.1 do
				sphereMK(2.5,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,MAINRUINCOLOR,0)
			end
			ModeOfGlitch = 666666
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0.75
					v.BrickColor = BrickColor.random()
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Black")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.random()
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Black")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = .75
					v.BrickColor = BrickColor.Random()
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.BrickColor = BrickColor.new("Black")
					v.Material = "Neon"
				end
			end
			for i = 0,2,0.1 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(-30),math.rad(0),math.rad(0)),.2)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0 - 10 * math.cos(sine / 0.2))),.2)
				RW.C0=clerp(RW.C0,cf(1.45,0.4,0)*angles(math.rad(-20),math.rad(0 - 2 * math.cos(sine / 0.2)),math.rad(80 + 2 * math.cos(sine / 0.2)))*angles(0,0,math.rad(0 - 10 * math.cos(sine / 0.2))),.2)
				LW.C0=clerp(LW.C0,cf(-1.45,0.4,0)*angles(math.rad(-20),math.rad(0 + 2 * math.cos(sine / 0.2)),math.rad(-80 - 2 * math.cos(sine / 0.2)))*angles(0,0,math.rad(0 - 10 * math.cos(sine / 0.2))),.2)
			end
			hum.WalkSpeed = storehumanoidWS
			attack = false
		end))
	end

	local attacktype = 1
	mouse.Button1Down:connect(function()
		if attack == false and attacktype == 1 then
			attacktype = 2
			attackone()
		elseif attack == false and attacktype == 2 then
			attacktype = 3
			attacktwo()
		elseif attack == false and attacktype == 3 then
			attacktype = 1
			attackthree()
		elseif attack == false and attacktype == 4 then
			attacktype = 1
			--attackfour()
		end
	end)

	function Judgement()
		attack = true
		hum.WalkSpeed = 0
		local p = Instance.new("Part",root)
		p.Anchored = true
		p.CanCollide = false
		p.BrickColor = MAINRUINCOLOR
		p.Material = Enum.Material.Neon
		p.Size = Vector3.new(1,1,1)
		p.CFrame = CFrame.new(mouse.Hit.p)+Vector3.new(0,1000,0)
		p.CFrame = p.CFrame * CFrame.Angles(0,0,89.5354)
		local m = Instance.new("SpecialMesh",p)
		m.MeshType = "Cylinder"
		m.Scale = Vector3.new(2000,2,2)
		local targ = Instance.new("Part",root)
		targ.Transparency = 1
		targ.CanCollide = false
		targ.Size = Vector3.new(1,1,1)
		targ.CFrame = p.CFrame-Vector3.new(0,1000,0)
		CFuncs.Sound.Create("rbxassetid://164178927", targ, 5, 1)
		CFuncs.Sound.Create("rbxassetid://1208650519", targ, 10, 1)
		for i = 1,15 do
			targ.CFrame = p.CFrame-Vector3.new(0,1000,0)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(-20),math.rad(0),math.rad(0)),0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-15),math.rad(0),math.rad(0)),.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(100)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-100)), 0.2)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(-20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(20)),.2)
			sphere(10, "Add", targ.CFrame, vt(15, 15, 15), 0.05, MAINRUINCOLOR)
			sphereMK(3, 0.5, "Add", targ.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 1, 1, 7, -0.005, MAINRUINCOLOR, 0)
			m.Scale = m.Scale+Vector3.new(0,1,1)
			p.CFrame = CFrame.new(mouse.Hit.p)+Vector3.new(0,1000,0)
			p.CFrame = p.CFrame * CFrame.Angles(0,0,89.5354)
			swait()
		end
		sphereMK(3, 0.2, "Add", targ.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 0.5, 0.5, 5, -0.005, MAINRUINCOLOR, 0)
		for i = 1,200 do
			targ.CFrame = p.CFrame-Vector3.new(0,1000,0)
			sphereMK(3, 0.5, "Add", targ.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 3, 3, 15, -0.005, MAINRUINCOLOR, 0)
			sphere(10, "Add", targ.CFrame, vt(15, 15, 15), 0.15, MAINRUINCOLOR)
			p.CFrame = CFrame.new(mouse.Hit.p)+Vector3.new(0,1000,0)
			p.CFrame = p.CFrame * CFrame.Angles(0,0,89.5354)
			MagniDamage(targ, 25, 5, 8, 0, "Normal")
			swait()
		end
		for i =1,15 do
			m.Scale = m.Scale-Vector3.new(1,1,1)
			p.Transparency = i / 15
			swait()
		end
		p:Destroy()
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	local ODerDB = false
	function ChooseODer()
		if(not ODerDB)then
			coroutine.wrap(function()

				local allowOD = true
				local whom = (mouse.Target and mouse.Target.Parent)
				if(whom and whom:FindFirstChildOfClass'Humanoid' and whom:FindFirstChild'Head')then
					ODerDB = true
					for _,v in next, ODers do
						if(v == whom)then
							print'nO OD SELF'
							allowOD = false
						end
					end
					if(allowOD)then
						local ref=CFuncs.Part.Create(m,Enum.Material.Neon,0,.4,(whom.Name == 'Nebula_Zorua' and 'Royal purple' or MAINRUINCOLOR),"ref",Vector3.new(0.05,0.05,0.05))
						local refz = CFuncs.Mesh.Create("SpecialMesh",ref,"Sphere","",Vector3.new(0, 0, 0),Vector3.new(14, 14, 14))

						ref.CFrame = Torso.CFrame
						ref.Anchored = true
						local e1 = Torso.CFrame:Lerp(whom.Head.CFrame, 0.25) * CFrame.new(math.random(-15, 15), math.random(0, 15), math.random(-15, 15))
						local e2 = Torso.CFrame:Lerp(whom.Head.CFrame, 0.75) * CFrame.new(math.random(-15, 15), math.random(0, 15), math.random(-15, 15))
						local MPos = whom.Head.CFrame*cf(0,4,0)
						for i = 0, 1, .05 do
							swait()
							ref.CFrame = newBezier(Torso.CFrame, e1, e2, MPos, i)

							sphere(10,"Add",ref.CFrame,vt(6,6,3),0,(whom.Name == 'Nebula_Zorua' and BrickColor.new'Royal purple' or MAINRUINCOLOR),true)
							if whom:FindFirstChild'Head' == nil then
								break
							end
						end
						ref:destroy()
						if whom:FindFirstChild'Head' then
							table.insert(ODers,whom)
							if(#ODers > 2)then
								table.remove(ODers,1)
							end
							sphere(1.5,"Add",whom.Head.CFrame * cf(0,4,0),vt(6,6,3),.15,(whom.Name == 'Nebula_Zorua' and BrickColor.new'Royal purple' or MAINRUINCOLOR),true)
						end
					end
					ODerDB = false
				end
			end)()
		end
	end

	function RiddleMeThisRiddleMeThat()-- Who's afraid of the big black IUSFGEYUI8TY8RUFETUYERFYAERFE7RFWAE9RASEVR7YTRWW65ERAY
		attack = true
		hum.WalkSpeed = 0
		storehumanoidWS = 75
		hum.JumpPower = 0
		newThemeCust("rbxassetid://1420353940",0,1,1)
		kan.TimePosition = 0
		ModeOfGlitch = 8376532578634534
		repeat swait() until kan.IsLoaded
		chatfunc("Riddle me this..",text.TextStrokeColor3)
		for i = 0, 14, .1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1-.2*math.cos(sine/16),0)*angles(0,math.rad(90),0),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1-.2*math.cos(sine/16),.05)*angles(0,math.rad(15),0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0+.2*math.cos(sine/16)),.1)  
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.1)
			RW.C0=clerp(RW.C0,cf(1,0.5+.2*math.cos(sine/16),-.65)*angles(math.rad(45),0,math.rad(-90)),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5+.2*math.cos(sine/16),-.65)*angles(math.rad(-45),0,math.rad(100)),.1)
		end
		chatfunc("Riddle me that..",text.TextStrokeColor3)
		for i = 0, 12, .1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1-.2*math.cos(sine/16),0)*angles(0,math.rad(90),0),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1-.2*math.cos(sine/16),.05)*angles(0,math.rad(15),0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0+.2*math.cos(sine/16)),.1)  
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,math.rad(25),0),.1)
			RW.C0=clerp(RW.C0,cf(1,0.5+.2*math.cos(sine/16),-.65)*angles(math.rad(45),0,math.rad(-90)),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5+.2*math.cos(sine/16),-.65)*angles(math.rad(-45),0,math.rad(100)),.1)
		end
		chatfunc("Who's afraid of the big black..",Color3.new(1,1,1))
		for i = 0, 16, .1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1-.2*math.cos(sine/16),0)*angles(0,math.rad(90),0),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1-.2*math.cos(sine/16),.05)*angles(0,math.rad(15),0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0+.2*math.cos(sine/16)),.1)  
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25),0,0),.1)
			RW.C0=clerp(RW.C0,cf(1,0.5+.2*math.cos(sine/16),-.65)*angles(math.rad(45),0,math.rad(-90)),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5+.2*math.cos(sine/16),-.65)*angles(math.rad(-45),0,math.rad(100)),.1)
		end
		CFuncs["Sound"].Create("rbxassetid://206082327", root, 2.5,1)
		CFuncs["Sound"].Create("rbxassetid://847061203", root, 5,1)
		CFuncs["Sound"].Create("rbxassetid://239000203", root, 2.5,1)
		CFuncs["Sound"].Create("rbxassetid://579687077", root, 2.5,0.75)
		pcall(function() Character.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'Black' end)
		pcall(function() Character.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'Black' end)
		RecolorTextAndRename("The Big Black",Color3.new(0,0,0),Color3.new(1,1,1))
		CameraEnshaking(5,2.5)
		MAINRUINCOLOR = BrickColor.new("Really black")
		sphere(2.5,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		tl1.Enabled = true
		tl2.Enabled = true
		tl3.Enabled = true
		for i = 0, 49 do
			PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2,2,2,0.04,MAINRUINCOLOR,0)
		end
		for i = 0,3,0.1 do
			sphereMK(2.5,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,MAINRUINCOLOR,0)
		end
		for i, v in pairs(mw2:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Really black")
				v.Material = "Glass"
			end
		end
		for i, v in pairs(mw1:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = 0
				v.BrickColor = BrickColor.new("Really black")
				v.Material = "Glass"
			end
		end
		for i, v in pairs(m:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Really black")
				v.Material = "Glass"
			end
		end
		for i, v in pairs(m2:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Dark stone grey")
				v.Material = "Granite"
			end
		end
		for i, v in pairs(m3:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Really black")
				v.Material = "Glass"
			end
		end
		for i, v in pairs(extrawingmod1:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = 0
				v.BrickColor = BrickColor.new("Dark stone grey")
				v.Material = "Glass"
			end
		end
		for i, v in pairs(extrawingmod2:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = 0
				v.BrickColor = BrickColor.new("Dark stone grey")
				v.Material = "Glass"
			end
		end
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(-30),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0 - 2.5 * math.cos(sine / 0.2))),.2)
			RW.C0=clerp(RW.C0,cf(1.45,0.4,0)*angles(math.rad(-20),math.rad(0 - 2 * math.cos(sine / 0.2)),math.rad(80 + 2 * math.cos(sine / 0.2))),.2)
			LW.C0=clerp(LW.C0,cf(-1.45,0.4,0)*angles(math.rad(-20),math.rad(0 + 2 * math.cos(sine / 0.2)),math.rad(-80 - 2 * math.cos(sine / 0.2))),.2)
		end
		hum.JumpPower = 50
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function FuckMeSidewaysAndCallMeGay()
		local whom = (mouse.Target and mouse.Target.Parent)
    --[[local fuckThisBoi = false
    if(whom and whom:FindFirstChildOfClass'Humanoid')then
        for _,v in next, ODers do
            if(v == whom)then
                fuckThisBoi = false
            end
        end
    end
    if(not fuckThisBoi)then
        attack = false
        warn'to fuck that boi you need to target them with z'
    else]]
		if(whom and whom:FindFirstChildOfClass'Humanoid' and whom:FindFirstChild'Torso' or whom:FindFirstChild'UpperTorso')then
			local hed = whom:FindFirstChild'Torso' or whom:FindFirstChild'UpperTorso'
			local hum = whom:FindFirstChildOfClass'Humanoid'
			local ocf = RootPart.CFrame
			hum.WalkSpeed = 0
			hum.JumpPower = 0
			hed.Anchored = true
			RootPart.Anchored = true
			Humanoid.WalkSpeed = 0
			Humanoid.JumpPower = 0
			RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Pink"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Pink"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Pink"))
			attack = true
			local speed = 1
			local heck;
			local stopitlol = false;
			heck = mouse.KeyUp:connect(function(k)
				if(k:lower() == 'm')then
					stopitlol = true
					heck:disconnect()
				end
			end)
			local times = 0
			repeat swait()
				speed = speed - .01
				times = times + 1
				if(speed < .1)then
					speed = .1
				end
				for i = 0, speed, .05 do
					RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
					swait()
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(50),0,0)*angles(0,math.rad(90),0),.4)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(50),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
					RootJoint.C0=clerp(RootJoint.C0,cf(0,-.1,0)*angles(math.rad(-25),0,0)*RootCF,.4)   
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.8)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(75),0,0),.4)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(75),0,0),.4)
				end
				CameraEnshaking(5,5)

				CFuncs["Sound"].Create("rbxassetid://836796971", Torso, 10,1)  

				for i = 0, speed, .05 do
					RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
					swait()
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-50),0,0)*angles(0,math.rad(90),0),.4)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(-50),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
					RootJoint.C0=clerp(RootJoint.C0,cf(0,-.1,0)*angles(math.rad(25),0,0)*RootCF,.4)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.8)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
				end
			until stopitlol and times >= 3
			for i = 1, 3 do
				for i = 0, 1.5, .05 do
					RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
					swait()
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(50),0,0)*angles(0,math.rad(90),0),.4)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(50),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
					RootJoint.C0=clerp(RootJoint.C0,cf(0,-.1,0)*angles(math.rad(-25),0,0)*RootCF,.4)   
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.8)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(75),0,0),.4)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(75),0,0),.4)
				end
				CameraEnshaking(5,25)

				CFuncs["Sound"].Create("rbxassetid://1430568042", Torso, 10,.75)


				coroutine.resume(coroutine.create(function()
					bld = Instance.new("ParticleEmitter",whom:WaitForChild("Torso"))
					bld.LightEmission = 0.1
					bld.Texture = "rbxassetid://284205403"
					bld.Color = ColorSequence.new(Color3.new(1,1,1))
					bld.Rate = 500
					bld.Lifetime = NumberRange.new(1)
					bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
					bld.Acceleration = vt(0,-25,0)
					bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
					bld.Speed = NumberRange.new(10,50)
					bld.EmissionDirection = "Back"
					bld.VelocitySpread = 25
					bld.Rotation = NumberRange.new(-500,500)
					bld.RotSpeed = NumberRange.new(-500,500)
					bld.Enabled = false
					bld:Emit(250)
				end))
				coroutine.resume(coroutine.create(function()
					bld = Instance.new("ParticleEmitter",whom:WaitForChild("LowerTorso"))
					bld.LightEmission = 0.1
					bld.Texture = "rbxassetid://284205403"
					bld.Color = ColorSequence.new(Color3.new(1,1,1))
					bld.Rate = 500
					bld.Lifetime = NumberRange.new(1)
					bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
					bld.Acceleration = vt(0,-25,0)
					bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
					bld.Speed = NumberRange.new(10,50)
					bld.EmissionDirection = "Back"
					bld.VelocitySpread = 25
					bld.Rotation = NumberRange.new(-500,500)
					bld.RotSpeed = NumberRange.new(-500,500)
					bld.Enabled = false
					bld:Emit(250)
				end))
				for i = 0, 1.5, .05 do
					RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
					swait()
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-50),0,0)*angles(0,math.rad(90),0),.4)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(-50),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
					RootJoint.C0=clerp(RootJoint.C0,cf(0,-.1,0)*angles(math.rad(25),0,0)*RootCF,.4)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.8)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
				end
			end
			for i = 0, 4, .05 do
				RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(100),0,0)*angles(0,math.rad(90),0),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(100),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.1)
				RootJoint.C0=clerp(RootJoint.C0,cf(0,-.75,0)*angles(math.rad(-50),0,0)*RootCF,.1)  
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.1)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(75),0,0),.1)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(75),0,0),.1)
			end
			CameraEnshaking(5,25)
			CFuncs["Sound"].Create("rbxassetid://429400881", hed, 3,1)
			CFuncs["Sound"].Create("rbxassetid://1430568042", Torso, 10,.75)

			dmg(whom)
			coroutine.resume(coroutine.create(function()
				bld = Instance.new("ParticleEmitter",whom:WaitForChild("Torso"))
				bld.LightEmission = 0.1
				bld.Texture = "rbxassetid://284205403"
				bld.Color = ColorSequence.new(Color3.new(1,1,1))
				bld.Rate = 500
				bld.Lifetime = NumberRange.new(1)
				bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Acceleration = vt(0,-25,0)
				bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Speed = NumberRange.new(10,50)
				bld.EmissionDirection = "Back"
				bld.VelocitySpread = 25
				bld.Rotation = NumberRange.new(-500,500)
				bld.RotSpeed = NumberRange.new(-500,500)
				bld.Enabled = true
			end))
			coroutine.resume(coroutine.create(function()
				bld = Instance.new("ParticleEmitter",whom:WaitForChild("LowerTorso"))
				bld.LightEmission = 0.1
				bld.Texture = "rbxassetid://284205403"
				bld.Color = ColorSequence.new(Color3.new(1,1,1))
				bld.Rate = 500
				bld.Lifetime = NumberRange.new(1)
				bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Acceleration = vt(0,-25,0)
				bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Speed = NumberRange.new(10,50)
				bld.EmissionDirection = "Back"
				bld.VelocitySpread = 25
				bld.Rotation = NumberRange.new(-500,500)
				bld.RotSpeed = NumberRange.new(-500,500)
				bld.Enabled = true
			end))
			for i = 0, 3, .05 do
				RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-100),0,0)*angles(0,math.rad(90),0),.4)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(-100),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
				RootJoint.C0=clerp(RootJoint.C0,cf(0,-.75,0)*angles(math.rad(50),0,0)*RootCF,.4)   
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
			end

			RootPart.CFrame = ocf
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Pink"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Pink"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Pink"))
			RootPart.Anchored = false
			Humanoid.WalkSpeed = storehumanoidWS
			Humanoid.JumpPower = 50
			attack = false
		end
	end

	local input = ""

	mouse.KeyDown:connect(function(k)
		if(k == "w" or k == "a" or k == "s" or k == "d" or k == "b")then
			input = input .. k
			local newInput = input
			coroutine.wrap(function()
				for i = 1, 25 do
					if(newInput ~= input)then break end
					swait()
				end
				if(newInput == input)then input = "" end
			end)()
			if(input == "w" and not AllowRape)then
				AllowRape = true
				warn("Rape unlocked! Have fun ;)")
			elseif(input == "w" and not AllowCata)then
				AllowCata = true
				warn("You unlocked CATASTROPHE.")
			elseif(input == 'b' and ModeOfGlitch == 4 and not attack)then
				ChaosBegone()
			end
		end
	end)

	mouse.KeyDown:connect(function(k)
		if k == "h" then

		end

		if k == "q" and attack == false and ModeOfGlitch ~= 2 then
			ModeOfGlitch = 2
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			chaosmode = false
			glitchymode = false
			tl1.Enabled = false
			tl2.Enabled = false
			tl3.Enabled = false
			RecolorTextAndRename("Purity",Color3.new(1,1,1),Color3.new(0,1,1))
			pcall(function() Character.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'Teal' end)
			pcall(function() Character.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'Teal' end)
			newTheme("rbxassetid://1539245059",0,1,1)
			MAINRUINCOLOR = BrickColor.new("Toothpaste")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Pastel light blue")
					v.Material = "Glass"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Toothpaste")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
		elseif k == "q" and attack == false and ModeOfGlitch == 2 then
			resetmode()
		end
		if k == "f" and attack == false and ModeOfGlitch ~= 69 then
			lustmode()
		elseif k == "f" and attack == false and ModeOfGlitch == 69 then
			resetmode()
		end
		if k == "m" and attack == false and ModeOfGlitch == 1 then
			RiddleMeThisRiddleMeThat()
		elseif k == "m" and attack == false and ModeOfGlitch == 8376532578634534 then
			resetmode()
		end
		if k == "e" and attack == false and ModeOfGlitch ~= 3 then
			ModeOfGlitch = 3
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			chaosmode = false
			glitchymode = true
			tl1.Enabled = true
			tl2.Enabled = true
			tl3.Enabled = true
			RecolorTextAndRename("gLiTcHy",Color3.new(0,0,0),Color3.new(0.35,0,1))
			newTheme("rbxassetid://1274310715",0,.93,1.25) -- 474074203
			pcall(function() Character.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'White' end)
			pcall(function() Character.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'White' end)
			MAINRUINCOLOR = BrickColor.new("White")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Really black")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Dark indigo")
					v.Material = "Glass"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("Royal purple")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
		elseif k == "e" and attack == false and ModeOfGlitch == 3 then
			resetmode()
		end
		if k == "r" and attack == false and ModeOfGlitch ~= 4 then
			ModeOfGlitch = 4
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			glitchymode = false
			chaosmode = true
			tl1.Enabled = true
			tl2.Enabled = true
			tl3.Enabled = true
			RecolorTextAndRename("CHAOS",Color3.new(0,0,0),BrickColor.random().Color)
			newTheme("rbxassetid://1369263130",0,1,1)
			MAINRUINCOLOR = BrickColor.new("Black")
			tr1.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tr2.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tr3.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0.75
					v.BrickColor = BrickColor.random()
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Black")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.random()
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Black")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
		elseif k == "r" and attack == false and ModeOfGlitch == 4 then
			resetmode()
		end

		if k == "m" and attack == false and ModeOfGlitch == 4 then
			insanitymode()
		elseif k == "m" and attack == false and ModeOfGlitch == 666666 then
			resetmode()
		end
		if k == "t" and attack == false and ModeOfGlitch ~= 5 then
			ModeOfGlitch = 5
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			chaosmode = false
			glitchymode = false
			tl1.Enabled = true
			tl2.Enabled = true
			tl3.Enabled = true
			RecolorTextAndRename("Divinity",Color3.new(1,1,1),Color3.new(1,1,0.5))
			newTheme("rbxassetid://661079869",0,1.02,1)
			pcall(function() Character.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'New Yeller' end)
			pcall(function() Character.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'New Yeller' end)
			MAINRUINCOLOR = BrickColor.new("Bright yellow")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Cool yellow")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Bright yellow")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Bright yellow")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
		elseif k == "t" and attack == false and ModeOfGlitch == 5 then
			resetmode()
		end
		if k == "y" and attack == false and ModeOfGlitch ~= 6 then
			ModeOfGlitch = 6
			storehumanoidWS = 75
			hum.WalkSpeed = 75
			rainbowmode = false
			chaosmode = false
			glitchymode = false
			tl1.Enabled = true
			tl2.Enabled = true
			tl3.Enabled = true
			RecolorTextAndRename("Justice",Color3.new(0,0,0),Color3.new(1,1,1))
			pcall(function() Character.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'White' end)
			pcall(function() Character.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'White' end)
			newTheme("rbxassetid://195916147",0,1,1)
			MAINRUINCOLOR = BrickColor.new("White")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
		elseif k == "y" and attack == false and ModeOfGlitch == 6 then
			resetmode()
		end
		if k == "u" and attack == false then

			storehumanoidWS = 50
			hum.WalkSpeed = 50
			rainbowmode = true
			chaosmode = false
			glitchymode = false
			tl1.Enabled = true
			tl2.Enabled = true
			tl3.Enabled = true

			if(ModeOfGlitch == 6127843)then
				vaporwave = not vaporwave
			end

			if(not vaporwave)then
				RecolorTextAndRename("RAINBOW",Color3.new(1,1,1),Color3.new(1,1,1))
				newTheme("rbxassetid://147930134",0,1,1)
			else
				RecolorTextAndRename("Vaporwave",Color3.new(1,1,1),Color3.new(1,1,1))
				newTheme("rbxassetid://1308711379",0,1,4)

			end


			ModeOfGlitch = 6127843
			MAINRUINCOLOR = BrickColor.new("White")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
		elseif k == "u" and attack == false and ModeOfGlitch == 6127843 then
			resetmode()
		end
		if k == "p" and attack == false and ModeOfGlitch ~= 1000000 then
			ModeOfGlitch = 1000000
			storehumanoidWS = 100
			hum.WalkSpeed = 100
			rainbowmode = false
			chaosmode = false
			glitchymode = false
			tl1.Enabled = true
			tl2.Enabled = true
			tl3.Enabled = true
			RecolorTextAndRename("CALAMITY",Color3.new(0.25,0,1),Color3.new(0.5,0,1))
			pcall(function() Character.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'Bright violet' end)
			pcall(function() Character.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'Bright violet' end)
			newTheme("rbxassetid://1359036559",0,1,1)
			MAINRUINCOLOR = BrickColor.new("Bright violet")
			tl1.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tl2.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tl3.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(0.5,0,1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(0.25,0,1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(0.45,0,1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0.75
					v.Color = Color3.new(0.25,0,1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0.75
					v.Color = Color3.new(0.5,0,1)
					v.Material = "Neon"
				end
			end
		elseif k == "p" and attack == false and ModeOfGlitch == 1000000 then
			resetmode()
		end
		if k == "m" and attack == false and ModeOfGlitch == 1000000 and ModeOfGlitch ~= 12345678987654321 and (plr.Name == 'Noobygames12' or plr.UserId == 5719877 or AllowCata) then
			newThemeCust("rbxassetid://1504604335",0,1,1)
			attack = true
			hum.WalkSpeed = 0
			MAINRUINCOLOR = BrickColor.new("Royal purple")
			for i = 0, 24, 0.1 do
				swait()
				sphereMK(1,-2,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MAINRUINCOLOR,100)
				RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
				LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
				RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
				LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
			end
			CameraEnshaking(1,1)
			sphere(5,"Add",root.CFrame,vt(0,0,0),2.5,MAINRUINCOLOR)
			CFuncs["Sound"].Create("rbxassetid://847061203", char, 0.5,1)
			wait(0.55)
			CameraEnshaking(1,2)
			sphere(5,"Add",root.CFrame,vt(0,0,0),7.5,MAINRUINCOLOR)
			sphere(5,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
			sphere(5,"Add",root.CFrame,vt(0,0,0),2.5,MAINRUINCOLOR)
			CFuncs["Sound"].Create("rbxassetid://847061203", char, 1,1)
			wait(0.55)
			CameraEnshaking(1,3)
			sphere(5,"Add",root.CFrame,vt(0,0,0),12.5,MAINRUINCOLOR)
			sphere(5,"Add",root.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
			sphere(5,"Add",root.CFrame,vt(0,0,0),7.5,MAINRUINCOLOR)
			sphere(5,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
			sphere(5,"Add",root.CFrame,vt(0,0,0),2.5,MAINRUINCOLOR)
			CFuncs["Sound"].Create("rbxassetid://847061203", char, 2,1)
			wait(0.55)
			CameraEnshaking(10,5)
			CFuncs["Sound"].Create("rbxassetid://741272936", char, 1, 1)
			CFuncs["Sound"].Create("rbxassetid://164881112", char, 1, 1)
			CFuncs["Sound"].Create("rbxassetid://1192402877", char, 1, 1)
			CFuncs["Sound"].Create("rbxassetid://429123896", char, 1, 0.85)
			CFuncs["Sound"].Create("rbxassetid://1208650519", char, 1, 1)
			sphere(1,"Add",root.CFrame,vt(0,0,0),2,MAINRUINCOLOR)
			sphere(2,"Add",root.CFrame,vt(0,0,0),4,MAINRUINCOLOR)
			sphere(3,"Add",root.CFrame,vt(0,0,0),6,MAINRUINCOLOR)
			sphere(4,"Add",root.CFrame,vt(0,0,0),8,MAINRUINCOLOR)
			sphere(5,"Add",root.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
			sphere(6,"Add",root.CFrame,vt(0,0,0),12,MAINRUINCOLOR)
			sphere(7,"Add",root.CFrame,vt(0,0,0),14,MAINRUINCOLOR)
			sphere(8,"Add",root.CFrame,vt(0,0,0),16,MAINRUINCOLOR)
			sphere(9,"Add",root.CFrame,vt(0,0,0),18,MAINRUINCOLOR)
			sphere(10,"Add",root.CFrame,vt(0,0,0),20,MAINRUINCOLOR)
			for i = 0, 49 do
				sphereMK(1,3,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),50,50,200,-1,MAINRUINCOLOR,0)
				sphereMK(2,6,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),50,50,150,-0.5,MAINRUINCOLOR,0)
				sphereMK(3,9,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),50,50,100,-0.5,MAINRUINCOLOR,0)
				sphereMK(4,12,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),50,50,50,-0.5,MAINRUINCOLOR,0)
			end
			ModeOfGlitch = 12345678987654321
			storehumanoidWS = 200
			hum.WalkSpeed = 200
			rainbowmode = false
			chaosmode = false
			glitchymode = false
			tl1.Enabled = true
			tl2.Enabled = true
			tl3.Enabled = true
			pcall(function() Character.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'Dark indigo' end)
			pcall(function() Character.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'Dark indigo' end)
			RecolorTextAndRename("CATASTROPHE",Color3.new(0.5,0,1),Color3.new(0.75,0,1))
			tl1.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tl2.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tl3.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(0.5,0,1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(0.5,0,1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(0.5,0,1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.Color = Color3.new(0.5,0,1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.Color = Color3.new(0.5,0,1)
					v.Material = "Neon"
				end
				attack = false
			end
		elseif k == "m" and attack == false and ModeOfGlitch == 12345678987654321 then
			resetmode()
		end
		if k == "l" and toggleTag == false then
			toggleTag = true
			text.TextTransparency = 0
			text.TextStrokeTransparency = 0
		elseif k == "l" and toggleTag == true then
			toggleTag = false
			text.TextTransparency = 1
			text.TextStrokeTransparency = 1
		end
		if k == "z" and attack == false and (ModeOfGlitch == 1 or ModeOfGlitch == 8376532578634534) then
			ExtinctiveHeartbreak()
		elseif k == "z" and attack == false and ModeOfGlitch == 2 then
			PureBomb()
		elseif k == "z" and attack == false and ModeOfGlitch == 3 then
			scattercorrupt()
		elseif k == "z" and attack == false and ModeOfGlitch == 5 then
			Judgement()
		elseif k == "z" and attack == false and ModeOfGlitch == 4 then
			ChaosGroundStrike()
		elseif k == "z" and attack == false and ModeOfGlitch == 666666 then
			InsaneGroundStrike()

		elseif k == "z" and attack == false and ModeOfGlitch == 69 then
			ChooseODer()
		elseif k == "z" and attack == false and ModeOfGlitch == 1000000 then
			Starfall()
		elseif k == "z" and attack == false and ModeOfGlitch == 6 then
			yinyangi()
		elseif k == "z" and attack == false and ModeOfGlitch == 6127843 then
			Wip()
		elseif k == "z" and attack == false and ModeOfGlitch == 12345678987654321 then
			StarfallEX()
		end
		if k == "x" and attack == false and ModeOfGlitch == 1000000 then
			StarDivision()
		elseif k == "x" and attack == false and ModeOfGlitch == 6 then
			JusticeBeam()
		end
		if k == "v" and attack == false and ModeOfGlitch == 12345678987654321 then
			UniversalCollapse()
		end
		if k == "b" and attack == false and ModeOfGlitch == 4 then

		end
		if k == "n" and attack == false then
			CorruptBlink()
		end
		if k == "m" and attack == false and ModeOfGlitch == 69 and AllowRape then
			FuckMeSidewaysAndCallMeGay()
		end
	end)
	coroutine.resume(coroutine.create(function()
		while true do
			swait(2)
			if rainbowmode == true or ModeOfGlitch == 6 or glitchymode then
				sphereMK(5,0.15,"Add",root.CFrame*CFrame.new(math.random(-5,5),-6,math.random(-5,5))*CFrame.Angles(math.rad(90),0,0),1.5,1.5,10,-0.015,MAINRUINCOLOR,0)
			end

		end
	end))


	coroutine.resume(coroutine.create(function()
		while true do
			if ModeOfGlitch == 1000000 then
				swait(0.5)
			end
			swait()
			if ModeOfGlitch == 1000000 or ModeOfGlitch == 12345678987654321 then
				sphereMK(5,0.5,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),0),1,1,15,-0.01,MAINRUINCOLOR,0)
			end
			if ModeOfGlitch == 12345678987654321 then
				sphereMK(5,math.random(1,2),"Add",root.CFrame*CFrame.new(math.random(-75,75),-25,math.random(-75,75))*CFrame.Angles(math.rad(90 + math.random(-25,25)),math.rad(math.random(-25,25)),0),1,1,50,-0.01,MAINRUINCOLOR,0)
			end
		end
	end))


	function RandomMaterial()
		local getRandom;
		local material;
		local function IsTerrainMaterial(mat)
			local isMaterial = pcall(function() workspace:FindFirstChildOfClass'Terrain':GetMaterialColor(mat) end)
			return isMaterial
		end
		getRandom = function()
			local mat = Enum.Material:GetEnumItems()[math.random(1,#Enum.Material:GetEnumItems())]
			if(not IsTerrainMaterial(mat))then material = mat else getRandom() end
		end
		getRandom()
		repeat wait() until material
		return material
	end
	function RandomCaps(str)
		local new = ""
		for i = 1, #str do
			if(math.random(1,2) == 1)then
				new = new .. (str:sub(i,i):upper())
			else
				new = new .. str:sub(i,i)
			end
		end
		return new
	end

	coroutine.resume(coroutine.create(function()
		while true do
			for i = 1, #ODers do
				local ODer = ODers[i]
				if(ODer)then
					local hed = ODer:FindFirstChild'Head'
					if(ODer.Parent and hed)then
						sphere(10,"Add",hed.CFrame * cf(0,4,0),vt(6,6,3),0,(ODer.Name == 'Nebula_Zorua' and BrickColor.new'Royal purple' or MAINRUINCOLOR),true,false,true)
					else
						table.remove(ODers,i)
					end
				else
					table.remove(ODers,i)
				end
			end
			if(not kan)then
				kan = Instance.new("Sound",char)
			end
			kan.Parent = char
			if(plr.UserId == 5719877)then kan.Volume = 3 else  kan.Volume = 1 end
			kan.Pitch = Pitch
			kan.SoundId = MID
			kan.Name = "wrecked"
			kan.Looped = true
			kan:Resume()
			swait()
			if glitchymode == true then
				local val = math.random(1,255)
				local color = Color3.fromRGB(val,val,val)
				pcall(function() Character.ReaperShadowHead.Eye1.Color = color end)
				pcall(function() Character.ReaperShadowHead.Eye2.Color = color end)
				tl1.Color = ColorSequence.new(color)
				tl2.Color = ColorSequence.new(color)
				tl3.Color = ColorSequence.new(color)
				tr1.Color = ColorSequence.new(color)
				tr2.Color = ColorSequence.new(color)
				tr3.Color = ColorSequence.new(color)
				for i, v in pairs(mw1:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.Color = color
						v.Material = "Neon"
					end
				end
				for i, v in pairs(mw2:GetChildren()) do
					if v:IsA("Part") then
						v.Color = color
						v.Material = "Neon"
					end
				end
				for i, v in pairs(m2:GetChildren()) do
					if v:IsA("Part") then
						v.Color = color
						v.Material = "Neon"
					end
				end
				RecolorTextAndRename((ModeOfGlitch == 3 and RandomCaps"glitchy"),Color3.new(0,0,0),color)
			end
			if chaosmode or glitchymode then
				pcall(function() Character.ReaperShadowHead.Eye1.Material = Enum.Material:GetEnumItems()[math.random(1,#Enum.Material:GetEnumItems())] end)
				pcall(function() Character.ReaperShadowHead.Eye2.Material = Enum.Material:GetEnumItems()[math.random(1,#Enum.Material:GetEnumItems())] end)
			else
				pcall(function() Character.ReaperShadowHead.Eye1.Material = Enum.Material.Neon end)
				pcall(function() Character.ReaperShadowHead.Eye2.Material = Enum.Material.Neon end)
			end
			if chaosmode == true then
				tl1.Color = ColorSequence.new(BrickColor.random().Color)
				tl2.Color = ColorSequence.new(BrickColor.random().Color)
				tl3.Color = ColorSequence.new(BrickColor.random().Color)
				RecolorTextAndRename((ModeOfGlitch == 666666 and "INSANITY" or "CHAOS"),Color3.new(0,0,0),BrickColor.random().Color)
				pcall(function() Character.ReaperShadowHead.Eye1.BrickColor = BrickColor.random() end)
				pcall(function() Character.ReaperShadowHead.Eye2.BrickColor = BrickColor.random() end)
				for i, v in pairs(mw1:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0.75
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				for i, v in pairs(extrawingmod1:GetChildren()) do
					if v:IsA("Part") and ModeOfGlitch == 666666 then
						v.Transparency = 0.75
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					elseif v:IsA("Part") then
						v.Transparency = 1
					end
				end
				for i, v in pairs(m2:GetChildren()) do
					if v:IsA("Part") then
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
			end
		end
	end))
	Humanoid.Name = "Humanoid"
	Humanoid.MaxHealth = math.huge
	Humanoid.Health = math.huge
	Instance.new("ForceField",char).Visible = false
	Humanoid.Animator.Parent = nil
	idleanim=.4
	while true do
		if rainbowmode == false and chaosmode == false and glitchymode == false then
			tr1.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tr2.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tr3.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tl1.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tl2.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			tl3.Color = ColorSequence.new(MAINRUINCOLOR.Color)
		end
		if rainbowmode == true then
			pcall(function() Character.ReaperShadowHead.Eye1.Color = Color3.new(r/255,g/255,b/255) end)
			pcall(function() Character.ReaperShadowHead.Eye2.Color = Color3.new(r/255,g/255,b/255) end)
			if(not vaporwave)then
				RecolorTextAndRename("RAINBOW",Color3.new(r/255,g/255,b/255),Color3.new(r/500,g/500,b/500))
			else
				RecolorTextAndRename("Vaporwave",Color3.new(r/255,g/255,b/255),Color3.new(r/500,g/500,b/500))
			end
			MAINRUINCOLOR = BrickColor.new("White")
			tr1.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			tr2.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			tr3.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			tl1.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			tl2.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			tl3.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r/255,g/255,b/255)
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r/255,g/255,b/255)
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r/255,g/255,b/255)
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r/255,g/255,b/255)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r/255,g/255,b/255)
					v.Material = "Neon"
				end
			end
		end
		CameraManager()
		swait()
		lwing1weld.C1=clerp(lwing1weld.C1,cf(2,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(5 + 10 * math.cos(sine / 32)),math.rad(0),math.rad(12.5 + 5 * math.cos(sine / 32))),.3)
		lwing2weld.C1=clerp(lwing2weld.C1,cf(3,1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(10 + 15 * math.cos(sine / 32)),math.rad(0),math.rad(25 + 7.5 * math.cos(sine / 32))),.3)
		lwing3weld.C1=clerp(lwing3weld.C1,cf(3.75,2,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(15 + 20 * math.cos(sine / 32)),math.rad(0),math.rad(37.5 + 10 * math.cos(sine / 32))),.3)
		lwing4weld.C1=clerp(lwing4weld.C1,cf(4.75,3,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(20 + 25 * math.cos(sine / 32)),math.rad(0),math.rad(50 + 12.5 * math.cos(sine / 32))),.3)
		lwing5weld.C1=clerp(lwing5weld.C1,cf(5.75,4,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(25 + 30 * math.cos(sine / 32)),math.rad(0),math.rad(62.5 + 15 * math.cos(sine / 32))),.3)
		lwing6weld.C1=clerp(lwing6weld.C1,cf(6.75,5,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(30 + 35 * math.cos(sine / 32)),math.rad(0),math.rad(75 + 17.5 * math.cos(sine / 32))),.3)

		rwing1weld.C1=clerp(rwing1weld.C1,cf(-2,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(5 + 10 * math.cos(sine / 32)),math.rad(0),math.rad(-12.5 - 5 * math.cos(sine / 32))),.3)
		rwing2weld.C1=clerp(rwing2weld.C1,cf(-3,1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(10 + 15 * math.cos(sine / 32)),math.rad(0),math.rad(-25 - 7.5 * math.cos(sine / 32))),.3)
		rwing3weld.C1=clerp(rwing3weld.C1,cf(-3.75,2,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(15 + 20 * math.cos(sine / 32)),math.rad(0),math.rad(-37.5 - 10 * math.cos(sine / 32))),.3)
		rwing4weld.C1=clerp(rwing4weld.C1,cf(-4.75,3,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(20 + 25 * math.cos(sine / 32)),math.rad(0),math.rad(-50 - 12.5 * math.cos(sine / 32))),.3)
		rwing5weld.C1=clerp(rwing5weld.C1,cf(-5.75,4,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(25 + 30 * math.cos(sine / 32)),math.rad(0),math.rad(-62.5 - 15 * math.cos(sine / 32))),.3)
		rwing6weld.C1=clerp(rwing6weld.C1,cf(-6.75,5,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(30 + 35 * math.cos(sine / 32)),math.rad(0),math.rad(-75 - 17.5 * math.cos(sine / 32))),.3)
		sine = sine + change
		local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude
		local velderp=RootPart.Velocity.y
		hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
		if equipped==true or equipped==false then
			if attack==false then
				idle=idle+1
			else
				idle=0
			end
			if idle>=500 then
				if attack==false then
					--Sheath()
				end
			end
			if RootPart.Velocity.y > 1 and hitfloor==nil then
				Anim="Jump"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
				end
			elseif RootPart.Velocity.y < -1 and hitfloor==nil then
				Anim="Fall"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-20),math.rad(0),math.rad(50)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-20),math.rad(0),math.rad(-50)),.1)
				end
			elseif torvel<1 and hitfloor~=nil then
				Anim="Idle"
				if attack==false then
					if ModeOfGlitch == 1 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-10 - 2.5 * math.cos(sine / 32)),math.rad(-20),math.rad(0)),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-10 + 2.5 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(10 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(20)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 2.5 * math.cos(sine / 32)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(-20 - 5 * math.cos(sine / 0.465))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(10),math.rad(-20),math.rad(30 + 2.5 * math.cos(sine / 25))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(160),math.rad(0),math.rad(25)),.1)

					elseif ModeOfGlitch == 2 or ModeOfGlitch == 6127843 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-7.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(0)),.1)
						RW.C0=clerp(RW.C0,cf(0.85,0.5 + 0.1 * math.cos(sine / 28),-0.65)*angles(math.rad(30 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(-100 - 2.5 * math.cos(sine / 28))),.1)
						LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.1 * math.cos(sine / 28),-0.65)*angles(math.rad(40 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(90 + 2.5 * math.cos(sine / 28))),.1)

					elseif ModeOfGlitch == 3 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 - 1 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(20),math.rad(0 + 1 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(-20)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 15 * math.cos(sine / 0.5265)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465)))*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(20)),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(15 - 15 * math.cos(sine / 0.5265)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465)))*angles(math.rad(math.random(5,15)),math.rad(-5),math.rad(15 + 7.5 * math.cos(sine / 12.5))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(15 - 15 * math.cos(sine / 0.5265)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465)))*angles(math.rad(math.random(5,15)),math.rad(5),math.rad(-15 - 7.5 * math.cos(sine / 12.5))),.1)
					elseif ModeOfGlitch == 4 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.025 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(20)),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.025 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(-20)),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.025 * math.cos(sine / 32))*angles(math.rad(20 - 0.5 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 5 * math.cos(sine / 0.5265)),math.rad(0 - 5 * math.cos(sine / 0.25)),math.rad(0 - 5 * math.cos(sine / 0.465))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(10 + 2.5 * math.cos(sine / 0.252)),math.rad(0 + 2.5 * math.cos(sine / 0.123)),math.rad(5 + 2.5 * math.cos(sine / 0.6))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(10 + 2.5 * math.cos(sine / 0.568)),math.rad(0 + 2.5 * math.cos(sine / 0.664)),math.rad(-5 + 2.5 * math.cos(sine / 0.23))),.1)
					elseif ModeOfGlitch == 69 then
						RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(0,0,math.rad(0+5*math.cos(sine/16)))*RootCF,.1)
						Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(0,0,-math.rad(0+5*math.cos(sine/16))),.1)
						LH.C0 = LH.C0:lerp(cf(-1-math.rad(0+5*math.cos(sine/16)),-1+math.rad(0+5*math.cos(sine/16)),0)*angles(0,0,-math.rad(0+5*math.cos(sine/16)))*angles(math.rad(-15),math.rad(25),0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.1)
						RH.C0 = RH.C0:lerp(cf(1-math.rad(0+5*math.cos(sine/16)),-1-math.rad(0+5*math.cos(sine/16)),0)*angles(0,0,-math.rad(0+5*math.cos(sine/16)))*angles(math.rad(0),math.rad(90),math.rad(0)),.1)
						LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0)*cf(0,-.15,0)*angles(math.rad(15),0,math.rad(20)),.1)
						RW.C0 = RW.C0:lerp(cf(1.5,0.5,0)*angles(0,0,math.rad(5+5*math.sin(sine/16))),.1)
					elseif ModeOfGlitch == 8376532578634534 then
						RH.C0=clerp(RH.C0,cf(1,-1-.2*math.cos(sine/16),0)*angles(0,math.rad(90),0),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1-.2*math.cos(sine/16),.05)*angles(0,math.rad(15),0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0+.2*math.cos(sine/16)),.1)  
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,math.rad(-25),0)*angles(math.rad(0 - 25 * math.cos(sine / 0.1164)),math.rad(0 - 30 * math.cos(sine / 0.25)),math.rad(0 - 30 * math.cos(sine / 0.465))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5+.2*math.cos(sine/16),-.65)*angles(math.rad(45),0,math.rad(-90)),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5+.2*math.cos(sine/16),-.65)*angles(math.rad(-45),0,math.rad(100)),.1)

					elseif ModeOfGlitch == 666666 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.025 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(20)),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.025 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(-20)),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.025 * math.cos(sine / 32))*angles(math.rad(20 - 0.5 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 5 * math.cos(sine / 0.5265)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465))),.1)
						RW.C0=clerp(RW.C0,cf(1.3,0.5,0)*angles(math.rad(180),math.rad(-90),math.rad(15))*angles(math.rad(-35),0,0)*angles(math.rad(10 + 2.5 * math.cos(sine / 0.252)),math.rad(0 + 2.5 * math.cos(sine / 0.123)),math.rad(5 + 2.5 * math.cos(sine / 0.6)))*angles(0,math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465))),.1)
						LW.C0=clerp(LW.C0,cf(-1.3,0.5,0)*angles(math.rad(180),math.rad(90),math.rad(-15))*angles(math.rad(-35),0,0)*angles(math.rad(10 + 2.5 * math.cos(sine / 0.568)),math.rad(0 + 2.5 * math.cos(sine / 0.664)),math.rad(-5 + 2.5 * math.cos(sine / 0.23)))*angles(0,math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465))),.1)

					elseif ModeOfGlitch == 5 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(0)),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.1 * math.cos(sine / 28),0.45)*angles(math.rad(-30),math.rad(0),math.rad(-30)),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.1 * math.cos(sine / 28),0.45)*angles(math.rad(-30),math.rad(0),math.rad(30)),.1)

					elseif ModeOfGlitch == 1000000 or ModeOfGlitch == 6 then
						RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(0)),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(20 + 2.5 * math.cos(sine / 28))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(-20 - 2.5 * math.cos(sine / 28))),.1)

					elseif ModeOfGlitch == 12345678987654321 then
						RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(-40)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(40)),.1)
						RW.C0=clerp(RW.C0,cf(0.85,0.5 + 0.1 * math.cos(sine / 28),-0.65)*angles(math.rad(30 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(-100 - 2.5 * math.cos(sine / 28))),.1)
						LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.1 * math.cos(sine / 28),-0.65)*angles(math.rad(40 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(90 + 2.5 * math.cos(sine / 28))),.1)
					end
				end
			elseif torvel>2 and torvel<22 and hitfloor~=nil then
				Anim="Walk"
				if attack==false then
					if ModeOfGlitch == 1 then
						RH.C0=clerp(RH.C0,cf(1,-.9-.4*math.cos(sine/8)/1.5,.4*math.cos(sine/8)/2)*angles(math.rad(2-2*math.cos(sine/8))-math.sin(sine/8)/2,0,0)*angles(0,math.rad(90),0),.1)
						LH.C0=clerp(LH.C0,cf(-1,-.9+.4*math.cos(sine/8)/1.5,-.4*math.cos(sine/8)/2)*angles(math.rad(2+2*math.cos(sine/8))+math.sin(sine/8)/2,0,0)*angles(0,math.rad(-90),0),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.1 - 0.1 * math.cos(sine / 4))*angles(math.rad(5),math.rad(0),math.rad(0 - 5 * math.cos(sine / 8))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 5 * math.cos(sine / 0.5265)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0 + 45 * math.cos(sine / 8)),math.rad(0),math.rad(10 - 10 * math.cos(sine / 4))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(160),math.rad(0),math.rad(25)),.1)
					elseif ModeOfGlitch == 4 then
						RH.C0=clerp(RH.C0,cf(1,-.9-.4*math.cos(sine/8)/2,.4*math.cos(sine/4)/2)*angles(math.rad(2-4*math.cos(sine/10))-math.sin(sine/10)/2,0,0)*angles(0,math.rad(90),0),.1)
						LH.C0=clerp(LH.C0,cf(-1,-.9+.4*math.cos(sine/8)/2,-.4*math.cos(sine/4)/2)*angles(math.rad(2+3*math.cos(sine/10))+math.sin(sine/10)/2,0,0)*angles(0,math.rad(-90),0),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.15 - 0.1 * math.cos(sine / 8))*angles(math.rad(12.5),math.rad(0),math.rad(0 - 5 * math.cos(sine / 12))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 5 * math.cos(sine / 0.5265)),math.rad(0 - 5 * math.cos(sine / 0.25)),math.rad(0 - 5 * math.cos(sine / 0.465))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(10 - 15 * math.cos(sine / 12)),math.rad(0 + 2.5 * math.cos(sine / 0.123)),math.rad(5 + 2.5 * math.cos(sine / 0.6))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(10 + 15 * math.cos(sine / 12)),math.rad(0 + 2.5 * math.cos(sine / 0.664)),math.rad(-5 + 2.5 * math.cos(sine / 0.23))),.1)
					elseif ModeOfGlitch == 666666 then
						RH.C0=clerp(RH.C0,cf(1,-.9-.4*math.cos(sine/8)/2,.4*math.cos(sine/8)/2)*angles(math.rad(2-2*math.cos(sine/10))-math.sin(sine/8)/2,0,0)*angles(0,math.rad(90),0),.1)
						LH.C0=clerp(LH.C0,cf(-1,-.9+.4*math.cos(sine/8)/2,-.4*math.cos(sine/8)/2)*angles(math.rad(2+2*math.cos(sine/10))+math.sin(sine/8)/2,0,0)*angles(0,math.rad(-90),0),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.15 - 0.1 * math.cos(sine / 8))*angles(math.rad(12.5),math.rad(0),math.rad(0 - 5 * math.cos(sine / 12))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 5 * math.cos(sine / 0.5265)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465))),.1)
						RW.C0=clerp(RW.C0,cf(1.3,0.5,0)*angles(math.rad(180),math.rad(-90),math.rad(15))*angles(math.rad(-35),0,0)*angles(math.rad(10 + 2.5 * math.cos(sine / 0.252)),math.rad(0 + 2.5 * math.cos(sine / 0.123)),math.rad(5 + 2.5 * math.cos(sine / 0.6)))*angles(0,math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465))),.1)
						LW.C0=clerp(LW.C0,cf(-1.3,0.5,0)*angles(math.rad(180),math.rad(90),math.rad(-15))*angles(math.rad(-35),0,0)*angles(math.rad(10 + 2.5 * math.cos(sine / 0.568)),math.rad(0 + 2.5 * math.cos(sine / 0.664)),math.rad(-5 + 2.5 * math.cos(sine / 0.23)))*angles(0,math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465))),.1)

					elseif ModeOfGlitch ~= 1 or ModeOfGlitch ~= 4 then
						RH.C0=clerp(RH.C0,cf(1,-.85-.4*math.cos(sine/8)/1.5,.4*math.cos(sine/8)/2)*angles(math.rad(2-2*math.cos(sine/8))-math.sin(sine/8)/2,0,0)*angles(0,math.rad(90),0),.1)
						LH.C0=clerp(LH.C0,cf(-1,-.85+.4*math.cos(sine/8)/1.5,-.4*math.cos(sine/8)/2)*angles(math.rad(2+2*math.cos(sine/8))+math.sin(sine/8)/2,0,0)*angles(0,math.rad(-90),0),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.15 - 0.1 * math.cos(sine / 4))*angles(math.rad(5),math.rad(0),math.rad(0 - 5 * math.cos(sine / 8))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 + 2.5 * math.cos(sine / 100)),math.rad(0),math.rad(0 + 5 * math.cos(sine / 8))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0 + 45 * math.cos(sine / 8)),math.rad(0),math.rad(10 - 10 * math.cos(sine / 4))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0 - 45 * math.cos(sine / 8)),math.rad(0),math.rad(-10 + 10 * math.cos(sine / 4))),.1)
					end
				end
			elseif torvel>=22 and hitfloor~=nil then
				Anim="Run"
				if attack==false then
					if ModeOfGlitch ~= 1000000 and ModeOfGlitch ~= 12345678987654321 and ModeOfGlitch ~= 4 and ModeOfGlitch ~= 6 and ModeOfGlitch ~= 8376532578634534 then
						RH.C0=clerp(RH.C0,cf(1,-1-.4*math.cos(sine/6)/2,.8*math.cos(sine/6)/2)*angles(math.rad(0-65*math.cos(sine/6))-math.sin(sine/6)/1.5,0,0)*angles(0,math.rad(90),0),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1+.4*math.cos(sine/6)/2,-.8*math.cos(sine/6)/2)*angles(math.rad(0+65*math.cos(sine/6))+math.sin(sine/6)/1.5,0,0)*angles(0,math.rad(-90),0),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.125 + 0.125 * math.cos(sine / 3))*angles(math.rad(20),math.rad(0),math.rad(0 - 15 * math.cos(sine / 6))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10 + 2.5 * math.cos(sine / 100)),math.rad(0),math.rad(0 + 15 * math.cos(sine / 6))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0 + 105 * math.cos(sine / 6)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 3))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0 - 105 * math.cos(sine / 6)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 3))),.1)
					elseif ModeOfGlitch == 666666 then
						RH.C0=clerp(RH.C0,cf(1,-0.75 - 0.25 * math.cos(sine / 3),-0.25 - 0.25 * math.cos(sine / 3))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 95 * math.cos(sine / 6))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-0.75 + 0.25 * math.cos(sine / 3),-0.25 + 0.25 * math.cos(sine / 3))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 95 * math.cos(sine / 6))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.125 + .125 * math.cos(sine / 3))*angles(math.rad(25),math.rad(0),math.rad(0 - 5 * math.cos(sine / 6))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 5 * math.cos(sine / 0.5265)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465))),.1)
						RW.C0=clerp(RW.C0,cf(1.3,0.5,0)*angles(math.rad(180),math.rad(-90),math.rad(15))*angles(math.rad(-35),0,0)*angles(math.rad(10 + 2.5 * math.cos(sine / 0.252)),math.rad(0 + 2.5 * math.cos(sine / 0.123)),math.rad(5 + 2.5 * math.cos(sine / 0.6)))*angles(0,math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465))),.1)
						LW.C0=clerp(LW.C0,cf(-1.3,0.5,0)*angles(math.rad(180),math.rad(90),math.rad(-15))*angles(math.rad(-35),0,0)*angles(math.rad(10 + 2.5 * math.cos(sine / 0.568)),math.rad(0 + 2.5 * math.cos(sine / 0.664)),math.rad(-5 + 2.5 * math.cos(sine / 0.23)))*angles(0,math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465))),.1)

					elseif ModeOfGlitch == 1000000 or ModeOfGlitch == 12345678987654321 or ModeOfGlitch == 4 or ModeOfGlitch == 6 or ModeOfGlitch == 8376532578634534 then
						RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.2)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.2)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(75),math.rad(0),math.rad(0)),.2)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-30),math.rad(0),math.rad(30 + 2.5 * math.cos(sine / 28))),.2)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-30),math.rad(0),math.rad(-30 - 2.5 * math.cos(sine / 28))),.2)
					end
				end
			end
		end
	end

end)

Button_9.MouseButton1Down:Connect(function()
	--//====================================================\\--
	--||                       BASIS
	--\\====================================================//--

	workspace.FallenPartsDestroyHeight = -1000

	-- -gh 5410099943

	local script = game:GetObjects("rbxassetid://6043210660")[1]

	local MODULE = script
	local CHARACTER = game.Players.LocalPlayer.Character["Dummy"]
	local PLAYER = game.Players.LocalPlayer
	local HUM = CHARACTER.Humanoid

	local ROOT = HUM.Torso
	local HEAD = CHARACTER.Head
	local TORSO = CHARACTER.Torso
	local RIGHTARM = CHARACTER["Right Arm"]
	local LEFTARM = CHARACTER["Left Arm"]
	local RIGHTLEG = CHARACTER["Right Leg"]
	local LEFTLEG = CHARACTER["Left Leg"]
	local ROOTJOINT = ROOT["RootJoint"]
	local NECK = TORSO["Neck"]
	local RIGHTSHOULDER = TORSO["Right Shoulder"]
	local LEFTSHOULDER = TORSO["Left Shoulder"]
	local RIGHTHIP = TORSO["Right Hip"]
	local LEFTHIP = TORSO["Left Hip"]
	local MOUSEPOS = ROOT.Position

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor

	--//====================================================\\--
	--||                  BACKGROUND VALUES
	--\\====================================================//--

	local ANIM_SPEED = 3
	local MOUSE = PLAYER:GetMouse()
	local FRAME_SPEED = 1 / 60 -- (1 / 30) OR (1 / 60)
	local CHANGE = 2 / ANIM_SPEED
	local DAMAGEMULTIPLIER = 1
	local ANIM = "Idle"
	local KEYHOLD = false
	local MOUSEHOLD = false
	local ATTACKING = false
	local Debris = game:GetService("Debris")
	local Effects = IT("Folder",CHARACTER)
	Effects.Name = "FXFolder"
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local ANIMATE = CHARACTER:FindFirstChild("Animate")
	local CROUCHED = false
	local POTATO = script.Potato
	POTATO.Parent = nil
	local DEAD = false

	--//====================================================\\--
	--||                     HEARTBEAT
	--\\====================================================//--

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = FRAME_SPEED
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	--//====================================================\\--
	--||                       CLERP
	--\\====================================================//--

	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then 
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	--//====================================================\\--
	--||                     FUNCTIONS
	--\\====================================================//--

	function Animate(INOUT)
		if INOUT == "In" then
			ANIMATE.Parent = CHARACTER
			ROOTJOINT.C0 = ROOTC0
			NECK.C0 = NECKC0
			RIGHTSHOULDER.C0 = CF(1.5, 0.5, 0) * RIGHTSHOULDERC0
			LEFTSHOULDER.C0 = CF(-1.5, 0.5, 0) * LEFTSHOULDERC0
			RIGHTHIP.C0 = CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
			LEFTHIP.C0 = CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
		elseif INOUT == "Out" then
			for _,v in next, HUM:GetPlayingAnimationTracks() do
				v:Stop();
			end
			ANIMATE.Parent = nil
		end
	end

	function WeldParts(A,B)
		local WLD = IT("ManualWeld")
		WLD.Part0 = A
		WLD.Part1 = B
		WLD.C1 = B.CFrame:inverse() * A.CFrame
		WLD.Parent = A
		return WLD
	end

	POTATO.Parent = Effects
	POTATO.CFrame = RIGHTARM.CFrame*CF(0,-1.1,0) * ANGLES(RAD(90), RAD(0), RAD(0))
	local WLD = WeldParts(RIGHTARM,POTATO)

	--NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
	function NewSound(TABLE)
		local ID = "rbxassetid://"..(TABLE.ID or 0)
		local PARENT = (TABLE.PARENT or ROOT)
		local VOLUME = (TABLE.VOLUME or 0.5)
		local PITCH = (TABLE.PITCH or 1)
		local LOOP = (TABLE.LOOP or false)
		local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
		local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
		local PLAYING = (TABLE.PLAYING or true)
		local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
		local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
		if ID ~= "rbxassetid://0" then
			local SOUND = IT("Sound",PARENT)
			SOUND.SoundId = ID
			SOUND.Volume = VOLUME
			SOUND.Pitch = PITCH
			SOUND.Looped = LOOP
			SOUND.MaxDistance = MAXDISTANCE
			SOUND.EmitterSize = EMITTERSIZE
			SOUND.PlayOnRemove = PLAYONREMOVE
			if DOESDEBRIS == true and PLAYING == true and LOOP == false then
				Debris:AddItem(SOUND,SOUND.TimeLength+5)
			end
			if PLAYING == true then
				SOUND:Play()
			end
			return SOUND
		end
	end

	function AttachmentCFrame(A)
		return A.Parent.CFrame*CF(A.Position)
	end

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end

	function ManSlaughter(MAN)
		if MAN then
			local ROOT = MAN:FindFirstChild("HumanoidRootPart")
			local MANHUM = MAN:FindFirstChildOfClass("Humanoid")
			if MANHUM then
				MANHUM.BreakJointsOnDeath = false
				--MANHUM.Health = 0
			end
			if MAN:FindFirstChild("R6Ragdoll") == nil and MAN:FindFirstChild("R15Ragdoll") == nil then
				local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
				if TORSO then
					NewSound({ID = 146594648,PARENT = TORSO,VOLUME = 1,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				end
			end
			--MAN:BreakJoints()
			if MAN:FindFirstChild("Slaughtered") then
				local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
			end
		end
	end

	function ApplyDamageTo(HUM,DAMAGE)
		if HUM.Health >= 0 then
			HUM.Health = HUM.Health - DAMAGE
			if HUM.Health <= 0 then
				ManSlaughter(HUM.Parent)
			end
		end
	end

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function Chatter(Text,Timer)
		local chat = coroutine.wrap(function()
			if CHARACTER:FindFirstChild("SpeechBoard")~= nil then
				CHARACTER:FindFirstChild("SpeechBoard"):destroy()
			end
			local naeeym2 = IT("BillboardGui",CHARACTER)
			naeeym2.Size = UD2(0,100,0,40)
			naeeym2.StudsOffset = Vector3.new(0,2,0)
			naeeym2.Adornee = HEAD
			naeeym2.Name = "SpeechBoard"
			naeeym2.AlwaysOnTop = true
			local tecks2 = IT("TextLabel",naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.BorderSizePixel = 0
			tecks2.Text = ""
			tecks2.Font = "Legacy"
			tecks2.TextSize = 15
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = Color3.new(1,1,1)
			tecks2.TextStrokeColor3 = Color3.new(0,0,0)
			tecks2.Size = UDim2.new(1,0,0.5,0)
			for i = 1,string.len(Text),1 do
				if naeeym2.Parent ~= CHARACTER then 
					break
				end
				NewSound({ID = 418252437,PARENT = HEAD,VOLUME = 1,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				tecks2.Text = string.sub(Text,1,i)
				wait(Timer)
			end
			wait(1)
			naeeym2:Destroy()
		end)
		chat()
	end

	--//====================================================\\--
	--||                     ABILITIES
	--\\====================================================//--

	local invpart = Instance.new("Part", game:GetService("Players").LocalPlayer.Character)
	invpart.Anchored = true
	invpart.Position = Vector3.new(0, -50, 0)
	invpart.CanCollide = false
	local InvAtt = Instance.new("Attachment", invpart)

	local sword = game.Players.LocalPlayer.Character["Potato"]

	sword.Handle.AccessoryWeld:Destroy()

	local function weldf(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		if part0 == sword.Handle then
			part0.Size = Vector3.new(1,1,1)
			attachment0.Orientation = Vector3.new(0, 50, 0)
			attachment0.Position = Vector3.new(-0.4, 0, -0.2)
		end
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 10000
		weldpos.MaxVelocity = 10000
		weldpos.Responsiveness = 10000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 10000
		weldrot.MaxAngularVelocity = 10000
		weldrot.Responsiveness = 10000
	end

	weldf(sword.Handle, POTATO)
	wait()

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	v.Anchored = false

	local Outline = Instance.new("SelectionBox", v)
	Outline.LineThickness = 0.1
	Outline.Color3 = Color3.fromRGB(195, 130, 0)
	Outline.Adornee = v

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if ATTACKING == false then
				bp.Position = game.Players.LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)

	local potating = false

	function Potato()
		if CROUCHED == false and potating == false then
			potating = true
			POTATO.Touched:Connect(function(hit)
				if hit.Parent:FindFirstChild("Humanoid") and potating == true then
					if hit.Parent.Name == game.Players.LocalPlayer.Name then
						--print("not flinging")
					else
						if hit.Parent:FindFirstChild("UpperTorso") then
							bp.Position = hit.Parent:FindFirstChild("UpperTorso").Position
						elseif hit.Parent:FindFirstChild("Torso") then
							bp.Position = hit.Parent:FindFirstChild("Torso").Position
						end
					end
				end
			end)
			Animate("Out")
			ATTACKING = true
			local TARGET = nil
			local POTAT = POTATO
			POTAT.Parent = Effects
			POTAT.CFrame = RIGHTARM.CFrame*CF(0,-1.1,0) * ANGLES(RAD(90), RAD(0), RAD(0))
			local WLD = WeldParts(RIGHTARM,POTAT)
			Chatter("GRIFFIIIIINNNN",0)
			NewSound({ID = 1526471893,PARENT = HEAD,VOLUME = 5,PITCH = MRANDOM(9,11)/5,LOOP = false,MAXDISTANCE = 200,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
			for i=0, 0.5, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-35)), 2 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(35)), 2 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 1, 0.2) * ANGLES(RAD(170), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(15), RAD(-45)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 2 / ANIM_SPEED)
			end
			for i=0, 0.1, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, -1, -0.5) * ANGLES(RAD(45), RAD(0), RAD(50)), 2 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(45), RAD(0), RAD(-10)), 2 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(25))*CF(0,-0.5,0) * RIGHTSHOULDERC0, 1 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-25), RAD(15), RAD(-15)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.7, -0.5) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(45)), 2 / ANIM_SPEED)
			end
			local FOES = {}
			for index, CHILD in pairs(workspace:GetChildren()) do
				if CHILD:FindFirstChildOfClass("Humanoid") and CHILD ~= CHARACTER then
					local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
					local ROOT2 = HUMAN.Torso
					if ROOT2 and CHILD:FindFirstChild("Head") then
						if (ROOT2.Position - ROOT.CFrame*CF(0,0,-1.25).p).Magnitude <= 3 then
							table.insert(FOES,CHILD.Head)
						end
					end
				end
			end
			if #FOES > 0 then
				local DIST = math.huge
				for E = 1, #FOES do
					if (FOES[E].Position - ROOT.Position).Magnitude < DIST then
						DIST = (FOES[E].Position - ROOT.Position).Magnitude
						TARGET = FOES[E]
					end
				end
			end
			if TARGET then
				NewSound({ID = 2174934221,PARENT = TARGET,VOLUME = 5,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 200,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				local BV = IT("BodyVelocity")
				BV.MaxForce = BV.MaxForce * 500
				BV.Velocity = CF(ROOT.Position,TARGET.Position+VT(0,0.5,0)).lookVector*25
				BV.Parent = TARGET
				Debris:AddItem(BV,0.05)
				local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
				if HUM then
					--ApplyDamageTo(HUM,25)
				end
				WLD:Remove()
				--POTAT.CFrame = CF(TARGET.Position,VT(ROOT.Position.X,TARGET.Position.Y,ROOT.Position.Z))*CF(0,0,-0.75)
				--WeldParts(POTAT,TARGET)
			end
			for i=0, 0.9, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, -1, -0.5) * ANGLES(RAD(45), RAD(0), RAD(50)), 2 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(45), RAD(0), RAD(-10)), 2 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(25))*CF(0,-0.5,0) * RIGHTSHOULDERC0, 1 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-25), RAD(15), RAD(-15)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.7, -0.5) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(45)), 2 / ANIM_SPEED)
			end
			Animate("In")
			ATTACKING = false
			potating = false
		end
	end

	function Dance()
		if CROUCHED == false then
			local SONGS = {322621962,569026863,502771070,408862087,1471935327,236336857,2280063143,334259331,344685843,1479420512,297754476,591661590,1571736139,2988953773,130768805,2516100492,580535766,213546066}
			local SONG = SONGS[MRANDOM(1,#SONGS)]
			Animate("Out")
			HUM.WalkSpeed = 0
			HUM.JumpPower = 0
			ATTACKING = true
			local REMOVETRACK = false
			local TRACK = nil
			if ROOT:FindFirstChild("BGM_MUSIC") then
				TRACK = ROOT:FindFirstChild("BGM_MUSIC")
			else
				TRACK = NewSound({ID = SONG,PARENT = ROOT,VOLUME = 1.5,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				REMOVETRACK = true
			end
			TRACK.SoundId = "rbxassetid://"..SONG
			TRACK:Play()
			local DONEWITHDANCING = false
			MOUSE.KeyDown:connect(function(V2, PLR)
				if V2 == "m" then
					DONEWITHDANCING = true
				elseif V2 == "t" then
					FuckYou()
				end
			end)
			local LOOP = 0
			local RAVE = IT("PointLight",ROOT)
			RAVE.Brightness = 100
			repeat
				LOOP = LOOP + 5
				RAVE.Color = BrickColor.random().Color
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(-0.25 * COS(LOOP / 50), 0, -0.5 - 0.5 * COS(LOOP / 25)) * ANGLES(RAD(0), RAD(0), RAD(45 * SIN(LOOP / 50))) * ANGLES(RAD(45 + 22.5 * COS(LOOP / 25)), RAD(0), RAD(0)), 2 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-45 - 22.5 * COS(LOOP / 25)), RAD(0), RAD(-45 * SIN(LOOP / 50))), 2 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(175+65 * SIN(LOOP / 25)), RAD(0), RAD(-45 * SIN(LOOP / 12.5))) * CF(0,-0.5,0) * RIGHTSHOULDERC0, 1 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(175+65 * SIN(LOOP / 25)), RAD(0), RAD(45 * SIN(LOOP / 12.5))) * CF(0,-0.5,0) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.5 + 0.5 * COS(LOOP / 25), -0.5 - 0.5 * COS(LOOP / 25)) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.5 + 0.5 * COS(LOOP / 25), -0.5 - 0.5 * COS(LOOP / 25)) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / ANIM_SPEED)
				Swait()
			until DONEWITHDANCING == true or HUM.Health <= 0
			RAVE:Remove()
			--NC:Disconnect()
			if REMOVETRACK == true then
				TRACK:Remove()
			else
				TRACK:Play()
				TRACK.SoundId = "rbxassetid://185558852"
			end
			ATTACKING = false
			HUM.WalkSpeed = 20
			HUM.JumpPower = 50
			Animate("In")
		end
	end

	function Crouch()
		if CROUCHED == false then
			ROOTJOINT.C0 = ROOTC0 * CF(0, 0, -1) * ANGLES(RAD(45), RAD(0), RAD(0))
			NECK.C0 = NECKC0 * ANGLES(RAD(-45), RAD(0), RAD(0))
			RIGHTSHOULDER.C0 = CF(1.5, 0.5, 0) * RIGHTSHOULDERC0
			LEFTSHOULDER.C0 = CF(-1.5, 0.5, 0) * LEFTSHOULDERC0
			RIGHTHIP.C0 = CF(1, 0, -1) * ANGLES(RAD(0), RAD(90), RAD(0))
			LEFTHIP.C0 = CF(-1, 0, -1) * ANGLES(RAD(0), RAD(-90), RAD(0))
			CROUCHED = true
		elseif CROUCHED == true then
			ROOTJOINT.C0 = ROOTC0
			NECK.C0 = NECKC0
			RIGHTSHOULDER.C0 = CF(1.5, 0.5, 0) * RIGHTSHOULDERC0
			LEFTSHOULDER.C0 = CF(-1.5, 0.5, 0) * LEFTSHOULDERC0
			RIGHTHIP.C0 = CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
			LEFTHIP.C0 = CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
			CROUCHED = false
		end
	end

	function The_Future_Is_Now()
		if CROUCHED == false then
			HUM.WalkSpeed = 0
			HUM.JumpPower = 0
			Animate("Out")
			ATTACKING = true
			local FACE = HEAD.face
			local MESH = function(MESHID,TEXTURE,SIZE)
				if MESHID then
					for index, CHILD in pairs(CHARACTER:GetDescendants()) do
						if CHILD:IsA("BasePart") then
							--CHILD.Transparency = 1
						end
					end
					FACE.Transparency = 1
					ROOT.Transparency = 0
					local MESH = ROOT:FindFirstChildOfClass("SpecialMesh") or IT("SpecialMesh",ROOT)
					MESH.MeshId = "rbxassetid://"..MESHID
					MESH.TextureId = "rbxassetid://"..TEXTURE
					MESH.Scale = SIZE
					MESH.Offset = VT(0,0.5,0)
				else
					for index, CHILD in pairs(CHARACTER:GetDescendants()) do
						if CHILD:IsA("BasePart") then
							CHILD.Transparency = 1
						end
					end
					FACE.Transparency = 0
					ROOT.Transparency = 1
					if ROOT:FindFirstChildOfClass("SpecialMesh") then
						ROOT:FindFirstChildOfClass("SpecialMesh"):Remove()
					end
				end
			end
			local BOOMED = false
			local WARIO = NewSound({ID = 2989518230,PARENT = ROOT,VOLUME = 5,PITCH = 1,LOOP = false,MAXDISTANCE = 200,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
			repeat
				Swait()
				if WARIO.TimePosition <= 2.335 then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-65), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 0.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
				elseif WARIO.TimePosition > 2.335 and WARIO.TimePosition < 3.35 then
					MESH(441220320,441220324,VT(0.4,0.4,0.4))
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
				else
					if BOOMED == false then
						BOOMED = true
						local BOOM = IT("Explosion")
						BOOM.Position = ROOT.Position
						BOOM.BlastRadius = 0
						BOOM.Parent = ROOT
					end
					MESH(441220320,441220324,VT(0,0,0))
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
				end
			until WARIO.Playing == false or WARIO.Parent ~= ROOT
			MESH()
			ATTACKING = false
			HUM.WalkSpeed = 20
			HUM.JumpPower = 50
			Animate("In")
		end
	end

	function FuckYou()
		local TEXT = {"I am going to slap a rabbit out of your nose","No it was your mom","Pics or it didnt happen","nein thoust","potato","no u, humans i swear","ok","m","literally a lemon",PLAYER.Name.." is here","literally consumes potatoes","i diagnose you with dead","GJIEUDJGHBEUYDTJGHGESIGUJSHGNUIESJDGTHNSEIUDGJHSEDNGIUKJSEDYHGNISUKEDJGHSNEIDUGJHSENDGUJSEHGNUISEJGM","gsap","toast when","I NEVER LEARNED HOW TO READ","help","haram hub best"}
		Chatter(TEXT[MRANDOM(1,#TEXT)],0)
	end

	--//====================================================\\--
	--||                       WRAP
	--\\====================================================//--

	MOUSE.Button1Down:Connect(function()
		--Potato()
	end)

	MOUSE.KeyDown:connect(function(k, PLR)
		if DEAD == false then
			--if V1 == "MousePositionUpdate" then
			--MOUSEPOS = V2
			if ATTACKING == false then
				if k == "z" then
					Potato()
				elseif k == "c" then
					Crouch()
				elseif k == "t" then
					FuckYou()
				elseif k == "m" then
					Dance()
				elseif k == "x" then
					The_Future_Is_Now()
				elseif k == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = 185558852,PARENT = ROOT,VOLUME = 1.5,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
			end
		end
	end)
	local M = NewSound({ID = 185558852,PARENT = ROOT,VOLUME = 1.5,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
	M.Name = "BGM_MUSIC"
	HUM.WalkSpeed = 20

	HUM.Died:Connect(function()
		ManSlaughter(CHARACTER)
		DEAD = true
		Chatter("OW IM DEAD",0)
		NewSound({ID = 2542613889,PARENT = HEAD,VOLUME = 10,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 200,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
	end)
end)

Button_10.MouseButton1Down:Connect(function()
	wait(0.5)

	local script = game:GetObjects("rbxassetid://5947050250")[1]

	local Player = game:GetService("Players").LocalPlayer --<=== Replace With Your Name

	warn([[SpectrumGlitcher v7 Loaded.
The super switcher.

Created, Reworked by NoobyGames12
1st Edit by GodzPlaysRB (SpectrumEeveez)
2nd Edit by wanTH092 (Filano)
3rd Edit by AlmightyToast
4th Edit by DerpzDeNugget_YT
5th Edit by KillerzTH
6th Fix by ZaBlazy_y
]])

	print([[ CHANGELOG v7.6
The unfinished final update
..
welp updated by filano i think

But FULLLLY fixed by ZaBlazy_y "Momiji" 
(learn to fix)


OY
OY
OYOYOYOYOYOYOYOYOYOYOY
BLUEBLOXGUY35 HERE WITH A MINOR EDIT, SPECTRUM SUCKS, AND  IM HELPING POISON LEAK

also unfair and spectrum dev team are skids



For alpha press B < For Cata press B < P for diversial
]])


	--- its obs smooth af do not touch 
	---- Sources and functions might be taken from others

	-- Nebula stuff --
	local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
	local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
	local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
	local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
	local R3 = {N=Region3.new}
	local De = S.Debris
	local WS = workspace
	local Lght = S.Lighting
	local RepS = S.ReplicatedStorage
	local IN = Instance.new
	local Plrs = S.Players
	local FXFolder = script:FindFirstChild'Effects'
	FXFolder.Parent = nil
	local Alpha = .3

	NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance)
		inst.Parent = parent
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end
	-- Script --

	plr = game:GetService("Players").LocalPlayer
	Player = plr 
	char = plr.Character["Dummy"]
	hum = char.Humanoid
	local cam = game.Workspace.CurrentCamera
	Camera = cam
	local CamInterrupt = false
	local TwoD = false
	local TargetInfo = {nil, nil}
	cam.CameraType = "Custom"
	t = char.Torso
	h = char.Head
	ra = char["Right Arm"]
	la = char["Left Arm"]
	rl = char["Right Leg"]
	ll = char["Left Leg"]
	tors = char.Torso
	lleg = char["Left Leg"]
	root = char.HumanoidRootPart
	hed = char.Head
	rleg = char["Right Leg"]
	rarm = char["Right Arm"]
	larm = char["Left Arm"]
	radian = math.rad
	random = math.random
	Vec3 = Vector3.new
	Inst = Instance.new
	cFrame = CFrame.new
	Euler = CFrame.fromEulerAnglesXYZ
	vt = Vector3.new
	bc = BrickColor.new
	br = BrickColor.random
	it = Instance.new
	cf = CFrame.new
	local Player_Size = 0
	cam = game.Workspace.CurrentCamera
	CF = CFrame.new
	angles = CFrame.Angles
	attack = false
	Euler = CFrame.fromEulerAnglesXYZ
	Rad = math.rad
	IT = Instance.new
	BrickC = BrickColor.new
	Cos = math.cos
	Acos = math.acos
	Sin = math.sin
	Asin = math.asin
	Abs = math.abs
	Mrandom = math.random
	Floor = math.floor
	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor
	local SINE = 0
	local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
	local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
	local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
	local ModeOfGlitch = 1
	CF = CFrame.new
	local hed = char.Head
	local root = char.HumanoidRootPart
	local rootj = root.RootJoint
	local tors = char.Torso
	Player_Size = 1
	Cos = math.cos
	Sin = math.sin
	Rad = math.rad	
	CF = CFrame.new
	local DoDamage = true
	local Diversial = false


	local Booleans = {
		CamFollow = true,
		GyroUse = true
	}

	function lerp(object, newCFrame, alpha)
		return object:lerp(newCFrame, alpha)
	end

	local Directer = Inst("BodyGyro", root)
	Directer.MaxTorque = Vec3(0, 0, 0)
	Directer.P = 600000
	local CPart = Inst("Part")
	CPart.Anchored = true
	CPart.CanCollide = false
	CPart.Locked = true
	CPart.Transparency = 1

	local CRAZED = false
	local rainbowmode = false
	local chaosmode = false
	local Error = false
	local unstablemode = false
	local MAINRUINCOLOR = BrickColor.new("Really red")


	local kan = Instance.new("Sound",char)
	kan.Volume = 1.25
	kan.TimePosition = 0
	kan.PlaybackSpeed = 1
	kan.Pitch = 1
	kan.SoundId = "rbxassetid://415898123"
	kan.Name = "wrecked"
	kan.Looped = true
	kan:Play()

	local currentThemePlaying = kan.SoundId
	local currentPitch = kan.Pitch
	local currentVol = kan.Volume
	function newTheme(ID,timepos,pitch,vol)
		local kanz = kan
		--kanz:Stop()
		kanz.Volume = vol
		--kanz.TimePosition = timepos
		kanz.PlaybackSpeed = pitch
		kanz.Pitch = pitch
		kanz.SoundId = ID
		kanz.Name = "wrecked"
		kanz.Looped = true
		currentThemePlaying = kanz.SoundId
		currentVol = kanz.Volume
		currentPitch = kanz.Pitch
		--kanz:Play()
		--coroutine.resume(coroutine.create(function()
		--wait(0.05)
		--end))
	end


	function newThemeCust(ID,timepos,pitch,vol)
		local kanz = kan
		kanz:Stop()
		kanz.Volume = vol
		kanz.TimePosition = timepos
		kanz.PlaybackSpeed = pitch
		kanz.Pitch = pitch
		kanz.SoundId = ID
		kanz.Name = "wrecked"
		kanz.Looped = true
		currentThemePlaying = kanz.SoundId
		currentVol = kanz.Volume
		currentPitch = kanz.Pitch
		kanz:Play()
		coroutine.resume(coroutine.create(function()
			wait(0.05)
		end))
	end

	local mutedtog = false



	local Instance = setmetatable({ClearChildrenOfClass = function(where,class,recursive) local children = (recursive and where:GetDescendants() or where:GetChildren()) for _,v in next, children do if(v:IsA(class))then v:destroy();end;end;end},{__index = Instance})

	--// Require stuff \\--
	function CamShake(who,times,intense,origin) 
		coroutine.wrap(function()
			if(FXFolder:FindFirstChild'CamShake')then
				local cam = FXFolder.CamShake:Clone()
				cam:WaitForChild'intensity'.Value = intense
				cam:WaitForChild'times'.Value = times

				if(origin)then NewInstance((typeof(origin) == 'Instance' and "ObjectValue" or typeof(origin) == 'Vector3' and 'Vector3Value'),cam,{Name='origin',Value=origin}) end
				cam.Parent = who
				wait()
				cam.Disabled = false
			end
		end)()
	end

	function CamShakeAll(times,intense,origin)
		for _,v in next, Plrs:players() do
			CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,times,intense,origin)
		end
	end

	function shakes(power,length)
		for i,v in pairs(game:GetService("Players"):GetChildren()) do
			local var = script.Shaker:Clone()
			var.Parent = v.PlayerGui
			local pw = var.Shakeval
			local lgth = var.MultLength
			pw.Value = power
			lgth.Value = length
			var.Disabled = false
		end
	end



	local toggleTag = true
	local bilguit = Instance.new("BillboardGui", hed)
	bilguit.Adornee = nil
	bilguit.Name = "ModeName"
	bilguit.Size = UDim2.new(4, 0, 1.2, 0)
	bilguit.StudsOffset = Vector3.new(-8, 8/1.5, 0)
	local modet = Instance.new("TextLabel", bilguit)
	modet.Size = UDim2.new(10/2, 0, 7/2, 0)
	modet.FontSize = "Size8"
	modet.TextScaled = true
	modet.TextTransparency = 0
	modet.BackgroundTransparency = 1 
	modet.TextTransparency = 0
	modet.TextStrokeTransparency = 0
	modet.Font = "Antique"
	modet.TextStrokeColor3 = Color3.new(1,0,0)
	modet.TextColor3 = Color3.new(0.25,0,0)
	modet.Text = "MAYHEM"


	function chatfunc(text,color,typet,font,timeex)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard")~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end
			local naeeym2 = Instance.new("BillboardGui",Character)
			naeeym2.Size = UDim2.new(0,100,0,40)
			naeeym2.StudsOffset = Vector3.new(0,3,0)
			naeeym2.Adornee = Character.Head
			naeeym2.Name = "TalkingBillBoard"
			local tecks2 = Instance.new("TextLabel",naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.BorderSizePixel = 0
			tecks2.Text = ""
			tecks2.Font = font
			tecks2.TextSize = 30
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = color
			tecks2.TextStrokeColor3 = Color3.new(0,0,0)
			tecks2.Size = UDim2.new(1,0,0.5,0)
			local tecks3 = Instance.new("TextLabel",naeeym2)
			tecks3.BackgroundTransparency = 1
			tecks3.BorderSizePixel = 0
			tecks3.Text = ""
			tecks3.Font = font
			tecks3.TextSize = 30
			tecks3.TextStrokeTransparency = 0
			if typet == "Inverted" then
				tecks3.TextColor3 = Color3.new(0,0,0)
				tecks3.TextStrokeColor3 = color
			elseif typet == "Normal" then
				tecks3.TextColor3 = color
				tecks3.TextStrokeColor3 = Color3.new(0,0,0)
			end
			tecks3.Size = UDim2.new(1,0,0.5,0)
			coroutine.resume(coroutine.create(function()
				while true do
					swait(1)
					if Error == true then
						tecks2.TextColor3 = BrickColor.random().Color
						tecks3.TextStrokeColor3 = BrickColor.random().Color
					end
				end
			end))
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if chaosmode == true then
						tecks2.Rotation = tecks2.Rotation + 8 * math.cos(SINE / 16)
						tecks3.Rotation = tecks3.Rotation + 8 * math.cos(SINE / 16)
						tecks2.TextColor3 = BrickColor.new("White").Color
						tecks2.TextColor3 = Color3.new(math.random(0.5,1),0,0)
						tecks3.TextStrokeColor3 = Color3.new(math.random(0.5,1),0,0)
						tecks3.TextStrokeColor3 = BrickColor.new("White").Color
						if math.random(1,10) == 1 then
							tecks2.TextColor3 = Color3.new(math.random(0.5,1),0,0)
							tecks2.TextColor3 = BrickColor.new("White").Color
							tecks3.TextStrokeColor3 = BrickColor.new("White").Color
							tecks3.TextStrokeColor3 = Color3.new(math.random(0.5,1),0,0)
						end
					end
				end
			end))
			coroutine.resume(coroutine.create(function()
				while true do
					swait(1)
					if chaosmode == true then
						tecks2.TextColor3 = BrickColor.random().Color
						tecks3.TextStrokeColor3 = BrickColor.random().Color
					end
				end
			end))
			modet.TextTransparency = modet.TextTransparency  + 1
			modet.TextStrokeTransparency = modet.TextStrokeTransparency + 1
			for i = 0, 74*timeex do
				swait()
				modet.TextTransparency = 1
				modet.TextStrokeTransparency = 1
				tecks2.Text = text
				tecks3.Text = text
			end
			local randomrot = math.random(1,2)
			if randomrot == 1 then
				for i = 1, 50 do
					swait()
					tecks2.Text = text
					tecks3.Text = text
					modet.TextTransparency = modet.TextTransparency - .02
					modet.TextStrokeTransparency = modet.TextStrokeTransparency - .02
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			elseif randomrot == 2 then
				for i = 1, 50 do
					swait()
					tecks2.Text = text
					tecks3.Text = text
					modet.TextTransparency = modet.TextTransparency - .02
					modet.TextStrokeTransparency = modet.TextStrokeTransparency - .02
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			end
			modet.TextTransparency = 0
			modet.TextStrokeTransparency = 0
			if toggleTag == false then
				modet.TextTransparency = 1
				modet.TextStrokeTransparency = 1
			end
			naeeym2:Destroy()
		end)
		--chat()
	end

	local rai = {"USER","User","USer","USEr","uSER","usER","useR","uSer","usEr","useR","PlAyEr","666"}

	function bosschatfunc(text,color,watval)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("Dialog")~= nil then
					v.PlayerGui:FindFirstChild("Dialog"):destroy()
				end
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
				scrg.Name = "Dialog"
				local txtlb = Instance.new("TextLabel",scrg)
				txtlb.Text = ""
				txtlb.Font = "Arcade"
				txtlb.TextColor3 = Color3.new(0,0,0)
				txtlb.TextStrokeTransparency = 0
				txtlb.BackgroundTransparency = 0.75
				txtlb.BackgroundColor3 = Color3.new(0,0,0)
				txtlb.TextStrokeColor3 = color
				txtlb.TextScaled = true
				txtlb.Size = UDim2.new(1,0,0.25,0)
				txtlb.TextXAlignment = "Left"
				txtlb.Position = UDim2.new(0,0,0.75 + 1,0)
				local txtlb2 = Instance.new("TextLabel",scrg)
				txtlb2.Text = modet.Text.." USER:"
				txtlb2.Font = "Arcade"
				txtlb2.TextColor3 = Color3.new(0,0,0)
				txtlb2.TextStrokeTransparency = 0
				txtlb2.BackgroundTransparency = 1
				txtlb2.TextStrokeColor3 = color
				txtlb2.TextSize = 40
				txtlb2.Size = UDim2.new(1,0,0.25,0)
				txtlb2.TextXAlignment = "Left"
				txtlb2.Position = UDim2.new(0,0,1,0)
				local fvalen = 0.55
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if ModeOfGlitch == 666666 then
							txtlb2.Text = modet.Text.."  U S E R :"
							txtlb.Rotation = math.random(-2,2)
							txtlb2.Rotation = math.random(-2,2)
							txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-2,2)/5,0,math.random(-2,2)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-2,2)/5,0,math.random(-2,2)/5)
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if Error == true then
							txtlb2.Text = modet.Text..rai[math.random(1,12)]
							txtlb.Rotation = math.random(-9,9)
							txtlb2.Rotation = math.random(-9,9)
							txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-8,8)/5,0,math.random(-8,8)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-8,8)/5,0,math.random(-8,8)/5)
							txtlb.TextStrokeColor3 = BrickColor.random().Color
							txtlb2.TextStrokeColor3 = BrickColor.random().Color
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if unstablemode == true then
							txtlb.TextStrokeColor3 = BrickColor.new(math.random(0,1),0,0).Color
							txtlb2.TextStrokeColor3 = BrickColor.new(math.random(0,1),0,0).Color
							txtlb.TextColor3 = BrickColor.new(1,1,1).Color
							txtlb2.TextColor3 = BrickColor.new(1,1,1).Color
							if math.random(1,10) == 1 then
								txtlb.TextStrokeColor3 = BrickColor.new(0,0,0).Color
								txtlb2.TextStrokeColor3 = BrickColor.new(0,0,0).Color
								txtlb.TextColor3 = BrickColor.new(math.random(0,1),0,0).Color
								txtlb2.TextColor3 = BrickColor.new(math.random(0,1),0,0).Color

							end
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if CRAZED == true then
							txtlb.Rotation = math.random(-4,4)
							txtlb2.Rotation = math.random(-4,4)
							txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb.TextStrokeColor3 = BrickColor.new(0,0,math.random(0,1)).Color
							txtlb.TextColor3 = BrickColor.new(0,0,math.random(0,1)).Color
							txtlb2.TextStrokeColor3 = BrickColor.new(0,0,math.random(0,1)).Color
							txtlb2.TextColor3 = BrickColor.new(0,0,math.random(0,1)).Color
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if chaosmode == true then
							txtlb.Rotation = math.random(-1,1)
							txtlb2.Rotation = math.random(-1,1)
							txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb.TextStrokeColor3 = BrickColor.random().Color
							txtlb2.TextStrokeColor3 = BrickColor.random().Color
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if scrg.Parent ~= nil then
							fvalen = fvalen - 0.0001
						elseif scrg.Parent == nil then
							break
						end
					end
				end))
				local flol = 1.75
				local flil = 1.6
				coroutine.resume(coroutine.create(function()
					for i = 0, 9 do
						swait()
						fval = fval + 0.05
						flol = flol - 0.1
						flil = flil - 0.1
						txtlb.Text = ""
						txtlb.Position = UDim2.new(0,0,flol,0)
						txtlb2.Position = UDim2.new(0,0,flil,0)
					end
					txtlb.Text = text
					wait(watval)
					local valinc = 0
					for i = 0, 99 do
						swait()
						valinc = valinc + 0.0001
						flol = flol + valinc
						flil = flil + valinc
						txtlb.Rotation = txtlb.Rotation + valinc*20
						txtlb2.Rotation = txtlb2.Rotation - valinc*50
						txtlb.Position = UDim2.new(0,0,flol,0)
						txtlb2.Position = UDim2.new(0,0,flil,0)
						txtlb.TextStrokeTransparency = txtlb.TextStrokeTransparency + 0.01
						txtlb.TextTransparency = txtlb.TextTransparency + 0.01
						txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
						txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
						txtlb.BackgroundTransparency = txtlb.BackgroundTransparency + 0.0025
					end
					scrg:Destroy()
				end))
			end))
		end
	end

	loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()
	local Create = LoadLibrary("RbxUtility").Create

	CFuncs = {	
		["Part"] = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part"){
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material,
				}
				RemoveOutlines(Part)
				return Part
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Weld"] = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld"){
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1,
				}
				return Weld
			end;
		};

		["Sound"] = {
			Create = function(id, par, vol, pit) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 10)
				end))
			end;
		};

		["TimeSound"] = {
			Create = function(id, par, vol, pit, timepos) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						TimePosition = timepos,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 10)
				end))
			end;
		};
		["EchoSound"] = {
			Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
				coroutine.resume(coroutine.create(function()
					local Sas = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						TimePosition = timepos,
						Parent = par or workspace,
					}
					local E = Create("EchoSoundEffect"){
						Delay = echodelay,
						Name = "Echo",
						Feedback = fedb,
						DryLevel = dryl,
						Parent = Sas,
					}
					wait() 
					Sas:play() 
					game:GetService("Debris"):AddItem(Sas, delays)
				end))
			end;
		};

		["LongSound"] = {
			Create = function(id, par, vol, pit) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 60)
				end))
			end;
		};

		["ParticleEmitter"] = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter"){
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread,
				}
				return fp
			end;
		};

		CreateTemplate = {

		};
	}



	New = function(Object, Parent, Name, Data)
		local Object = Instance.new(Object)
		for Index, Value in pairs(Data or {}) do
			Object[Index] = Value
		end
		Object.Parent = Parent
		Object.Name = Name
		return Object
	end
	local halocolor = BrickColor.new("Pastel light blue")
	local halocolor2 = BrickColor.new("Cool yellow")
	local starcolor = BrickColor.new("Bright yellow")
	local lunacolor = BrickColor.new("Navy blue")
	local lunacolor2 = BrickColor.new("Bright blue")
	local wepcolor = BrickColor.new("Really black")
	local maincolor = BrickColor.new("Really black")
	local m = Instance.new("Model",char)
	local m2 = Instance.new("Model",char)
	local m3 = Instance.new("Model",char)
	local mw1 = Instance.new("Model",char)
	local mw2 = Instance.new("Model",char)

	local est = {"error","Errors","eRror","erRor","errOr","erroR","ERror","ErRor","ErrOr","ErroR","eRRor","eRrOr","eRroR","erROr","erRoR","errOR","ERROR"}



	gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
		local gui = it(GuiType)
		gui.Parent = parent
		gui.Text = text
		gui.BackgroundTransparency = backtrans
		gui.BackgroundColor3 = backcol
		gui.SizeConstraint = "RelativeXY"
		gui.TextXAlignment = "Center"
		gui.TextYAlignment = "Center"
		gui.Position = pos
		gui.Size = size
		gui.Font = "SourceSans"
		gui.FontSize = "Size14"
		gui.TextWrapped = false
		gui.TextStrokeTransparency = 0
		gui.TextColor = BrickColor.new("White")
		return gui
	end
	--------------------------- GUI STUFF
	local basgui = it("GuiMain")
	basgui.Parent = plr.PlayerGui
	basgui.Name = "VISgui"
	local fullscreenz = it("Frame")
	fullscreenz.Parent = basgui
	fullscreenz.BackgroundColor3 = Color3.new(255, 255, 255)
	fullscreenz.BackgroundTransparency = 1
	fullscreenz.BorderColor3 = Color3.new(17, 17, 17)
	fullscreenz.Size = UDim2.new(1, 0, 1, 0)
	fullscreenz.Position = UDim2.new(0, 0, 0, 0)
	local imgl2 = Instance.new("ImageLabel",fullscreenz)
	imgl2.BackgroundTransparency = 1
	imgl2.BorderSizePixel = 0
	imgl2.ImageTransparency = 0.5
	imgl2.ImageColor3 = Color3.new(1,0,0)
	imgl2.Position = UDim2.new(0.75,-200,0.55,-200)
	imgl2.Size = UDim2.new(0,1000,0,1000)
	imgl2.Image = "rbxassetid://2076458450"
	local techc = Instance.new("ImageLabel",fullscreenz)
	techc.BackgroundTransparency = 1
	techc.BorderSizePixel = 0
	techc.ImageTransparency = 0.5
	techc.ImageColor3 = Color3.new(1,0,0)
	techc.Position = UDim2.new(0.75,-200,0.55,-200)
	techc.Size = UDim2.new(0,1000,0,1000)
	techc.Image = "rbxassetid://2092248396"
	local circl = imgl2:Clone()
	circl.Parent = fullscreenz
	circl.ImageTransparency = 0
	circl.Size = UDim2.new(0,550,0,550)
	circl.Position = UDim2.new(0.75,25,0.55,25)
	circl.ImageColor3 = Color3.new(0,0,0)
	circl.Image = "rbxassetid://2365416622"
	local circl2 = imgl2:Clone()
	circl2.Parent = fullscreenz
	circl2.ImageTransparency = 0
	circl2.Size = UDim2.new(0,700,0,700)
	circl2.Position = UDim2.new(0.75,-50,0.55,-50)
	circl2.ImageColor3 = Color3.new(1,0,0)
	circl2.Image = "rbxassetid://2365431459"
	local imgl2b = imgl2:Clone()
	imgl2b.Parent = fullscreenz
	imgl2b.ImageTransparency = 0
	imgl2b.Size = UDim2.new(0,800,0,800)
	imgl2b.Position = UDim2.new(0.75,-100,0.55,-100)
	imgl2b.ImageColor3 = Color3.new(0,0,0)
	local ned = Instance.new("TextLabel",fullscreenz)
	ned.ZIndex = 2
	ned.Font = "Arcade"
	ned.BackgroundTransparency = 1
	ned.BorderSizePixel = 0.65
	ned.Size = UDim2.new(0.3,0,0.2,0)
	ned.Position = UDim2.new(0.7,0,0.8,0)
	ned.TextColor3 = BrickColor.new("Really red").Color
	ned.TextStrokeColor3 = BrickColor.new("Really black").Color
	ned.TextScaled = true
	ned.TextStrokeTransparency = 0
	ned.Text = "MAYHEM"
	ned.TextSize = 24
	ned.Rotation = 1
	ned.TextXAlignment = "Right"
	ned.TextYAlignment = "Bottom"
	local wobble = Instance.new("Frame",basgui)
	wobble.Name = "Wobble"
	wobble.BackgroundTransparency = 0.5
	wobble.Size = UDim2.new(1.1,0,1.1,0)
	wobble.Position = UDim2.new(-0.08,0,0.943,0)
	local wobble2 = Instance.new("Frame",basgui)
	wobble2.Name = "wobble2"
	wobble2.BackgroundTransparency = 0.5
	wobble2.Size = UDim2.new(1.1,0,0.09,0)
	wobble2.Position = UDim2.new(-0.08,0,0.878,0)
	local Visuals = Instance.new("Frame",basgui)
	Visuals.Name = "Visuals"
	Visuals.BackgroundTransparency = 0.3
	Visuals.Size = UDim2.new(0,100,0,100)
	Visuals.Position = UDim2.new(0.462,0,0.826,0)
	local glow = Instance.new("ImageLabel",basgui)
	glow.Name = "glow"
	glow.BackgroundTransparency = 1
	glow.ImageTransparency = 0
	glow.Image = "rbxassetid://2344870656"
	glow.Size = UDim2.new(0,0,0,0)
	glow.Position = UDim2.new(0.026,0,-0.235,0)
	local Visuals2 = Instance.new("Frame",basgui)
	Visuals2.Name = "Visuals2"
	Visuals2.BackgroundTransparency = 0.3
	Visuals2.Size = UDim2.new(0,50,0,50)
	Visuals2.Position = UDim2.new(0.48,0,0.867,0) -- {0.476, 0},{0.901, 0}
	local TextFrame = Instance.new("TextLabel",basgui)
	TextFrame.Name = "Farmer"
	TextFrame.Font = "Arcade"
	TextFrame.Text = "Spectrum Glitcher"
	TextFrame.TextSize = 60
	TextFrame.BackgroundTransparency = 1
	TextFrame.Size = UDim2.new(0,42,0,42)
	TextFrame.Position = UDim2.new(0.48,0,0.867,0) -- {0.476, 0},{0.867, 0}
	-- local TextFrame2 = Instance.new("TextLabel",basgui)
	-- TextFrame2.Name = "Farmer3"
	-- TextFrame2.Font = "Arcade"
	-- TextFrame2.Text = ""
	-- TextFrame2.TextXAlignment = "Center"
	-- TextFrame2.TextSize = 40
	-- TextFrame2.BackgroundTransparency = 1
	-- TextFrame2.Size = UDim2.new(0,1367,0,42)
	-- TextFrame2.Position = UDim2.new(0,0,0,0) -- {0.476, 0},{0.901, 0}
	local DamageFrame = Instance.new("TextLabel",basgui)
	DamageFrame.Name = "Farmer2"
	DamageFrame.Font = "SciFi"
	DamageFrame.Text = "Damage = Enabled"
	DamageFrame.TextSize = 30
	DamageFrame.BackgroundTransparency = 1
	DamageFrame.TextStrokeTransparency = 0
	DamageFrame.Size = UDim2.new(0,42,0,42)
	DamageFrame.Rotation = 15
	DamageFrame.Position = UDim2.new(0.069,0,0.91,0) -- {0.476, 0},{0.901, 0}
	local ModeFrame = Instance.new("TextLabel",basgui)
	ModeFrame.Name = "Farmer5000"
	ModeFrame.Font = "SciFi"
	ModeFrame.Text = "Side: Spectrum"
	ModeFrame.TextSize = 30
	ModeFrame.BackgroundTransparency = 1
	ModeFrame.TextStrokeTransparency = 0
	ModeFrame.Size = UDim2.new(0,42,0,42)
	ModeFrame.Rotation = 15
	ModeFrame.Position = UDim2.new(0.069,0,0.86,0) -- {0.476, 0},{0.901, 0}
	chatfunc("Converted by Destroid!",Color3.new(255,0,0),"Inverted","Antique",0.75)


	local extrawingmod1 = Instance.new("Model",char)
	local extrawingmod2 = Instance.new("Model",char)

	function CreateParta(parent,transparency,reflectance,material,brickcolor)
		local p = Instance.new("Part")
		p.TopSurface = 0
		p.BottomSurface = 0
		p.Parent = parent
		p.Size = Vector3.new(0.1,0.1,0.1)
		p.Transparency = transparency
		p.Reflectance = reflectance
		p.CanCollide = false
		p.Locked = true
		p.BrickColor = brickcolor
		p.Material = material
		return p
	end

	function CreateMesh(parent,meshtype,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = meshtype
		mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
		return mesh
	end

	function CreateSpecialMesh(parent,meshid,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.Scale = Vector3.new(x1,y1,z1)
		return mesh
	end


	function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
		mesh.Scale = Vector3.new(x1,y1,z1)
		mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
		return mesh
	end

	function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
		local weld = Instance.new("Weld")
		weld.Parent = parent
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
		weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
		return weld
	end


	--------------
	-------------- ground effect
	local cen = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWeld(cen,root,cen,0,3,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local effar = Instance.new("ParticleEmitter",cen)
	effar.Texture = "rbxassetid://2344870656"
	effar.LightEmission = 1
	effar.Color = ColorSequence.new(Color3.new(1,0,0))
	effar.Rate = 50
	effar.Enabled = false
	effar.EmissionDirection = "Front"
	effar.Lifetime = NumberRange.new(1)
	effar.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.1,5,0),NumberSequenceKeypoint.new(0.8,15,0),NumberSequenceKeypoint.new(1,40,0)})
	effar.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
	effar.Speed = NumberRange.new(80,90)
	effar.Acceleration = Vector3.new(0,10,0)
	effar.Drag = 5
	effar.Rotation = NumberRange.new(-500,500)
	effar.SpreadAngle = Vector2.new(0,900)
	effar.RotSpeed = NumberRange.new(-500,500)

	----
	local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWeld(sorb,rarm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWeld(sorb2,larm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local handlex = CreateParta(mw2,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0,0,0)
	local handlexweld = CreateWeld(handlex,tors,handlex,0,-1.5,-1.05,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local valuaring = 10
	for i = 0, 49 do
		valuaring = valuaring + 10
		rn = CreateParta(mw2,0,0,"Neon",halocolor)
		CreateMesh(rn,"Brick",0.25,0.1,0.1)
		CreateWeld(rn,handlex,rn,0,1,0,math.rad(0),math.rad(0),math.rad(valuaring),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	end

	local refec = Instance.new("ParticleEmitter",handlex)
	refec.Texture = "rbxassetid://249270319"
	refec.LightEmission = 0.95
	refec.Color = ColorSequence.new(BrickColor.new("Really red").Color)
	refec.Rate = 50
	refec.Lifetime = NumberRange.new(0.5)
	refec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.5,0.75,0),NumberSequenceKeypoint.new(1,0.1,0)})
	refec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
	refec.Speed = NumberRange.new(0,2)
	refec.Drag = 5
	refec.LockedToPart = true
	refec.Rotation = NumberRange.new(-500,500)
	refec.VelocitySpread = 9000
	refec.RotSpeed = NumberRange.new(-500,500)

	local handle = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local handleweld = CreateWeld(handle,tors,handle,0,-1.5,-1.05,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	--"rbxassetid://31727915"
	--- Left wing.

	local MPASword = {}
	for _,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
		if v:IsA("Accessory") and v.Name:find("MeshPartAccessory") and v.Handle.Size == Vector3.new(4,4,1) then
			table.insert(MPASword,v)
		end
	end

	local lwing1 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing1weld = CreateWeld(lwing1,handle,lwing1,3,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local function align(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0,0,0) --Custom Positioning Values Here
		attachment0.Rotation = Vector3.new(0,0,-55) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = true
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = false
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end



	if MPASword[1] then

		local HatChoice = MPASword[1]

		align(HatChoice.Handle, lwing1)

		table.remove(MPASword,1)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing1,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing1,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25,0.25)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,lwing1,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,-0.25,-2)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,lwing1,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	tl1 = Instance.new('Trail',wed)
	tl1.Attachment0 = A1
	tl1.Attachment1 = A0
	tl1.Texture = "rbxassetid://2108945559"
	tl1.LightEmission = 1
	tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl1.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tl1.Lifetime = 0.6


	local lwing2 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing2weld = CreateWeld(lwing2,handle,lwing2,4,1,0,math.rad(10),math.rad(0),math.rad(25),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if MPASword[1] then

		local HatChoice = MPASword[1]

		align(HatChoice.Handle, lwing2)

		table.remove(MPASword,1)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing2,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing2,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25,0.25)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,lwing2,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,-0.25,-2)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,lwing2,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	tl2 = Instance.new('Trail',wed)
	tl2.Attachment0 = A1
	tl2.Attachment1 = A0
	tl2.Texture = "rbxassetid://2108945559"
	tl2.LightEmission = 1
	tl2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl2.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tl2.Lifetime = 0.6

	local lwing3 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing3weld = CreateWeld(lwing3,handle,lwing3,4.75,2,0,math.rad(15),math.rad(0),math.rad(37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if game.Players.LocalPlayer.Character:FindFirstChild("BladeMasterAccessory") then

		local HatChoice = game.Players.LocalPlayer.Character:FindFirstChild("ShadowBladeMasterAccessory")

		align(HatChoice.Handle, lwing3)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing3,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,lwing3,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25,0.25)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,lwing3,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,-0.25,-2)
	wed = CreateParta(mw1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,lwing3,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	tl3 = Instance.new('Trail',wed)
	tl3.Attachment0 = A1
	tl3.Attachment1 = A0
	tl3.Texture = "rbxassetid://2108945559"
	tl3.LightEmission = 1
	tl3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl3.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tl3.Lifetime = 0.6
	local lwing4 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing4weld = CreateWeld(lwing4,handle,lwing4,5.75,3,0,math.rad(20),math.rad(0),math.rad(50),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,lwing4,wed,0,0,0.25*2,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,lwing4,wed,0,0,0.25*2,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25*2,0.25*2)
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,3*2)
	CreateWeld(wed,lwing4,wed,0,-0.25*2,1.75*2,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,-0.25*2,-2*2)
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.0*25,3*2,0.5*2)
	CreateWeld(wed,lwing4,wed,0,-1.75*2,0.25*2,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	tl4 = Instance.new('Trail',wed)
	tl4.Attachment0 = A1
	tl4.Attachment1 = A0
	tl4.Texture = "rbxassetid://2108945559"
	tl4.LightEmission = 1
	tl4.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl4.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tl4.Lifetime = 0.6
	local lwing5 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing5weld = CreateWeld(lwing5,handle,lwing5,6.75,4,0,math.rad(25),math.rad(0),math.rad(62.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,lwing5,wed,0,0,0.25*2,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,lwing5,wed,0,0,0.25*2,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25*2,0.25*2)
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,3*2)
	CreateWeld(wed,lwing5,wed,0,-0.25*2,1.75*2,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,-0.25*2,-2*2)
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,3*2,0.5*2)
	CreateWeld(wed,lwing5,wed,0,-1.75*2,0.25*2,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	tl5 = Instance.new('Trail',wed)
	tl5.Attachment0 = A1
	tl5.Attachment1 = A0
	tl5.Texture = "rbxassetid://2108945559"
	tl5.LightEmission = 1
	tl5.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl5.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tl5.Lifetime = 0.6
	local lwing6 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing6weld = CreateWeld(lwing6,handle,lwing6,7.75,5,0,math.rad(30),math.rad(0),math.rad(75),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,lwing6,wed,0,0,0.25*2,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,lwing6,wed,0,0,0.25*2,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25*2,0.25*2)
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,3*2)
	CreateWeld(wed,lwing6,wed,0,-0.25*2,1.75*2,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,-0.25*2,-2*2)
	wed = CreateParta(extrawingmod1,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,3*2,0.5*2)
	CreateWeld(wed,lwing6,wed,0,-1.75*2,0.25*2,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	tl6 = Instance.new('Trail',wed)
	tl6.Attachment0 = A1
	tl6.Attachment1 = A0
	tl6.Texture = "rbxassetid://2108945559"
	tl6.LightEmission = 1
	tl6.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl6.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tl6.Lifetime = 0.6

	tl1.Enabled = false
	tl2.Enabled = false
	tl3.Enabled = false
	tl4.Enabled = false
	tl5.Enabled = false
	tl6.Enabled = false
	-- Right wing.

	local rwing1 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing1weld = CreateWeld(rwing1,handle,rwing1,-3,0,0,math.rad(5),math.rad(0),math.rad(-12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if MPASword[1] then

		local HatChoice = MPASword[1]

		align(HatChoice.Handle, rwing1)

		table.remove(MPASword,1)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing1,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25,0.25)
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing1,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,rwing1,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,rwing1,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,2,0.25)

	tr1 = Instance.new('Trail',wed)
	tr1.Attachment0 = A1
	tr1.Attachment1 = A0
	tr1.Texture = "rbxassetid://2108945559"
	tr1.LightEmission = 1
	tr1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr1.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tr1.Lifetime = 0.6

	local rwing2 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing2weld = CreateWeld(rwing2,handle,rwing2,-4,1,0,math.rad(10),math.rad(0),math.rad(-25),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if MPASword[1] then

		local HatChoice = MPASword[1]

		align(HatChoice.Handle, rwing2)

		table.remove(MPASword,1)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing2,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25,0.25)
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing2,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,rwing2,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,rwing2,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,2,0.25)

	tr2 = Instance.new('Trail',wed)
	tr2.Attachment0 = A1
	tr2.Attachment1 = A0
	tr2.Texture = "rbxassetid://2108945559"
	tr2.LightEmission = 1
	tr2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr2.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tr2.Lifetime = 0.6

	local rwing3 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing3weld = CreateWeld(rwing3,handle,rwing3,-4.75,2,0,math.rad(15),math.rad(0),math.rad(-37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if game.Players.LocalPlayer.Character:FindFirstChild("BladeMasterAccessory") then

		local HatChoice = game.Players.LocalPlayer.Character:FindFirstChild("BladeMasterAccessory")

		align(HatChoice.Handle, rwing3)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing3,wed,0,0,0.25,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25,0.25)
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,0.5)
	CreateWeld(wed,rwing3,wed,0,0,0.25,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,0.5,3)
	CreateWeld(wed,rwing3,wed,0,-0.25,1.75,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(mw2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05,3,0.5)
	CreateWeld(wed,rwing3,wed,0,-1.75,0.25,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,2,0.25)

	tr3 = Instance.new('Trail',wed)
	tr3.Attachment0 = A1
	tr3.Attachment1 = A0
	tr3.Texture = "rbxassetid://2108945559"
	tr3.LightEmission = 1
	tr3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr3.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tr3.Lifetime = 0.6


	local rwing4 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing4weld = CreateWeld(rwing4,handle,rwing4,-5.75,3,0,math.rad(20),math.rad(0),math.rad(-50),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,rwing4,wed,0,0,0.25*2,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25*2,0.25*2)
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,rwing4,wed,0,0,0.25*2,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,3*2)
	CreateWeld(wed,rwing4,wed,0,-0.25*2,1.75*2,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,3*2,0.5*2)
	CreateWeld(wed,rwing4,wed,0,-1.75*2,0.25*2,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,2,0.25)

	tr4 = Instance.new('Trail',wed)
	tr4.Attachment0 = A1
	tr4.Attachment1 = A0
	tr4.Texture = "rbxassetid://2108945559"
	tr4.LightEmission = 1
	tr4.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr4.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tr4.Lifetime = 0.6

	local rwing5 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing5weld = CreateWeld(rwing5,handle,rwing5,-6.75,4,0,math.rad(25),math.rad(0),math.rad(-62.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,rwing5,wed,0,0,0.25*2,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25*2,0.25*2)
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,rwing5,wed,0,0,0.25*2,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,3*2)
	CreateWeld(wed,rwing5,wed,0,-0.25*2,1.75*2,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,3*2,0.5*2)
	CreateWeld(wed,rwing5,wed,0,-1.75*2,0.25*2,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,2,0.25)

	tr5 = Instance.new('Trail',wed)
	tr5.Attachment0 = A1
	tr5.Attachment1 = A0
	tr5.Texture = "rbxassetid://2108945559"
	tr5.LightEmission = 1
	tr5.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr5.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tr5.Lifetime = 0.6

	local rwing6 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing6weld = CreateWeld(rwing6,handle,rwing6,-7.75,3,0,math.rad(30),math.rad(0),math.rad(-75),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,rwing6,wed,0,0,0.25*2,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A0 = Instance.new('Attachment',wed)
	A0.Position = vt(0,0.25*2,0.25*2)
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,0.5*2)
	CreateWeld(wed,rwing6,wed,0,0,0.25*2,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,0.5*2,3*2)
	CreateWeld(wed,rwing6,wed,0,-0.25*2,1.75*2,math.rad(0),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	wed = CreateParta(extrawingmod2,0,0,"Neon",halocolor)
	CreateMesh(wed,"Wedge",0.05*2,3*2,0.5*2)
	CreateWeld(wed,rwing6,wed,0,-1.75*2,0.25*2,math.rad(90),math.rad(90),math.rad(90),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	A1 = Instance.new('Attachment',wed)
	A1.Position = vt(0,2,0.25)

	tr6 = Instance.new('Trail',wed)
	tr6.Attachment0 = A1
	tr6.Attachment1 = A0
	tr6.Texture = "rbxassetid://2108945559"
	tr6.LightEmission = 1
	tr6.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr6.Color = ColorSequence.new(BrickColor.new('Really red').Color)
	tr6.Lifetime = 0.6

	tr4.Enabled = false
	tr5.Enabled = false
	tr6.Enabled = false
	---- HERES THE RING


--[[ran = CreateParta(m2,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.02,1.02,1.02)
CreateWeld(ran,larm,ran,0,0.15,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",0.9,0.9,1.025)
CreateWeld(ran,larm,ran,0,0.155,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.025,0.9,0.9)
CreateWeld(ran,larm,ran,0,0.155,-0.025,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))


gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
CreateMesh(gane,"Brick",1.0625,0.2,1.0625)
CreateWeld(gane,larm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateSpecialMesh(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
CreateWeld(star,larm,star,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
CreateSpecialMesh(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
CreateWeld(starl,larm,starl,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

--- second ring

ran = CreateParta(m2,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.02,1.02,1.02)
CreateWeld(ran,rarm,ran,0,0.15,0,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",0.9,0.9,1.025)
CreateWeld(ran,rarm,ran,0,0.155,0,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.025,0.9,0.9)
CreateWeld(ran,rarm,ran,0,0.155,-0.025,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
CreateMesh(gane,"Brick",1.0625,0.2,1.0625)
CreateWeld(gane,rarm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateSpecialMesh(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
CreateWeld(star,rarm,star,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
CreateSpecialMesh(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
CreateWeld(starl,rarm,starl,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))]]--



	for i, v in pairs(m:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Really black")
			v.Material = "Glass"
		end
	end
	for i, v in pairs(m2:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Crimson")
			v.Material = "Granite"
		end
	end
	for i, v in pairs(m3:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Really red")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(mw2:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Really red")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(mw1:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("Really red")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(extrawingmod1:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("White")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(extrawingmod2:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("White")
			v.Material = "Neon"
		end
	end
	------


	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part")({
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material
		})
		Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
		RemoveOutlines(Part)
		return Part
	end
	function CreateMesha(Mesh, Part, MeshType, MeshId, OffSet, Scale)
		local Msh = Create(Mesh)({
			Parent = Part,
			Offset = OffSet,
			Scale = Scale
		})
		if Mesh == "SpecialMesh" then
			Msh.MeshType = MeshType
			Msh.MeshId = MeshId
		end
		return Msh
	end
	function CreateWeld(Parent, Part0, Part1, C0, C1)
		local Weld = Create("Weld")({
			Parent = Parent,
			Part0 = Part0,
			Part1 = Part1,
			C0 = C0,
			C1 = C1
		})
		return Weld
	end

	Character=Player.Character["Dummy"]
	PlayerGui=Player.PlayerGui 
	Backpack=Player.Backpack 
	Torso=Character.Torso 
	Head=Character.Head 
	Humanoid=Character.Humanoid
	m=Instance.new('Model',Character)
	LeftArm=Character["Left Arm"] 
	LeftLeg=Character["Left Leg"] 
	RightArm=Character["Right Arm"] 
	RightLeg=Character["Right Leg"] 
	LS=Torso["Left Shoulder"] 
	LH=Torso["Left Hip"] 
	RS=Torso["Right Shoulder"] 
	RH=Torso["Right Hip"] 
	Face = Head.face
	Neck=Torso.Neck
	it=Instance.new
	attacktype=1
	vt=Vector3.new
	cf=CFrame.new
	euler=CFrame.fromEulerAnglesXYZ
	angles=CFrame.Angles
	cloaked=false
	necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
	LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
	RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
	RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
	RootPart=Character.HumanoidRootPart
	RootJoint=RootPart.RootJoint
	RootCF=euler(-1.57,0,3.14)
	attack = false 
	attackdebounce = false 
	deb=false
	equipped=true
	hand=false
	MMouse=nil
	combo=0
	mana=0
	trispeed=.2
	attackmode='none'
	local idle=0
	local Anim="Idle"
	local Effects={}
	local gun=false
	local shoot=false
	local sine = 0
	local change = 1


	function RecolorTextAndRename(name,col1,col2,font)
		modet.TextStrokeColor3 = col2
		modet.TextColor3 = col1
		modet.Font = font
		modet.Text = name
		techc.ImageColor3 = col2
		circl.ImageColor3 = col2
		circl2.ImageColor3 = col1
		imgl2.ImageColor3 = col1
		imgl2b.ImageColor3 = col2
		ned.Text = name
		ned.TextColor3 = col1
		ned.TextStrokeColor3 = col2
	end

	local disably = false

	local r = 255
	local g = 0
	local b = 0
	coroutine.resume(coroutine.create(function()
		while wait() do
			for i = 0, 254/5 do
				swait()
				g = g + 5
			end
			for i = 0, 254/5 do
				swait()
				r = r - 5
			end
			for i = 0, 254/5 do
				swait()
				b = b + 5
			end
			for i = 0, 254/5 do
				swait()
				g = g - 5
			end
			for i = 0, 254/5 do
				swait()
				r = r + 5
			end
			for i = 0, 254/5 do
				swait()
				b = b - 5
			end
		end
	end))

	function warnedpeople(text,represfont,color,color2)
		if disably ~= true then
			CFuncs["Sound"].Create("rbxassetid://534859368", char, 1.25,1)
			CFuncs["Sound"].Create("rbxassetid://963718869", char, 0.8,1)
			for i,v in pairs(game:GetService("Players"):GetPlayers()) do
				coroutine.resume(coroutine.create(function()
					if v.PlayerGui:FindFirstChild("Spinny")~= nil then
						v.PlayerGui:FindFirstChild("Spinny"):destroy()
					end
					local scrg = Instance.new("ScreenGui",v.PlayerGui)
					scrg.Name = "Spinny"
					local frm = Instance.new("Frame",scrg)
					frm.BackgroundTransparency = 0.25
					frm.BackgroundColor3 = color
					frm.BorderSizePixel = 0
					frm.Rotation = 45
					frm.Size = UDim2.new(3,0,0,100)
					frm.Position = UDim2.new(-4,0,0,0)
					local frm2 = frm:Clone()
					frm2.Parent = scrg
					frm2.BackgroundColor3 = color2
					frm2.Position = UDim2.new(-4.05,0,0,0)
					local imlb = Instance.new("ImageLabel",scrg)
					imlb.BackgroundTransparency = 1
					imlb.BackgroundColor3 = Color3.new(0,0,0)
					imlb.Image = "rbxassetid://2344851144"
					imlb.Size = UDim2.new(0,750,0,750)
					imlb.ImageColor3 = color2
					imlb.ImageTransparency = 0.25
					imlb.Position = UDim2.new(-2.5,0,-2.5,0)
					local imlb2 = imlb:Clone()
					imlb2.Image = "rbxassetid://2076458450"
					imlb2.Size = UDim2.new(1,0,1,0)
					imlb2.ImageColor3 = color
					imlb2.ImageTransparency = 0
					imlb2.Position = UDim2.new(0,0,0,0)
					local imlb3 = imlb:Clone()
					imlb3.Image = "rbxassetid://2312119891"
					imlb3.Size = UDim2.new(1,0,1,0)
					imlb3.ImageColor3 = color2
					imlb3.ImageTransparency = 0
					imlb3.Position = UDim2.new(0,0,0,0)
					local imlb4 = imlb:Clone()
					imlb4.Image = "rbxassetid://2092248396"
					imlb4.Size = UDim2.new(3,0,3,0)
					imlb3.ImageColor3 = color
					imlb4.ImageTransparency = 0
					imlb4.Position = UDim2.new(-1,0,-1,0)
					local imlb5 = imlb:Clone()
					imlb5.Image = "rbxassetid://2344870656"
					imlb5.Size = UDim2.new(10,0,10,0)
					imlb5.ImageColor3 = color2
					imlb5.ImageTransparency = 0
					imlb5.Position = UDim2.new(-4.5,0,-4.5,0)
					imlb2.Parent = imlb
					imlb3.Parent = imlb
					imlb4.Parent = imlb
					imlb5.Parent = imlb
					local txtlb2 = Instance.new("TextLabel",imlb)
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if Error == false then
								txtlb2.Text = text
							elseif Error == true then
								txtlb2.Text = est[math.random(1,17)]
							end
						end
					end))
					txtlb2.Font = represfont
					txtlb2.TextColor3 = color
					txtlb2.TextStrokeTransparency = 0
					txtlb2.BackgroundTransparency = 1
					txtlb2.TextStrokeColor3 = color2
					txtlb2.TextScaled = true
					txtlb2.Size = UDim2.new(1,0,1,0)
					txtlb2.Position = UDim2.new(0,0,0,0)
					local fvalen = 0.55
					local fval = -0.49
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if unstablemode == true then
								imlb.ImageColor3 = Color3.new(math.random(0.5,1),0,0)
								frm.BackgroundColor3 = Color3.new(math.random(0.5,1),0,0)
								frm2.BackgroundColor3 = Color3.new(math.random(0.5,1),0,0)
								imlb4.ImageColor3 = Color3.new(math.random(0.5,1),0,0)
								txtlb2.TextStrokeColor3 = Color3.new(math.random(0.5,1),0,0)
								txtlb2.TextColor3 = Color3.new(1,1,1)
								imlb.ImageColor3 = Color3.new(math.random(0.5,1),0,0)
								imlb3.ImageColor3 = Color3.new(math.random(0.5,1),0,0)
								imgl2b.ImageColor3 = Color3.new(math.random(0.5,1),0,0)
								frm.BackgroundColor3 = Color3.new(math.random(0.5,1),0,0)
								frm2.BackgroundColor3 = Color3.new(math.random(0.5,1),0,0)
								if math.random(1,12) == 1 then
									imlb.ImageColor3 = Color3.new(0,0,0)
									frm.BackgroundColor3 = Color3.new(0,0,0)
									frm2.BackgroundColor3 = Color3.new(0,0,0)
									txtlb2.TextStrokeColor3 = Color3.new(0,0,0)
									txtlb2.TextColor3 = Color3.new(math.random(0.2,1),0,0)
									imlb4.ImageColor3 = Color3.new(0,0,0)
									imlb.ImageColor3 = Color3.new(0,0,0)
									imlb3.ImageColor3 = Color3.new(0,0,0)
									imgl2b.ImageColor3 = Color3.new(0,0,0)
									frm.BackgroundColor3 = Color3.new(0,0,0)
									frm2.BackgroundColor3 = Color3.new(0,0,0)
								end
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if rainbowmode == true then
								imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.TextStrokeColor3 = Color3.new(r/255,g/255,b/255)
								txtlb2.TextColor3 = Color3.new(r/255,g/255,b/255)
								imlb.ImageColor3 = Color3.new(r/255,g/255,b/255)
								frm.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
								frm2.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
								txtlb2.TextStrokeColor3 = Color3.new(1,1,1)
								txtlb2.TextColor3 = Color3.new(r/255,g/255,b/255)
								imlb.ImageColor3 = Color3.new(r/255,g/255,b/255)
								imlb3.ImageColor3 = Color3.new(r/255,g/255,b/255)
								imgl2b.ImageColor3 = Color3.new(r/255,g/255,b/255)
								frm.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
								frm2.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if Error == true then
								imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.TextStrokeColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								txtlb2.TextColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imlb.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imlb2.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imlb3.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imlb4.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imlb5.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imgl2b.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								frm.BackgroundColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								frm2.BackgroundColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								text = est[math.random(1,17)]
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if CRAZED == true then
								txtlb2.Rotation = math.random(-1,1)
								imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.TextStrokeColor3 = Color3.new(0,0,math.random(0.1,1))
								txtlb2.TextColor3 = Color3.new(0,0,math.random(0,0.2))
								imlb.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								imlb2.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								imlb3.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								imlb4.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								imlb5.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								imgl2b.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								frm.BackgroundColor3 = Color3.new(0,0,math.random(0.1,1))
								frm2.BackgroundColor3 = Color3.new(0,0,math.random(0.1,1))
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if chaosmode == true then
								txtlb2.Rotation = math.random(-1,1)
								imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								imlb.ImageColor3 = BrickColor.random().Color
								txtlb2.TextStrokeColor3 = BrickColor.random().Color
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if scrg.Parent ~= nil then
								fvalen = fvalen - 0.0001
							elseif scrg.Parent == nil then
								break
							end
						end
					end))
					local flol = -5
					local flil = 1.6
					coroutine.resume(coroutine.create(function()
						for i = 0, 49 do
							swait()
							flol = flol + 0.125
							flil = flil - 0.1
							frm.Size = frm.Size + UDim2.new(0.1,0,0,0)
							frm.Rotation = frm.Rotation - 0.25
							frm2.Size = frm2.Size + UDim2.new(0.1,0,0,0)
							frm2.Rotation = frm.Rotation + 0.325
							imlb3.Rotation = imlb3.Rotation - 10
							imlb2.Rotation = imlb.Rotation + 7.5
							imlb.Rotation = imlb.Rotation + 5
							if Error == false then
								txtlb2.Rotation = txtlb2.Rotation - 5.125
							elseif Error == true then
								txtlb2.Rotation = txtlb2.Rotation - 5.125 + math.random(-6,6)
							end
							imlb.Position = imlb.Position + UDim2.new(0.05125,0,0.04775,0)
						end
						for i = 0, 99 do
							swait()
							fval = fval + 0.05
							flol = flol + 0.005
							frm.Size = frm.Size + UDim2.new(0.005,0,0,0)
							frm.Rotation = frm.Rotation - 0.075
							frm2.Size = frm2.Size + UDim2.new(0.005,0,0,0)
							frm2.Rotation = frm2.Rotation + 0.125
							imlb3.Rotation = imlb3.Rotation - 2
							imlb2.Rotation = imlb.Rotation + 1.5
							imlb.Rotation = imlb.Rotation + 1
							if Error == false then
								txtlb2.Rotation = txtlb2.Rotation - 1.125
							elseif Error == true then
								txtlb2.Rotation = txtlb2.Rotation - 1.125 + math.random(-6,6)
							end
							imlb.Position = imlb.Position + UDim2.new(0.0015,0,0.00075,0)
						end
						local valinc = 0
						local vinc2 = 1
						for i = 0, 99 do
							swait()
							vinc2 = vinc2 + 0.25
							valinc = valinc + 0.0001
							flol = flol + valinc
							flil = flil + valinc
							txtlb2.Rotation = txtlb2.Rotation - 1.125*vinc2
							imlb3.Rotation = imlb3.Rotation - 2*vinc2
							imlb.Rotation = imlb.Rotation + 1*vinc2
							imlb.Position = imlb.Position + UDim2.new(0.0015*vinc2,0,0.0005*vinc2,0)
							frm.Size = frm.Size + UDim2.new(0.005*vinc2,0,0,0)
							frm.Rotation = frm.Rotation + 0.1*vinc2
							frm2.Size = frm2.Size + UDim2.new(0.005*vinc2,0,0,0)
							frm2.Rotation = frm2.Rotation + 0.225*vinc2
							frm2.BackgroundTransparency = frm2.BackgroundTransparency + 0.0075
							frm.BackgroundTransparency = frm.BackgroundTransparency + 0.0075
							imlb.ImageTransparency = imlb.ImageTransparency + 0.005
							imlb2.ImageTransparency = imlb2.ImageTransparency + 0.01
							imlb3.ImageTransparency = imlb3.ImageTransparency + 0.01
							imlb4.ImageTransparency = imlb4.ImageTransparency + 0.01
							imlb5.ImageTransparency = imlb4.ImageTransparency + 0.01
							txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
							txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
						end
						scrg:Destroy()
					end))
				end))
			end
		end
	end

	function TheoriesMSGfunc(text,color,C3)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("Dialog")~= nil then
					v.PlayerGui:FindFirstChild("Dialog"):destroy()
				end
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
				scrg.Name = "Dialog"
				local txtlb = Instance.new("TextLabel",scrg)
				txtlb.Text = ""
				txtlb.Font = "Bodoni"
				txtlb.TextColor3 = Color3.new(0,0,0)
				txtlb.TextStrokeTransparency = 1
				txtlb.BackgroundTransparency = 1
				txtlb.BackgroundColor3 = color
				txtlb.TextStrokeColor3 = C3
				txtlb.TextColor3 = color
				txtlb.TextScaled = true
				txtlb.Size = UDim2.new(1,0,1,0)
				txtlb.TextXAlignment = "Left"
				txtlb.Position = UDim2.new(0,0,6.75 + 1,0)
				local txtlb2 = Instance.new("TextLabel",scrg)
				txtlb2.Text = ""
				txtlb2.Font = "Bodoni"
				txtlb2.TextColor3 = Color3.new(0,0,0)
				txtlb2.TextStrokeTransparency = 0
				txtlb2.BackgroundTransparency = 0.96
				txtlb2.BackgroundColor3 = C3
				txtlb2.TextStrokeColor3 = color
				txtlb2.TextScaled = true
				txtlb2.Size = UDim2.new(0, 999999, 0, 999)
				txtlb2.TextXAlignment = "Center"
				txtlb2.Position = UDim2.new(0,0,0,0)
				local Iml = Instance.new("ImageLabel",scrg)
				Iml.BackgroundTransparency = 1
				Iml.BorderSizePixel = 0
				Iml.ImageTransparency = 0
				Iml.ImageColor3 = C3
				Iml.Position = UDim2.new(0,0,0.75 + 1,0)
				Iml.Size = UDim2.new(0, 638.82, 0, 591.5)
				Iml.Image = "rbxassetid://0"
				local Iml1 = Instance.new("ImageLabel",scrg)
				Iml1.BackgroundTransparency = 1
				Iml1.BorderSizePixel = 0
				Iml1.ImageTransparency = 0
				Iml1.ImageColor3 = C3
				Iml1.Position = UDim2.new(0,0,0.75 + 1,0)
				Iml1.Size = UDim2.new(0, 638.82, 0, 591.5)
				Iml1.Image = "rbxassetid://2312119891"
				local Iml2 = Instance.new("ImageLabel",scrg)
				Iml2.BackgroundTransparency = 1
				Iml2.BorderSizePixel = 0
				Iml2.ImageTransparency = 0
				Iml2.ImageColor3 = color
				Iml2.Position = UDim2.new(0,0,0.75 + 1,0)
				Iml2.Size = UDim2.new(0, 638.82, 0, 591.5)
				Iml2.Image = "rbxassetid://2312119891"
				local txtlb = Instance.new("TextLabel",Iml)
				txtlb.Text = text
				txtlb.Font = "SciFi"
				txtlb.TextColor3 = color
				txtlb.TextStrokeTransparency = 0
				txtlb.BackgroundTransparency = 1
				txtlb.TextStrokeColor3 = color
				txtlb.TextScaled = true
				txtlb.Size = UDim2.new(1,0,1,0)
				txtlb.Position = UDim2.new(0,0,6.75 + 1,0)
				local fvalen = 0.4
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if scrg.Parent ~= nil then
							fvalen = fvalen - 0.0001
						elseif scrg.Parent == nil then
							break
						end
					end
				end))
				local flol = -0.625
				local flil = -0.935
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						Iml1.Rotation = Iml1.Rotation + 2.5
						Iml2.Rotation = Iml2.Rotation - 2.5
					end
				end))
				coroutine.resume(coroutine.create(function()
					for i = 0, 36 do
						swait()
						fval = fval + 0.0125
						flol = flol + 0.025
						flil = flil + 0.025
						txtlb.Text = text
						txtlb2.BackgroundTransparency = txtlb2.BackgroundTransparency - 0.008
						txtlb.Position = UDim2.new(flil,0,0,0)
						Iml.Position = UDim2.new(flol,0,-0.05,0)
						Iml1.Position = UDim2.new(flol,0,-0.05,0)
						Iml2.Position = UDim2.new(flol,0,-0.05,0)
					end
					coroutine.resume(coroutine.create(function()
						for i = 0, 99 do
							swait()
							fval = fval + 0.00001
							flol = flol + 0.0001
							flil = flil + 0.0001
							txtlb.Text = text
							txtlb.Position = UDim2.new(flil,0,0,0)
							Iml1.Position = UDim2.new(flol,0,-0.05,0)
							Iml1.Position = UDim2.new(flol,0,-0.05,0)
							Iml2.Position = UDim2.new(flol,0,-0.05,0)
						end
					end))
					wait(1.6)
					local valinc = 0
					for i = 0, 99 do
						swait()
						valinc = valinc + 0.0001
						flol = flol + valinc
						flil = flil + valinc
						Iml1.Rotation = Iml1.Rotation - valinc*50
						Iml.Rotation = Iml1.Rotation - valinc*2
						Iml2.Rotation = Iml2.Rotation - valinc*50
						Iml.Position = UDim2.new(flol,0,0,0)
						Iml1.Position = UDim2.new(flol,0,-0.05,0)
						Iml2.Position = UDim2.new(flol,0,-0.05,0)
						txtlb.TextStrokeTransparency = txtlb.TextStrokeTransparency + 0.01
						txtlb2.BackgroundTransparency = txtlb2.BackgroundTransparency + 0.006
						txtlb.TextTransparency = txtlb.TextTransparency + 0.01
						Iml.ImageTransparency = Iml1.ImageTransparency + 0.01
						Iml1.ImageTransparency = Iml1.ImageTransparency + 0.01
						Iml2.ImageTransparency = Iml2.ImageTransparency + 0.01
						txtlb.BackgroundTransparency = txtlb.BackgroundTransparency + 0.0025
					end
					scrg:Destroy()
				end))
			end))
		end
	end

	function IdolsWarn(text,represfont,color,color2)
		if disably ~= true then
			CFuncs["Sound"].Create("rbxassetid://534859368", char, 1.25,1)
			CFuncs["Sound"].Create("rbxassetid://963718869", char, 0.8,1)
			for i,v in pairs(game:GetService("Players"):GetPlayers()) do
				coroutine.resume(coroutine.create(function()
					if v.PlayerGui:FindFirstChild("Spinny")~= nil then
						v.PlayerGui:FindFirstChild("Spinny"):destroy()
					end
					local scrg = Instance.new("ScreenGui",v.PlayerGui)
					scrg.Name = "Spinny"
					local frm = Instance.new("Frame",scrg)
					frm.BackgroundTransparency = 0.25
					frm.BackgroundColor3 = color
					frm.BorderSizePixel = 0
					frm.Rotation = 45
					frm.Size = UDim2.new(3,0,0,100)
					frm.Position = UDim2.new(-4,0,0,0)
					local frm2 = frm:Clone()
					frm2.Parent = scrg
					frm2.BackgroundColor3 = color2
					frm2.Position = UDim2.new(-4.05,0,0,0)
					local imlb = Instance.new("ImageLabel",scrg)
					imlb.BackgroundTransparency = 1
					imlb.BackgroundColor3 = color
					imlb.Image = "rbxassetid://787198541"
					imlb.Size = UDim2.new(0,750,0,750)
					imlb.ImageColor3 = color2
					imlb.ImageTransparency = 0.25
					imlb.Position = UDim2.new(-2.5,0,-2.5,0)
					local imlb2 = imlb:Clone()
					imlb2.Image = "rbxassetid://197468643"
					imlb2.Size = UDim2.new(1,0,1,0)
					imlb2.ImageTransparency = 0
					imlb2.Position = UDim2.new(0,0,0,0)
					local imlb3 = imlb:Clone()
					imlb3.Image = "rbxassetid://787191999"
					imlb3.Size = UDim2.new(1,0,1,0)
					imlb3.ImageColor3 = color2
					imlb3.ImageTransparency = 0
					imlb3.Position = UDim2.new(0,0,0,0)
					local imlb4 = imlb:Clone()
					imlb4.Image = "rbxassetid://2092248396"
					imlb4.Size = UDim2.new(3,0,3,0)
					imlb3.ImageColor3 = color
					imlb4.ImageTransparency = 0
					imlb4.Position = UDim2.new(-1,0,-1,0)
					local imlb5 = imlb:Clone()
					imlb5.Image = "rbxassetid://2344870656"
					imlb5.Size = UDim2.new(10,0,10,0)
					imlb5.ImageColor3 = color2
					imlb5.ImageTransparency = 0
					imlb5.Position = UDim2.new(-4.5,0,-4.5,0)
					imlb2.Parent = imlb
					imlb3.Parent = imlb
					imlb4.Parent = imlb
					imlb5.Parent = imlb
					local txtlb2 = Instance.new("TextLabel",imlb)
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if Error == false then
								txtlb2.Text = text
							elseif Error == true then
								txtlb2.Text = est[math.random(1,17)]
							end
						end
					end))
					txtlb2.Font = represfont
					txtlb2.TextColor3 = color
					txtlb2.TextStrokeTransparency = 0
					txtlb2.BackgroundTransparency = 1
					txtlb2.TextStrokeColor3 = color2
					txtlb2.TextScaled = true
					txtlb2.Size = UDim2.new(1,0,1,0)
					txtlb2.Position = UDim2.new(0,0,0,0)
					local fvalen = 0.55
					local fval = -0.49
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if rainbowmode == true then
								imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.TextStrokeColor3 = Color3.new(r/255,g/255,b/255)
								txtlb2.TextColor3 = Color3.new(r/255,g/255,b/255)
								imlb.ImageColor3 = Color3.new(r/255,g/255,b/255)
								frm.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
								frm2.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
								txtlb2.TextStrokeColor3 = Color3.new(1,1,1)
								txtlb2.TextColor3 = Color3.new(r/255,g/255,b/255)
								imlb.ImageColor3 = Color3.new(r/255,g/255,b/255)
								imlb3.ImageColor3 = Color3.new(r/255,g/255,b/255)
								imgl2b.ImageColor3 = Color3.new(r/255,g/255,b/255)
								frm.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
								frm2.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if Error == true then
								imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.TextStrokeColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								txtlb2.TextColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imlb.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imlb2.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imlb3.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imlb4.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imlb5.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								imgl2b.ImageColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								frm.BackgroundColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								frm2.BackgroundColor3 = Color3.new(math.random(0,1),math.random(0,1),math.random(0,1))
								text = est[math.random(1,17)]
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if CRAZED == true then
								txtlb2.Rotation = math.random(-1,1)
								imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.TextStrokeColor3 = Color3.new(0,0,math.random(0.1,1))
								txtlb2.TextColor3 = Color3.new(0,0,math.random(0,0.2))
								imlb.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								imlb2.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								imlb3.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								imlb4.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								imlb5.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								imgl2b.ImageColor3 = Color3.new(0,0,math.random(0.1,1))
								frm.BackgroundColor3 = Color3.new(0,0,math.random(0.1,1))
								frm2.BackgroundColor3 = Color3.new(0,0,math.random(0.1,1))
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if chaosmode == true then
								txtlb2.Rotation = math.random(-1,1)
								imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								imlb.ImageColor3 = BrickColor.random().Color
								txtlb2.TextStrokeColor3 = BrickColor.random().Color
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if scrg.Parent ~= nil then
								fvalen = fvalen - 0.0001
							elseif scrg.Parent == nil then
								break
							end
						end
					end))
					local flol = -5
					local flil = 1.6
					coroutine.resume(coroutine.create(function()
						for i = 0, 49 do
							swait()
							flol = flol + 0.125
							flil = flil - 0.1
							frm.Size = frm.Size + UDim2.new(0.1,0,0,0)
							frm.Rotation = frm.Rotation - 0.25
							frm2.Size = frm2.Size + UDim2.new(0.1,0,0,0)
							frm2.Rotation = frm.Rotation + 0.325
							imlb3.Rotation = imlb3.Rotation - 10
							imlb2.Rotation = imlb.Rotation + 7.5
							imlb.Rotation = imlb.Rotation + 5
							if Error == false then
								txtlb2.Rotation = txtlb2.Rotation - 5.125
							elseif Error == true then
								txtlb2.Rotation = txtlb2.Rotation - 5.125 + math.random(-6,6)
							end
							imlb.Position = imlb.Position + UDim2.new(0.05125,0,0.04775,0)
						end
						for i = 0, 99 do
							swait()
							fval = fval + 0.05
							flol = flol + 0.005
							frm.Size = frm.Size + UDim2.new(0.005,0,0,0)
							frm.Rotation = frm.Rotation - 0.075
							frm2.Size = frm2.Size + UDim2.new(0.005,0,0,0)
							frm2.Rotation = frm2.Rotation + 0.125
							imlb3.Rotation = imlb3.Rotation - 2
							imlb2.Rotation = imlb.Rotation + 1.5
							imlb.Rotation = imlb.Rotation + 1
							if Error == false then
								txtlb2.Rotation = txtlb2.Rotation - 1.125
							elseif Error == true then
								txtlb2.Rotation = txtlb2.Rotation - 1.125 + math.random(-6,6)
							end
							imlb.Position = imlb.Position + UDim2.new(0.0015,0,0.00075,0)
						end
						local valinc = 0
						local vinc2 = 1
						for i = 0, 99 do
							swait()
							vinc2 = vinc2 + 0.25
							valinc = valinc + 0.0001
							flol = flol + valinc
							flil = flil + valinc
							txtlb2.Rotation = txtlb2.Rotation - 1.125*vinc2
							imlb3.Rotation = imlb3.Rotation - 2*vinc2
							imlb.Rotation = imlb.Rotation + 1*vinc2
							imlb.Position = imlb.Position + UDim2.new(0.0015*vinc2,0,0.0005*vinc2,0)
							frm.Size = frm.Size + UDim2.new(0.005*vinc2,0,0,0)
							frm.Rotation = frm.Rotation + 0.1*vinc2
							frm2.Size = frm2.Size + UDim2.new(0.005*vinc2,0,0,0)
							frm2.Rotation = frm2.Rotation + 0.225*vinc2
							frm2.BackgroundTransparency = frm2.BackgroundTransparency + 0.0075
							frm.BackgroundTransparency = frm.BackgroundTransparency + 0.0075
							imlb.ImageTransparency = imlb.ImageTransparency + 0.005
							imlb2.ImageTransparency = imlb2.ImageTransparency + 0.01
							imlb3.ImageTransparency = imlb3.ImageTransparency + 0.01
							imlb4.ImageTransparency = imlb4.ImageTransparency + 0.01
							imlb5.ImageTransparency = imlb4.ImageTransparency + 0.01
							txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
							txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
						end
						scrg:Destroy()
					end))
				end))
			end
		end
	end


	--save shoulders 
	RSH, LSH=nil, nil 
	--welds 
	RW, LW=Instance.new("Weld"), Instance.new("Weld") 
	RW.Name="Right Shoulder" LW.Name="Left Shoulder"
	LH=Torso["Left Hip"]
	RH=Torso["Right Hip"]
	TorsoColor=Torso.BrickColor
	function NoOutline(Part)
		Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
	end
	ch=Character
	RSH=ch.Torso["Right Shoulder"] 
	LSH=ch.Torso["Left Shoulder"] 
	-- 
	RSH.Parent=nil 
	LSH.Parent=nil 
	-- 
	RW.Name="Right Shoulder"
	RW.Part0=ch.Torso 
	RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
	RW.C1=cf(0, 0.5, 0) 
	RW.Part1=ch["Right Arm"] 
	RW.Parent=ch.Torso 
	-- 
	LW.Name="Left Shoulder"
	LW.Part0=ch.Torso 
	LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
	LW.C1=cf(0, 0.5, 0) 
	LW.Part1=ch["Left Arm"] 
	LW.Parent=ch.Torso 

	local Stats=Instance.new("BoolValue")
	Stats.Name="Stats"
	Stats.Parent=Character
	local Atk=Instance.new("NumberValue")
	Atk.Name="Damage"
	Atk.Parent=Stats
	Atk.Value=1
	local Def=Instance.new("NumberValue")
	Def.Name="Defense"
	Def.Parent=Stats
	Def.Value=1
	local Speed=Instance.new("NumberValue")
	Speed.Name="Speed"
	Speed.Parent=Stats
	Speed.Value=1
	local Mvmt=Instance.new("NumberValue")
	Mvmt.Name="Movement"
	Mvmt.Parent=Stats
	Mvmt.Value=1

	local donum=0


	function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
		local fp=it("Part")
		fp.formFactor=formfactor 
		fp.Parent=parent
		fp.Reflectance=reflectance
		fp.Transparency=transparency
		fp.CanCollide=false 
		fp.Locked=true
		fp.BrickColor=brickcolor
		fp.Name=name
		fp.Size=size
		fp.Position=Torso.Position 
		NoOutline(fp)
		fp.Material="SmoothPlastic"
		fp:BreakJoints()
		return fp 
	end 

	function mesh(Mesh,part,meshtype,meshid,offset,scale)
		local mesh=it(Mesh) 
		mesh.Parent=part
		if Mesh=="SpecialMesh" then
			mesh.MeshType=meshtype
			if meshid~="nil" then
				mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
			end
		end
		mesh.Offset=offset
		mesh.Scale=scale
		return mesh
	end

	function weld(parent,part0,part1,c0)
		local weld=it("Weld") 
		weld.Parent=parent
		weld.Part0=part0 
		weld.Part1=part1 
		weld.C0=c0
		return weld
	end

	local Color1=Torso.BrickColor

	local bodvel=Instance.new("BodyVelocity")
	local bg=Instance.new("BodyGyro")

	--------- SazEreno's Artificial HB --------------
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")
	Frame_Speed = 1 / 60
	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	------------------
	function swait(num)
		if num == 0 or num == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, num do
				ArtificialHB.Event:wait()
			end
		end
	end
	-------- RAINBOW LEAVE IT TO ME


	so = function(id,par,vol,pit) 
		coroutine.resume(coroutine.create(function()
			local sou = Instance.new("Sound",par or workspace)
			sou.Volume=vol
			sou.Pitch=pit or 1
			sou.SoundId=id
			swait() 
			sou:play() 
			game:GetService("Debris"):AddItem(sou,6)
		end))
	end

	function clerp(a,b,t) 
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)} 
		local ax, ay, az = a.x, a.y, a.z 
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1-t
		return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
	end 

	function aclerp(startCF,endCF,alpha)
		return startCF:lerp(endCF, alpha)
	end

	function QuaternionFromCFrame(cf) 
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
		local trace = m00 + m11 + m22 
		if trace > 0 then 
			local s = math.sqrt(1 + trace) 
			local recip = 0.5/s 
			return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
		else 
			local i = 0 
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then 
				i = 2 
			end 
			if i == 0 then 
				local s = math.sqrt(m00-m11-m22+1) 
				local recip = 0.5/s 
				return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
			elseif i == 1 then 
				local s = math.sqrt(m11-m22-m00+1) 
				local recip = 0.5/s 
				return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
			elseif i == 2 then 
				local s = math.sqrt(m22-m00-m11+1) 
				local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
			end 
		end 
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w) 
		local xs, ys, zs = x + x, y + y, z + z 
		local wx, wy, wz = w*xs, w*ys, w*zs 
		local xx = x*xs 
		local xy = x*ys 
		local xz = x*zs 
		local yy = y*ys 
		local yz = y*zs 
		local zz = z*zs 
		return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
	end

	function QuaternionSlerp(a, b, t) 
		local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
		local startInterp, finishInterp; 
		if cosTheta >= 0.0001 then 
			if (1 - cosTheta) > 0.0001 then 
				local theta = math.acos(cosTheta) 
				local invSinTheta = 1/math.sin(theta) 
				startInterp = math.sin((1-t)*theta)*invSinTheta 
				finishInterp = math.sin(t*theta)*invSinTheta  
			else 
				startInterp = 1-t 
				finishInterp = t 
			end 
		else 
			if (1+cosTheta) > 0.0001 then 
				local theta = math.acos(-cosTheta) 
				local invSinTheta = 1/math.sin(theta) 
				startInterp = math.sin((t-1)*theta)*invSinTheta 
				finishInterp = math.sin(t*theta)*invSinTheta 
			else 
				startInterp = t-1 
				finishInterp = t 
			end 
		end 
		return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
	end

	local function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CFrame.new(at.x, at.y, at.z,
			right.x, top.x, back.x,
			right.y, top.y, back.y,
			right.z, top.z, back.z)
	end

	function Triangle(a, b, c)
		local edg1 = (c-a):Dot((b-a).unit)
		local edg2 = (a-b):Dot((c-b).unit)
		local edg3 = (b-c):Dot((a-c).unit)
		if edg1 <= (b-a).magnitude and edg1 >= 0 then
			a, b, c = a, b, c
		elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
			a, b, c = b, c, a
		elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
			a, b, c = c, a, b
		else
			assert(false, "unreachable")
		end

		local len1 = (c-a):Dot((b-a).unit)
		local len2 = (b-a).magnitude - len1
		local width = (a + (b-a).unit*len1 - c).magnitude

		local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)

		local list = {}

		if len1 > 0.01 then
			local w1 = Instance.new('WedgePart', m)
			game:GetService("Debris"):AddItem(w1,5)
			w1.Material = "SmoothPlastic"
			w1.FormFactor = 'Custom'
			w1.BrickColor = BrickColor.new("Really red")
			w1.Transparency = 0
			w1.Reflectance = 0
			w1.Material = "SmoothPlastic"
			w1.CanCollide = false
			local l1 = Instance.new("PointLight",w1)
			l1.Color = Color3.new(170,0,0)
			NoOutline(w1)
			local sz = Vector3.new(0.2, width, len1)
			w1.Size = sz
			local sp = Instance.new("SpecialMesh",w1)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
			w1:BreakJoints()
			w1.Anchored = true
			w1.Parent = workspace
			w1.Transparency = 0.7
			table.insert(Effects,{w1,"Disappear",.01})
			w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
			table.insert(list,w1)
		end

		if len2 > 0.01 then
			local w2 = Instance.new('WedgePart', m)
			game:GetService("Debris"):AddItem(w2,5)
			w2.Material = "SmoothPlastic"
			w2.FormFactor = 'Custom'
			w2.BrickColor = BrickColor.new("Really red")
			w2.Transparency = 0
			w2.Reflectance = 0
			w2.Material = "SmoothPlastic"
			w2.CanCollide = false
			local l2 = Instance.new("PointLight",w2)
			l2.Color = Color3.new(170,0,0)
			NoOutline(w2)
			local sz = Vector3.new(0.2, width, len2)
			w2.Size = sz
			local sp = Instance.new("SpecialMesh",w2)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
			w2:BreakJoints()
			w2.Anchored = true
			w2.Parent = workspace
			w2.Transparency = 0.7
			table.insert(Effects,{w2,"Disappear",.01})
			w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
			table.insert(list,w2)
		end
		return unpack(list)
	end


	function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)

	end
	function ShowDamage(Pos, Text, Time, Color)
		local Rate = 0.03333333333333333
		local Pos = Pos or Vector3.new(0, 0, 0)
		local Text = Text or ""
		local Time = Time or 2
		local Color = Color or Color3.new(1, 0, 1)
		local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
		EffectPart.Anchored = true
		local BillboardGui = Create("BillboardGui")({
			Size = UDim2.new(3, 0, 3, 0),
			Adornee = EffectPart,
			Parent = EffectPart
		})
		local TextLabel = Create("TextLabel")({
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			TextColor3 = Color,
			TextScaled = true,
			Font = Enum.Font.ArialBold,
			Parent = BillboardGui
		})
		game.Debris:AddItem(EffectPart, Time + 0.1)
		EffectPart.Parent = game:GetService("Workspace")
		delay(0, function()
			local Frames = Time / Rate
			for Frame = 1, Frames do
				wait(Rate)
				local Percent = Frame / Frames
				EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
				TextLabel.TextTransparency = Percent
			end
			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end)
	end
	function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChildOfClass("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Head")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
					end
				end
			end
		end
	end

	function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChild("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Torso")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
						Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
					end
				end
			end
		end
	end

	function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
	end 

	function tbeam(col1,col2)
		local lookavec = 0 
		local mult = 1
		local elocacenter = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
		elocacenter.Anchored = true
		elocacenter.CFrame = root.CFrame
		local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca1.Anchored = true
		eloca1.CFrame = elocacenter.CFrame
		local at1 = Instance.new("Attachment",eloca1)
		at1.Position = vt(0,10,0)
		local at2 = Instance.new("Attachment",eloca1)
		at2.Position = vt(0,-10,0)
		local trl = Instance.new('Trail',eloca1)
		trl.Attachment0 = at1
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 1
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(col1.Color)
		trl.Lifetime = 4
		local eff = Instance.new("ParticleEmitter",eloca1)
		eff.Texture = "rbxassetid://2273224484"
		eff.LightEmission = 1
		eff.Color = ColorSequence.new(col1.Color)
		eff.Rate = 500000
		eff.Lifetime = NumberRange.new(0.5,1)
		eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
		eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
		eff.Speed = NumberRange.new(20,250)
		eff.Drag = 5
		eff.Rotation = NumberRange.new(-500,500)
		eff.VelocitySpread = 9000
		eff.RotSpeed = NumberRange.new(-50,50)
		local eloca2 = eloca1:Clone()
		eloca2.Parent = elocacenter
		local eloca3 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca3.Anchored = true
		eloca3.CFrame = elocacenter.CFrame
		local at1 = Instance.new("Attachment",eloca3)
		at1.Position = vt(0,10,0)
		local at2 = Instance.new("Attachment",eloca3)
		at2.Position = vt(0,-10,0)
		local trl = Instance.new('Trail',eloca3)
		trl.Attachment0 = at1
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 1
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(col2.Color)
		trl.Lifetime = 4
		local eff = Instance.new("ParticleEmitter",eloca3)
		eff.Texture = "rbxassetid://2273224484"
		eff.LightEmission = 1
		eff.Color = ColorSequence.new(col2.Color)
		eff.Rate = 500000
		eff.Lifetime = NumberRange.new(0.5,1)
		eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
		eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
		eff.Speed = NumberRange.new(20,250)
		eff.Drag = 5
		eff.Rotation = NumberRange.new(-500,500)
		eff.VelocitySpread = 9000
		eff.RotSpeed = NumberRange.new(-50,50)
		local eloca4 = eloca3:Clone()
		eloca4.Parent = elocacenter
		elocacenter.CFrame = root.CFrame
		sphere2(6,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(1,10000,1),0.9,7,0.9,col2)
		sphere2(5,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(1,10000,1),0.8,7,0.8,col1)
		sphere2(4,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(1,10000,1),0.6,7,0.6,col2)
		sphere2(3,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(1,10000,1),0.5,7,0.5,col1)
		local effx = Instance.new("ParticleEmitter",root)
		effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
		effx.LightEmission = 1
		effx.Color = ColorSequence.new(col1.Color)
		effx.Rate = 500000
		effx.Lifetime = NumberRange.new(0.25,0.75)
		effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
		effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
		effx.Speed = NumberRange.new(0,10)
		effx.Drag = 5
		effx.Rotation = NumberRange.new(-500,500)
		effx.VelocitySpread = 9000
		effx.RotSpeed = NumberRange.new(-50,50)
		local effx2 = Instance.new("ParticleEmitter",root)
		effx2.Texture = "rbxassetid://2273224484"
		effx2.LightEmission = 1
		effx2.Color = ColorSequence.new(col1.Color)
		effx2.Rate = 500000
		effx2.Lifetime = NumberRange.new(1,2)
		effx2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,200,0),NumberSequenceKeypoint.new(0.1,50,0),NumberSequenceKeypoint.new(0.8,25,0),NumberSequenceKeypoint.new(1,0,0)})
		effx2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
		effx2.Speed = NumberRange.new(50,1200)
		effx2.Drag = 5
		effx2.Rotation = NumberRange.new(-500,500)
		effx2.VelocitySpread = 9000
		effx2.RotSpeed = NumberRange.new(-50,50)
		local effx3 = effx2:Clone()
		effx3.Parent = root
		effx3.Color = ColorSequence.new(col2.Color)
		symbolizeBlink(root,0,144580273,col1.Color,20,0,0,0,root,true,-5,2)
		symbolizeBlink(root,0,144580273,col2.Color,25,0,0,0,root,true,-5,1)
		for i = 0, 1 do
			CFuncs["Sound"].Create("rbxassetid://763717897", root, 5, 1.25)
			CFuncs["Sound"].Create("rbxassetid://1192402877", root, 5,0.75)
			CFuncs["Sound"].Create("rbxassetid://1664711478", root, 2.5,1)
			CFuncs["Sound"].Create("rbxassetid://763718160", root, 5, 0.75)
		end
		coroutine.resume(coroutine.create(function()
			wait(0.05)
			effx.Enabled = false
			wait(0.1)
			effx2.Enabled = false
			effx3.Enabled = false
		end))
		coroutine.resume(coroutine.create(function()
			for i = 0, 9, 0.1 do
				swait()
				mult = mult + 0.5
				lookavec = lookavec + 0.1*mult
				elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/10),0)
				eloca1.CFrame = elocacenter.CFrame*CFrame.new(40+lookavec/5,-15+lookavec*2,0)
				eloca2.CFrame = elocacenter.CFrame*CFrame.new(-40-lookavec/5,-15+lookavec*2,0)
				eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,-15+lookavec*2,40+lookavec/5)
				eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,-15+lookavec*2,-40-lookavec/5)
			end
			for i,v in pairs(elocacenter:GetDescendants()) do
				if v:IsA("ParticleEmitter") then
					v.Enabled = false
				end
			end
			wait(6)
			effx:Destroy()
			effx2:Destroy()
			effx3:Destroy()
			elocacenter:Destroy()
		end))
	end

	function SkullEffect(brickcolor,cframe,x1,y1,z1,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=4770583",vt(0,0,0),vt(x1,y1,z1))
		--http://www.roblox.com/asset/?id=4770560
		game:GetService("Debris"):AddItem(prt,2)
		CF=prt.CFrame
		coroutine.resume(coroutine.create(function(Part,Mesh,TehCF) 
			for i=0,1,0.2 do
				wait()
				Part.CFrame=CF*cf(0,0,-0.4)
			end
			for i=0,1,delay do
				wait()
				--Part.CFrame=CF*cf((math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5)
				Mesh.Scale=Mesh.Scale
			end
			for i=0,1,0.1 do
				wait()
				Part.Transparency=i
			end
			Part.Parent=nil
		end),prt,msh,CF)
	end

	function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				swait()
				Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicSphere(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShock(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
		local prt=part(3,char,1,1,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		local dec = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
		local dec2 = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				dec.Transparency=i
				dec2.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockAlt(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockAltCircle(brickcolor,cframe,x1,z1,x3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0.1,0)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,-0.1,0)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,0,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockTrailAlt(brickcolor,cframe,x1,y1,z1,x3,y3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockTrailAlt2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlock2(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=false
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		local wld=weld(prt,prt,Parent,cframe)
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
			for i=0,1,delay do
				wait()
				Weld.C0=euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))*cframe
				--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,wld)
	end

	function MagicBlock3(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=false
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		local wld=weld(prt,prt,Parent,euler(0,0,0)*cf(0,0,0))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
			for i=0,1,delay do
				wait()
				Weld.C0=euler(i*20,0,0)
				--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,wld)
	end

	function MagicCircle2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("CylinderMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
				local prt2=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
				prt2.Anchored=true
				prt2.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				local msh2=mesh("SpecialMesh",prt2,"Sphere","",vt(0,0,0),vt(0.5,0.5,0.5))
				game:GetService("Debris"):AddItem(prt2,2)
				coroutine.resume(coroutine.create(function(Part,Mesh) 
					for i=0,1,0.1 do
						wait()
						Part.CFrame=Part.CFrame*cf(0,0.5,0)
					end
					Part.Parent=nil
				end),prt2,msh2)
			end
			for i=0,1,delay*2 do
				wait()
				Part.CFrame=Part.CFrame
				Mesh.Scale=vt((x1+x3)-(x1+x3)*i,(y1+y3)-(y1+y3)*i,(z1+z3)-(z1+z3)*i)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function BreakEffect(brickcolor,cframe,x1,y1,z1)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,CF,Numbb,randnumb) 
			CF=Part.CFrame
			Numbb=0
			randnumb=math.random()/10
			rand1=math.random()/10
			for i=0,1,rand1 do
				wait()
				CF=CF*cf(0,math.random()/2,0)
				--Part.CFrame=Part.CFrame*euler(0.5,0,0)*cf(0,1,0)
				Part.CFrame=CF*euler(Numbb,0,0)
				Part.Transparency=i
				Numbb=Numbb+randnumb
			end
			Part.Parent=nil
		end),prt,CF,Numbb,randnumb)
	end

	function MagicWaveThing(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=1051557",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame*euler(0,0.7,0)
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function WaveEffect(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=20329976",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame*cf(0,y3/2,0)
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function waveEff(bonuspeed,type,typeoftrans,pos,scale,value,value2,color)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		if typeoftrans == "In" then
			rng.Transparency = 1
		end
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "FileMesh"
		rngm.MeshId = "rbxassetid://20329976"
		rngm.Scale = scale
		local scaler2 = 1
		local scaler2b = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
		end
		local randomrot = math.random(1,2)
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
				end
				if randomrot == 1 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(5*bonuspeed/2),0)
				elseif randomrot == 2 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-5*bonuspeed/2),0)
				end
				if typeoftrans == "Out" then
					rng.Transparency = rng.Transparency + 0.01*bonuspeed
				elseif typeoftrans == "In" then
					rng.Transparency = rng.Transparency - 0.01*bonuspeed
				end
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function StravEffect(brickcolor,cframe,x,y,z,x1,y1,z1,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe*cf(x,y,z)
		msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://168892363",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,ex,why,zee) 
			local num=math.random()
			local num2=math.random(-3,2)+math.random()
			local numm=0
			for i=0,1,delay*2 do
				swait()
				Part.CFrame=cframe*euler(0,numm*num*10,0)*cf(ex,why,zee)*cf(-i*10,num2,0)
				Part.Transparency=i
				numm=numm+0.01
			end
			Part.Parent=nil
			Mesh.Parent=nil
		end),prt,msh,x,y,z)
	end

	function dmgstart(dmg,what)
		hitcon = what.Touched:connect(function(hit)
			local hum = hit.Parent:FindFirstChild("Humanoid")
			if hum and not hum:IsDescendantOf(Character) then
				--hum:TakeDamage(dmg)
			end
		end)
	end

	function dmgstop()
		hitcon:disconnect()
	end

	function Cloak()
		Face.Parent=nil
		cloaked=true
		for _,v in pairs(Torso.Parent:children()) do
			if v.className=="Part" and v.Name~="HumanoidRootPart" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.2 do
						wait()
						v.Transparency=i
					end
					v.Transparency=1
				end))
			end
			if v.className=="Hat" then
				hatp=v.Handle
				coroutine.resume(coroutine.create(function(derp) 
					for i=0,1,0.2 do
						wait()
						derp.Transparency=i
					end
					derp.Transparency=1
				end),hatp)
			end
		end
		for _,v in pairs(m:children()) do
			if v.className=="Part" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.2 do
						wait()
						v.Transparency=i
					end
					v.Transparency=1
				end))
			end
		end
	end

	function UnCloak()
		so("http://roblox.com/asset/?id=2767090",Torso,1,1.1) 
		Face.Parent=Head 
		cloaked=false
		for _,v in pairs(Torso.Parent:children()) do
			if v.className=="Part" and v.Name~="HumanoidRootPart" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.1 do
						wait()
						v.Transparency=v.Transparency-0.1
					end
					v.Transparency=0
				end))
			end
			if v.className=="Hat" then
				hatp=v.Handle
				coroutine.resume(coroutine.create(function(derp) 
					for i=0,1,0.1 do
						wait()
						derp.Transparency=derp.Transparency-0.1
					end
					derp.Transparency=0
				end),hatp)
			end
		end
		for _,v in pairs(m:children()) do
			if v.className=="Part" and v.Name~="hitbox" and v.Name~='tip' then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.1 do
						wait()
						v.Transparency=v.Transparency-0.1
					end
					v.Transparency=0
				end))
				v.Transparency=0
			end
		end
	end

	local origcolor = BrickColor.new("Pastel light blue")
	---- This section of explosions.

	----


	function ring(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
			end
			rng:Destroy()
		end))
	end


	function wave(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function wind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function groundwind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
			end
			rng:Destroy()
		end))
	end

	function CameraManager()
		if TwoD and not CamInterrupt then
			if Humanoid.Health > 0 then
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Scriptable"
				Humanoid.AutoRotate = false
				if Booleans.GyroUse then
					Directer.MaxTorque = Vec3(0, huge, 0)
				else
					Directer.MaxTorque = Vec3(0, 0, 0)
				end
				if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
					if Booleans.CamFollow then
						CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
						Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
					else
						CPart.Position = RootPart.Position
					end
				else
					local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
					CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
				end
				Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
			else
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Custom"
				Controller.Disabled = false
			end
		end
	end

	function ring(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
			end
			rng:Destroy()
		end))
	end


	function wave(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function sphere(bonuspeed,type,pos,scale,value,color)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = scale
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = scale
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		if ModeOfGlitch == 666666 then
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					rng.Material = "Glass"
				end
			end))
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function ragdoll(who)
		pcall(function()
			local ded = who
			local h1 = ded:FindFirstChild("Head")
			local t1 = ded:FindFirstChild("Torso") or ded:FindFirstChild("UpperTorso")
			if t1.Name == "UpperTorso" then
				r15r(ded)
				return ragdoll
			end
			local ff = ded:FindFirstChildOfClass("ForceField")
			if ff ~= nil then
				ff:Destroy()
			end
			local ra1 = ded:FindFirstChild("Right Arm")
			local la1 = ded:FindFirstChild("Left Arm")
			local rl1 = ded:FindFirstChild("Right Leg")
			local ll1 = ded:FindFirstChild("Left Leg")
			local hum1 = ded:FindFirstChildOfClass("Humanoid")
			local acc = ded:FindFirstChild("xdded")
			if acc == nil then 
				local ac = Instance.new("Glue",ded) ac.Name = "xdded"
				local rut1 = ded:FindFirstChild("HumanoidRootPart")
				hum1.PlatformStand = true
				if rut1 ~= nil then
					rut1.Parent = nil
				end
				pcall(function()
					for i,v in pairs(who:GetChildren()) do
						if v:IsA("Accessory") or v:IsA("Hat") then
							local gl = Instance.new("WeldConstraint",v.Handle)
							gl.Part0 = h1 gl.Part1 = v.Handle
						end
					end
					for i,v in pairs(who:GetChildren()) do
						if v:IsA("Script") or v:IsA("LocalScript") then
							if v.Name == "Health" then
								v.Parent = nil
							end
						end
					end
					for i,v in pairs(who:GetChildren()) do
						if v:IsA("BasePart") then
							v.Anchored = false
						end
						if v:IsA("Accessory") or v:IsA("Hat") then
							v.Handle.Anchored = false
						end
					end
				end)
				hum1.MaxHealth = 100
				hum1.Health = math.random(10,50)
				t1:BreakJoints()
				ra1:BreakJoints()
				la1:BreakJoints()
				rl1:BreakJoints()
				ll1:BreakJoints()
				--//Joints~//--
				--Neck--
				if h1 ~= nil then
					local neca = Instance.new("Glue",t1) neca.Part0 = t1 neca.Part1 = h1 neca.C0 = CFrame.new(0,t1.Size.y/2,0) neca.C1 = CFrame.new(0,-h1.Size.y/2,0) neca.Name = "yo"
					local ch = Instance.new("Part",t1) ch.Name = "yo" ch.Size = Vector3.new(h1.Size.x/2,h1.Size.y/2,h1.Size.z/2 + h1.Size.z/4) ch.TopSurface = "Smooth" ch.BottomSurface = "Smooth" ch.Transparency = 1
					local wh = Instance.new("Weld",ch) wh.Part0 = h1 wh.Part1 = ch
				end
				--Right Arm--
				if ra1 ~= nil then
					local rsa = Instance.new("Glue",t1) rsa.Part0 = t1 rsa.Part1 = ra1 rsa.C0 = CFrame.new(t1.Size.x/2 + t1.Size.x/4,t1.Size.y/4,0) rsa.C1 = CFrame.new(0,ra1.Size.y/4,0) rsa.Name = "yo"
					local cra = Instance.new("Part",t1) cra.Name = "yo" cra.Size = Vector3.new(ra1.Size.y/2 + ra1.Size.y/4,ra1.Size.y/2,ra1.Size.z) cra.TopSurface = "Smooth" cra.BottomSurface = "Smooth" cra.Transparency = 1
					local wra = Instance.new("Weld",cra) wra.Part0 = ra1 wra.Part1 = cra wra.C0 = CFrame.new(0,-ra1.Size.y/8,0) * CFrame.Angles(rad(0),rad(0),rad(90))
				end
				--Left Arm--
				if la1 ~= nil then
					local lsa = Instance.new("Glue",t1) lsa.Part0 = t1 lsa.Part1 = la1 lsa.C0 = CFrame.new(-t1.Size.x/2 - t1.Size.x/4,t1.Size.y/4,0) lsa.C1 = CFrame.new(0,la1.Size.y/4,0) lsa.Name = "yo"
					local cla = Instance.new("Part",t1) cla.Name = "yo" cla.Size = Vector3.new(la1.Size.y/2 + la1.Size.y/4,la1.Size.y/2,la1.Size.z) cla.TopSurface = "Smooth" cla.BottomSurface = "Smooth" cla.Transparency = 1
					local wla = Instance.new("Weld",cla) wla.Part0 = la1 wla.Part1 = cla wla.C0 = CFrame.new(0,-la1.Size.y/8,0) * CFrame.Angles(rad(0),rad(0),rad(90))
				end
				--Right Leg--
				if rl1 ~= nil then
					local rha = Instance.new("Glue",t1) rha.Part0 = t1 rha.Part1 = rl1 rha.C0 = CFrame.new(t1.Size.x/4,-t1.Size.y/2,0) rha.C1 = CFrame.new(0,rl1.Size.y/2,0) rha.Name = "yo"
					local crl = Instance.new("Part",t1) crl.Name = "yo" crl.Size = Vector3.new(rl1.Size.y/2 + rl1.Size.y/4,rl1.Size.y/2,rl1.Size.z) crl.TopSurface = "Smooth" crl.BottomSurface = "Smooth" crl.Transparency = 1
					local wrl = Instance.new("Weld",crl) wrl.Part0 = rl1 wrl.Part1 = crl wrl.C0 = CFrame.new(0,-rl1.Size.y/8,0) * CFrame.Angles(rad(0),rad(0),rad(90))
				end
				--Left Leg--
				if ll1 ~= nil then
					local lha = Instance.new("Glue",t1) lha.Part0 = t1 lha.Part1 = ll1 lha.C0 = CFrame.new(-t1.Size.x/4,-t1.Size.y/2,0) lha.C1 = CFrame.new(0,ll1.Size.y/2,0) lha.Name = "yo"
					local cll = Instance.new("Part",t1) cll.Name = "yo" cll.Size = Vector3.new(ll1.Size.y/2 + ll1.Size.y/4,ll1.Size.y/2,ll1.Size.z) cll.TopSurface = "Smooth" cll.BottomSurface = "Smooth" cll.Transparency = 1
					local wll = Instance.new("Weld",cll) wll.Part0 = ll1 wll.Part1 = cll wll.C0 = CFrame.new(0,-ll1.Size.y/8,0) * CFrame.Angles(rad(0),rad(0),rad(90))
				end
				--//End of Joints~//--
			end
		end)
	end
	function r15r(who)
		local ded = who
		local ac = ded:FindFirstChild("xdded")
		if ac == nil then
			Instance.new("Glue",ded).Name = "xdded"
			local h2 = ded:FindFirstChild("Head")
			local t2 = ded:FindFirstChild("UpperTorso")
			local lt2 = ded:FindFirstChild("LowerTorso")
			local rua2 = ded:FindFirstChild("RightUpperArm")
			local lua2 = ded:FindFirstChild("LeftUpperArm")
			local rla2 = ded:FindFirstChild("RightLowerArm")
			local lla2 = ded:FindFirstChild("LeftLowerArm")
			local rh2 = ded:FindFirstChild("RightHand")
			local lh2 = ded:FindFirstChild("LeftHand")
			local rul2 = ded:FindFirstChild("RightUpperLeg")
			local lul2 = ded:FindFirstChild("LeftUpperLeg")
			local rll2 = ded:FindFirstChild("RightLowerLeg")
			local lll2 = ded:FindFirstChild("LeftLowerLeg")
			local rf2 = ded:FindFirstChild("RightFoot")
			local lf2 = ded:FindFirstChild("LeftFoot")
			local rut1 = ded:FindFirstChild("HumanoidRootPart")
			if rut1 ~= nil then
				rut1:Destroy()
			end
			for i,v in pairs(who:GetChildren()) do
				if v:IsA("Script") or v:IsA("LocalScript") then
					if v.Name == "Health" then
						v.Parent = nil
					end
				end
			end
			local hum1 = ded:FindFirstChildOfClass("Humanoid")
			hum1.PlatformStand = true
			hum1.MaxHealth = 100
			hum1.Health = math.random(10,50)
			local trans = 1
			if h2 ~= nil then
				h2:BreakJoints()
				local nc = Instance.new("Glue",t2) nc.Name = "yo" nc.C0 = CFrame.new(0,t2.Size.y/2,0) nc.C1 = CFrame.new(0,-h2.Size.y/2,0) nc.Part0 = t2 nc.Part1 = h2
				local ncc = Instance.new("Part",t2) ncc.Name = "yo" ncc.Transparency = trans ncc.Size = Vector3.new(h2.Size.x/2 + h2.Size.x/4,h2.Size.y/2,h2.Size.z)
				local ncw = Instance.new("Weld",t2) ncw.Name = "yo" ncw.Part0 = h2 ncw.Part1 = ncc
			end
			for i,v in pairs(who:GetChildren()) do
				if v:IsA("BasePart") then
					v.Anchored = false
				end
				if v:IsA("Accessory") or v:IsA("Hat") then
					v.Handle.Anchored = false
					local aw = Instance.new("WeldConstraint",v) aw.Part0 = h2 aw.Part1 = v.Handle
				end
			end
			hum1.PlatformStand = true
			if lt2 ~= nil then
				lt2:BreakJoints()
				local tc = Instance.new("Glue",t2) tc.Name = "yo" tc.C0 = CFrame.new(0,-t2.Size.y/2,0) tc.C1 = CFrame.new(0,lt2.Size.y/2,0) tc.Part0 = t2 tc.Part1 = lt2
				local tcc = Instance.new("Part",t2) tcc.Name = "yo" tcc.Transparency = trans tcc.Size = Vector3.new(lt2.Size.x/2,lt2.Size.y/2,lt2.Size.z)
				local tcw = Instance.new("Weld",t2) tcw.Name = "yo" tcw.Part0 = lt2 tcw.Part1 = tcc
			end
			if rua2 ~= nil then
				rua2:BreakJoints()
				local ruac = Instance.new("Glue",t2) ruac.Name = "yo" ruac.C0 = CFrame.new(t2.Size.x/2 + t2.Size.y/4,t2.Size.y/4,0) ruac.C1 = CFrame.new(0,rua2.Size.y/4.6666,0) ruac.Part0 = t2 ruac.Part1 = rua2
				local ruacc = Instance.new("Part",t2) ruacc.Name = "yo" ruacc.Transparency = trans ruacc.Size = Vector3.new(rua2.Size.x/1.2,rua2.Size.y/4,rua2.Size.z/1.2)
				local ruacw = Instance.new("Weld",t2) ruacw.Name = "yo" ruacw.Part0 = rua2 ruacw.Part1 = ruacc ruacw.C0 = CFrame.new(0,rua2.Size.y/7,0)
			end
			if lua2 ~= nil then
				lua2:BreakJoints()
				local luac = Instance.new("Glue",t2) luac.Name = "yo" luac.C0 = CFrame.new(-t2.Size.x/2 + -t2.Size.y/4,t2.Size.y/4,0) luac.C1 = CFrame.new(0,lua2.Size.y/4.6666,0) luac.Part0 = t2 luac.Part1 = lua2
				local luacc = Instance.new("Part",t2) luacc.Name = "yo" luacc.Transparency = trans luacc.Size = Vector3.new(lua2.Size.x/1.2,lua2.Size.y/4,lua2.Size.z/1.2)
				local luacw = Instance.new("Weld",t2) luacw.Name = "yo" luacw.Part0 = lua2 luacw.Part1 = luacc luacw.C0 = CFrame.new(0,lua2.Size.y/7,0)
			end
			if rla2 ~= nil then
				rla2:BreakJoints()
				local rlac = Instance.new("Glue",t2) rlac.Name = "yo" rlac.C0 = CFrame.new(0,-rua2.Size.y/4.6666,0) rlac.C1 = CFrame.new(0,rla2.Size.y/8,0) rlac.Part0 = rua2 rlac.Part1 = rla2
				local rlacc = Instance.new("Part",t2) rlacc.Name = "yo" rlacc.Transparency = trans rlacc.Size = Vector3.new(rla2.Size.x/1.2,rla2.Size.y/4,rla2.Size.z/1.2)
				local rlacw = Instance.new("Weld",t2) rlacw.Name = "yo" rlacw.Part0 = rla2 rlacw.Part1 = rlacc rlacw.C0 = CFrame.new(0,-rla2.Size.y/7,0)
			end
			if lla2 ~= nil then
				lla2:BreakJoints()
				local llac = Instance.new("Glue",t2) llac.Name = "yo" llac.C0 = CFrame.new(0,-lua2.Size.y/4.6666,0) llac.C1 = CFrame.new(0,lla2.Size.y/8,0) llac.Part0 = lua2 llac.Part1 = lla2
				local llacc = Instance.new("Part",t2) llacc.Name = "yo" llacc.Transparency = trans llacc.Size = Vector3.new(lla2.Size.x/1.2,lla2.Size.y/4,lla2.Size.z/1.2)
				local llacw = Instance.new("Weld",t2) llacw.Name = "yo" llacw.Part0 = lla2 llacw.Part1 = llacc llacw.C0 = CFrame.new(0,-lla2.Size.y/7,0)
			end
			if rh2 ~= nil then
				rh2:BreakJoints()
				local rhc = Instance.new("Glue",t2) rhc.Name = "yo" rhc.C0 = CFrame.new(0,-rla2.Size.y/2,0) rhc.C1 = CFrame.new(0,rh2.Size.y/3,0) rhc.Part0 = rla2 rhc.Part1 = rh2
				local rhcc = Instance.new("Part",t2) rhcc.Name = "yo" rhcc.Transparency = trans rhcc.Size = Vector3.new(rh2.Size.x/1.2,rh2.Size.y,rh2.Size.z/1.2)
				local rhcw = Instance.new("Weld",t2) rhcw.Name = "yo" rhcw.Part0 = rh2 rhcw.Part1 = rhcc rhcw.C0 = CFrame.new(0,0,0)
			end
			if lh2 ~= nil then
				lh2:BreakJoints()
				local lhc = Instance.new("Glue",t2) lhc.Name = "yo" lhc.C0 = CFrame.new(0,-lla2.Size.y/2,0) lhc.C1 = CFrame.new(0,lh2.Size.y/3,0) lhc.Part0 = lla2 lhc.Part1 = lh2
				local lhcc = Instance.new("Part",t2) lhcc.Name = "yo" lhcc.Transparency = trans lhcc.Size = Vector3.new(lh2.Size.x/1.2,lh2.Size.y,lh2.Size.z/1.2)
				local lhcw = Instance.new("Weld",t2) lhcw.Name = "yo" lhcw.Part0 = lh2 lhcw.Part1 = lhcc lhcw.C0 = CFrame.new(0,0,0)
			end
			if rul2 ~= nil then
				rul2:BreakJoints()
				local rulc = Instance.new("Glue",t2) rulc.Name = "yo" rulc.C0 = CFrame.new(lt2.Size.x/4,-lt2.Size.y/2,0) rulc.C1 = CFrame.new(0,rul2.Size.y/3,0) rulc.Part0 = lt2 rulc.Part1 = rul2
				local rulcc = Instance.new("Part",t2) rulcc.Name = "yo" rulcc.Transparency = trans rulcc.Size = Vector3.new(rul2.Size.x/1.2,rul2.Size.y/4,rul2.Size.z/1.2)
				local rulcw = Instance.new("Weld",t2) rulcw.Name = "yo" rulcw.Part0 = rul2 rulcw.Part1 = rulcc rulcw.C0 = CFrame.new(0,rul2.Size.y/7,0)
			end
			if lul2 ~= nil then
				lul2:BreakJoints()
				local lulc = Instance.new("Glue",t2) lulc.Name = "yo" lulc.C0 = CFrame.new(-lt2.Size.x/4,-lt2.Size.y/2,0) lulc.C1 = CFrame.new(0,lul2.Size.y/3,0) lulc.Part0 = lt2 lulc.Part1 = lul2
				local lulcc = Instance.new("Part",t2) lulcc.Name = "yo" lulcc.Transparency = trans lulcc.Size = Vector3.new(lul2.Size.x/1.2,lul2.Size.y/4,lul2.Size.z/1.2)
				local lulcw = Instance.new("Weld",t2) lulcw.Name = "yo" lulcw.Part0 = lul2 lulcw.Part1 = lulcc lulcw.C0 = CFrame.new(0,lul2.Size.y/7,0)
			end
			if rll2 ~= nil then
				rll2:BreakJoints()
				local rllc = Instance.new("Glue",t2) rllc.Name = "yo" rllc.C0 = CFrame.new(0,-rll2.Size.y/6,0) rllc.C1 = CFrame.new(0,rll2.Size.y/5,0) rllc.Part0 = rul2 rllc.Part1 = rll2
				local rllcc = Instance.new("Part",t2) rllcc.Name = "yo" rllcc.Transparency = trans rllcc.Size = Vector3.new(rll2.Size.x/1.2,rll2.Size.y/3.5,rll2.Size.z/1.2)
				local rllcw = Instance.new("Weld",t2) rllcw.Name = "yo" rllcw.Part0 = rll2 rllcw.Part1 = rllcc rllcw.C0 = CFrame.new(0,-rll2.Size.y/7,0)
			end
			if lll2 ~= nil then
				lll2:BreakJoints()
				local lllc = Instance.new("Glue",t2) lllc.Name = "yo" lllc.C0 = CFrame.new(0,-lll2.Size.y/6,0) lllc.C1 = CFrame.new(0,lll2.Size.y/5,0) lllc.Part0 = lul2 lllc.Part1 = lll2
				local lllcc = Instance.new("Part",t2) lllcc.Name = "yo" lllcc.Transparency = trans lllcc.Size = Vector3.new(lll2.Size.x/1.2,lll2.Size.y/3.5,lll2.Size.z/1.2)
				local lllcw = Instance.new("Weld",t2) lllcw.Name = "yo" lllcw.Part0 = lll2 lllcw.Part1 = lllcc lllcw.C0 = CFrame.new(0,-lll2.Size.y/7,0)
			end
			if rf2 ~= nil then
				rf2:BreakJoints()
				local rfc = Instance.new("Glue",t2) rfc.Name = "yo" rfc.C0 = CFrame.new(0,-rul2.Size.y/2.7,0) rfc.C1 = CFrame.new(0,rll2.Size.y/6,0) rfc.Part0 = rll2 rfc.Part1 = rf2
				local rfcc = Instance.new("Part",t2) rfcc.Name = "yo" rfcc.Transparency = trans rfcc.Size = Vector3.new(rf2.Size.x/1,rf2.Size.y,rf2.Size.z/1)
				local rfcw = Instance.new("Weld",t2) rfcw.Name = "yo" rfcw.Part0 = rf2 rfcw.Part1 = rfcc
			end
			if lf2 ~= nil then
				lf2:BreakJoints()
				local lfc = Instance.new("Glue",t2) lfc.Name = "yo" lfc.C0 = CFrame.new(0,-lul2.Size.y/2.7,0) lfc.C1 = CFrame.new(0,lll2.Size.y/6,0) lfc.Part0 = lll2 lfc.Part1 = lf2
				local lfcc = Instance.new("Part",t2) lfcc.Name = "yo" lfcc.Transparency = trans lfcc.Size = Vector3.new(lf2.Size.x/1,lf2.Size.y,lf2.Size.z/1)
				local lfcw = Instance.new("Weld",t2) lfcw.Name = "yo" lfcw.Part0 = lf2 lfcw.Part1 = lfcc
			end
		end
	end

	function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
		local type = type
		local rotenable = rotatingop
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		if typeoftrans == "In" then
			rng.Transparency = 1
		end
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "FileMesh"
		if typeofshape == "Normal" then
			rngm.MeshId = "rbxassetid://662586858"
		elseif typeofshape == "Round" then
			rngm.MeshId = "rbxassetid://662585058"
		end
		rngm.Scale = scale
		local scaler2 = 1/10
		if type == "Add" then
			scaler2 = 1*value/10
		elseif type == "Divide" then
			scaler2 = 1/value/10
		end
		local randomrot = math.random(1,2)
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed/10
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed/10
				end
				if rotenable == true then
					if randomrot == 1 then
						rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
					elseif randomrot == 2 then
						rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
					end
				end
				if typeoftrans == "Out" then
					rng.Transparency = rng.Transparency + 0.01*bonuspeed
				elseif typeoftrans == "In" then
					rng.Transparency = rng.Transparency - 0.01*bonuspeed
				end
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
			end
			rng:Destroy()
		end))
	end

	function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		if ModeOfGlitch ~= 666666 then
			rng.Material = "Neon"
		elseif ModeOfGlitch == 666666 then
			rng.Material = "Glass"
		end
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 0
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder + 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.Color = color3
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = scale
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end


	function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 1
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end

		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end

	function dmg(dude)

	end


	function FindNearestHead(Position, Distance, SinglePlayer)
		if SinglePlayer then
			return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
		end
		local List = {}
		for i, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") then
				if v:findFirstChild("Head") then
					if v ~= Character then
						if (v.Head.Position - Position).magnitude <= Distance then
							table.insert(List, v)
						end 
					end 
				end 
			end 
		end
		return List
	end

	function FaceMouse()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end

	function FaceMouse2()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end


	-- Functions are ready.
	local storehumanoidWS = 16

	function createBGCircle(size,parent,color)
		local bgui = Instance.new("BillboardGui",parent)
		bgui.Size = UDim2.new(size, 0, size, 0)
		local imgc = Instance.new("ImageLabel",bgui)
		imgc.BackgroundTransparency = 1
		imgc.ImageTransparency = 0
		imgc.Size = UDim2.new(1,0,1,0)
		imgc.Image = "rbxassetid://997291547" --997291547,521073910
		imgc.ImageColor3 = color
		return bgui,imgc
	end

	function symbolizeBlink(guipar,size,img,color,bonussize,vol,pit,soundid,spar,rotationenabled,rotsp,delay)
		local bgui,imgc = createBGCircle(size,guipar,color)
		bgui.AlwaysOnTop = true
		imgc.Image = "rbxassetid://" ..img
		local rrot = math.random(1,2)
		CFuncs["Sound"].Create("rbxassetid://" ..soundid, spar, vol,pit)
		coroutine.resume(coroutine.create(function()
			for i = 0, 24*delay do
				swait()
				if rotationenabled == true then
					if rrot == 1 then
						imgc.Rotation = imgc.Rotation + rotsp
					elseif rrot == 2 then
						imgc.Rotation = imgc.Rotation - rotsp
					end
				end
				bgui.Size = bgui.Size + UDim2.new(1*bonussize/delay,0,1*bonussize/delay,0)
				imgc.ImageTransparency = imgc.ImageTransparency + 0.04/delay
			end
			bgui:Destroy()
		end))
	end
	function RecolorThing(one,two,three,four,five,exonetran,exone,extwotran,extwo,secondaryenabled,sectrailenabled)
		for i, v in pairs(mw2:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = one
				v.Material = "Neon"
			end
		end
		CFuncs["EchoSound"].Create("rbxassetid://847061203", root, 1, 1,0,10,0.25,0.25,1)
		symbolizeBlink(root,0,2092248396,one.Color,5,3,1,847061203,root,true,10,1)
		symbolizeBlink(root,0,2092248396,one.Color,4,0,0,0,root,true,-5,1)
		tr1.Color = ColorSequence.new(one.Color)
		tr2.Color = ColorSequence.new(one.Color)
		tr3.Color = ColorSequence.new(one.Color)
		for i, v in pairs(mw1:GetChildren()) do
			if v:IsA("Part") then
				if secondaryenabled == false then
					v.Transparency = 1
				elseif secondaryenabled == true then
					v.Transparency = 0
				end
				v.BrickColor = two
				v.Material = "Neon"
			end
		end
		if secondaryenabled == false then
			tl1.Enabled = false
			tl2.Enabled = false
			tl3.Enabled = false
		elseif secondaryenabled == true then
			tl1.Enabled = true
			tl2.Enabled = true
			tl3.Enabled = true
		end
		refec.Color = ColorSequence.new(MAINRUINCOLOR.Color)
		tl1.Color = ColorSequence.new(two.Color)
		tl2.Color = ColorSequence.new(two.Color)
		tl3.Color = ColorSequence.new(two.Color)
		for i, v in pairs(m:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = three
				v.Material = "Ice"
			end
		end
		for i, v in pairs(m2:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = four
				v.Material = "Ice"
			end
		end
		for i, v in pairs(m3:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = five
				v.Material = "Neon"
			end
		end
		for i, v in pairs(extrawingmod1:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = exonetran
				v.BrickColor = exone
				v.Material = "Neon"
			end
		end
		if sectrailenabled == true then
			tl4.Enabled = true
			tl5.Enabled = true
			tl6.Enabled = true
			tr4.Enabled = true
			tr5.Enabled = true
			tr6.Enabled = true
			tl4.Color = ColorSequence.new(exone.Color)
			tl5.Color = ColorSequence.new(exone.Color)
			tl6.Color = ColorSequence.new(exone.Color)
			tr4.Color = ColorSequence.new(extwo.Color)
			tr5.Color = ColorSequence.new(extwo.Color)
			tr6.Color = ColorSequence.new(extwo.Color)
		elseif sectrailenabled == false then
			tl4.Enabled = false
			tl5.Enabled = false
			tl6.Enabled = false
			tr4.Enabled = false
			tr5.Enabled = false
			tr6.Enabled = false
		end
		for i, v in pairs(extrawingmod2:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = extwotran
				v.BrickColor = extwo
				v.Material = "Neon"
			end
		end
	end

	function RecolorThing2(one,two,three,four,five,exonetran,exone,extwotran,extwo,secondaryenabled,sectrailenabled)
		local keptcolor = one
		local locat = Instance.new("Part", char)
		locat.CanCollide = false
		locat.FormFactor = 3
		locat.Name = "Ring"
		locat.Material = "Neon"
		locat.Size = Vector3.new(1, 1, 1)
		locat.Transparency = 1
		locat.TopSurface = 0
		locat.BottomSurface = 0
		locat.Anchored = true
		locat.CFrame = root.CFrame*CFrame.new(0,-3,0)
		local poste = 0
		local rotation = 0
		local upperpos = 0
		local rate = 0
		local x = locat

		for i, v in pairs(mw2:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = one
				v.Material = "Neon"
			end
		end

		tbeam(one,two)
		tr1.Color = ColorSequence.new(one.Color)
		tr2.Color = ColorSequence.new(one.Color)
		tr3.Color = ColorSequence.new(one.Color)
		for i, v in pairs(mw1:GetChildren()) do
			if v:IsA("Part") then
				if secondaryenabled == false then
					v.Transparency = 1
				elseif secondaryenabled == true then
					v.Transparency = 0
				end
				v.BrickColor = two
				v.Material = "Neon"
			end
		end
		if secondaryenabled == false then
			tl1.Enabled = false
			tl2.Enabled = false
			tl3.Enabled = false
		elseif secondaryenabled == true then
			tl1.Enabled = true
			tl2.Enabled = true
			tl3.Enabled = true
		end
		refec.Color = ColorSequence.new(MAINRUINCOLOR.Color)
		tl1.Color = ColorSequence.new(two.Color)
		tl2.Color = ColorSequence.new(two.Color)
		tl3.Color = ColorSequence.new(two.Color)
		for i, v in pairs(m:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = three
				v.Material = "Ice"
			end
		end
		for i, v in pairs(m2:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = four
				v.Material = "Ice"
			end
		end
		for i, v in pairs(m3:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = five
				v.Material = "Neon"
			end
		end
		for i, v in pairs(extrawingmod1:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = exonetran
				v.BrickColor = exone
				v.Material = "Neon"
			end
		end
		if sectrailenabled == true then
			tl4.Enabled = true
			tl5.Enabled = true
			tl6.Enabled = true
			tr4.Enabled = true
			tr5.Enabled = true
			tr6.Enabled = true
			tl4.Color = ColorSequence.new(exone.Color)
			tl5.Color = ColorSequence.new(exone.Color)
			tl6.Color = ColorSequence.new(exone.Color)
			tr4.Color = ColorSequence.new(extwo.Color)
			tr5.Color = ColorSequence.new(extwo.Color)
			tr6.Color = ColorSequence.new(extwo.Color)
		elseif sectrailenabled == false then
			tl4.Enabled = false
			tl5.Enabled = false
			tl6.Enabled = false
			tr4.Enabled = false
			tr5.Enabled = false
			tr6.Enabled = false
		end
		for i, v in pairs(extrawingmod2:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = extwotran
				v.BrickColor = extwo
				v.Material = "Neon"
			end
		end
	end

	function normalmog()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 5, 1.25)
		for i = 0,6,0.1 do
			swait()
			sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
			slash(math.random(30,60)/10,5,true,"Round","Add","In",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.01,0.5),-0.5,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.15)*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0 - 5 * math.cos(sine / 0.2))),.2)
			RW.C0=clerp(RW.C0,cf(1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(-50)),.2)
			LW.C0=clerp(LW.C0,cf(-1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(50)),.2)
		end
		CFuncs["Sound"].Create("rbxassetid://206082327", root, 7.5,1)
		CFuncs["Sound"].Create("rbxassetid://847061203", root, 10,1)
		CFuncs["Sound"].Create("rbxassetid://239000203", root, 7.5,1)
		CFuncs["Sound"].Create("rbxassetid://579687077", root, 7.5,0.75)
		CFuncs["Sound"].Create("rbxassetid://1368637781", root, 10,1)
		CFuncs["Sound"].Create("rbxassetid://763718160", root, 7.5, 1.1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 7.5, 1)
		rainbowmode = false
		chaosmode = false
		ModeOfGlitch = 1
		storehumanoidWS = 16
		newTheme("rbxassetid://415898123",48.6,1,1.25)
		RecolorTextAndRename("MAYHEM",Color3.new(0.25,0,0),Color3.new(1,0,0),"Antique")
		MAINRUINCOLOR = BrickColor.new("Really red")
		sphere(2.5,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		for i = 0, 49 do
			PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2,2,2,0.04,MAINRUINCOLOR,0)
		end
		for i = 0, 24 do
			sphere2(2,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,7,-0.01,MAINRUINCOLOR)
			slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,350)/250,BrickColor.new("White"))
		end
		for i = 0,3,0.1 do
			sphereMK(2.5,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,MAINRUINCOLOR,0)
		end
		RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.5)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.3,-0.15)*angles(math.rad(-30),math.rad(0),math.rad(0)),.5)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0 - 2.5 * math.cos(sine / 0.2))),.5)
			RW.C0=clerp(RW.C0,cf(1.45,0.4,0)*angles(math.rad(-20),math.rad(0 - 2 * math.cos(sine / 0.2)),math.rad(80 + 2 * math.cos(sine / 0.2))),.5)
			LW.C0=clerp(LW.C0,cf(-1.45,0.4,0)*angles(math.rad(-20),math.rad(0 + 2 * math.cos(sine / 0.2)),math.rad(-80 - 2 * math.cos(sine / 0.2))),.5)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function attackone()
		attack = true
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 5, 1.5)
		for i = 0,2,0.1 do
			swait()
			sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
			slash(math.random(30,60)/10,5,true,"Round","Add","In",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.01,0.5),-0.5,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.15)*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0 - 5 * math.cos(sine / 0.2))),.2)
			RW.C0=clerp(RW.C0,cf(1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(-50)),.2)
			LW.C0=clerp(LW.C0,cf(-1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(50)),.2)
		end
		for i = 0, 24 do
			sphere2(2,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,7,-0.01,MAINRUINCOLOR)
			slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,350)/250,BrickColor.new("White"))
		end
		for i, v in pairs(FindNearestHead(Torso.CFrame.p, 52.5)) do
			if v:FindFirstChild('Torso') then
				dmg(v)
			end
		end
		for i = 0, 24 do
			sphere2(2,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,7,-0.01,MAINRUINCOLOR)
			slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,350)/250,BrickColor.new("White"))
		end
		CFuncs["Sound"].Create("rbxassetid://206082327", root, 7.5,1)
		CFuncs["Sound"].Create("rbxassetid://847061203", root, 10,1)
		CFuncs["Sound"].Create("rbxassetid://239000203", root, 7.5,1)
		CFuncs["Sound"].Create("rbxassetid://579687077", root, 7.5,0.75)
		CFuncs["Sound"].Create("rbxassetid://1368637781", root, 10,1)
		CFuncs["Sound"].Create("rbxassetid://763718160", root, 7.5, 1.1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 7.5, 1)
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.5)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.3,-0.15)*angles(math.rad(-30),math.rad(0),math.rad(0)),.5)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0 - 2.5 * math.cos(sine / 0.2))),.5)
			RW.C0=clerp(RW.C0,cf(1.45,0.4,0)*angles(math.rad(-20),math.rad(0 - 2 * math.cos(sine / 0.2)),math.rad(80 + 2 * math.cos(sine / 0.2))),.5)
			LW.C0=clerp(LW.C0,cf(-1.45,0.4,0)*angles(math.rad(-20),math.rad(0 + 2 * math.cos(sine / 0.2)),math.rad(-80 - 2 * math.cos(sine / 0.2))),.5)
		end
		attack = false
	end

	function attacktwo()
		attack = true
		hum.WalkSpeed = 2
		local keptcolor = MAINRUINCOLOR
		CFuncs["Sound"].Create("rbxassetid://847061203", root, 2, 1)
		sphere2(5,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.1,0.1,0.1,keptcolor,keptcolor.Color)
		sphere2(5,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.2,0.2,0.2,keptcolor,keptcolor.Color)
		for i = 0, 14 do
			PixelBlock(1,math.random(1,3),"Add",rarm.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,keptcolor,0)
		end
		for i = 0,1,0.1 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.3)
			RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.3)
		end
		for i = 0, 1 do
			CFuncs["Sound"].Create("rbxassetid://763755889", root, 3,1.1)
			for i = 0,1,0.6 do
				swait()
				sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
				slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.6)
				RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-60)),.6)
				LW.C0=clerp(LW.C0,cf(-1.15,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.6)
			end
			for i = 0,1,0.6 do
				swait()
				sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
				slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.6)
				RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-60)),.6)
				LW.C0=clerp(LW.C0,cf(-1.15,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.6)
			end
			for i = 0,1,0.6 do
				swait()
				sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
				slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-180)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.6)
				RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-60)),.6)
				LW.C0=clerp(LW.C0,cf(-1.15,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.6)
			end
			for i = 0,1,0.6 do
				swait()
				sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
				slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-270)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.6)
				RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-60)),.6)
				LW.C0=clerp(LW.C0,cf(-1.15,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.6)
			end
			local rot = 0
			local dis = CreateParta(char,0.5,1,"Neon",keptcolor)
			CFuncs["EchoSound"].Create("rbxassetid://763718160", dis, 3, 1.1,0,10,0.15,0.5,1)
			dis.CFrame = root.CFrame*CFrame.new(0,2,-3)
			CreateMesh(dis,"Sphere",10,1,10)
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-5,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(5,0,0)
			local trl = Instance.new('Trail',wed)
			trl.Attachment0 = at1
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 0.6
			local a = Instance.new("Part",workspace)
			a.Name = "Direction"	
			a.Anchored = true
			a.BrickColor = bc("Bright red")
			a.Material = "Neon"
			a.Transparency = 1
			a.CanCollide = false
			local ray = Ray.new(
				dis.CFrame.p,                           -- origin
				(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
			) 
			local ignore = dis
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			local distance = (dis.CFrame.p - position).magnitude
			a.Size = Vector3.new(0.1, 0.1, 0.1)
			a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
			dis.CFrame = a.CFrame
			dis.CFrame = dis.CFrame*CFrame.Angles(0,math.rad(rot),0)
			a:Destroy()
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*250
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 5)
			local hitted = false
			coroutine.resume(coroutine.create(function()
				dis.Touched:connect(function(hit) 
					if hitted == false and hit.Parent ~= char then
						hitted = true
						CFuncs["EchoSound"].Create("rbxassetid://782200047", dis, 7, 1.1,0,10,0.15,0.5,1)
						MagniDamage(dis, 30, 33,56, 0, "Normal")
						sphere2(8,"Add",dis.CFrame,vt(10,1,10),1,0.1,1,keptcolor,keptcolor.Color)
						sphere2(4,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,keptcolor,keptcolor.Color)
						sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,keptcolor,keptcolor.Color)
						coroutine.resume(coroutine.create(function()
							local eff = Instance.new("ParticleEmitter",dis)
							eff.Texture = "rbxassetid://2344870656"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(dis.Color)
							eff.Rate = 10000000
							eff.Enabled = true
							eff.EmissionDirection = "Front"
							eff.Lifetime = NumberRange.new(1)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,20,0),NumberSequenceKeypoint.new(0.8,40,0),NumberSequenceKeypoint.new(1,60,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(150)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.SpreadAngle = Vector2.new(0,900)
							eff.RotSpeed = NumberRange.new(-500,500)
							wait(0.2)
							eff.Enabled = false
						end))
						coroutine.resume(coroutine.create(function()
							for i = 0, 9 do
								local disr = CreateParta(char,1,1,"Neon",keptcolor)
								disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
								local at1 = Instance.new("Attachment",disr)
								at1.Position = vt(-5,0,0)
								local at2 = Instance.new("Attachment",disr)
								at2.Position = vt(5,0,0)
								local trl = Instance.new('Trail',disr)
								trl.Attachment0 = at1
								trl.FaceCamera = true
								trl.Attachment1 = at2
								trl.Texture = "rbxassetid://2342682798"
								trl.LightEmission = 1
								trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
								trl.Color = ColorSequence.new(keptcolor.Color)
								trl.Lifetime = 0.5
								local bv = Instance.new("BodyVelocity")
								bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
								bv.velocity = disr.CFrame.lookVector*math.random(50,200)
								bv.Parent = disr
								local val = 0
								coroutine.resume(coroutine.create(function()
									swait(30)
									for i = 0, 9 do
										swait()
										val = val + 0.1
										trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
									end
									game:GetService("Debris"):AddItem(disr, 3)
								end))
							end
							local eff = Instance.new("ParticleEmitter",dis)
							eff.Texture = "rbxassetid://2273224484"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(keptcolor.Color)
							eff.Rate = 500000
							eff.Lifetime = NumberRange.new(0.5,2)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(20,250)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.VelocitySpread = 9000
							eff.RotSpeed = NumberRange.new(-50,50)
							wait(0.25)
							eff.Enabled = false
						end))
						for i = 0, 9 do
							slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(100,200)/250,BrickColor.new("White"))
						end
						for i = 0, 19 do
							PixelBlock(1,math.random(5,20),"Add",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),4,4,4,0.08,keptcolor,0)
						end
						coroutine.resume(coroutine.create(function()
							for i = 0, 19 do
								swait()
								hum.CameraOffset = vt(math.random(-10,10)/70,math.random(-10,10)/70,math.random(-10,10)/70)
							end
							hum.CameraOffset = vt(0,0,0)
						end))
						dis.Anchored = true
						dis.Transparency = 1
						wait(8)
						dis:Destroy()
					end
				end)
			end))
			rot = rot - 15
		end
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-30),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(5)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(50)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(60)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function attackthree()
		attack = true
		local keptcolor = MAINRUINCOLOR
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 2, 1.5)
		for i = 0,2,0.1 do
			swait()
			sphere2(5,"Add",larm.CFrame*CFrame.new(0,-1.5,0),vt(1,1,1),0.025,0.025,0.025,MAINRUINCOLOR,MAINRUINCOLOR.Color)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(10),math.rad(0),math.rad(50)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-50)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(80), math.rad(10), math.rad(60)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(140), math.rad(0), math.rad(-70)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(-50),math.rad(-10)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(40)),.3)
		end
		CFuncs["Sound"].Create("rbxassetid://763716870", root, 3,1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 5,0.9)
		CFuncs["Sound"].Create("rbxassetid://782225570", root, 4,0.5)
		CFuncs["Sound"].Create("rbxassetid://763717569", root, 3,1)
		sphere2(5,"Add",root.CFrame,vt(1,1,1),1,1,1,MAINRUINCOLOR)
		sphere2(5,"Add",root.CFrame,vt(1,1,1),0.5,0.5,0.5,MAINRUINCOLOR)
		for i = 0, 24 do
			slash(math.random(10,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),math.rad(0)),vt(0.01,0.01,0.01),math.random(50,200)/250,BrickColor.new("White"))
		end
		for i = 0,4,0.1 do
			swait()
			root.CFrame = root.CFrame + root.CFrame.lookVector*5
			local dis = CreateParta(char,0.25,1,"Neon",MAINRUINCOLOR)
			CreateMesh(dis,"Sphere",1,1,1)
			dis.Anchored = true
			dis.CFrame = larm.CFrame*CFrame.new(0,-3,0)
			sphere2(5,"Add",dis.CFrame,vt(1,1,1),0.1,0.1,0.1,dis.BrickColor,dis.Color)
			coroutine.resume(coroutine.create(function()
				swait(30)
				dis.Transparency = 1
				coroutine.resume(coroutine.create(function()
					for i = 0, 19 do
						swait()
						hum.CameraOffset = vt(math.random(-10,10)/40,math.random(-10,10)/40,math.random(-10,10)/40)
					end
					hum.CameraOffset = vt(0,0,0)
				end))
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",dis)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(dis.Color)
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(0.5,2)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(50,450)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					wait(0.125)
					eff.Enabled = false
				end))
				MagniDamage(dis, 30, 45,50, 0, "Normal")
				for i = 0, 2 do
					slash(math.random(10,80)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(50,150)/250,dis.BrickColor)
				end
				CFuncs["Sound"].Create("rbxassetid://782353117", dis, 1,1)
				CFuncs["Sound"].Create("rbxassetid://1666361078", dis, 1,1.5)
				CFuncs["Sound"].Create("rbxassetid://782353443", dis, 2,1.65)
				sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.4,0.4,0.4,dis.BrickColor,dis.Color)
			end))
			game:GetService("Debris"):AddItem(dis, 5)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(89),math.rad(-8),math.rad(-5)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-30),math.rad(0),math.rad(8)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-14), math.rad(1), math.rad(17)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.85, 0) * angles(math.rad(180), math.rad(0), math.rad(-8)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-8),math.rad(0),math.rad(-20)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(9),math.rad(0),math.rad(20)),.5)
		end
		attack = false
	end


	local blush = Instance.new("Decal",hed)
	blush.Texture = "rbxassetid://898404027"
	blush.Face = "Front"
	blush.Parent = nil
	blush.Transparency = 1
	----------------------------------- Abilities

	function ExtinctiveHeartbreak()
		local targetted = nil
		if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			targetted = mouse.Target.Parent
		end
		if targetted ~= nil then
			attack = true
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			local originalpos = root.CFrame
			RootPart.CFrame = targetted.Head.CFrame * CFrame.new(0,-2,2)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			hum.WalkSpeed = 0
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			local radm = math.random(1,3)
			if radm == 1 then
				bosschatfunc("YOU WONT BE NECCESSARY.",MAINRUINCOLOR.Color,2)
			elseif radm == 2 then
				bosschatfunc("YOUR EXISTANCE WILL BE GONE.",MAINRUINCOLOR.Color,2)
			elseif radm == 3 then
				bosschatfunc("DIE!",MAINRUINCOLOR.Color,2)
			end
			for i = 0,2,0.1 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-10),math.rad(0)),.4)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.4)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(80)),.4)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(10)),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(10)),.4)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(90),math.rad(0),math.rad(60)),.4)
			end
			CFuncs["Sound"].Create("rbxassetid://153092227", root, 5,1)
			CFuncs["EchoSound"].Create("rbxassetid://153092227", root, 10, 1,0,10,0.25,0.5,1)
			for i = 0,2,0.1 do
				swait()
				coroutine.resume(coroutine.create(function()
					targetted.Head.CFrame = larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(-90),0,0)
					for i,v in pairs(targetted:GetChildren()) do
						if v:IsA("Part") or v:IsA("MeshPart") then
							v.Velocity = vt(0,0,0)
						end
					end
				end))
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.8)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.8)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(-80)),.8)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(80)),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(10)),.8)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(90),math.rad(0),math.rad(-80)),.8)
			end
			CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 1.5, 1,0,10,0.25,0.5,1)
			CFuncs["EchoSound"].Create("rbxassetid://153092227", char, 1.5, 0.9,0,10,0.25,0.5,1)
			for i = 0, 1 do
				CFuncs["EchoSound"].Create("rbxassetid://1690476035", char, 1.5, 1,0.1,10,0.15,0.5,1)
			end
			CFuncs["EchoSound"].Create("rbxassetid://1690476035", root, 10, 1,0.1,10,0.15,0.5,1)
			chatfunc("RRRRROOAGHH!",Color3.new(1,0,0),"Inverted","Antique",0.75)
			for i = 0,4,0.1 do
				swait()
				coroutine.resume(coroutine.create(function()
					local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
					dis.CFrame = targetted.Head.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
					local at1 = Instance.new("Attachment",dis)
					at1.Position = vt(-25000,0,0)
					local at2 = Instance.new("Attachment",dis)
					at2.Position = vt(25000,0,0)
					local trl = Instance.new('Trail',dis)
					trl.Attachment0 = at1
					trl.FaceCamera = true
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(Color3.new(1,0,0))
					trl.Lifetime = 5
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
					bv.Parent = dis
					game:GetService("Debris"):AddItem(dis, 5)
					targetted.Head.CFrame = larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(-90),0,0)
					CFuncs["Sound"].Create("rbxassetid://782353443", targetted.Head, 4,1)
					CFuncs["Sound"].Create("rbxassetid://824687369", targetted.Head, 6, 1)
					CFuncs["Sound"].Create("rbxassetid://153092227", targetted.Head,6,math.random(75,150)/150)
					CFuncs["Sound"].Create("rbxassetid://163680447", targetted.Head, 3,math.random(75,150)/150)
					CFuncs["Sound"].Create("rbxassetid://782354021", targetted.Head, 2.5,0.75)
					sphere2(5,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,3,3),-0.03,15,-0.03,MAINRUINCOLOR)
					targetted:FindFirstChildOfClass("Humanoid").CameraOffset = vt(math.random(-10,10)/5,math.random(-10,10)/5,math.random(-10,10)/5)
					for i = 0, 2 do
						slash(5,5,true,"Round","Add","Out",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(50,350)/250,BrickColor.new("Crimson"))
					end
					symbolizeBlink(targetted.Head,0,2092248396,Color3.new(1,0,0),math.random(3,35),0,0,0,targetted.Head,true,math.random(3,9),0.25)
					for i,v in pairs(targetted:GetChildren()) do
						if v:IsA("Part") or v:IsA("MeshPart") then
							v.Velocity = vt(0,0,0)
						end
					end
				end))
				CamShakeAll(10,90,Character)
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.8)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.8)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(-80)),.8)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(80)),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(40)),.8)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(170),math.rad(0),math.rad(-30)),.8)
			end
			for i = 0, 49 do
				local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
				dis.CFrame = targetted.Head.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				local at1 = Instance.new("Attachment",dis)
				at1.Position = vt(-50000,0,0)
				local at2 = Instance.new("Attachment",dis)
				at2.Position = vt(50000,0,0)
				local trl = Instance.new('Trail',dis)
				trl.Attachment0 = at1
				trl.FaceCamera = true
				trl.Attachment1 = at2
				trl.Texture = "rbxassetid://1049219073"
				trl.LightEmission = 1
				trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
				trl.Color = ColorSequence.new(Color3.new(1,0.1,0.1))
				trl.Lifetime = 5
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
				bv.Parent = dis
				game:GetService("Debris"):AddItem(dis, 5)
			end
			for i = 0, 49 do
				sphere2(math.random(10,75)/10,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(5,5,5),-0.05,50,-0.05,MAINRUINCOLOR)
				slash(math.random(10,30)/15,5,true,"Round","Add","Out",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(40,500)/250,BrickColor.new("Really red"))
			end
			CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 2, 0.9,0,10,0.25,0.5,1)
			for i = 0, 1 do
				CFuncs["Sound"].Create("rbxassetid://221920821", targetted.Head, 5,0.9)
				CFuncs["Sound"].Create("rbxassetid://221920821", targetted.Head, 7.5,0.75)
			end
			for i = 0, 4 do
				CFuncs["Sound"].Create("rbxassetid://824687369", targetted.Head, 10, 1)
			end
			symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,1)
			symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,2)
			symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,4)
			dmg(targetted)
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			root.CFrame = originalpos
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			attack = false
			hum.WalkSpeed = storehumanoidWS
		end
	end

	function ColorEnbelived()
		attack = true
		hum.WalkSpeed = 0
		chatfunc("Well color me convinced...",Color3.new(0,0,0),"Inverted","Antique",0.75)
		for i = 0,50 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 9 * math.cos(sine / 51))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 7 * math.cos(sine / 44))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 47),0 + 0.25 * math.cos(sine / 35),3 + 1 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(13)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(24 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-13 + 2 * math.cos(sine / 53))),.1)
			RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function PlaguedJump()
		attack = true
		local keptcolor = BrickColor.new("Forest green")
		CFuncs["Sound"].Create("rbxassetid://1295446488", root, 10, 1)
		CFuncs["EchoSound"].Create("rbxassetid://1657242236", char, 4, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1657242236", root, 10, 1,0,10,0.15,0.5,1)
		for i = 0, 5 do
			swait()
			waveEff(math.random(10,100)/10,"Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(15,0.25,15),math.random(25,250)/250,0.25,BrickColor.new("White"))
			slash(math.random(10,100)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,500)/250,BrickColor.new("White"))
		end
		CamShakeAll(20,100,char)
		root.Velocity = vt(0,250,0) + root.CFrame.lookVector*250
		wait(0.3)
		repeat
			swait()
			for i = 0, 1, 0.6 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(30)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.6)
				RW.C0=clerp(RW.C0,cf(1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(-30)),.6)
				LW.C0=clerp(LW.C0,cf(-1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(30)),.6)
			end
			for i = 0, 1, 0.6 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(30)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.2,0)*angles(math.rad(90),math.rad(0),math.rad(0)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.6)
				RW.C0=clerp(RW.C0,cf(1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(-30)),.6)
				LW.C0=clerp(LW.C0,cf(-1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(30)),.6)
			end
			for i = 0, 1, 0.6 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(30)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.2,0)*angles(math.rad(180),math.rad(0),math.rad(0)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.6)
				RW.C0=clerp(RW.C0,cf(1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(-30)),.6)
				LW.C0=clerp(LW.C0,cf(-1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(30)),.6)
			end
			for i = 0, 1, 0.6 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(30)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.2,0)*angles(math.rad(270),math.rad(0),math.rad(0)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.6)
				RW.C0=clerp(RW.C0,cf(1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(-30)),.6)
				LW.C0=clerp(LW.C0,cf(-1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(30)),.6)
			end
			hfr,pfr=rayCast(root.Position,(CFrame.new(root.Position,root.Position - vt(0,1,0))).lookVector,4,char)
		until hfr ~= nil
		if hfr ~= nil then
			local locat = Instance.new("Part", char)
			locat.CanCollide = false
			locat.FormFactor = 3
			locat.Name = "Ring"
			locat.Material = "Neon"
			locat.Size = Vector3.new(1, 1, 1)
			locat.Transparency = 1
			locat.TopSurface = 0
			locat.BottomSurface = 0
			locat.Anchored = true
			locat.CFrame = root.CFrame*CFrame.new(0,-3,0)
			local poste = 0
			local rotation = 0
			local upperpos = 0
			local rate = 0
			local x = locat
			CamShakeAll(50,100,char)
			CFuncs["Sound"].Create("rbxassetid://847061203", char, 1,1)
			CFuncs["Sound"].Create("rbxassetid://763717897", char, 2.5, 1)
			CFuncs["Sound"].Create("rbxassetid://1192402877", char, 2.5, 0.5)
			sphere(1.25,"Add",root.CFrame,vt(0,0,0),16,MAINRUINCOLOR)
			sphere(0.85,"Add",root.CFrame,vt(0,0,0),19,MAINRUINCOLOR)
			for i = 0, 49 do
				slash(math.random(10,13)/10,2,false,"Round","Add","Out",root.CFrame*CFrame.new(0,3,0)*CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))),vt(0.05,0.01,0.05),math.random(9,14),MAINRUINCOLOR)
			end
			for i, v in pairs(FindNearestHead(Torso.CFrame.p, 280)) do
				if v:FindFirstChild('Torso') then
					dmg(v)
				end
			end
			coroutine.resume(coroutine.create(function()
				coroutine.resume(coroutine.create(function()
					for i = 0, 119 do
						sphere2(math.random(1,2),"Add",x.CFrame*CFrame.new(math.random(-350,350),0,math.random(-350,350)),vt(5,1,5),-0.05,math.random(50,250)/50,-0.05,keptcolor)
					end
				end))
				for i = 0, 158 do
					swait()
					rotation = rotation + 5
					poste = poste + 1
					upperpos = upperpos + rate
					rate = rate + 0.1
					sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(5+upperpos/10,5+upperpos/10,5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
					sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(90-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(5+upperpos/10,5+upperpos/10,5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
					sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(180-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(5+upperpos/10,5+upperpos/10,5+upperpos/10),-0.025,-0.025,-0.025,keptcolor)
					sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(270-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(5+upperpos/10,5+upperpos/10,5+upperpos/10),-0.025,-0.025,-0.025,keptcolor)
				end
				x:Destroy()
			end))
		end
		attack = false
	end

	function CrazedInsanity()
		attack = true
		for i = 0,30 do
			swait()
			sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
			sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + MRANDOM(-3,3)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 6 * math.cos(sine / 39) + MRANDOM(-5,5))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + MRANDOM(-3,3)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 45) + MRANDOM(-5,5))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.25 * math.cos(sine / 47),0 - 0.25 * math.cos(sine / 40),7 + 1 * math.cos(sine / 32))*angles(math.rad(-15 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(45)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(45)),.5)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(50)),.5)
			LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(20),math.rad(10),math.rad(-30)),.5)
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 2 do
				swait()
				for i = 0, 2 do
					CFuncs["Sound"].Create("rbxassetid://1664711478", char, 10,1)
					CFuncs["LongSound"].Create("rbxassetid://763717897", char, 10, 0.5)
					CFuncs["LongSound"].Create("rbxassetid://763717897", char, 7.5, 0.25)
					CFuncs["Sound"].Create("rbxassetid://763718160", char, 10, 0.9)
					CFuncs["Sound"].Create("rbxassetid://782353443", char, 10, 0.5)
					CFuncs["Sound"].Create("rbxassetid://335657174", char, 5, 0.75)
					CFuncs["LongSound"].Create("rbxassetid://335657174", char, 10, 0.25)
					CFuncs["Sound"].Create("rbxassetid://167115397", char, 10, 1)
					CFuncs["LongSound"].Create("rbxassetid://167115397", char, 10, 0.75)
					CFuncs["LongSound"].Create("rbxassetid://167115397", char, 10, 0.5)
				end
				for i = 0, 2 do
					block(3,"Add",root.CFrame,vt(1,1,1),6.5*2,6.5*2,6.5*2,BrickColor.new("Dark blue"),BrickColor.new("Dark blue").Color)
					block(2,"Add",root.CFrame,vt(1,1,1),6*2,6*2,6*2,BrickColor.new("Really Black"),BrickColor.new("Really Black").Color)
					block(1,"Add",root.CFrame,vt(1,1,1),4.5*2,4.5*2,4.5*2,BrickColor.new("Dark blue"),BrickColor.new("Dark blue").Color)
				end
				for i = 0, 49 do
					slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,2500)/250,BrickColor.new("Really black"))
				end
				CamShakeAll(20,120,char)
				for i = 0, 199 do
					swait()
					coroutine.resume(coroutine.create(function()
						for i, v in pairs(FindNearestHead(root.CFrame.p, 250)) do
							if v:FindFirstChild('Head') then
								dmg(v)
							end
						end
					end))
					local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
					dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
					local at1 = Instance.new("Attachment",dis)
					at1.Position = vt(-25000,0,0)
					local at2 = Instance.new("Attachment",dis)
					at2.Position = vt(25000,0,0)
					local trl = Instance.new('Trail',dis)
					trl.Attachment0 = at1
					trl.FaceCamera = true
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(MAINRUINCOLOR.Color)
					trl.Lifetime = 5
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
					bv.Parent = dis
					game:GetService("Debris"):AddItem(dis, 5)
					sphere2(15,"Add",root.CFrame,vt(1.25,1.25,1.25),2.5,2.5,2.5,BrickColor.new("Dark blue"))
					for i = 0, 2 do
						CamShakeAll(20,120,char)
						slash(15,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),25,BrickColor.new("Dark blue"))
						slash(15,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),50,BrickColor.new("Really black"))
					end
				end
			end
		end))
		for i = 0,60,0.1 do
			swait()
			sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
			sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + MRANDOM(-3,3)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 6 * math.cos(sine / 39) + MRANDOM(-5,5))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + MRANDOM(-3,3)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 45) + MRANDOM(-5,5))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.25 * math.cos(sine / 47),0 - 0.25 * math.cos(sine / 40),7 + 1 * math.cos(sine / 32))*angles(math.rad(7.5 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-15)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(-15)),.5)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0)*angles(math.rad(85),math.rad(0),math.rad(-20)),.5)
			LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(20),math.rad(10),math.rad(-30)),.5)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function RainbowBeam()
		attack = true
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 2, 1.7)
		local rngb = Instance.new("Part", char)
		rngb.Anchored = true
		rngb.BrickColor = origcolor
		rngb.CanCollide = false
		rngb.FormFactor = 3
		rngb.Name = "Ring"
		rngb.Material = "Neon"
		rngb.Size = Vector3.new(1, 0.05, 1)
		rngb.Transparency = 1
		rngb.TopSurface = 0
		rngb.BottomSurface = 0
		local rngmb = Instance.new("SpecialMesh", rngb)
		rngmb.MeshType = "Brick"
		rngmb.Name = "SizeMesh"
		rngmb.Scale = vt(0,1,0)
		local obj1 = script.chring2:Clone()
		obj1.Parent = char
		obj1.Transparency = 1
		obj1.Size = vt(1,1,1)
		obj1.Color = BrickColor.new("White").Color
		if rainbowmode == true then
			obj1.Color = Color3.new(r/255,g/255,b/255)
		end
		local orb = rngb:Clone()
		orb.Parent = char
		orb.Transparency = 0
		orb.BrickColor = BrickColor.new("White")
		orb.Size = vt(1,1,1)
		local orbmish = orb.SizeMesh
		orbmish.Scale = vt(0,0,0)
		orbmish.MeshType = "Sphere"

		local orbe = rngb:Clone()
		orbe.Parent = char
		orbe.Transparency = 0.5
		orbe.BrickColor = BrickColor.new("New Yeller")
		orbe.Size = vt(1,1,1)
		local orbmish2 = orbe.SizeMesh
		orbmish2.Scale = vt(0,0,0)
		orbmish2.MeshType = "Sphere"
		orbe.Color = Color3.new(r/255,g/255,b/255)

		rngb:Destroy()
		CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1.5, 1)
		local rval = 0
		local eval = 1
		coroutine.resume(coroutine.create(function()
			for i = 0,7,0.1 do
				swait()
				rval = rval + math.random(30,40)
				eval = eval + 0.45
				obj1.CFrame = root.CFrame*CFrame.new(0,1,-5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(rval))
			end
		end))
		RootPart.CFrame = FaceMouse()[1]
		for i = 0,5,0.1 do
			swait()
			if rainbowmode == true then
				orbe.Color = Color3.new(r/255,g/255,b/255)
			end
			orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
			orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
			rval = rval + math.random(30,40)
			eval = eval + 0.45
			obj1.Transparency = obj1.Transparency - 0.005
			obj1.Size = obj1.Size + vt(0.7,0.7,0.1)
			obj1.CFrame = root.CFrame*CFrame.new(0,1,-5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(rval))

			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)

		end
		coroutine.resume(coroutine.create(function()
			local eff = Instance.new("ParticleEmitter",obj1)
			eff.Texture = "rbxassetid://2273224484"
			eff.LightEmission = 1
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					eff.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
				end
			end))
			eff.Rate = 27500
			eff.Lifetime = NumberRange.new(1,2)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,60,0),NumberSequenceKeypoint.new(0.2,3,0),NumberSequenceKeypoint.new(0.8,24,0),NumberSequenceKeypoint.new(1,0,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(100,650)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.VelocitySpread = 9000
			eff.RotSpeed = NumberRange.new(-50,50)
			wait(0.35)
			eff.Enabled = false
		end))
		orbe.Transparency = 1
		orb.Transparency = 1
		orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*5
		CFuncs["Sound"].Create("rbxassetid://294188875", char, 1, 1)
		local a = Instance.new("Part",Character)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("White")
		a.Material = "Neon"
		a.Transparency = 0
		a.Shape = "Cylinder"
		a.CanCollide = false
		local a2 = Instance.new("Part",Character)
		a2.Name = "Direction"	
		a2.Anchored = true
		a2.BrickColor = bc("New Yeller")
		a2.Color = Color3.new(r/255,g/255,b/255)
		a2.Material = "Neon"
		a2.Transparency = 0.5
		a2.Shape = "Cylinder"
		a2.CanCollide = false
		local ba = Instance.new("Part",Character)
		ba.Name = "HitDirect"	
		ba.Anchored = true
		ba.BrickColor = bc("Cool yellow")
		ba.Material = "Neon"
		ba.Transparency = 1
		ba.CanCollide = false
		local ray = Ray.new(
			orb.CFrame.p,                           -- origin
			(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
		) 
		local ignore = Character
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		a2.BottomSurface = 10
		a2.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance, 1, 1)
		a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		a2.Size = Vector3.new(distance, 1, 1)
		a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
		a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
		a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
		game:GetService("Debris"):AddItem(a, 20)
		game:GetService("Debris"):AddItem(a2, 20)
		game:GetService("Debris"):AddItem(ba, 20)
		local msh = Instance.new("SpecialMesh",a)
		msh.MeshType = "Cylinder"
		msh.Scale = vt(1,5*5,5*5)
		local msh2 = Instance.new("SpecialMesh",a2)
		msh2.MeshType = "Cylinder"
		msh2.Scale = vt(1,6*5,6*5)
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				shakes(0.2,0.8)
				rval = rval + math.random(30,40)
				eval = eval + 0.45
				obj1.Transparency = obj1.Transparency - 0.005
				obj1.Size = obj1.Size + vt(0,0,0.075)
				obj1.Size = obj1.Size - vt(0.125,0.125,0)
				obj1.CFrame = root.CFrame*CFrame.new(0,1,-5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(rval))
				a2.Color = Color3.new(r/255,g/255,b/255)
				orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
				orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
				ray = Ray.new(
					orb.CFrame.p,                           -- origin
					(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
				) 
				hit, position, normal = workspace:FindPartOnRay(ray, ignore)
				distance = (orb.CFrame.p - position).magnitude
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
				a.Size = Vector3.new(distance, 1, 1)
				a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
				a2.Size = Vector3.new(distance, 1, 1)
				a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
				ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
				a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
				a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
				msh.Scale = msh.Scale - vt(0,0.025*5,0.025*5)
				msh2.Scale = msh2.Scale - vt(0,0.03*5,0.03*5)
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",ba)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
					eff.Rate = 50
					eff.Lifetime = NumberRange.new(0.5,2)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,60,0),NumberSequenceKeypoint.new(0.2,3,0),NumberSequenceKeypoint.new(0.8,24,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(50,450)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					wait(0.25)
					eff.Enabled = false
				end))
				sphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15*2,15*2,25*2,-0.15,MAINRUINCOLOR,0)
				sphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15*2,15*2,25*2,-0.15,MAINRUINCOLOR,0)
				MagniDamage(ba, 30*2, 10,20, 0, "Normal")
			end
			attack = false
			for i = 0,49 do
				swait()
				msh.Scale = msh.Scale - vt(0,0.05*5,0.05*5)
				msh2.Scale = msh2.Scale - vt(0,0.06*5,0.06*5)
				orbe.Transparency = obj1.Transparency + 0.02
				orb.Transparency = obj1.Transparency + 0.02
				obj1.Transparency = obj1.Transparency + 0.02
				obj1.Size = obj1.Size + vt(0,-0.5,-0.5)
			end
			a:Destroy()
			a2:Destroy()
			orb:Destroy()
			orbe:Destroy()
			wait(3)
			obj1:Destroy()
			ba:Destroy()
		end))
	end


	function CorruptionEvent()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://838392947", root, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
		local keptcolor = MAINRUINCOLOR
		for i = 0,4,0.1 do
			swait()
			CamShakeAll(10,45,Character)
			block(10,"Add",rleg.CFrame*CFrame.new(0,-1,0),vt(1,1,1),0.01,0.01,0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
			RH.C0=clerp(RH.C0,cf(1,-0.15,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5),math.rad(-20)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,-0.05)*angles(math.rad(-20),math.rad(0),math.rad(10)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-10)),.1)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-5),math.rad(-10),math.rad(20)),.1)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-5),math.rad(10),math.rad(-20)),.1)
		end
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,1)
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,1.5)
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,3)
		CFuncs["Sound"].Create("rbxassetid://1368637781", root, 3,1)
		CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 1.1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", root, 10, 1.1,0,10,0.25,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 1.5, 1.1,0,10,0.25,0.5,1)
		coroutine.resume(coroutine.create(function()
			local eff = Instance.new("ParticleEmitter",cen)
			eff.Texture = "rbxassetid://2344870656"
			eff.LightEmission = 1
			eff.Color = ColorSequence.new(keptcolor.Color)
			eff.Rate = 10000000
			eff.Enabled = true
			eff.EmissionDirection = "Front"
			eff.Lifetime = NumberRange.new(2)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,120,0),NumberSequenceKeypoint.new(0.1,40,0),NumberSequenceKeypoint.new(0.8,80,0),NumberSequenceKeypoint.new(1,140,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(500)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.SpreadAngle = Vector2.new(0,900)
			eff.RotSpeed = NumberRange.new(-500,500)
			wait(0.2)
			eff.Enabled = false
			wait(5)
			eff:Destroy()
		end))
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),1,0.01,1,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),2,0.01,2,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		for i = 0, 24 do
			slash(math.random(15,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.new("Really black"))
		end
		local rrot = 0
		coroutine.resume(coroutine.create(function()
			for i = 0, 4 do
				rrot = rrot + 45
				local xa = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xa.Anchored = true
				local xb = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xb.Anchored = true
				local xc = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xc.Anchored = true
				local xd = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xd.Anchored = true
				CFuncs["Sound"].Create("rbxassetid://824687369", xa, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xa, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xa, 3,1)
				CFuncs["Sound"].Create("rbxassetid://824687369", xb, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xb, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xb, 3,1)
				CFuncs["Sound"].Create("rbxassetid://824687369", xc, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xc, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xc, 3,1)
				CFuncs["Sound"].Create("rbxassetid://824687369", xd, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xd, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xd, 3,1)
				xa.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(0,-3,-rrot/1.75)
				xb.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(0,-3,rrot/1.75)
				xc.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(-rrot/1.75,-3,0)
				xd.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(rrot/1.75,-3,0)
				MagniDamage(xa, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				MagniDamage(xb, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				MagniDamage(xc, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				MagniDamage(xd, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				for i = 0, 9 do
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xb.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xc.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xd.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
				end
				block(1.5,"Add",xa.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				block(1.5,"Add",xb.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				block(1.5,"Add",xc.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				block(1.5,"Add",xd.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xc.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xd.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(4,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				sphere2(4,"Add",xb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				sphere2(4,"Add",xc.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				sphere2(4,"Add",xd.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				game:GetService("Debris"):AddItem(xa, 5)
				game:GetService("Debris"):AddItem(xb, 5)
				game:GetService("Debris"):AddItem(xc, 5)
				game:GetService("Debris"):AddItem(xd, 5)
				coroutine.resume(coroutine.create(function()
					for i = 0, 19 do
						swait()
						CamShakeAll(10,75,Character)
					end
				end))
				swait(9)
			end
		end))
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(10)),.8)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(10)),.8)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,-0.05)*angles(math.rad(10),math.rad(0),math.rad(0)),.8)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(40),math.rad(0),math.rad(0)),.8)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-35),math.rad(-10),math.rad(60)),.8)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-35),math.rad(10),math.rad(-50)),.8)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function HolyBarrier()
		attack = true
		shielding = true
		CFuncs["Sound"].Create("rbxassetid://1368583274", root, 7.5, 1)
		for i = 0, 2, 0.1 do
			swait()
			slash(math.random(30,100)/10,5,true,"Round","Add","Out",Torso.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-1, 1)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))),vt(0.05,0.01,0.05),math.random(50,60)/250,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(60),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(-20),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.5 + 0.1 * math.cos(sine / 32))*angles(math.rad(30),math.rad(0),math.rad(0)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(120),math.rad(-230),math.rad(-40)),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(120),math.rad(230),math.rad(40)),.1)
		end
		CFuncs["Sound"].Create("rbxassetid://1368637781", root, 7, 1)
		stash = Instance.new("Model",workspace)
		local barrier = Instance.new("Part",stash)
		barrier.Anchored = true
		barrier.CanCollide = false
		barrier.Size = Vector3.new(20,20,20)
		barrier.CFrame = root.CFrame
		barrier.Transparency = 0.4
		barrier.BrickColor = MAINRUINCOLOR
		barrier.Material = Enum.Material.Neon
		barrier.Shape = Enum.PartType.Ball
		barrier.CFrame = root.CFrame
		sphere(3, "Add", root.CFrame, vt(20, 20, 20), 0.15, MAINRUINCOLOR)
		Torso.Anchored = true
		for i=1,50 do
			local p = Instance.new("Part",stash)
			p.Anchored = true
			p.Transparency = 1
			p.Size = Vector3.new(11,11,11)
			p.CFrame = root.CFrame * CFrame.Angles(math.random(0,360),math.random(0,360),math.random(0,360))
		end
		repeat
			swait(5)
			CamShakeAll(10,7,Character)
			waveEff(5,"Add","In",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(15,0.25,15),-0.075,0.05,BrickColor.new("Deep orange"))
			slash(math.random(30,100)/10,1,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-1,1)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(1,50)/250,MAINRUINCOLOR)
			slash(math.random(30,100)/10,1,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-1,1)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(1,50)/250,MAINRUINCOLOR)
			slash(math.random(30,100)/10,1,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-1,1)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(1,50)/250,MAINRUINCOLOR)
			sphereMK(3,0.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("White"),0)
		until shielding == false
		stash:Remove()
		Torso.Anchored = false
		shielding = false
		sphere(3, "Add", root.CFrame, vt(20, 20, 20), 0.15, MAINRUINCOLOR)
		attack = false
	end

	function EndGROUND()
		attack = true
		hum.WalkSpeed = 0
		bosschatfunc("THIS IS IT!",MAINRUINCOLOR.Color,1)
		CFuncs["Sound"].Create("rbxassetid://838392947", root, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
		CFuncs["EchoSound"].Create("rbxassetid://1690475123", char, 1.5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1690475123", root, 10, 1,0,10,0.15,0.5,1)
		local keptcolor = MAINRUINCOLOR
		for i = 0,4,0.1 do
			swait()
			block(10,"Add",rarm.CFrame*CFrame.new(0,-6,0),vt(4,4,4),0.05,0.05,0.05,MAINRUINCOLOR,MAINRUINCOLOR.Color)
			slash(math.random(25,50)/10,5,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-6,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.01,0.1),-0.1,BrickColor.new("Really black"))
			RH.C0=clerp(RH.C0,cf(1,-0.15,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-15),math.rad(-20)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,-0.05)*angles(math.rad(-20),math.rad(0),math.rad(30)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.1)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(170),math.rad(-5),math.rad(10)),.1)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-5),math.rad(10),math.rad(-20)),.1)
		end
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,1)
		CFuncs["Sound"].Create("rbxassetid://1368637781", root, 3,1)
		CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 1.1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", root, 10, 1,0,10,0.25,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 2, 1,0,10,0.25,0.5,1)
		coroutine.resume(coroutine.create(function()
			CamShakeAll(40,100,Character)
			local eff = Instance.new("ParticleEmitter",cen)
			eff.Texture = "rbxassetid://2344870656"
			eff.LightEmission = 1
			eff.Color = ColorSequence.new(keptcolor.Color)
			eff.Rate = 10000000
			eff.Enabled = true
			eff.EmissionDirection = "Front"
			eff.Lifetime = NumberRange.new(2)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,120,0),NumberSequenceKeypoint.new(0.1,40,0),NumberSequenceKeypoint.new(0.8,80,0),NumberSequenceKeypoint.new(1,140,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(500)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.SpreadAngle = Vector2.new(0,900)
			eff.RotSpeed = NumberRange.new(-500,500)
			wait(0.2)
			eff.Enabled = false
			wait(5)
			eff:Destroy()
		end))
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),1,0.01,1,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),2,0.01,2,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		for i = 0, 24 do
			slash(math.random(15,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.new("Really black"))
		end
		local rrot = 0
		local xam = 1
		coroutine.resume(coroutine.create(function()
			for i = 0, 14 do
				swait()
				rrot = rrot + 40*xam
				xam = xam + 0.25
				local bonus = xam
				local xa = CreateParta(char,0.5,1,"Neon",BrickColor.random())
				xa.Anchored = true
				xa.Color = Color3.new(0,0,0)
				xa.CFrame = root.CFrame*CFrame.new(0,-3,-rrot/1.75)
				CreateMesh(xa,"Sphere",30*bonus,1,30*bonus)
				local xc = 0
				coroutine.resume(coroutine.create(function()
					for i = 0, 99 do
						swait()
						xc = xc + 0.01
						xa.Color = Color3.new(xc,0,0)
					end
					xa.Transparency = 1
					CFuncs["Sound"].Create("rbxassetid://331666100", xa, 5,0.75)
					MagniDamage(xa, 30*bonus, 78*bonus,99*bonus, 0, "Normal")
					for i = 0, 9 do
						slash(math.random(15,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01*bonus,0.01,0.01*bonus),math.random(50,125)/250*bonus,BrickColor.new("Really black"))
					end
					CamShakeAll(20,100,xa)
					block(1.5,"Add",xa.CFrame*CFrame.new(0,-10,0),vt(30*bonus,30*bonus,30*bonus),0.3,0.3,0.3,keptcolor,keptcolor.Color)
					sphere2(2,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25*bonus,1,25*bonus),0.05*bonus,1.5*bonus,0.05*bonus,keptcolor,keptcolor.Color)
					sphere2(4,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30*bonus,1,30*bonus),0.05*bonus,1.5*bonus,0.05*bonus,BrickColor.new("Really black"),Color3.new(0,0,0))
					game:GetService("Debris"):AddItem(xa, 5)
				end))
			end
		end))
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-25),math.rad(30)),.8)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.8)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,-0.5)*angles(math.rad(30),math.rad(0),math.rad(50)),.8)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-50)),.8)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(35),math.rad(-10),math.rad(30)),.8)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-35),math.rad(10),math.rad(-50)),.8)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function ClearDisk()
		attack = true
		hum.WalkSpeed = 2
		local keptcolor = MAINRUINCOLOR
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Clear Disks!",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("TAKE THAT!!!",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("Hey!",MAINRUINCOLOR.Color,1)
		end
		CFuncs["Sound"].Create("rbxassetid://847061203", root, 2, 1)
		CFuncs["EchoSound"].Create("rbxassetid://1625448638", root, 4, 1,0,10,0.15,0.5,1)
		sphere2(5,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.1,0.1,0.1,keptcolor,keptcolor.Color)
		sphere2(5,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.2,0.2,0.2,keptcolor,keptcolor.Color)
		for i = 0, 14 do
			PixelBlock(1,math.random(1,3),"Add",larm.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,BrickColor.new("Pastel Blue"),0)
		end
		for i = 0,2,0.1 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.3)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.3)
		end
		CFuncs["Sound"].Create("rbxassetid://763755889", root, 2.5,1.1)
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(180)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(270)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		local rot = 25
		for i = 0, 3 do
			local dis = CreateParta(char,0.5,1,"Neon",BrickColor.new("Pastel Blue"))
			CFuncs["EchoSound"].Create("rbxassetid://763718160", dis, 3, 1.1,0,10,0.15,0.5,1)
			dis.CFrame = root.CFrame*CFrame.new(0,2,-3)
			dis.Transparency = 0.5
			CreateMesh(dis,"Sphere",10,1,10)
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-5,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(5,0,0)
			local trl = Instance.new('Trail',wed)
			trl.Attachment0 = at1
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 0.6
			local a = Instance.new("Part",workspace)
			a.Name = "Direction"	
			a.Anchored = true
			a.BrickColor = bc("Bright red")
			a.Material = "Neon"
			a.Transparency = 1
			a.CanCollide = false
			local ray = Ray.new(
				dis.CFrame.p,                           -- origin
				(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
			) 
			local ignore = dis
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			local distance = (dis.CFrame.p - position).magnitude
			a.Size = Vector3.new(0.1, 0.1, 0.1)
			a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
			dis.CFrame = a.CFrame
			dis.CFrame = dis.CFrame*CFrame.Angles(0,math.rad(rot),0)
			a:Destroy()
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*250
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 5)
			local hitted = false
			coroutine.resume(coroutine.create(function()
				dis.Touched:connect(function(hit) 
					if hitted == false and hit.Parent ~= char then
						hitted = true
						CamShakeAll(20,35,Character)
						CFuncs["EchoSound"].Create("rbxassetid://782200047", dis, 7, 1.1,0,10,0.15,0.5,1)
						MagniDamage(dis, 30, 82,34575, 0, "Normal")
						sphere2(8,"Add",dis.CFrame,vt(10,1,10),1,0.1,1,keptcolor,keptcolor.Color)
						sphere2(4,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,keptcolor,keptcolor.Color)
						sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,BrickColor.new("White"),Color3.new(1,1,1))
						coroutine.resume(coroutine.create(function()
							local eff = Instance.new("ParticleEmitter",dis)
							eff.Texture = "rbxassetid://2344870656"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(dis.Color)
							eff.Rate = 10000000
							eff.Enabled = true
							eff.EmissionDirection = "Front"
							eff.Lifetime = NumberRange.new(1)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,20,0),NumberSequenceKeypoint.new(0.8,40,0),NumberSequenceKeypoint.new(1,60,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(150)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.SpreadAngle = Vector2.new(0,900)
							eff.RotSpeed = NumberRange.new(-500,500)
							wait(0.2)
							eff.Enabled = false
						end))
						coroutine.resume(coroutine.create(function()
							for i = 0, 9 do
								local disr = CreateParta(char,1,1,"Neon",keptcolor)
								disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
								local at1 = Instance.new("Attachment",disr)
								at1.Position = vt(-2,0,0)
								local at2 = Instance.new("Attachment",disr)
								at2.Position = vt(2,0,0)
								local trl = Instance.new('Trail',disr)
								trl.Attachment0 = at1
								trl.FaceCamera = true
								trl.Attachment1 = at2
								trl.Texture = "rbxassetid://2342682798"
								trl.LightEmission = 1
								trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
								trl.Color = ColorSequence.new(Color3.new(0.3,1,1))
								trl.Lifetime = 0.5
								local bv = Instance.new("BodyVelocity")
								bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
								bv.velocity = disr.CFrame.lookVector*math.random(50,200)
								bv.Parent = disr
								local val = 0
								coroutine.resume(coroutine.create(function()
									swait(30)
									for i = 0, 9 do
										swait()
										val = val + 0.1
										trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
									end
									game:GetService("Debris"):AddItem(disr, 3)
								end))
							end
							local eff = Instance.new("ParticleEmitter",dis)
							eff.Texture = "rbxassetid://2273224484"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(Color3.new(0.3,1,1))
							eff.Rate = 500000
							eff.Lifetime = NumberRange.new(0.5,2)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(20,250)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.VelocitySpread = 9000
							eff.RotSpeed = NumberRange.new(-50,50)
							wait(0.25)
							eff.Enabled = false
						end))
						for i = 0, 9 do
							slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(100,200)/250,BrickColor.new("White"))
						end
						for i = 0, 19 do
							PixelBlock(1,math.random(5,20),"Add",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),4,4,4,0.08,BrickColor.new("Pastel Blue"),0)
						end
						dis.Anchored = true
						dis.Transparency = 1
						wait(8)
						dis:Destroy()
					end
				end)
			end))
			rot = rot - 15
		end
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-30),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(5)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(-50)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function HeavenlyDisk()
		attack = true
		hum.WalkSpeed = 2
		local keptcolor = MAINRUINCOLOR
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Dont make this too easy for you.",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("Heavenly Disks!",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("Take it!",MAINRUINCOLOR.Color,1)
		end
		CFuncs["Sound"].Create("rbxassetid://847061203", root, 2, 1)
		CFuncs["EchoSound"].Create("rbxassetid://1625448638", root, 4, 1,0,10,0.15,0.5,1)
		sphere2(5,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.1,0.1,0.1,keptcolor,keptcolor.Color)
		sphere2(5,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.2,0.2,0.2,keptcolor,keptcolor.Color)
		for i = 0, 14 do
			PixelBlock(1,math.random(1,3),"Add",larm.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,BrickColor.new("Toothpaste"),0)
		end
		for i = 0,2,0.1 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.3)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.3)
		end
		CFuncs["Sound"].Create("rbxassetid://763755889", root, 2.5,1.1)
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(180)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(270)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		local rot = 15
		for i = 0, 2 do
			local dis = CreateParta(char,0.5,1,"Neon",BrickColor.new("Toothpaste"))
			CFuncs["EchoSound"].Create("rbxassetid://763718160", dis, 3, 1.1,0,10,0.15,0.5,1)
			dis.CFrame = root.CFrame*CFrame.new(0,2,-3)
			CreateMesh(dis,"Sphere",10,1,10)
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-5,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(5,0,0)
			local trl = Instance.new('Trail',wed)
			trl.Attachment0 = at1
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 0.6
			local a = Instance.new("Part",workspace)
			a.Name = "Direction"	
			a.Anchored = true
			a.BrickColor = bc("Bright red")
			a.Material = "Neon"
			a.Transparency = 1
			a.CanCollide = false
			local ray = Ray.new(
				dis.CFrame.p,                           -- origin
				(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
			) 
			local ignore = dis
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			local distance = (dis.CFrame.p - position).magnitude
			a.Size = Vector3.new(0.1, 0.1, 0.1)
			a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
			dis.CFrame = a.CFrame
			dis.CFrame = dis.CFrame*CFrame.Angles(0,math.rad(rot),0)
			a:Destroy()
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*250
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 5)
			local hitted = false
			coroutine.resume(coroutine.create(function()
				dis.Touched:connect(function(hit) 
					if hitted == false and hit.Parent ~= char then
						hitted = true
						CamShakeAll(20,35,Character)
						CFuncs["EchoSound"].Create("rbxassetid://782200047", dis, 7, 1.1,0,10,0.15,0.5,1)
						MagniDamage(dis, 30, 82,34575, 0, "Normal")
						sphere2(8,"Add",dis.CFrame,vt(10,1,10),1,0.1,1,keptcolor,keptcolor.Color)
						sphere2(4,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,keptcolor,keptcolor.Color)
						sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,BrickColor.new("White"),Color3.new(1,1,1))
						coroutine.resume(coroutine.create(function()
							local eff = Instance.new("ParticleEmitter",dis)
							eff.Texture = "rbxassetid://2344870656"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(dis.Color)
							eff.Rate = 10000000
							eff.Enabled = true
							eff.EmissionDirection = "Front"
							eff.Lifetime = NumberRange.new(1)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,20,0),NumberSequenceKeypoint.new(0.8,40,0),NumberSequenceKeypoint.new(1,60,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(150)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.SpreadAngle = Vector2.new(0,900)
							eff.RotSpeed = NumberRange.new(-500,500)
							wait(0.2)
							eff.Enabled = false
						end))
						coroutine.resume(coroutine.create(function()
							for i = 0, 9 do
								local disr = CreateParta(char,1,1,"Neon",keptcolor)
								disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
								local at1 = Instance.new("Attachment",disr)
								at1.Position = vt(-2,0,0)
								local at2 = Instance.new("Attachment",disr)
								at2.Position = vt(2,0,0)
								local trl = Instance.new('Trail',disr)
								trl.Attachment0 = at1
								trl.FaceCamera = true
								trl.Attachment1 = at2
								trl.Texture = "rbxassetid://2342682798"
								trl.LightEmission = 1
								trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
								trl.Color = ColorSequence.new(Color3.new(0.3,1,1))
								trl.Lifetime = 0.5
								local bv = Instance.new("BodyVelocity")
								bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
								bv.velocity = disr.CFrame.lookVector*math.random(50,200)
								bv.Parent = disr
								local val = 0
								coroutine.resume(coroutine.create(function()
									swait(30)
									for i = 0, 9 do
										swait()
										val = val + 0.1
										trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
									end
									game:GetService("Debris"):AddItem(disr, 3)
								end))
							end
							local eff = Instance.new("ParticleEmitter",dis)
							eff.Texture = "rbxassetid://2273224484"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(Color3.new(0.3,1,1))
							eff.Rate = 500000
							eff.Lifetime = NumberRange.new(0.5,2)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(20,250)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.VelocitySpread = 9000
							eff.RotSpeed = NumberRange.new(-50,50)
							wait(0.25)
							eff.Enabled = false
						end))
						for i = 0, 9 do
							slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(100,200)/250,BrickColor.new("White"))
						end
						for i = 0, 19 do
							PixelBlock(1,math.random(5,20),"Add",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),4,4,4,0.08,BrickColor.new("Toothpaste"),0)
						end
						dis.Anchored = true
						dis.Transparency = 1
						wait(8)
						dis:Destroy()
					end
				end)
			end))
			rot = rot - 15
		end
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-30),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(5)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(-50)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function RapidBurst()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://1368598393", char, 2.5, 0.5)
		CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 0.5)
		CFuncs["EchoSound"].Create("rbxassetid://1718412034", char, 4, 1,0,10,0.15,0.5,1)
		bosschatfunc("S H A T T E R !",MAINRUINCOLOR.Color,2)
		local keptcolor = MAINRUINCOLOR
		for i = 0,8,0.1 do
			swait()
			CamShakeAll(15,30,Character)
			slash(math.random(25,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,25,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(2,0.01,2),-2,BrickColor.random())
			block(10,"Add",root.CFrame*CFrame.new(0,25,0),vt(0,0,0),0.5,0.5,0.5,BrickColor.random(),BrickColor.random().Color)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-15 - 2 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 2 * math.cos(sine / 32))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.15 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(-15 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-25 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
			RW.C0=clerp(RW.C0,cf(1.35,1 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-10 + 3 * math.cos(sine / 45))),.1)
			LW.C0=clerp(LW.C0,cf(-1.35,1 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(13 - 3 * math.cos(sine / 45))),.1)
		end
		CamShakeAll(30,300,Character)
		for i = 0, 134 do
			local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
			dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-25000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(25000,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.FaceCamera = true
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(BrickColor.random().Color)
			trl.Lifetime = 12
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 5)
		end
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,125,0,0,0,root,false,0,1)
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,125,0,0,0,root,false,0,1.5)
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,125,0,0,0,root,false,0,3)
		sphere2(2,"Add",root.CFrame,vt(1,1,1),1,1,1,BrickColor.random(),BrickColor.random().Color)
		sphere2(2,"Add",root.CFrame,vt(1,1,1),2,2,2,BrickColor.random(),BrickColor.random().Color)
		sphere2(2,"Add",root.CFrame,vt(1,1,1),4,4,4,BrickColor.random(),BrickColor.random().Color)
		sphere2(2,"Add",root.CFrame,vt(1,1,1),8,8,8,BrickColor.random(),BrickColor.random().Color)
		CFuncs["Sound"].Create("rbxassetid://1841058541", root, 10,1)
		CFuncs["Sound"].Create("rbxassetid://2095993595", char, 5,0.8)
		CFuncs["Sound"].Create("rbxassetid://1841058541", char, 5,1)
		for i = 0, 24 do
			slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(500,1500)/250,BrickColor.random())
		end
		local distam = 0
		coroutine.resume(coroutine.create(function()
			for i = 0, 99 do
				wait()
				CamShakeAll(15,100,Character)
				distam = distam + 1
				local xa = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xa.Anchored = true
				xa.CFrame = root.CFrame*CFrame.new(math.random(-distam,distam),math.random(-distam,distam),math.random(-distam,distam))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				game:GetService("Debris"):AddItem(xa, 5)
				for i = 0, 4 do
					slash(math.random(25,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.random())
				end
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",xa)
					eff.Texture = "rbxassetid://2344870656"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(xa.Color)
					eff.Rate = 10000000
					eff.Enabled = true
					eff.Lifetime = NumberRange.new(2.5)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,20,0),NumberSequenceKeypoint.new(0.8,40,0),NumberSequenceKeypoint.new(1,60,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(200)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.SpreadAngle = Vector2.new(0,900)
					eff.RotSpeed = NumberRange.new(-500,500)
					wait(0.2)
					eff.Enabled = false
				end))
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",xa)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(BrickColor.random().Color)
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(1,3)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,30,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(50,500)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					wait(0.25)
					eff.Enabled = false
				end))
				CFuncs["Sound"].Create("rbxassetid://675172759", xa, 7,math.random(100,200)/200)
				sphere2(5,"Add",xa.CFrame,vt(1,1,1),1,1,1,BrickColor.random(),BrickColor.random().Color)
				sphere2(5,"Add",xa.CFrame,vt(1,1,1),2,2,2,BrickColor.random(),BrickColor.random().Color)
				MagniDamage(xa, 60, 9999,99999, 0, "Normal")
			end
		end))
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function DivineSwarm()
		attack = true
		hum.WalkSpeed = 2
		local keptcolor = MAINRUINCOLOR
		CFuncs["EchoSound"].Create("rbxassetid://1535994669", char, 1.5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1535994669", root, 60, 1,0,10,0.15,0.5,1)
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Divine Swarm.",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("I'll take you out again.",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("Give up to justice.",MAINRUINCOLOR.Color,1)
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 12 do
				swait(8)
				local dis = CreateParta(char,0.5,1,"Neon",MAINRUINCOLOR)
				dis.Anchored = true
				CFuncs["Sound"].Create("rbxassetid://137463716", dis, 2.5,1.5)
				dis.CFrame = root.CFrame*CFrame.new(math.random(-35,35),math.random(10,45),math.random(-35,35))
				CreateMesh(dis,"Sphere",2,2,2)
				sphere2(5,"Add",dis.CFrame,vt(1,1,1),0.1,0.1,0.1,keptcolor,keptcolor.Color)
				slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(10,50)/250,BrickColor.new("White"))
				coroutine.resume(coroutine.create(function()
					wait(0.75)
					dis.Anchored = false
					CFuncs["EchoSound"].Create("rbxassetid://1602800656", dis, 9, 1,0,2,0.15,0.1,1)
					local at1 = Instance.new("Attachment",dis)
					at1.Position = vt(-1,0,0)
					local at2 = Instance.new("Attachment",dis)
					at2.Position = vt(1,0,0)
					local trl = Instance.new('Trail',dis)
					trl.Attachment0 = at1
					trl.FaceCamera = true
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(dis.Color)
					trl.Lifetime = 0.6
					local a = Instance.new("Part",workspace)
					a.Name = "Direction"	
					a.Anchored = true
					a.BrickColor = bc("Bright red")
					a.Material = "Neon"
					a.Transparency = 1
					a.CanCollide = false
					local ray = Ray.new(
						dis.CFrame.p,                           -- origin
						(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
					) 
					local ignore = dis
					local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
					a.BottomSurface = 10
					a.TopSurface = 10
					local distance = (dis.CFrame.p - position).magnitude
					a.Size = Vector3.new(0.1, 0.1, 0.1)
					a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
					dis.CFrame = a.CFrame
					a:Destroy()
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = dis.CFrame.lookVector*2000
					bv.Parent = dis
					game:GetService("Debris"):AddItem(dis, 5)
					local hitted = false
					coroutine.resume(coroutine.create(function()
						dis.Touched:connect(function(hit) 
							if hitted == false and hit.Parent ~= char then
								hitted = true
								CFuncs["EchoSound"].Create("rbxassetid://675172759", dis, 5, 0.8,0,10,0.15,0.5,1)
								CFuncs["EchoSound"].Create("rbxassetid://1448044156", dis, 6, 0.8,0,10,0.15,0.5,1)
								MagniDamage(dis, 60, 15,35, 0, "Normal")
								sphere2(1,"Add",dis.CFrame,vt(1,1,1),1,1,1,keptcolor,keptcolor.Color)
								sphere2(8,"Add",dis.CFrame,vt(1,1,1),1.25,1.25,1.25,BrickColor.new("White"),Color3.new(1,1,1))
								coroutine.resume(coroutine.create(function()
									for i = 0, 2 do
										local disr = CreateParta(char,1,1,"Neon",keptcolor)
										disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
										local at1 = Instance.new("Attachment",disr)
										at1.Position = vt(-10,0,0)
										local at2 = Instance.new("Attachment",disr)
										at2.Position = vt(10,0,0)
										local trl = Instance.new('Trail',disr)
										trl.Attachment0 = at1
										trl.FaceCamera = true
										trl.Attachment1 = at2
										trl.Texture = "rbxassetid://2342682798"
										trl.LightEmission = 1
										trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
										trl.Color = ColorSequence.new(disr.Color)
										trl.Lifetime = 0.5
										local bv = Instance.new("BodyVelocity")
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
										bv.velocity = disr.CFrame.lookVector*math.random(125,250)
										bv.Parent = disr
										local val = 0
										coroutine.resume(coroutine.create(function()
											swait(30)
											for i = 0, 9 do
												swait()
												val = val + 0.1
												trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
											end
											game:GetService("Debris"):AddItem(disr, 3)
										end))
									end
									local eff = Instance.new("ParticleEmitter",dis)
									eff.Texture = "rbxassetid://1049219073"
									eff.LightEmission = 1
									eff.Color = ColorSequence.new(dis.Color)
									eff.Rate = 500000
									eff.Lifetime = NumberRange.new(0.5,2)
									eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
									eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
									eff.Speed = NumberRange.new(20,250)
									eff.Drag = 5
									eff.Rotation = NumberRange.new(-500,500)
									eff.VelocitySpread = 9000
									eff.RotSpeed = NumberRange.new(-50,50)
									wait(0.5)
									eff.Enabled = false
								end))
								for i = 0, 4 do
									slash(math.random(20,50)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,200)/250,BrickColor.new("White"))
								end
								coroutine.resume(coroutine.create(function()
									for i = 0, 19 do
										swait()
										CamShakeAll(5,30,Character)
									end
								end))
								dis.Anchored = true
								dis.Transparency = 1
								wait(8)
								dis:Destroy()
							end
						end)
					end))
				end))
			end
		end))
		for i = 0,2,0.1 do
			swait()
			sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15 - 2 * math.cos(sine / 37)),math.rad(-15 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(170 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 45))),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(8 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-9 - 4 * math.cos(sine / 45))),.3)
		end
		for i = 0,11,0.1 do
			swait()
			sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-75)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(-15 + 1 * math.cos(sine / 58)),math.rad(75 + 2 * math.cos(sine / 53))),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(9 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(9 + 2 * math.cos(sine / 45))),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(90 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-75 - 4 * math.cos(sine / 45))),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function FallenOrbs()
		attack = true
		hum.WalkSpeed = 2
		local keptcolor = MAINRUINCOLOR
		CFuncs["EchoSound"].Create("rbxassetid://1448033299", char, 1.5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1448033299", root, 10, 1,0,10,0.15,0.5,1)
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("This wont be easy to you.",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("How about this?",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("How do you like this?",MAINRUINCOLOR.Color,1)
		end
		local obj1 = script.chring:Clone()
		obj1.Parent = char
		obj1.Transparency = 1
		obj1.Color = BrickColor.new("Toothpaste").Color
		local obj2 = script.spball:Clone()
		obj2.Parent = char
		obj2.Transparency = 1
		obj2.Color = MAINRUINCOLOR.Color
		local cfor = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
		cfor.Anchored = true
		cfor.CFrame = obj2.CFrame
		local cef = Instance.new("ParticleEmitter",cfor)
		cef.Texture = "rbxassetid://2344870656"
		cef.LightEmission = 1
		cef.Color = ColorSequence.new(obj2.Color)
		cef.Rate = 150
		cef.Lifetime = NumberRange.new(0.25)
		cef.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5,1,0),NumberSequenceKeypoint.new(1,0,0)})
		cef.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
		cef.Speed = NumberRange.new(0)
		local rval = 0
		local eval = 1
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 10,0.7)
		for i = 0,10,0.1 do
			swait()
			rval = rval + math.random(30,40)
			eval = eval + 1.5
			obj1.Transparency = obj1.Transparency - 0.003
			obj1.Size = obj1.Size + vt(0,1,1)
			obj1.CFrame = root.CFrame*CFrame.new(0,16,0)*CFrame.Angles(math.rad(0),math.rad(rval),math.rad(-90))
			obj2.Transparency = obj2.Transparency - 0.005
			obj2.Size = obj2.Size + vt(0.5,0.5,0.5)
			cef.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5,eval,0),NumberSequenceKeypoint.new(1,0,0)})
			obj2.CFrame = root.CFrame*CFrame.new(0,36,0)*CFrame.Angles(math.rad(rval),math.rad(rval),math.rad(-rval))
			cfor.CFrame = obj2.CFrame
			slash(math.random(50,90)/10,5,true,"Round","Add","In",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,0.01,1),math.random(-400,-200)/250,BrickColor.new("Deep orange"))
			slash(math.random(50,90)/10,5,true,"Round","Add","In",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,0.01,1),math.random(-400,-200)/250,BrickColor.new("Toothpaste"))
			sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
			sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Deep orange"),BrickColor.new("Deep orange").Color)
			sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Toothpaste"),BrickColor.new("Toothpaste").Color)

			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 43),0 - 0.25 * math.cos(sine / 53),6 + 1 * math.cos(sine / 32))*angles(math.rad(-20 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(70)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 - 2 * math.cos(sine / 37)),math.rad(5 + 1 * math.cos(sine / 58)),math.rad(-70 + 2 * math.cos(sine / 53))),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(170 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(10 + 2 * math.cos(sine / 45))),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(8 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-9 - 4 * math.cos(sine / 45))),.3)
		end
		CamShakeAll(40,120,Character)
		cef.Enabled = false
		coroutine.resume(coroutine.create(function()
			for i = 0,49 do
				swait()
				rval = rval + 100
				obj2.CFrame = obj2.CFrame*CFrame.Angles(math.rad(rval),math.rad(rval),math.rad(-rval))
				obj2.Transparency = obj2.Transparency + 0.02
				obj2.Size = obj2.Size + vt(5,5,5)
				obj1.Transparency = obj1.Transparency + 0.02
				obj1.Size = obj1.Size + vt(0,-0.5,-0.5)
			end
			obj1:Destroy()
			obj2:Destroy()
			cfor:Destroy()
		end))
		for i = 0, 9 do
			slash(math.random(10,40)/10,5,true,"Round","Add","Out",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,450)/250,BrickColor.new("Deep orange"))
			slash(math.random(10,40)/10,5,true,"Round","Add","Out",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,450)/250,BrickColor.new("Toothpaste"))
		end
		sphere2(3,"Add",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),1,1,1,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(3,"Add",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),2,2,2,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		CFuncs["EchoSound"].Create("rbxassetid://675172759", root, 10, 0.8,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://763717897", root, 7.5, 1.1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://675172759", root, 5, 0.7,0,10,0.15,0.5,1)
		CamShakeAll(40,100,Character)
		coroutine.resume(coroutine.create(function()
			for i = 0, 26 do
				swait()
				local custcol = math.random(1,3)
				local dis = CreateParta(char,0.5,1,"Neon",MAINRUINCOLOR)
				if custcol == 1 then
					dis.BrickColor = MAINRUINCOLOR
				elseif custcol == 2 then
					dis.BrickColor = BrickColor.new("Toothpaste")
				elseif custcol == 3 then
					dis.BrickColor = BrickColor.new("Deep orange")
				end
				dis.Anchored = true
				CFuncs["Sound"].Create("rbxassetid://137463716", dis, 2.5,1.5)
				dis.CFrame = root.CFrame*CFrame.new(math.random(-30,30),math.random(11,51),math.random(-30,30))
				CreateMesh(dis,"Sphere",2,2,2)
				sphere2(5,"Add",dis.CFrame,vt(1,1,1),0.1,0.1,0.1,dis.BrickColor,dis.Color)
				slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(10,50)/250,BrickColor.new("White"))
				coroutine.resume(coroutine.create(function()
					wait(1)
					dis.Anchored = false
					CFuncs["EchoSound"].Create("rbxassetid://1602800656", dis, 5, 1,0,2,0.15,0.1,1)
					local at1 = Instance.new("Attachment",dis)
					at1.Position = vt(-1,0,0)
					local at2 = Instance.new("Attachment",dis)
					at2.Position = vt(1,0,0)
					local trl = Instance.new('Trail',dis)
					trl.Attachment0 = at1
					trl.FaceCamera = true
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(dis.Color)
					trl.Lifetime = 0.6
					local a = Instance.new("Part",workspace)
					a.Name = "Direction"	
					a.Anchored = true
					a.BrickColor = bc("Bright red")
					a.Material = "Neon"
					a.Transparency = 1
					a.CanCollide = false
					local ray = Ray.new(
						dis.CFrame.p,                           -- origin
						(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
					) 
					local ignore = dis
					local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
					a.BottomSurface = 10
					a.TopSurface = 10
					local distance = (dis.CFrame.p - position).magnitude
					a.Size = Vector3.new(0.1, 0.1, 0.1)
					a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
					dis.CFrame = a.CFrame
					a:Destroy()
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = dis.CFrame.lookVector*650
					bv.Parent = dis
					game:GetService("Debris"):AddItem(dis, 5)
					local hitted = false
					coroutine.resume(coroutine.create(function()
						dis.Touched:connect(function(hit) 
							if hitted == false and hit.Parent ~= char then
								hitted = true
								CamShakeAll(20,50,Character)
								CFuncs["EchoSound"].Create("rbxassetid://675172759", dis, 2.5, 0.8,0,10,0.15,0.5,1)
								MagniDamage(dis, 60, 25456,124672, 0, "Normal")
								sphere2(1,"Add",dis.CFrame,vt(1,1,1),1,1,1,dis.BrickColor,dis.Color)
								sphere2(8,"Add",dis.CFrame,vt(1,1,1),1.25,1.25,1.25,BrickColor.new("White"),Color3.new(1,1,1))
								coroutine.resume(coroutine.create(function()
									local eff = Instance.new("ParticleEmitter",dis)
									eff.Texture = "rbxassetid://2344870656"
									eff.LightEmission = 1
									eff.Color = ColorSequence.new(dis.Color)
									eff.Rate = 10000000
									eff.Enabled = true
									eff.EmissionDirection = "Front"
									eff.Lifetime = NumberRange.new(3)
									eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,20,0),NumberSequenceKeypoint.new(0.8,40,0),NumberSequenceKeypoint.new(1,60,0)})
									eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
									eff.Speed = NumberRange.new(250)
									eff.Drag = 5
									eff.Rotation = NumberRange.new(-500,500)
									eff.SpreadAngle = Vector2.new(0,900)
									eff.RotSpeed = NumberRange.new(-500,500)
									wait(0.2)
									eff.Enabled = false
								end))
								coroutine.resume(coroutine.create(function()
									for i = 0, 4 do
										local disr = CreateParta(char,1,1,"Neon",dis.BrickColor)
										disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
										local at1 = Instance.new("Attachment",disr)
										at1.Position = vt(-10,0,0)
										local at2 = Instance.new("Attachment",disr)
										at2.Position = vt(10,0,0)
										local trl = Instance.new('Trail',disr)
										trl.Attachment0 = at1
										trl.FaceCamera = true
										trl.Attachment1 = at2
										trl.Texture = "rbxassetid://2342682798"
										trl.LightEmission = 1
										trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
										trl.Color = ColorSequence.new(disr.Color)
										trl.Lifetime = 0.5
										local bv = Instance.new("BodyVelocity")
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
										bv.velocity = disr.CFrame.lookVector*math.random(125,250)
										bv.Parent = disr
										local val = 0
										coroutine.resume(coroutine.create(function()
											swait(30)
											for i = 0, 9 do
												swait()
												val = val + 0.1
												trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
											end
											game:GetService("Debris"):AddItem(disr, 3)
										end))
									end
									local eff = Instance.new("ParticleEmitter",dis)
									eff.Texture = "rbxassetid://2273224484"
									eff.LightEmission = 1
									eff.Color = ColorSequence.new(dis.Color)
									eff.Rate = 500000
									eff.Lifetime = NumberRange.new(0.5,2)
									eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
									eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
									eff.Speed = NumberRange.new(20,250)
									eff.Drag = 5
									eff.Rotation = NumberRange.new(-500,500)
									eff.VelocitySpread = 9000
									eff.RotSpeed = NumberRange.new(-50,50)
									wait(0.5)
									eff.Enabled = false
								end))
								for i = 0, 4 do
									slash(math.random(20,50)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,200)/250,BrickColor.new("White"))
								end
								dis.Anchored = true
								dis.Transparency = 1
								wait(8)
								dis:Destroy()
							end
						end)
					end))
				end))
			end
		end))
		for i = 0,9,0.1 do
			swait()
			sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Deep orange"),BrickColor.new("Deep orange").Color)
			sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Toothpaste"),BrickColor.new("Toothpaste").Color)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 43),0 - 0.25 * math.cos(sine / 53),6 + 1 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(90)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(-15 + 1 * math.cos(sine / 58)),math.rad(-90 + 2 * math.cos(sine / 53))),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(90 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(90 + 2 * math.cos(sine / 45))),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(8 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-9 - 4 * math.cos(sine / 45))),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end



	function EquinoxOrbs()
		hum.WalkSpeed = 0
		attack = true
		for i = 0,1,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5)*angles(math.rad(90),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(5),math.rad(40)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-5),math.rad(-40)),.3)
		end
		sphere2(5,"Add",root.CFrame,vt(1,1,1),1.5,1.5,1.5,MAINRUINCOLOR)
		sphere2(5,"Add",root.CFrame,vt(1,1,1),1,1,1,MAINRUINCOLOR)
		for i = 0, 24 do
			slash(math.random(10,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),math.rad(0)),vt(0.01,0.01,0.01),math.random(100,400)/250,BrickColor.new("White"))
		end
		CFuncs["Sound"].Create("rbxassetid://763716870", root, 8,1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 10,0.8)
		CFuncs["Sound"].Create("rbxassetid://782225570", root, 9,0.5)
		CFuncs["Sound"].Create("rbxassetid://763717569", root, 8,0.9)
		for i = 0,4,0.1 do
			swait()
			root.CFrame = root.CFrame + root.CFrame.lookVector*7.5
			local dis = CreateParta(char,0.25,1,"Neon",MAINRUINCOLOR)
			CreateMesh(dis,"Sphere",1,1,1)
			dis.Anchored = true
			dis.CFrame = larm.CFrame*CFrame.new(0,-3,0)
			local dis2 = CreateParta(char,0.25,1,"Neon",BrickColor.new("White"))
			CreateMesh(dis2,"Sphere",1,1,1)
			dis2.Anchored = true
			dis2.CFrame = rarm.CFrame*CFrame.new(0,-3,0)
			sphere2(5,"Add",dis.CFrame,vt(1,1,1),0.1,0.1,0.1,dis.BrickColor,dis.Color)
			sphere2(5,"Add",dis2.CFrame,vt(1,1,1),0.1,0.1,0.1,dis2.BrickColor,dis2.Color)
			coroutine.resume(coroutine.create(function()
				swait(60)
				dis.Transparency = 1
				dis2.Transparency = 1
				coroutine.resume(coroutine.create(function()
					for i = 0, 19 do
						swait()
						CamShakeAll(10,30,Character)
					end
				end))
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",dis)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(dis.Color)
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(0.5,2)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(50,450)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					local eff2 = eff:Clone()
					eff2.Parent = dis2
					eff2.LightEmission = 0
					eff2.Color = ColorSequence.new(dis2.Color)
					wait(0.25)
					eff.Enabled = false
					eff2.Enabled = false
				end))
				MagniDamage(dis, 55, 89,219788936, 0, "Normal")
				MagniDamage(dis2, 55, 89,219788936, 0, "Normal")
				for i = 0, 2 do
					slash(math.random(10,80)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,300)/250,dis.BrickColor)
					slash(math.random(10,80)/10,5,true,"Round","Add","Out",dis2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,300)/250,dis2.BrickColor)
				end
				CFuncs["Sound"].Create("rbxassetid://782353117", dis, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://782353117", dis2, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://1666361078", dis, 1,1.25)
				CFuncs["Sound"].Create("rbxassetid://1666361078", dis2, 1,1.25)
				CFuncs["Sound"].Create("rbxassetid://782353443", dis, 2,1.15)
				CFuncs["Sound"].Create("rbxassetid://782353443", dis2, 2,1.15)
				sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.8,0.8,0.8,dis.BrickColor,dis.Color)
				sphere2(3,"Add",dis2.CFrame,vt(1,1,1),0.8,0.8,0.8,dis2.BrickColor,dis2.Color)
			end))
			game:GetService("Debris"):AddItem(dis, 5)
			game:GetService("Debris"):AddItem(dis2, 5)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5)*angles(math.rad(90),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.4,1.5,0)*angles(math.rad(0),math.rad(5),math.rad(210)),.1)
			LW.C0=clerp(LW.C0,cf(-1.4,1.5,0)*angles(math.rad(0),math.rad(-5),math.rad(-210)),.1)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end
	function FallenDEMISE()
		attack = true
		hum.WalkSpeed = 0
		local keptcolor = MAINRUINCOLOR
		bosschatfunc("ALL OF YOUR EXISTANCE WILL BE GONE.",MAINRUINCOLOR.Color,3)
		CFuncs["Sound"].Create("rbxassetid://289315275", char, 2.5,0.75)
		CFuncs["Sound"].Create("rbxassetid://136007472", char, 2,0.5)
		for i = 0, 15, 0.1 do
			swait()
			local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
			dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-25000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(25000,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.FaceCamera = true
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 5
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 1)
			sphere2(15,"Add",root.CFrame,vt(8,8,8),2,2,2,MAINRUINCOLOR)
			slash(math.random(30,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(1,0.01,1),math.random(100,500)/250,BrickColor.new("Toothpaste"))
			slash(math.random(30,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(1,0.01,1),math.random(100,500)/250,BrickColor.new("Deep orange"))
			RH.C0=clerp(RH.C0,cf(1,-0.35,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-35)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.45,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(35)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(92),math.rad(0),math.rad(-67)),.1)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(68)),.1)
		end
		CFuncs["Sound"].Create("rbxassetid://294188875", char, 10,1)
		for i = 0, 30, 0.1 do
			swait()
			CamShakeAll(10,350,Character)
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(FindNearestHead(root.CFrame.p, 10000000)) do
					if v:FindFirstChild('Head') then
						dmg(v)
					end
				end
			end))
			local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
			dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-50000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(50000,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.FaceCamera = true
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 10
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(1500,10000)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, math.random(1,4))
			sphere2(15,"Add",root.CFrame,vt(8,80000,8),5,1,5,MAINRUINCOLOR)
			sphere2(15,"Add",root.CFrame,vt(8,8,8),8,8,8,MAINRUINCOLOR)
			sphere2(2,"Add",root.CFrame*CFrame.new(math.random(-2000,2000),math.random(-2000,2000),math.random(-2000,2000)),vt(0,0,0),5,5,5,BrickColor.new("Deep orange"))
			sphere2(2,"Add",root.CFrame*CFrame.new(math.random(-2000,2000),math.random(-2000,2000),math.random(-2000,2000)),vt(0,0,0),5,5,5,BrickColor.new("Toothpaste"))
			slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(5,0.01,5),math.random(500,5000)/250,BrickColor.new("Deep orange"))
			slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(5,0.01,5),math.random(500,5000)/250,BrickColor.new("Toothpaste"))
			for i = 0, 2 do
				slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,math.random(-3,1000),0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(2,0.01,2),math.random(250,750)/250,MAINRUINCOLOR)
			end
			RH.C0=clerp(RH.C0,cf(1,-0.35,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-35)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.45,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(35)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(92),math.rad(0),math.rad(-67)),.1)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(68)),.1)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function SHDTwist()
		attack = true
		hum.WalkSpeed = 2
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Plasmatic Burst!",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("How cute.",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("Suffer to the brightness.",MAINRUINCOLOR.Color,1)
		end
		CFuncs["Sound"].Create("rbxassetid://136007472", rarm, 1.5,1.25)
		local obj1 = script.chring2:Clone()
		obj1.Parent = char
		obj1.Transparency = 1
		obj1.Size = vt(1,1,1)
		obj1.Color = BrickColor.new("Pink").Color
		local obj2 = script.spball:Clone()
		obj2.Parent = char
		obj2.Transparency = 1
		obj2.Size = vt(1,1,1)
		obj2.Color = MAINRUINCOLOR.Color
		local cfor = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
		cfor.Anchored = true
		cfor.CFrame = obj2.CFrame
		local cef = Instance.new("ParticleEmitter",cfor)
		cef.Texture = "rbxassetid://2344870656"
		cef.LightEmission = 1
		cef.Color = ColorSequence.new(obj2.Color)
		cef.Rate = 150
		cef.Lifetime = NumberRange.new(0.25)
		cef.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5,1,0),NumberSequenceKeypoint.new(1,0,0)})
		cef.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
		cef.Speed = NumberRange.new(0)
		local rval = 0
		local eval = 1
		for i = 0,7,0.1 do
			swait()
			rval = rval + math.random(30,40)
			eval = eval + 0.45
			obj1.Transparency = obj1.Transparency - 0.005
			obj1.Size = obj1.Size + vt(0.3,0.3,0.1)
			obj1.CFrame = root.CFrame*CFrame.new(0,1,-5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(rval))
			obj2.Transparency = obj2.Transparency - 0.007
			obj2.Size = obj2.Size + vt(0.15,0.15,0.15)
			cef.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5,eval,0),NumberSequenceKeypoint.new(1,0,0)})
			obj2.CFrame = root.CFrame*CFrame.new(0,1,-7)*CFrame.Angles(math.rad(rval),math.rad(rval),math.rad(-rval))
			cfor.CFrame = obj2.CFrame
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Pastel light blue"),BrickColor.new("Pastel light blue").Color)
			sphere2(10,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.15,-0.01,BrickColor.new("Pink"),BrickColor.new("Pink").Color)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-50)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2 * math.cos(sine / 37)),math.rad(10 + 1 * math.cos(sine / 58)),math.rad(50 + 2 * math.cos(sine / 53))),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(10 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(5 + 2 * math.cos(sine / 45))),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(90 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-50 - 4 * math.cos(sine / 45))),.3)
		end
		cef.Enabled = false
		coroutine.resume(coroutine.create(function()
			for i = 0,49 do
				swait()
				rval = rval + 100
				obj2.CFrame = obj2.CFrame*CFrame.Angles(math.rad(rval),math.rad(rval),math.rad(-rval))
				obj2.Transparency = obj2.Transparency + 0.02
				obj2.Size = obj2.Size + vt(5,5,5)
				obj1.Transparency = obj1.Transparency + 0.02
				obj1.Size = obj1.Size + vt(0,-0.5,-0.5)
			end
			obj1:Destroy()
			obj2:Destroy()
			cfor:Destroy()
		end))
		local lva = 1
		local ica = 0
		local cent = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
		CFuncs["Sound"].Create("rbxassetid://1177785010", cent, 10, 1)
		cent.CFrame = root.CFrame*CFrame.Angles(0,0,0) + root.CFrame.lookVector*5
		sphere2(2,"Add",cent.CFrame,vt(1,1,1),0.5,0.5,0.5,BrickColor.new("Pastel light blue"),BrickColor.new("Pastel light blue").Color)
		sphere2(3,"Add",cent.CFrame,vt(1,1,1),0.5,0.5,0.5,BrickColor.new("Pink"),BrickColor.new("Pink").Color)

		local a = Instance.new("Part",workspace)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			cent.CFrame.p,                           -- origin
			(mouse.Hit.p - cent.CFrame.p).unit * 500 -- direction
		) 
		local ignore = cent
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (cent.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(cent.CFrame.p, position) * CFrame.new(0, 0, 0)
		cent.CFrame = a.CFrame
		a:Destroy()
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = cent.CFrame.lookVector*0
		bv.Parent = cent
		game:GetService("Debris"):AddItem(cent, 20)
		local hitted = false
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				if hitted == false and cent.Parent ~= nil then
					ica = ica + 4*lva
					lva = lva + 0.1
					bv.velocity = cent.CFrame.lookVector*ica
					sphere2(3,"Add",cent.CFrame,vt(5,5,5),-0.05,-0.05,-0.05,BrickColor.new("Pastel light blue"))
					sphere2(5,"Add",cent.CFrame*CFrame.Angles(0,0,math.rad(ica))*CFrame.new(0,-5,0),vt(4,4,4),-0.04,-0.04,-0.04,BrickColor.new("Pink"))
					sphere2(5,"Add",cent.CFrame*CFrame.Angles(0,0,math.rad(ica))*CFrame.new(0,5,0),vt(4,4,4),-0.04,-0.04,-0.04,BrickColor.new("Pastel light blue"))
				elseif hitted == true or cent.Parent == nil then
					break
				end
			end
		end))
		coroutine.resume(coroutine.create(function()
			cent.Touched:connect(function(hit) 
				if hitted == false and hit.Parent ~= char then
					hitted = true
					cent.Anchored = true
					CFuncs["Sound"].Create("rbxassetid://782353443", cent, 10, 1)
					CFuncs["Sound"].Create("rbxassetid://1368637781", cent, 8, 1)
					CFuncs["Sound"].Create("rbxassetid://763717897", cent, 5, 1)
					CFuncs["EchoSound"].Create("rbxassetid://1177785010", cent, 8, 1.1,0,10,0.15,0.5,1)
					MagniDamage(cent, 50, 50,99999, 0, "Normal")
					sphere2(2,"Add",cent.CFrame,vt(1,1,1),1,1,1,BrickColor.new("Pastel light blue"),BrickColor.new("Pastel light blue").Color)
					sphere2(3,"Add",cent.CFrame,vt(1,1,1),1.2,1.2,1.2,BrickColor.new("Pink"),BrickColor.new("Pink").Color)
					for i = 0, 19 do
						slash(math.random(10,50)/10,5,true,"Round","Add","Out",cent.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(200,400)/250,BrickColor.new("Pink"))
						slash(math.random(10,50)/10,5,true,"Round","Add","Out",cent.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,300)/250,BrickColor.new("Pastel light blue"))
					end
					coroutine.resume(coroutine.create(function()
						local eff = Instance.new("ParticleEmitter",cent)
						eff.Texture = "rbxassetid://2344870656"
						eff.LightEmission = 1
						eff.Color = ColorSequence.new(BrickColor.new("Pastel light blue").Color)
						eff.Rate = 10000000
						eff.Enabled = true
						eff.EmissionDirection = "Front"
						eff.Lifetime = NumberRange.new(5)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,40,0),NumberSequenceKeypoint.new(0.8,60,0),NumberSequenceKeypoint.new(1,80,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(350)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.SpreadAngle = Vector2.new(0,900)
						eff.RotSpeed = NumberRange.new(-500,500)
						local eff2 = eff:Clone()
						eff2.Parent = cent
						eff2.Speed = NumberRange.new(250) 
						eff2.Color = ColorSequence.new(BrickColor.new("Pink").Color)
						wait(0.2)
						eff.Enabled = false
						eff2.Enabled = false
					end))
				end
			end)
		end))
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function CardStorm()
		attack = true
		hum.WalkSpeed = 0 
		local keptcolor = MAINRUINCOLOR
		for i = 0,2,0.1 do
			swait()
			sphere2(8,"Add",LeftArm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("White"),BrickColor.new("Deep orange").Color)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 47),0 + 0.25 * math.cos(sine / 35),7 + 1 * math.cos(sine / 32))* angles(math.rad(0),math.rad(0),math.rad(40)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-40)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(6), math.rad(-20), math.rad(12)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(50), math.rad(40), math.rad(-40)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 9 * math.cos(sine / 51))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 7 * math.cos(sine / 44))),.1)
		end
		local RCARD = {83485107,83486447,83485303,83483451,83486567,83484022,83486756}

		local orb = Instance.new("Part", char)
		orb.BrickColor = keptcolor
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 0.75, 1.25)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Brick"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(4,4,4)
		orb.CFrame = root.CFrame*CFrame.new(0,8,-3) + root.CFrame.lookVector*3
		local eff = Instance.new("ParticleEmitter",orb)
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				eff.Texture = "rbxassetid://"..RCARD[math.random(1,7)]
			end
		end))
		eff.LightEmission = 0.95
		eff.Color = ColorSequence.new(Color3.new(1,1,1))
		eff.Rate = 10000
		eff.Lifetime = NumberRange.new(1.5)
		eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2.75,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
		eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.75,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
		eff.Speed = NumberRange.new(20,85)
		eff.Drag = 5
		eff.Rotation = NumberRange.new(-250,250)
		eff.VelocitySpread = 9000
		eff.RotSpeed = NumberRange.new(-50,50)
		local a = Instance.new("Part",workspace)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			orb.CFrame.p,                           -- origin
			(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
		) 
		local ignore = orb
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
		orb.CFrame = a.CFrame
		a:Destroy()
		CFuncs["Sound"].Create("rbxassetid://304448425", orb, 1.5, 0.9)
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = orb.CFrame.lookVector*300
		bv.Parent = orb
		game:GetService("Debris"):AddItem(orb, 10)
		local hitted = false
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if orb.Parent ~= nil and hitted == false then
					sphere2(4,"Add",orb.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),0) - orb.CFrame.lookVector*1.5,vt(3,3,3),-0.03,-0.03,-0.03,keptcolor)
				elseif orb.Parent == nil and hitted == true then
					break
				end
			end
		end))
		local hit =orb.Touched:connect(function(hit) 
			if hitted == false and hit.Parent ~= char then
				hitted = true
				eff.Enabled = false
				CamShakeAll(30,50,Character)
				CFuncs["Sound"].Create("rbxassetid://1226980789", orb, 4.5, 0.7)
				CFuncs["Sound"].Create("rbxassetid://178452221", orb, 2.5, 0.4)
				MagniDamage(orb, 25*2, 20,30, 0, "Normal")
				sphere2(4,"Add",orb.CFrame,vt(4*2,4*2,4*2),0.5*2,0.5*2,0.5*2,keptcolor)
				sphere2(3,"Add",orb.CFrame,vt(4*2,4*2,4*2),0.5*2,0.5*2,0.5*2,keptcolor)
				sphere2(2,"Add",orb.CFrame,vt(4*2,4*2,4*2),0.5*2,0.5*2,0.5*2,keptcolor)
				for i = 0, 9 do
					sphere2(4,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1.5,1,1.5),-0.005,4,-0.005,keptcolor)
				end
				for i = 0, 49 do
					local rsiz = math.random(10,30)
					sphereMK(math.random(1,3),1,"Add",orb.CFrame*CFrame.new(math.random(-20,20)/50,math.random(-20,20)/50,math.random(-20,20)/50)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,keptcolor,0)
				end
				local eff = Instance.new("ParticleEmitter",orb)
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						eff.Texture = "rbxassetid://"..RCARD[math.random(1,7)]
					end
				end))
				eff.LightEmission = 0.95
				eff.Color = ColorSequence.new(Color3.new(1,1,1))
				eff.Rate = 10000
				eff.Lifetime = NumberRange.new(1.5)
				eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.1,15,0),NumberSequenceKeypoint.new(0.8,25,0),NumberSequenceKeypoint.new(1,0,0)})
				eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
				eff.Speed = NumberRange.new(150,350)
				eff.Drag = 5
				eff.Rotation = NumberRange.new(-500,500)
				eff.VelocitySpread = 9000
				eff.RotSpeed = NumberRange.new(-500,500)
				coroutine.resume(coroutine.create(function()
					wait(0.25)
					eff.Enabled = false
				end))
				local hfr,pfr=rayCast(orb.Position,(CFrame.new(orb.Position,orb.Position - Vector3.new(0,1,0))).lookVector,4,char)
				orb.Anchored = true
				orb.Transparency = 1
				coroutine.resume(coroutine.create(function()
					if hfr ~= nil then
						orb.Size = vt(50,1,50)
						orb.Orientation = vt(0,0,0)
						orb.CFrame = orb.CFrame*CFrame.new(0,-5,0)
						orbm:Destroy()
						local firef = eff:Clone()
						coroutine.resume(coroutine.create(function()
							while true do
								swait()
								firef.Texture = "rbxassetid://"..RCARD[math.random(1,7)]
							end
						end))
						firef.Parent = orb
						firef.VelocitySpread = 50
						firef.Rate = 500
						firef.Drag = 3
						firef.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
						firef.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.5,0),NumberSequenceKeypoint.new(0.05,2.5,0),NumberSequenceKeypoint.new(0.4,1,0),NumberSequenceKeypoint.new(1,0,0)})
						firef.Speed = NumberRange.new(10,30)
						for i = 0, 24 do
							wait(0.25)
							MagniDamage(orb, 25, 3,6, 0, "Normal")
						end
						firef.Enabled = false
					end
				end))
				wait(10)
				orb:Destroy()
			end
		end)
		for i = 0,1,0.1 do
			swait()
			sphere2(8,"Add",LeftArm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("White"),BrickColor.new("Deep orange").Color)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 47),0 + 0.25 * math.cos(sine / 35),7 + 1 * math.cos(sine / 32))* angles(math.rad(-15),math.rad(0),math.rad(-50)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(50)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(6), math.rad(-20), math.rad(12)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(140), math.rad(0), math.rad(-20)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 9 * math.cos(sine / 51))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 7 * math.cos(sine / 44))),.1)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function hugg()
		attack = true
		hum.WalkSpeed = 5
		local rsiz = math.random(5,15)
		for i = 0, 2, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7.5),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(0)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(110),math.rad(0),math.rad(40)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(110),math.rad(0),math.rad(-40)),.3)
		end
		CFuncs["Sound"].Create("rbxassetid://444895479", root, 0.5,1)
		local hb = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
		hb.Anchored = true
		hb.CFrame = root.CFrame*CFrame.new(0,1,0) + root.CFrame.lookVector*2
		local huggedperson = nil
		local act = false
		local alreadydid = false
		for i = 0, 3, 0.1 do
			swait()
			if act == false then
				for i, v in pairs(FindNearestHead(hb.CFrame.p, 1.25)) do
					if v:FindFirstChild('Head') then
						if alreadydid == false then
							huggedperson = v
							hum.WalkSpeed = 0
							CFuncs["Sound"].Create("rbxassetid://294861193", root, 1,1)
							CFuncs["Sound"].Create("rbxassetid://200632821", root, 1,1.15)
							CFuncs["Sound"].Create("rbxassetid://1042716828", root, 1.5,1)
							CFuncs["Sound"].Create("rbxassetid://884155627", root, 2,1)
							local radm = math.random(1,3)
							if radm == 1 then
								bosschatfunc("I'm sorry.. if I hurt you..",MAINRUINCOLOR.Color,1)
							elseif radm == 2 then
								bosschatfunc("I..I'm interested in you",MAINRUINCOLOR.Color,1)
							elseif radm == 3 then
								bosschatfunc("Don't worry.. I'm with you",MAINRUINCOLOR.Color,1)
							end
							root.Anchored = true
							coroutine.resume(coroutine.create(function()
								huggedperson.Humanoid.WalkSpeed = 0
								huggedperson:WaitForChild("HumanoidRootPart").Anchored = true
							end))
							chatfunc(string.lower(huggedperson.Name).. "~~",BrickColor.new("Pink").Color,"Normal","SourceSansBold",1)
							alreadydid = true
							act = true
							print(huggedperson.Name)
						end
					end
				end
				hb.CFrame = root.CFrame*CFrame.new(0,1,0) + root.CFrame.lookVector*2
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(0)),.3)
			elseif act == true then
				coroutine.resume(coroutine.create(function()
					huggedperson:FindFirstChildOfClass("Humanoid").Health = huggedperson:FindFirstChildOfClass("Humanoid").Health + 0.2
				end))
				rsiz = math.random(5,15)
				sphereMK(math.random(1,4),0.15,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-8,-4),math.random(-5,5))*CFrame.Angles(math.rad(90),0,0),rsiz/20,rsiz/20,rsiz/20,0,MAINRUINCOLOR,0)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(40)),.1)
				huggedperson.Head.CFrame = root.CFrame*CFrame.new(0,1.25,-1.25)*CFrame.Angles(0,math.rad(180),0)
			end
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7.5),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			RW.C0=clerp(RW.C0,cf(1,0.7,-1)*angles(math.rad(120),math.rad(0),math.rad(-50)),.3)
			LW.C0=clerp(LW.C0,cf(-1,0.7,-1)*angles(math.rad(100),math.rad(0),math.rad(50)),.3)
		end
		hb:Destroy()
		if act == true then
			for x = 0, 2 do
				for i = 0, 2, 0.1 do
					swait()
					coroutine.resume(coroutine.create(function()
						huggedperson:FindFirstChildOfClass("Humanoid").Health = huggedperson:FindFirstChildOfClass("Humanoid").Health + 0.2
					end))
					rsiz = math.random(5,15)
					sphereMK(math.random(1,4),0.15,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-8,-4),math.random(-5,5))*CFrame.Angles(math.rad(90),0,0),rsiz/20,rsiz/20,rsiz/20,0,MAINRUINCOLOR,0)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(45)),.1)
					huggedperson.Head.CFrame = root.CFrame*CFrame.new(0,1.25,-1.25)*CFrame.Angles(0,math.rad(180),0)
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7.5),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.3)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.3)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					RW.C0=clerp(RW.C0,cf(1,0.7,-1)*angles(math.rad(120),math.rad(0),math.rad(-50)),.3)
					LW.C0=clerp(LW.C0,cf(-1,0.7,-1)*angles(math.rad(100),math.rad(0),math.rad(50)),.3)
				end
				for i = 0, 2, 0.1 do
					swait()
					coroutine.resume(coroutine.create(function()
						huggedperson:FindFirstChildOfClass("Humanoid").Health = huggedperson:FindFirstChildOfClass("Humanoid").Health + 0.2
					end))
					rsiz = math.random(5,15)
					sphereMK(math.random(1,4),0.15,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-8,-4),math.random(-5,5))*CFrame.Angles(math.rad(90),0,0),rsiz/20,rsiz/20,rsiz/20,0,MAINRUINCOLOR,0)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(35)),.1)
					huggedperson.Head.CFrame = root.CFrame*CFrame.new(0,1.25,-1.25)*CFrame.Angles(0,math.rad(180),0)
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7.5),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.3)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.3)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					RW.C0=clerp(RW.C0,cf(1,0.7,-1)*angles(math.rad(120),math.rad(0),math.rad(-50)),.3)
					LW.C0=clerp(LW.C0,cf(-1,0.7,-1)*angles(math.rad(100),math.rad(0),math.rad(50)),.3)
				end
			end
		end
		hum.WalkSpeed = storehumanoidWS
		root.Anchored = false
		if act == true then
			coroutine.resume(coroutine.create(function()
				huggedperson.Humanoid.WalkSpeed = 16
				huggedperson:WaitForChild("HumanoidRootPart").Anchored = false
			end))
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function TheoriesTran()
		attack = true
		hum.WalkSpeed = 0
		newThemeCust("rbxassetid://1485663990",0,1.01,1.25)

		local vel = Instance.new("BodyPosition", root)
		vel.P = 10000
		vel.D = 1000
		vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
		vel.position = root.CFrame.p + vt(0,150,0)
		wait(1)
		sphere(1,"Divide",root.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
		for i = 0, 80, 0.1 do
			swait()
			slash(math.random(10,13)/10,2,false,"Round","Add","Out",root.CFrame*CFrame.new(0,3,0)*CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))),vt(0.05,0.01,0.05),math.random(3,5),BrickColor.new("Black"))
			sphereMKCharge(1,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,BrickColor.new("Black"),0)
			shakes(0.15,0.2)
			RH.C0=clerp(RH.C0,cf(1,-0.4 - 0.05 * math.cos(sine / 32),-0.4)*angles(math.rad(5),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.4 - 0.05 * math.cos(sine / 32),-0.4)*angles(math.rad(5),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),1 + 0.05 * math.cos(sine / 32))*angles(math.rad(15 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),-0.1)*angles(math.rad(160 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),-0.1)*angles(math.rad(160 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
		end
		TheoriesMSGfunc("THEORIES",BrickColor.new("Cyan").Color,BrickColor.new("New Yeller").Color)
		ModeOfGlitch = 102341
		storehumanoidWS = 125
		hum.WalkSpeed = 125
		rainbowmode = false
		chaosmode = false
		RecolorTextAndRename("THEORIES",BrickColor.new("New Yeller").Color,BrickColor.new("Cyan").Color,"Code")
		MAINRUINCOLOR = BrickColor.new("New Yeller")
		RecolorThing(MAINRUINCOLOR,BrickColor.new("Cyan"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,BrickColor.new("Cyan"),0,MAINRUINCOLOR,true)
		sphere(2.5,"Add",root.CFrame,vt(1,1,1),1,MAINRUINCOLOR)
		for i = 0, 49 do
			PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2,2,2,0.04,MAINRUINCOLOR,0)
		end
		for i = 0, 19 do
			sphereMK(2.5,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,MAINRUINCOLOR,0)
		end
		vel:Destroy()
		local vel2 = Instance.new("BodyPosition", root)
		vel2.P = 20000
		vel2.D = 1000
		vel2.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
		vel2.position = root.CFrame.p - vt(0,148,0)
		wait(0.5)
		sphere(2.5,"Add",root.CFrame,vt(1,1,1),3,MAINRUINCOLOR)
		for i = 0, 49 do
			PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2,2,2,0.04,MAINRUINCOLOR,0)
		end
		for i = 0, 19 do
			sphereMK(2.5,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5.5,5.5,55,-0.055,MAINRUINCOLOR,0)
		end
		CFuncs["Sound"].Create("rbxassetid://239000203", root, 4, 1)
		CFuncs["Sound"].Create("rbxassetid://1042716828", root, 2, 1)
		CFuncs["Sound"].Create("rbxassetid://847061203", root, 3, 1)
		coroutine.resume(coroutine.create(function()
			wait(0.2)
			vel2:Destroy()
		end))
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function ViolentStrike()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://136007472", rarm, 1, 1)
		bosschatfunc("NO MORE!!",MAINRUINCOLOR.Color,0.7)
		local orb = Instance.new("Part", char)
		orb.BrickColor = MAINRUINCOLOR
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(2,2,2)
		orb.CFrame = mouse.Hit
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = orb.CFrame.lookVector*100
		bv.Parent = orb
		local hitted = false
		coroutine.resume(coroutine.create(function()
			game:GetService("Debris"):AddItem(orb, 5)
			orb.Transparency = 1
			orb.Anchored = true
			local elocacenter = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			elocacenter.Anchored = true
			elocacenter.CFrame = orb.CFrame
			elocacenter.Orientation = vt(0,0,0)
			local eloca1 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			eloca1.Anchored = true
			eloca1.CFrame = elocacenter.CFrame
			local eloca2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			eloca2.Anchored = true
			eloca2.CFrame = elocacenter.CFrame
			local eloca3 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			eloca3.Anchored = true
			eloca3.CFrame = elocacenter.CFrame
			local eloca4 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			eloca4.Anchored = true
			eloca4.CFrame = elocacenter.CFrame
			local lookavec = 0 
			local speeds = 0
			CamShakeAll(27.5,30,char)
			coroutine.resume(coroutine.create(function()
				CFuncs["Sound"].Create("rbxassetid://419447292", elocacenter, 10,1)
				sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
				sphere(6,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
				sphere(7,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
				sphere(8,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
				sphere(9,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
				for i = 0, 24 do
					swait()
					lookavec = lookavec + 2
					speeds = speeds + 1
					elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
					eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
					PixelBlockNeg(2,math.random(1,2),"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

					eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
					PixelBlockNeg(2,math.random(1,2),"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

					eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
					PixelBlockNeg(2,math.random(1,2),"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

					eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
					PixelBlockNeg(2,math.random(1,2),"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)
				end

				local risen = 0
				for i = 0, 176 do
					swait()
					lookavec = lookavec + 0.25
					risen = risen + 0.05
					speeds = speeds + 0.1
					elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
					eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
					PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

					eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
					PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

					eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
					PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

					eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
					PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)
				end

				for i = 0, 176 do
					swait()
					lookavec = lookavec + 0.5
					risen = risen + 0.05
					speeds = speeds + 0.1
					elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
					eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
					PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),5,5,5,0.05,MAINRUINCOLOR,-2)

					eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
					PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),5,5,5,0.05,MAINRUINCOLOR,-2)

					eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
					PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),5,5,5,0.05,MAINRUINCOLOR,-2)

					eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
					PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),5,5,5,0.05,MAINRUINCOLOR,-2)
				end
			end))
			for i = 0, 12, 0.1 do
				swait()
				PixelBlockX(5,0.5,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,MAINRUINCOLOR,0)
				PixelBlockNeg(5,0.5,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,MAINRUINCOLOR,0)
				PixelBlockX(5,0.5,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,MAINRUINCOLOR,0)
				PixelBlockNeg(5,0.5,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,MAINRUINCOLOR,0)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25 + 0.02 * math.cos(sine / 32),1 + 0.1 * math.cos(sine / 32))*angles(math.rad(-40 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(140 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(10 + 3 * math.cos(sine / 45))),.1)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(140 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-10 + 3 * math.cos(sine / 45))),.1)
			end
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(FindNearestHead(elocacenter.CFrame.p, 100)) do
					if v:FindFirstChild('Head') then
						dmg(v)
					end
				end
				CamShakeAll(65,90,Character)
				MagniDamage(elocacenter, 150, 20,50, 0, "Normal")
				CFuncs["Sound"].Create("rbxassetid://468991944", char, 2, 1)
				CFuncs["Sound"].Create("rbxassetid://533636230", char, 2.5, 0.75)
				CFuncs["Sound"].Create("rbxassetid://419447292", char, 0.25,1)
				CFuncs["Sound"].Create("rbxassetid://421328847", char, 0.25,1)
				CFuncs["Sound"].Create("rbxassetid://919941001", char, 1.5,1.05)
				sphere(1,"Add",elocacenter.CFrame,vt(100,90000,100),-0.25,MAINRUINCOLOR)
				sphere(1,"Add",elocacenter.CFrame,vt(100,90000,100),0.5,MAINRUINCOLOR)
				sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
				sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
				sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
				sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
				sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
				sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),500,MAINRUINCOLOR)
				for i = 0, 24 do
					sphereMK(2,2,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,100,-0.25,MAINRUINCOLOR,0)
					sphereMK(4,4,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,75,-0.25,MAINRUINCOLOR,0)
					sphereMK(6,6,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,50,-0.25,MAINRUINCOLOR,0)
					sphereMK(8,8,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,25,-0.25,MAINRUINCOLOR,0)
				end
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",elocacenter)
					eff.Texture = "rbxassetid://2092248396"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(BrickColor.new("Maroon").Color)
					eff.Rate = 50000
					eff.Lifetime = NumberRange.new(6,12)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,60,0),NumberSequenceKeypoint.new(0.2,0.75,0),NumberSequenceKeypoint.new(1,0.1,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(100,1000)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-100,100)
					wait(0.6)
					eff.Enabled = false
				end))
				wait(1.25)
				for i, v in pairs(FindNearestHead(elocacenter.CFrame.p, 100*2)) do
					if v:FindFirstChild('Head') then
						dmg(v)
					end
				end
				CamShakeAll(65,90,Character)
				MagniDamage(elocacenter, 150*2, 20,50, 0, "Normal")
				CFuncs["Sound"].Create("rbxassetid://468991944", char, 2, 1)
				CFuncs["Sound"].Create("rbxassetid://533636230", char, 2.5, 0.75)
				CFuncs["Sound"].Create("rbxassetid://419447292", char, 0.25,1)
				CFuncs["Sound"].Create("rbxassetid://421328847", char, 0.25,1)
				CFuncs["Sound"].Create("rbxassetid://919941001", char, 1.5,1.05)
				sphere(1,"Add",elocacenter.CFrame,vt(150,90000,150),-0.5,MAINRUINCOLOR)
				sphere(1,"Add",elocacenter.CFrame,vt(150,90000,150),1,MAINRUINCOLOR)
				sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),5*2,MAINRUINCOLOR)
				sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),5*2,MAINRUINCOLOR)
				sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),5*2,MAINRUINCOLOR)
				sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),5*2,MAINRUINCOLOR)
				sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),5*2,MAINRUINCOLOR)
				sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),500*2,MAINRUINCOLOR)
				for i = 0, 24 do
					sphereMK(2,2,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,100,-0.25*2,MAINRUINCOLOR,0)
					sphereMK(4,4,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,75,-0.25*2,MAINRUINCOLOR,0)
					sphereMK(6,6,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,50,-0.25*2,MAINRUINCOLOR,0)
					sphereMK(8,8,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,25,-0.25*2,MAINRUINCOLOR,0)
				end
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",elocacenter)
					eff.Texture = "rbxassetid://2092248396"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(BrickColor.new("Maroon").Color)
					eff.Rate = 50000
					eff.Lifetime = NumberRange.new(6,12)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,90,0),NumberSequenceKeypoint.new(0.2,1.25,0),NumberSequenceKeypoint.new(1,0.1,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(125,1250)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-100,100)
					wait(1.25)
					eff.Enabled = false
				end))
				wait(1.25)
				for i, v in pairs(FindNearestHead(elocacenter.CFrame.p, 100*3)) do
					if v:FindFirstChild('Head') then
						dmg(v)
					end
				end
				CamShakeAll(65,90,Character)
				MagniDamage(elocacenter, 150*3, 20,50, 0, "Normal")
				CFuncs["Sound"].Create("rbxassetid://468991944", char, 2, 1)
				CFuncs["Sound"].Create("rbxassetid://533636230", char, 2.5, 0.75)
				CFuncs["Sound"].Create("rbxassetid://419447292", char, 0.25,1)
				CFuncs["Sound"].Create("rbxassetid://421328847", char, 0.25,1)
				CFuncs["Sound"].Create("rbxassetid://919941001", char, 1.5,1.05)
				sphere(1,"Add",elocacenter.CFrame,vt(225,90000,225),-0.25*3,MAINRUINCOLOR)
				sphere(1,"Add",elocacenter.CFrame,vt(225,90000,225),0.5*3,MAINRUINCOLOR)
				sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),5*3,MAINRUINCOLOR)
				sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),5*3,MAINRUINCOLOR)
				sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),5*3,MAINRUINCOLOR)
				sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),5*3,MAINRUINCOLOR)
				sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),5*3,MAINRUINCOLOR)
				sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),500*3,MAINRUINCOLOR)
				for i = 0, 24 do
					sphereMK(2,2,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,100,-0.25*3,MAINRUINCOLOR,0)
					sphereMK(4,4,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,75,-0.25*3,MAINRUINCOLOR,0)
					sphereMK(6,6,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,50,-0.25*3,MAINRUINCOLOR,0)
					sphereMK(8,8,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,25,-0.25*3,MAINRUINCOLOR,0)
				end
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",elocacenter)
					eff.Texture = "rbxassetid://2092248396"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(BrickColor.new("Maroon").Color)
					eff.Rate = 50000
					eff.Lifetime = NumberRange.new(6,12)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,120,0),NumberSequenceKeypoint.new(0.2,2.5,0),NumberSequenceKeypoint.new(1,0.1,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(150,1500)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-100,100)
					wait(1.25)
					eff.Enabled = false
				end))
				wait(0.5)
				chatfunc("That was fun..",MAINRUINCOLOR.Color,"Inverted","Arcade",1)
				CFuncs["EchoSound"].Create("rbxassetid://1535995263", char, 4.75, 1,0,10,0.15,0.5,1)
				CFuncs["EchoSound"].Create("rbxassetid://1535995263", root, 9, 1,0,10,0.15,0.5,1)
			end))
			for i = 0, 4, 0.1 do
				swait()
				PixelBlockX(5,0.5,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,MAINRUINCOLOR,0)
				PixelBlockNeg(5,0.5,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,MAINRUINCOLOR,0)
				PixelBlockX(5,0.5,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,MAINRUINCOLOR,0)
				PixelBlockNeg(5,0.5,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,MAINRUINCOLOR,0)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.2)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25 + 0.02 * math.cos(sine / 32),1 + 0.1 * math.cos(sine / 32))*angles(math.rad(30 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.2)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.2)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(80 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(10 + 3 * math.cos(sine / 45))),.2)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(80 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-10 + 3 * math.cos(sine / 45))),.2)
			end
			hum.WalkSpeed = storehumanoidWS
			attack = false
			coroutine.resume(coroutine.create(function()
				wait(10)
				elocacenter:Destroy()
				eloca1:Destroy()
				eloca2:Destroy()
				eloca3:Destroy()
				eloca4:Destroy()
			end))
		end))
	end

	function ExtCalbeam()
		local lookavec = 0 
		local mult = 1
		local keptcolor = MAINRUINCOLOR
		local dis = CreateParta(char,0,1,"Neon",keptcolor)
		for i = 0, 2 do
			CFuncs["Sound"].Create("rbxassetid://335657174", dis, 10, 0.5)
		end
		dis.CFrame = root.CFrame*CFrame.new(0,2,-3)
		CreateMesh(dis,"Sphere",4,4,4)
		local at1 = Instance.new("Attachment",dis)
		at1.Position = vt(-2,0,0)
		local at2 = Instance.new("Attachment",dis)
		at2.Position = vt(2,0,0)
		local trl = Instance.new('Trail',dis)
		trl.Attachment0 = at1
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 1
		trl.FaceCamera = true
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(dis.Color)
		trl.Lifetime = 3
		local efec = Instance.new("ParticleEmitter",dis)
		efec.Texture = "rbxassetid://144580273"
		efec.LightEmission = 1
		efec.Color = ColorSequence.new(keptcolor.Color)
		efec.Rate = 500000
		efec.Lifetime = NumberRange.new(1)
		efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
		efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
		efec.Drag = 5
		efec.Rotation = NumberRange.new(-500,500)
		efec.VelocitySpread = 9000
		efec.RotSpeed = NumberRange.new(-500,500)
		local a = Instance.new("Part",workspace)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			dis.CFrame.p,                           -- origin
			(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
		) 
		local ignore = dis
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (dis.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
		dis.CFrame = a.CFrame
		a:Destroy()
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = dis.CFrame.lookVector*250
		bv.Parent = dis
		game:GetService("Debris"):AddItem(dis, 15)
		local hitted = false
		coroutine.resume(coroutine.create(function()
			dis.Touched:connect(function(hit) 
				if hitted == false and hit.Parent ~= char then
					hitted = true
					shakes(1,1)
					efec.Enabled = false
					dis.Anchored = true
					dis.Transparency = 1
					local elocacenter = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
					elocacenter.Anchored = true
					elocacenter.CFrame = dis.CFrame*CFrame.new(0,1,0)
					elocacenter.Orientation = Vector3.new(0,0,0)
					local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
					eloca1.Anchored = true
					eloca1.CFrame = elocacenter.CFrame
					local at1 = Instance.new("Attachment",eloca1)
					at1.Position = vt(0,20,0)
					local at2 = Instance.new("Attachment",eloca1)
					at2.Position = vt(0,-20,0)
					local at1b = Instance.new("Attachment",eloca1)
					at1b.Position = vt(0,0,100)
					local at2b = Instance.new("Attachment",eloca1)
					at2b.Position = vt(0,0,-100)
					local trl = Instance.new('Trail',eloca1)
					trl.Attachment0 = at1
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(keptcolor.Color)
					trl.Lifetime = 4
					local trl2 = trl:Clone()
					trl2.Parent = eloca1
					trl2.Attachment0 = at1b
					trl2.Attachment1 = at2b
					trl2.Texture = "rbxassetid://2108945559"
					trl2.Lifetime = 2
					local eff = Instance.new("ParticleEmitter",eloca1)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(keptcolor.Color)
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(0.5,3)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(20,250)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					local eloca2 = eloca1:Clone()
					eloca2.Parent = elocacenter
					local eloca3 = eloca1:Clone()
					eloca3.Parent = elocacenter
					local eloca4 = eloca1:Clone()
					eloca4.Parent = elocacenter
					sphere2(2,"Add",elocacenter.CFrame,vt(1,1,1),2,2,2,keptcolor)
					sphere2(3,"Add",elocacenter.CFrame,vt(1,1,1),4,4,4,keptcolor)
					sphere2(4,"Add",elocacenter.CFrame,vt(1,1,1),5,5,5,keptcolor)
					sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),6,6,6,keptcolor)
					for i = 0, 2 do
						CFuncs["Sound"].Create("rbxassetid://419447292", elocacenter, 8, 1)
						CFuncs["Sound"].Create("rbxassetid://1192402877", elocacenter, 10, 0.5)
					end
					local effx = Instance.new("ParticleEmitter",elocacenter)
					effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
					effx.LightEmission = 1
					effx.Color = ColorSequence.new(keptcolor.Color)
					effx.Rate = 500000
					effx.Lifetime = NumberRange.new(0.25,0.75)
					effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
					effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					effx.Speed = NumberRange.new(0,10)
					effx.Drag = 5
					effx.Rotation = NumberRange.new(-500,500)
					effx.VelocitySpread = 9000
					effx.RotSpeed = NumberRange.new(-50,50)
					coroutine.resume(coroutine.create(function()
						wait(0.05)
						effx.Enabled = false
					end))
					coroutine.resume(coroutine.create(function()
						for i = 0, 9, 0.1 do
							swait()
							mult = mult + 0.5
							lookavec = lookavec + 0.06*mult
							sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
							elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
							eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
							eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
							eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
							eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
						end
						for i = 0, 11, 0.1 do
							swait()
							sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
							elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
							eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
							eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
							eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
							eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
						end
						shakes(1.5,1.5)
						MagniDamage(elocacenter, 200, 50,99, 0, "Normal")
						coroutine.resume(coroutine.create(function()
							for i, v in pairs(FindNearestHead(elocacenter.CFrame.p, 150)) do
								if v:FindFirstChild('Head') then
									dmg(v)
								end
							end
						end))
						local effe = Instance.new("ParticleEmitter",elocacenter)
						effe.Texture = "rbxassetid://2273224484"
						effe.LightEmission = 1
						effe.Color = ColorSequence.new(keptcolor.Color)
						effe.Rate = 500000
						effe.Lifetime = NumberRange.new(3,5)
						effe.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,150,0),NumberSequenceKeypoint.new(0.2,15,0),NumberSequenceKeypoint.new(0.8,15,0),NumberSequenceKeypoint.new(1,0,0)})
						effe.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
						effe.Speed = NumberRange.new(250,1200)
						effe.Drag = 5
						effe.Rotation = NumberRange.new(-500,500)
						effe.VelocitySpread = 9000
						effe.RotSpeed = NumberRange.new(-50,50)
						coroutine.resume(coroutine.create(function()
							effx.Enabled = true
							wait(0.15)
							effx.Enabled = false
							wait(0.25)
							effe.Enabled = false
						end))
						coroutine.resume(coroutine.create(function()
							local elocor = elocacenter
							local lookavec = 0 
							local mult = 1
							local elocacenter = CreateParta(elocor,1,1,"SmoothPlastic",BrickColor.random())
							elocacenter.Anchored = true
							elocacenter.CFrame = elocor.CFrame
							local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
							eloca1.Anchored = true
							eloca1.CFrame = elocacenter.CFrame
							local at1 = Instance.new("Attachment",eloca1)
							at1.Position = vt(0,10,0)
							local at2 = Instance.new("Attachment",eloca1)
							at2.Position = vt(0,-10,0)
							local trl = Instance.new('Trail',eloca1)
							trl.Attachment0 = at1
							trl.Attachment1 = at2
							trl.Texture = "rbxassetid://1049219073"
							trl.LightEmission = 1
							trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
							trl.Color = ColorSequence.new(keptcolor.Color)
							trl.Lifetime = 8
							local eff = Instance.new("ParticleEmitter",eloca1)
							eff.Texture = "rbxassetid://2273224484"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(keptcolor.Color)
							eff.Rate = 500000
							eff.Lifetime = NumberRange.new(0.5,1)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(20,250)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.VelocitySpread = 9000
							eff.RotSpeed = NumberRange.new(-50,50)
							local eloca2 = eloca1:Clone()
							eloca2.Parent = elocacenter
							local eloca3 = eloca1:Clone()
							eloca3.Parent = elocacenter
							local eloca4 = eloca1:Clone()
							eloca4.Parent = elocacenter
							coroutine.resume(coroutine.create(function()
								for i = 0, 19, 0.1 do
									swait()
									mult = mult + 0.25
									lookavec = lookavec + 0.05*mult
									elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/10),0)
									eloca1.CFrame = elocacenter.CFrame*CFrame.new(40+lookavec/5,-15+lookavec*2,0)
									eloca2.CFrame = elocacenter.CFrame*CFrame.new(-40-lookavec/5,-15+lookavec*2,0)
									eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,-15+lookavec*2,40+lookavec/5)
									eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,-15+lookavec*2,-40-lookavec/5)
								end
								for i,v in pairs(elocacenter:GetDescendants()) do
									if v:IsA("ParticleEmitter") then
										v.Enabled = false
									end
								end
								wait(6)
								elocacenter:Destroy()
							end))
						end))
						CFuncs["Sound"].Create("rbxassetid://763717897", char, 3, 1)
						CFuncs["Sound"].Create("rbxassetid://763717897", char, 3, 0.75)
						CFuncs["Sound"].Create("rbxassetid://763717897", char, 4, 0.5)
						CFuncs["Sound"].Create("rbxassetid://1192402877", char, 6,0.5)
						CFuncs["Sound"].Create("rbxassetid://1664711478", char, 2.5,1)
						CFuncs["Sound"].Create("rbxassetid://763718160", char, 3, 0.75)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,20,0,0,0,root,true,-5,3)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,40,0,0,0,root,true,-5,3)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,60,0,0,0,root,true,-5,3)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,80,0,0,0,root,true,-5,3)
						sphere2(2,"Add",elocacenter.CFrame,vt(10,10000,10),2,2,2,keptcolor)
						sphere2(1,"Add",elocacenter.CFrame,vt(10,10000,10),2,2,2,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(10,10,10),5,5,5,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(10,10,10),7.5,7.5,7.5,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(10,10,10),10,10,10,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(10,10,10),2.5,2.5,2.5,keptcolor)
						for i = 0, 29 do
							slash(math.random(10,30)/10,5,true,"Round","Add","Out",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(500,1000)/250,BrickColor.new("White"))
						end
						for i = 0, 9, 0.1 do
							swait()
							mult = mult - 0.5
							lookavec = lookavec - 0.06*mult
							sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
							elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
							eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
							eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
							eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
							eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
						end
						for i,v in pairs(elocacenter:GetDescendants()) do
							if v:IsA("ParticleEmitter") then
								v.Enabled = false
							end
						end
						wait(6)
						elocacenter:Destroy()
					end))
				end
			end)
		end))	
	end

	function ExtCatbeam()
		local lookavec = 0 
		local mult = 1
		local keptcolor = MAINRUINCOLOR
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("SO DO YOU WANT IT TO BE STOP?",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("YALL ARE USELESS!!",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("HAHAHAHA",MAINRUINCOLOR.Color,1)
		end
		local dis = CreateParta(char,0,1,"Neon",keptcolor)
		for i = 0, 2 do
			CFuncs["Sound"].Create("rbxassetid://335657174", dis, 10, 0.5)
		end
		dis.CFrame = root.CFrame*CFrame.new(0,2,-3)
		CreateMesh(dis,"Sphere",4,4,4)
		local at1 = Instance.new("Attachment",dis)
		at1.Position = vt(-2,0,0)
		local at2 = Instance.new("Attachment",dis)
		at2.Position = vt(2,0,0)
		local trl = Instance.new('Trail',dis)
		trl.Attachment0 = at1
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 1
		trl.FaceCamera = true
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(dis.Color)
		trl.Lifetime = 3
		local efec = Instance.new("ParticleEmitter",dis)
		efec.Texture = "rbxassetid://144580273"
		efec.LightEmission = 1
		efec.Color = ColorSequence.new(keptcolor.Color)
		efec.Rate = 500000
		efec.Lifetime = NumberRange.new(1)
		efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
		efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
		efec.Drag = 5
		efec.Rotation = NumberRange.new(-500,500)
		efec.VelocitySpread = 9000
		efec.RotSpeed = NumberRange.new(-500,500)
		local a = Instance.new("Part",workspace)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			dis.CFrame.p,                           -- origin
			(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
		) 
		local ignore = dis
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (dis.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
		dis.CFrame = a.CFrame
		a:Destroy()
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = dis.CFrame.lookVector*250
		bv.Parent = dis
		game:GetService("Debris"):AddItem(dis, 15)
		local hitted = false
		coroutine.resume(coroutine.create(function()
			dis.Touched:connect(function(hit) 
				if hitted == false and hit.Parent ~= char then
					hitted = true
					shakes(1,1)
					efec.Enabled = false
					dis.Anchored = true
					dis.Transparency = 1
					local elocacenter = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
					elocacenter.Anchored = true
					elocacenter.CFrame = dis.CFrame*CFrame.new(0,1,0)
					elocacenter.Orientation = Vector3.new(0,0,0)
					local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
					eloca1.Anchored = true
					eloca1.CFrame = elocacenter.CFrame
					local at1 = Instance.new("Attachment",eloca1)
					at1.Position = vt(0,20,0)
					local at2 = Instance.new("Attachment",eloca1)
					at2.Position = vt(0,-20,0)
					local at1b = Instance.new("Attachment",eloca1)
					at1b.Position = vt(0,0,100)
					local at2b = Instance.new("Attachment",eloca1)
					at2b.Position = vt(0,0,-100)
					local trl = Instance.new('Trail',eloca1)
					trl.Attachment0 = at1
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(keptcolor.Color)
					trl.Lifetime = 4
					local trl2 = trl:Clone()
					trl2.Parent = eloca1
					trl2.Attachment0 = at1b
					trl2.Attachment1 = at2b
					trl2.Texture = "rbxassetid://2108945559"
					trl2.Lifetime = 2
					local eff = Instance.new("ParticleEmitter",eloca1)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(keptcolor.Color)
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(0.5,3)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(20,250)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					local eloca2 = eloca1:Clone()
					eloca2.Parent = elocacenter
					local eloca3 = eloca1:Clone()
					eloca3.Parent = elocacenter
					local eloca4 = eloca1:Clone()
					eloca4.Parent = elocacenter
					sphere2(2,"Add",elocacenter.CFrame,vt(1,1,1),2,2,2,keptcolor)
					sphere2(3,"Add",elocacenter.CFrame,vt(1,1,1),4,4,4,keptcolor)
					sphere2(4,"Add",elocacenter.CFrame,vt(1,1,1),5,5,5,keptcolor)
					sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),6,6,6,keptcolor)
					for i = 0, 2 do
						CFuncs["Sound"].Create("rbxassetid://419447292", elocacenter, 8, 1)
						CFuncs["Sound"].Create("rbxassetid://1192402877", elocacenter, 10, 0.5)
					end
					local effx = Instance.new("ParticleEmitter",elocacenter)
					effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
					effx.LightEmission = 1
					effx.Color = ColorSequence.new(keptcolor.Color)
					effx.Rate = 500000
					effx.Lifetime = NumberRange.new(0.25,0.75)
					effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
					effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					effx.Speed = NumberRange.new(0,10)
					effx.Drag = 5
					effx.Rotation = NumberRange.new(-500,500)
					effx.VelocitySpread = 9000
					effx.RotSpeed = NumberRange.new(-50,50)
					coroutine.resume(coroutine.create(function()
						wait(0.05)
						effx.Enabled = false
					end))
					coroutine.resume(coroutine.create(function()
						for i = 0, 9*2, 0.1 do
							swait()
							mult = mult + 0.5
							lookavec = lookavec + 0.06*mult
							sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
							elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
							eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
							eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
							eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
							eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
						end
						for i = 0, 24, 0.1 do
							swait()
							sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
							elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
							eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
							eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
							eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
							eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
						end
						shakes(3,1.5)
						MagniDamage(elocacenter, 500, 50,99, 0, "Normal")
						coroutine.resume(coroutine.create(function()
							for i, v in pairs(FindNearestHead(elocacenter.CFrame.p, 420)) do
								if v:FindFirstChild('Head') then
									dmg(v)
								end
							end
						end))
						local effe = Instance.new("ParticleEmitter",elocacenter)
						effe.Texture = "rbxassetid://2273224484"
						effe.LightEmission = 1
						effe.Color = ColorSequence.new(keptcolor.Color)
						effe.Rate = 500000
						effe.Lifetime = NumberRange.new(3,5)
						effe.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,150,0),NumberSequenceKeypoint.new(0.2,15,0),NumberSequenceKeypoint.new(0.8,15,0),NumberSequenceKeypoint.new(1,0,0)})
						effe.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
						effe.Speed = NumberRange.new(250,1200)
						effe.Drag = 5
						effe.Rotation = NumberRange.new(-500,500)
						effe.VelocitySpread = 9000
						effe.RotSpeed = NumberRange.new(-50,50)
						coroutine.resume(coroutine.create(function()
							effx.Enabled = true
							wait(0.15)
							effx.Enabled = false
							wait(0.25)
							effe.Enabled = false
						end))
						coroutine.resume(coroutine.create(function()
							local elocor = elocacenter
							local lookavec = 0 
							local mult = 1
							local elocacenter = CreateParta(elocor,1,1,"SmoothPlastic",BrickColor.random())
							elocacenter.Anchored = true
							elocacenter.CFrame = elocor.CFrame
							local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
							eloca1.Anchored = true
							eloca1.CFrame = elocacenter.CFrame
							local at1 = Instance.new("Attachment",eloca1)
							at1.Position = vt(0,10,0)
							local at2 = Instance.new("Attachment",eloca1)
							at2.Position = vt(0,-10,0)
							local trl = Instance.new('Trail',eloca1)
							trl.Attachment0 = at1
							trl.Attachment1 = at2
							trl.Texture = "rbxassetid://1049219073"
							trl.LightEmission = 1
							trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
							trl.Color = ColorSequence.new(keptcolor.Color)
							trl.Lifetime = 8
							local eff = Instance.new("ParticleEmitter",eloca1)
							eff.Texture = "rbxassetid://2273224484"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(keptcolor.Color)
							eff.Rate = 500000
							eff.Lifetime = NumberRange.new(0.5,1)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(20,250)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.VelocitySpread = 9000
							eff.RotSpeed = NumberRange.new(-50,50)
							local eloca2 = eloca1:Clone()
							eloca2.Parent = elocacenter
							local eloca3 = eloca1:Clone()
							eloca3.Parent = elocacenter
							local eloca4 = eloca1:Clone()
							eloca4.Parent = elocacenter
							coroutine.resume(coroutine.create(function()
								for i = 0, 19, 0.1 do
									swait()
									mult = mult + 0.25
									lookavec = lookavec + 0.05*mult
									elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/10),0)
									eloca1.CFrame = elocacenter.CFrame*CFrame.new(40+lookavec/5,-15+lookavec*2,0)
									eloca2.CFrame = elocacenter.CFrame*CFrame.new(-40-lookavec/5,-15+lookavec*2,0)
									eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,-15+lookavec*2,40+lookavec/5)
									eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,-15+lookavec*2,-40-lookavec/5)
								end
								for i,v in pairs(elocacenter:GetDescendants()) do
									if v:IsA("ParticleEmitter") then
										v.Enabled = false
									end
								end
								wait(6)
								elocacenter:Destroy()
							end))
						end))
						CFuncs["Sound"].Create("rbxassetid://763717897", char, 4, 1)
						CFuncs["Sound"].Create("rbxassetid://763717897", char, 4, 0.75)
						CFuncs["Sound"].Create("rbxassetid://763717897", char, 5, 0.5)
						CFuncs["Sound"].Create("rbxassetid://1192402877", char, 7,0.5)
						CFuncs["Sound"].Create("rbxassetid://1664711478", char, 3.5,1)
						CFuncs["Sound"].Create("rbxassetid://763718160", char, 4, 0.75)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,40*2,0,0,0,root,true,-5,3)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,80*2,0,0,0,root,true,-5,3)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,120*2,0,0,0,root,true,-5,3)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,160*2,0,0,0,root,true,-5,3)
						sphere2(2,"Add",elocacenter.CFrame,vt(110,10000,110),4,4,4,keptcolor)
						sphere2(1,"Add",elocacenter.CFrame,vt(110,10000,110),4,4,4,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(110,110,110),10,10,10,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(110,110,110),15,15,15,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(110,110,110),20,20,20,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(110,110,110),5,5,5,keptcolor)
						for i = 0, 29 do
							slash(math.random(10,30)/10,5,true,"Round","Add","Out",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(500,1000)/150,BrickColor.new("White"))
						end
						for i = 0, 9, 0.1 do
							swait()
							mult = mult - 0.5
							lookavec = lookavec - 0.06*mult
							sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
							elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
							eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
							eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
							eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
							eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
						end
						for i,v in pairs(elocacenter:GetDescendants()) do
							if v:IsA("ParticleEmitter") then
								v.Enabled = false
							end
						end
						wait(6)
						elocacenter:Destroy()
					end))
				end
			end)
		end))	
	end

	function CalMets()
		attack = true
		hum.WalkSpeed = 0
		local lookavec = 0 
		local mult = 1
		local keptcolor = MAINRUINCOLOR
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Beyonder..",MAINRUINCOLOR.Color,2.5)
		elseif radm == 2 then
			bosschatfunc("Sky's upon yall.",MAINRUINCOLOR.Color,2.5)
		elseif radm == 3 then
			bosschatfunc("Look up.",MAINRUINCOLOR.Color,2.5)
		end
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 7, 1.25)
		for i = 0,4,0.1 do
			swait()
			slash(math.random(25,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,10,1)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.2,0.01,0.2),-0.2,keptcolor)
			sphere2(3,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(3,3,3),0.06,0.06,0.06,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 5 * math.cos(sine / 51))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 44))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-35),math.rad(0),math.rad(0)),.1)
			RW.C0 = clerp(RW.C0, CFrame.new(1.25, 1, -0.5) * angles(math.rad(170), math.rad(0), math.rad(-20)), 0.1)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 1, -0.5) * angles(math.rad(170), math.rad(0), math.rad(20)), 0.1)
		end
		sphere2(2,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(3,3,3),0.6,0.6,0.6,keptcolor)
		sphere2(4,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(3,3,3),0.6,0.6,0.6,keptcolor)
		sphere2(3,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(1,10000,1),0.06,0.06,0.06,keptcolor)
		local elocacenter = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
		elocacenter.Anchored = true
		elocacenter.CFrame = root.CFrame*CFrame.new(0,150,0)
		local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca1.Anchored = true
		eloca1.CFrame = elocacenter.CFrame
		local at1 = Instance.new("Attachment",eloca1)
		at1.Position = vt(0,30,0)
		local at2 = Instance.new("Attachment",eloca1)
		at2.Position = vt(0,-30,0)
		local at1b = Instance.new("Attachment",eloca1)
		at1b.Position = vt(0,0,180)
		local at2b = Instance.new("Attachment",eloca1)
		at2b.Position = vt(0,0,-180)
		local trl = Instance.new('Trail',eloca1)
		trl.Attachment0 = at1
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 1
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(keptcolor.Color)
		trl.Lifetime = 4
		local trl2 = trl:Clone()
		trl2.Parent = eloca1
		trl2.Attachment0 = at1b
		trl2.Attachment1 = at2b
		trl2.Texture = "rbxassetid://2108945559"
		trl2.Lifetime = 2
		local eff = Instance.new("ParticleEmitter",eloca1)
		eff.Texture = "rbxassetid://2273224484"
		eff.LightEmission = 1
		eff.Color = ColorSequence.new(keptcolor.Color)
		eff.Rate = 500000
		eff.Lifetime = NumberRange.new(0.5,3)
		eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
		eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
		eff.Speed = NumberRange.new(20,250)
		eff.Drag = 5
		eff.Rotation = NumberRange.new(-500,500)
		eff.VelocitySpread = 9000
		eff.RotSpeed = NumberRange.new(-50,50)
		local eloca2 = eloca1:Clone()
		eloca2.Parent = elocacenter
		local eloca3 = eloca1:Clone()
		eloca3.Parent = elocacenter
		local eloca4 = eloca1:Clone()
		eloca4.Parent = elocacenter
		shakes(0.5,0.5)
		sphere2(2,"Add",elocacenter.CFrame,vt(1,1,1),2,2,2,keptcolor)
		sphere2(3,"Add",elocacenter.CFrame,vt(1,1,1),4,4,4,keptcolor)
		sphere2(4,"Add",elocacenter.CFrame,vt(1,1,1),5,5,5,keptcolor)
		sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),6,6,6,keptcolor)
		sphere2(3,"Add",elocacenter.CFrame,vt(1,1,1),25,0.1,25,keptcolor)
		sphere2(4,"Add",elocacenter.CFrame,vt(1,1,1),25,0.1,25,keptcolor)
		CFuncs["Sound"].Create("rbxassetid://419447292", char, 4, 1)
		local effx = Instance.new("ParticleEmitter",elocacenter)
		effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
		effx.LightEmission = 1
		effx.Color = ColorSequence.new(keptcolor.Color)
		effx.Rate = 500000
		effx.Lifetime = NumberRange.new(0.25,0.75)
		effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
		effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
		effx.Speed = NumberRange.new(0,10)
		effx.Drag = 5
		effx.Rotation = NumberRange.new(-500,500)
		effx.VelocitySpread = 9000
		effx.RotSpeed = NumberRange.new(-50,50)
		coroutine.resume(coroutine.create(function()
			wait(0.05)
			effx.Enabled = false
		end))
		coroutine.resume(coroutine.create(function()
			for i = 0, 9, 0.1 do
				swait()
				mult = mult + 0.5
				lookavec = lookavec + 0.1*mult
				sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
				elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
				eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
				eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
				eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
				eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
			end
			for i = 0, 19 do
				for i = 0, 1, 0.1 do
					swait()
					sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
					elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
					eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
					eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
					eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
					eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
				end
				local lb = Instance.new("Part")
				lb.Color = keptcolor.Color
				lb.CanCollide = false
				lb.Material = "Neon"
				lb.Anchored = true
				lb.TopSurface = 0
				lb.BottomSurface = 0
				lb.Transparency = 0
				lb.Size = vt(1,1,1)
				lb.CFrame = elocacenter.CFrame*CFrame.new(math.random(-150,150),0,math.random(-150,150))*CFrame.Angles(math.rad(-90 + math.random(-15,15)),0,math.rad(math.random(-15,15)))
				lb.Anchored = false
				lb.Parent = char
				local thingery = Instance.new("SpecialMesh",lb)
				thingery.MeshType = "Sphere"
				thingery.Scale = vt(20,20,20)
				game:GetService("Debris"):AddItem(lb, 10)
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = lb.CFrame.lookVector*math.random(125,350)
				bv.Parent = lb
				sphere(2.5,"Add",lb.CFrame,vt(50,50,0),0.25,keptcolor)
				sphere(5,"Add",lb.CFrame,vt(50,50,0),0.5,keptcolor)
				CFuncs["Sound"].Create("rbxassetid://633627961",lb, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://1002081188", lb, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://741272936", lb, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://1192402877", lb, 10, 1)
				local hitted = false
				local tril = Instance.new("ParticleEmitter",lb)
				tril.Texture = "rbxassetid://144580273" -- 144580273 74564879
				tril.LightEmission = 1
				tril.Color = ColorSequence.new(keptcolor.Color)
				tril.Rate = 500000
				tril.Lifetime = NumberRange.new(0.5,1)
				tril.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(1,0,0)})
				tril.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
				tril.Speed = NumberRange.new(0,10)
				tril.Drag = 5
				tril.Rotation = NumberRange.new(-500,500)
				tril.VelocitySpread = 9000
				tril.RotSpeed = NumberRange.new(-50,50)
				game:GetService("Debris"):AddItem(a, 0.1)

				coroutine.resume(coroutine.create(function()
					lb.Touched:connect(function(hit)
						if hitted == false and hit.Parent ~= char then
							hitted = true
							lb.Transparency = 1
							lb.Anchored = true
							tril.Enabled = false
							CFuncs["EchoSound"].Create("rbxassetid://675172759", lb, 8, 0.8,0,10,0.15,0.5,1)
							CFuncs["EchoSound"].Create("rbxassetid://782200047", lb, 10, 1.1,0,10,0.15,0.5,1)
							MagniDamage(lb, 60, 50,100, 0, "Normal")
							CamShakeAll(25,15,char)
							local effx = Instance.new("ParticleEmitter",lb)
							effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
							effx.LightEmission = 1
							effx.Color = ColorSequence.new(keptcolor.Color)
							effx.Rate = 500000
							effx.Lifetime = NumberRange.new(0.25,0.75)
							effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
							effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							effx.Speed = NumberRange.new(0,10)
							effx.Drag = 5
							effx.Rotation = NumberRange.new(-500,500)
							effx.VelocitySpread = 9000
							effx.RotSpeed = NumberRange.new(-50,50)
							sphere(5,"Add",lb.CFrame,vt(20,20,20),1,keptcolor)
							sphere(6,"Add",lb.CFrame,vt(20,20,20),2,keptcolor)
							wait(0.05)
							effx.Enabled = false
						end
					end)
				end))
			end
			for i = 0, 9, 0.1 do
				swait()
				mult = mult - 0.5
				lookavec = lookavec - 0.1*mult
				sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
				elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
				eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
				eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
				eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
				eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
			end
			for i,v in pairs(elocacenter:GetDescendants()) do
				if v:IsA("ParticleEmitter") then
					v.Enabled = false
				end
			end
			wait(6)
			elocacenter:Destroy()
		end))
		attack = false
		hum.WalkSpeed = storehumanoidWS	
	end

	function CatMets()
		attack = true
		hum.WalkSpeed = 0
		local lookavec = 0 
		local mult = 1
		local keptcolor = MAINRUINCOLOR
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("YOUR FAITH IS UPON THIS SKY!!",MAINRUINCOLOR.Color,2.5)
		elseif radm == 2 then
			bosschatfunc("DISASTER SKY!!",MAINRUINCOLOR.Color,2.5)
		elseif radm == 3 then
			bosschatfunc("YOU SHOULD THINK ABOUT THAT AGAIN!!",MAINRUINCOLOR.Color,2.5)
		end
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 7, 1.25)
		for i = 0,4,0.1 do
			swait()
			slash(math.random(25,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,10,1)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.01,0.5),-0.5,keptcolor)
			sphere2(3,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(3,3,3),0.09,0.09,0.09,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 5 * math.cos(sine / 51))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 44))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 43),0 - 0.25 * math.cos(sine / 53),6 + 1 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-35),math.rad(0),math.rad(0)),.1)
			RW.C0 = clerp(RW.C0, CFrame.new(1.25, 1, -0.5) * angles(math.rad(170), math.rad(0), math.rad(-20)), 0.1)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 1, -0.5) * angles(math.rad(170), math.rad(0), math.rad(20)), 0.1)
		end
		sphere2(2,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(3,3,3),0.9,0.9,0.9,keptcolor)
		sphere2(4,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(3,3,3),0.9,0.9,0.9,keptcolor)
		sphere2(3,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(1,10000,1),0.09,0.09,0.09,keptcolor)
		local elocacenter = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
		elocacenter.Anchored = true
		elocacenter.CFrame = root.CFrame*CFrame.new(0,235,0)
		local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca1.Anchored = true
		eloca1.CFrame = elocacenter.CFrame
		local at1 = Instance.new("Attachment",eloca1)
		at1.Position = vt(0,30,0)
		local at2 = Instance.new("Attachment",eloca1)
		at2.Position = vt(0,-30,0)
		local at1b = Instance.new("Attachment",eloca1)
		at1b.Position = vt(0,0,180)
		local at2b = Instance.new("Attachment",eloca1)
		at2b.Position = vt(0,0,-180)
		local trl = Instance.new('Trail',eloca1)
		trl.Attachment0 = at1
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 1
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(keptcolor.Color)
		trl.Lifetime = 4
		local trl2 = trl:Clone()
		trl2.Parent = eloca1
		trl2.Attachment0 = at1b
		trl2.Attachment1 = at2b
		trl2.Texture = "rbxassetid://2108945559"
		trl2.Lifetime = 2
		local eff = Instance.new("ParticleEmitter",eloca1)
		eff.Texture = "rbxassetid://2273224484"
		eff.LightEmission = 1
		eff.Color = ColorSequence.new(keptcolor.Color)
		eff.Rate = 500000
		eff.Lifetime = NumberRange.new(0.5,3)
		eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
		eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
		eff.Speed = NumberRange.new(20,250)
		eff.Drag = 5
		eff.Rotation = NumberRange.new(-500,500)
		eff.VelocitySpread = 9000
		eff.RotSpeed = NumberRange.new(-50,50)
		local eloca2 = eloca1:Clone()
		eloca2.Parent = elocacenter
		local eloca3 = eloca1:Clone()
		eloca3.Parent = elocacenter
		local eloca4 = eloca1:Clone()
		eloca4.Parent = elocacenter
		shakes(0.5,0.5)
		sphere2(2,"Add",elocacenter.CFrame,vt(1,1,1),2,2,2,keptcolor)
		sphere2(3,"Add",elocacenter.CFrame,vt(1,1,1),4,4,4,keptcolor)
		sphere2(4,"Add",elocacenter.CFrame,vt(1,1,1),5,5,5,keptcolor)
		sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),6,6,6,keptcolor)
		sphere2(3,"Add",elocacenter.CFrame,vt(1,1,1),25,0.1,25,keptcolor)
		sphere2(4,"Add",elocacenter.CFrame,vt(1,1,1),25,0.1,25,keptcolor)
		local effx = Instance.new("ParticleEmitter",elocacenter)
		effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
		effx.LightEmission = 1
		effx.Color = ColorSequence.new(keptcolor.Color)
		effx.Rate = 500000
		effx.Lifetime = NumberRange.new(0.25,0.75)
		effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
		effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
		effx.Speed = NumberRange.new(0,10)
		effx.Drag = 5
		effx.Rotation = NumberRange.new(-500,500)
		effx.VelocitySpread = 9000
		effx.RotSpeed = NumberRange.new(-50,50)
		coroutine.resume(coroutine.create(function()
			wait(0.05)
			effx.Enabled = false
		end))
		coroutine.resume(coroutine.create(function()
			for i = 0, 9*2, 0.1 do
				swait()
				mult = mult + 0.5
				lookavec = lookavec + 0.1*mult
				sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
				elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
				eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
				eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
				eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
				eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
			end
			for i = 0, 272.5 do
				for i = 0, 0.175, 0.1 do
					swait()
					sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
					elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
					eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
					eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
					eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
					eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
				end
				local lb = Instance.new("Part")
				lb.Color = keptcolor.Color
				lb.CanCollide = false
				lb.Material = "Neon"
				lb.Anchored = true
				lb.TopSurface = 0
				lb.BottomSurface = 0
				lb.Transparency = 0
				lb.Size = vt(1,1,1)
				lb.CFrame = elocacenter.CFrame*CFrame.new(math.random(-525,525),0,math.random(-525,525))*CFrame.Angles(math.rad(-90 + math.random(-30,30)),0,math.rad(math.random(-30,30)))
				lb.Anchored = false
				lb.Parent = char
				local thingery = Instance.new("SpecialMesh",lb)
				thingery.MeshType = "Sphere"
				thingery.Scale = vt(20,20,20)
				game:GetService("Debris"):AddItem(lb, 10)
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = lb.CFrame.lookVector*math.random(200,525)
				bv.Parent = lb
				sphere(2.5,"Add",lb.CFrame,vt(50,50,0),0.25,keptcolor)
				sphere(5,"Add",lb.CFrame,vt(50,50,0),0.5,keptcolor)
				CFuncs["Sound"].Create("rbxassetid://633627961",lb, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://1002081188", lb, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://741272936", lb, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://1192402877", lb, 10, 1)
				local hitted = false
				local tril = Instance.new("ParticleEmitter",lb)
				tril.Texture = "rbxassetid://144580273" -- 144580273 74564879
				tril.LightEmission = 1
				tril.Color = ColorSequence.new(keptcolor.Color)
				tril.Rate = 500000
				tril.Lifetime = NumberRange.new(0.5,1)
				tril.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(1,0,0)})
				tril.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
				tril.Speed = NumberRange.new(0,10)
				tril.Drag = 5
				tril.Rotation = NumberRange.new(-500,500)
				tril.VelocitySpread = 9000
				tril.RotSpeed = NumberRange.new(-50,50)
				game:GetService("Debris"):AddItem(a, 0.1)

				coroutine.resume(coroutine.create(function()
					lb.Touched:connect(function(hit)
						if hitted == false and hit.Parent ~= char then
							hitted = true
							lb.Transparency = 1
							lb.Anchored = true
							tril.Enabled = false
							CFuncs["EchoSound"].Create("rbxassetid://675172759", lb, 8, 0.8,0,10,0.15,0.5,1)
							CFuncs["EchoSound"].Create("rbxassetid://782200047", lb, 10, 1.1,0,10,0.15,0.5,1)
							MagniDamage(lb, 60, 20,90, 0, "Normal")
							CamShakeAll(25,15,char)
							local effx = Instance.new("ParticleEmitter",lb)
							effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
							effx.LightEmission = 1
							effx.Color = ColorSequence.new(keptcolor.Color)
							effx.Rate = 500000
							effx.Lifetime = NumberRange.new(0.25,0.75)
							effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
							effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							effx.Speed = NumberRange.new(0,10)
							effx.Drag = 5
							effx.Rotation = NumberRange.new(-500,500)
							effx.VelocitySpread = 9000
							effx.RotSpeed = NumberRange.new(-50,50)
							sphere(5,"Add",lb.CFrame,vt(20,20,20),1,keptcolor)
							sphere(6,"Add",lb.CFrame,vt(20,20,20),2,keptcolor)
							wait(0.05)
							effx.Enabled = false
						end
					end)
				end))
			end
			for i = 0, 9, 0.1 do
				swait()
				mult = mult - 0.5
				lookavec = lookavec - 0.1*mult
				sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
				elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
				eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
				eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
				eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
				eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
			end
			for i,v in pairs(elocacenter:GetDescendants()) do
				if v:IsA("ParticleEmitter") then
					v.Enabled = false
				end
			end
			wait(6)
			elocacenter:Destroy()
		end))
		attack = false
		hum.WalkSpeed = storehumanoidWS	
	end

	function EternalChaosOrb()
		attack = true
		hum.WalkSpeed = 1
		CFuncs["EchoSound"].Create("rbxassetid://1448033299", char, 3, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1448033299", root, 10, 1,0,10,0.15,0.5,1)
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("How do you like this..",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("The Eternal life..",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("Orby..",MAINRUINCOLOR.Color,1)
		end
		local keptcolor = MAINRUINCOLOR
		CFuncs["Sound"].Create("rbxassetid://1042700914", root, 5, 0.25)
		for i = 0,14,0.1 do
			swait()
			sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Lime green"),Color3.new(0,1,0))
			slash(math.random(25,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,6,1)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.2,0.01,0.2),-0.2,BrickColor.new(0,MRANDOM(0,1),0))
			sphere2(3,"Add",root.CFrame*CFrame.new(0,6,0) + root.CFrame.lookVector*1,vt(3,3,3),0.06,0.06,0.06,MAINRUINCOLOR)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-35),math.rad(0),math.rad(0)),.1)
			RW.C0 = clerp(RW.C0, CFrame.new(1.25, 1, -0.5) * angles(math.rad(170), math.rad(0), math.rad(-20)), 0.1)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 1, -0.5) * angles(math.rad(170), math.rad(0), math.rad(20)), 0.1)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(0)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
		end
		local dis = CreateParta(char,0,1,"Neon",BrickColor.new("Lime green"))
		for i = 0, 4 do
			CFuncs["Sound"].Create("rbxassetid://335657174", dis, 10, 0.5)
		end
		dis.CFrame = root.CFrame*CFrame.new(0,5,-3)
		CreateMesh(dis,"Sphere",10,10,10)
		local at1 = Instance.new("Attachment",dis)
		at1.Position = vt(-5,0,0)
		local at2 = Instance.new("Attachment",dis)
		at2.Position = vt(5,0,0)
		local trl = Instance.new('Trail',dis)
		trl.Attachment0 = at1
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 1
		trl.FaceCamera = true
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(dis.Color)
		trl.Lifetime = 3
		local efec = Instance.new("ParticleEmitter",dis)
		efec.Texture = "rbxassetid://2109052855"
		efec.LightEmission = 1
		efec.Color = ColorSequence.new(Color3.new(0.5,0,1))
		efec.Rate = 5
		efec.Lifetime = NumberRange.new(3)
		efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,25,0),NumberSequenceKeypoint.new(0.2,50,0),NumberSequenceKeypoint.new(0.6,35,0),NumberSequenceKeypoint.new(0.8,50,0),NumberSequenceKeypoint.new(1,75,0)})
		efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.25,0),NumberSequenceKeypoint.new(0.6,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
		efec.Drag = 5
		efec.LockedToPart = true
		efec.Rotation = NumberRange.new(-500,500)
		efec.VelocitySpread = 9000
		efec.RotSpeed = NumberRange.new(-500,500)
		local a = Instance.new("Part",workspace)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			dis.CFrame.p,                           -- origin
			(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
		) 
		local ignore = dis
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (dis.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
		dis.CFrame = a.CFrame
		a:Destroy()
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = dis.CFrame.lookVector*100
		bv.Parent = dis
		game:GetService("Debris"):AddItem(dis, 15)
		local hitted = false
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if hitted == false and dis.Parent ~= nil then
					PixelBlock(3,math.random(0,2),"Add",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,5,0.05,BrickColor.new("Lime green"),0)
					trl.Color = ColorSequence.new(BrickColor.new("Earth green").Color)
					efec.Color = ColorSequence.new(BrickColor.new("Lime green").Color)
					coroutine.resume(coroutine.create(function()
						for i, v in pairs(FindNearestHead(dis.CFrame.p, 50)) do
							if v:FindFirstChild('Head') then
								dmg(v)
							end
						end
					end))
				elseif hitted == true and dis.Parent == nil then
					break
				end
			end
		end))
		coroutine.resume(coroutine.create(function()
			dis.Touched:connect(function(hit) 
				if hitted == false and hit.Parent ~= char then
					hitted = true
					shakes(1,1)
					efec.Enabled = false
					for i = 0, 3 do
						CFuncs["Sound"].Create("rbxassetid://1368637781", dis, 7.5,1)
						CFuncs["Sound"].Create("rbxassetid://763718160", dis, 10, 1.1)
						CFuncs["Sound"].Create("rbxassetid://782353443", dis, 10, 1)
						CFuncs["Sound"].Create("rbxassetid://335657174", dis, 10, 1)
					end
					MagniDamage(dis, 125, 82000,345700005, 0, "Normal")
					coroutine.resume(coroutine.create(function()
						for i, v in pairs(FindNearestHead(dis.CFrame.p, 100)) do
							if v:FindFirstChild('Head') then
								dmg(v)
							end
						end
					end))
					sphere2(2,"Add",dis.CFrame,vt(1,1,1),3,3,3,BrickColor.new("Earth green"),keptcolor.Color)
					sphere2(3,"Add",dis.CFrame,vt(1,1,1),3,3,3,BrickColor.new("Earth green"),keptcolor.Color)
					sphere2(4,"Add",dis.CFrame,vt(1,1,1),4,4,4,BrickColor.new("Lime green"),keptcolor.Color)
					sphere2(5,"Add",dis.CFrame,vt(1,1,1),4,4,4,BrickColor.new("Earth green"),keptcolor.Color)
					coroutine.resume(coroutine.create(function()
						local eff = Instance.new("ParticleEmitter",dis)
						eff.Texture = "rbxassetid://2344870656"
						eff.LightEmission = 1
						eff.Color = ColorSequence.new(dis.Color)
						eff.Rate = 10000000
						eff.Enabled = true
						eff.EmissionDirection = "Front"
						eff.Lifetime = NumberRange.new(3)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,20,0),NumberSequenceKeypoint.new(0.8,40,0),NumberSequenceKeypoint.new(1,60,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(350)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.SpreadAngle = Vector2.new(0,900)
						eff.RotSpeed = NumberRange.new(-500,500)
						wait(0.2)
						eff.Enabled = false
					end))
					coroutine.resume(coroutine.create(function()
						for i = 0, 9 do
							local disr = CreateParta(char,1,1,"Neon",keptcolor)
							disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
							local at1 = Instance.new("Attachment",disr)
							at1.Position = vt(-30,0,0)
							local at2 = Instance.new("Attachment",disr)
							at2.Position = vt(30,0,0)
							local trl = Instance.new('Trail',disr)
							trl.Attachment0 = at1
							trl.FaceCamera = true
							trl.Attachment1 = at2
							trl.Texture = "rbxassetid://2342682798"
							trl.LightEmission = 1
							trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
							trl.Color = ColorSequence.new(BrickColor.new(0,MRANDOM(0,1),0).Color)
							trl.Lifetime = 0.5
							local bv = Instance.new("BodyVelocity")
							bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
							bv.velocity = disr.CFrame.lookVector*math.random(150,350)
							bv.Parent = disr
							local val = 0
							coroutine.resume(coroutine.create(function()
								swait(30)
								for i = 0, 9 do
									swait()
									val = val + 0.1
									trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
								end
								game:GetService("Debris"):AddItem(disr, 3)
							end))
						end
						local eff = Instance.new("ParticleEmitter",dis)
						eff.Texture = "rbxassetid://2273224484"
						eff.LightEmission = 1
						eff.Color = ColorSequence.new(BrickColor.new(0,MRANDOM(0,1),0).Color)
						eff.Rate = 500000
						eff.Lifetime = NumberRange.new(0.5,2)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,4,0),NumberSequenceKeypoint.new(1,0,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(100,400)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.VelocitySpread = 9000
						eff.RotSpeed = NumberRange.new(-50,50)
						wait(0.25)
						eff.Enabled = false
					end))
					for i = 0, 19 do
						slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(200,800)/250,BrickColor.new("Really black"))
					end
					for i = 0, 49 do
						PixelBlock(1,math.random(5,40),"Add",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10,10,10,0.2,BrickColor.new("Lime green"),0)
					end
					coroutine.resume(coroutine.create(function()
						for i = 0, 19 do
							swait()
							hum.CameraOffset = vt(math.random(-10,10)/70,math.random(-10,10)/70,math.random(-10,10)/70)
						end
						hum.CameraOffset = vt(0,0,0)
					end))
					dis.Anchored = true
					dis.Transparency = 1
					wait(8)
					dis:Destroy()
				end
			end)
		end))
		for i = 0,2,0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.5)* angles(math.rad(30),math.rad(0),math.rad(0)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(-10)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(10)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-0.75 - 0.05 * math.cos(sine / 25),-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(30)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function lovesqueal()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://2500548008", root, 2.5, 1)
		local blush = Instance.new("Decal",hed)
		blush.Texture = "rbxassetid://898404027"
		blush.Face = "Front"
		for i = 0, 11, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(3),math.rad(0),math.rad(20 - 2 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(6),math.rad(0),math.rad(-20 + 2 * math.cos(sine / 32))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.2 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(20 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20 - 5 * math.cos(sine / 37)),math.rad(0 + 14 * math.cos(sine / 58)),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(3 + 3 * math.cos(sine / 45))),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-3 - 3 * math.cos(sine / 45))),.1)
		end
		for x = 0, 1 do
			for i = 0, 1, 0.2 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(3),math.rad(0),math.rad(-5 - 2 * math.cos(sine / 32))),.3)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(6),math.rad(0),math.rad(5 + 2 * math.cos(sine / 32))),.3)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.05 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(-5 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.3)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 - 5 * math.cos(sine / 37)),math.rad(0 + 14 * math.cos(sine / 58)),math.rad(0)),.1)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(3 + 3 * math.cos(sine / 45))),.1)
				LW.C0=clerp(LW.C0,cf(-1,0.75 + 0.025 * math.cos(sine / 45),-0.6)*angles(math.rad(140 - 3 * math.cos(sine / 73)),math.rad(5 - 1 * math.cos(sine / 55)),math.rad(80 - 3 * math.cos(sine / 45))),.3)
			end
			for i = 0, 1, 0.2 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1.025 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(3),math.rad(0),math.rad(-5 - 2 * math.cos(sine / 32))),.3)
				LH.C0=clerp(LH.C0,cf(-1,-1.025 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(6),math.rad(0),math.rad(5 + 2 * math.cos(sine / 32))),.3)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.05 + 0.02 * math.cos(sine / 32),0.025 + 0.05 * math.cos(sine / 32))*angles(math.rad(-5 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.3)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 - 5 * math.cos(sine / 37)),math.rad(0 + 14 * math.cos(sine / 58)),math.rad(0)),.1)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(3 + 3 * math.cos(sine / 45))),.1)
				LW.C0=clerp(LW.C0,cf(-1,0.8 + 0.025 * math.cos(sine / 45),-0.6)*angles(math.rad(140 - 3 * math.cos(sine / 73)),math.rad(5 - 1 * math.cos(sine / 55)),math.rad(80 - 3 * math.cos(sine / 45))),.3)
			end
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 49 do
				swait()
				blush.Transparency = blush.Transparency + 0.02
			end
			blush:Destroy()
		end))
		attack = false
		hum.WalkSpeed = storehumanoidWS	
	end

	function shytaunty()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://543623779", char, 3, 1)
		for i = 0, 13, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28) + 0.05 * math.cos(sine / 44),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7 - 5 * math.cos(sine / 44)),math.rad(0),math.rad(-6 - 3 * math.cos(sine / 34))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28) - 0.05 * math.cos(sine / 44),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(3 + 5 * math.cos(sine / 44)),math.rad(0),math.rad(0 + 3 * math.cos(sine / 34))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.05 * math.cos(sine / 44),0 + 0.03 * math.cos(sine / 34),-0.05 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0 - 5 * math.cos(sine / 44)),math.rad(-5)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2 - 2.5 * math.cos(sine / 28)),math.rad(20 + 5 * math.cos(sine / 62)),math.rad(35 + 5 * math.cos(sine / 59))),.1)
			RW.C0=clerp(RW.C0,cf(1,0.5 + 0.1 * math.cos(sine / 28),-0.45)*angles(math.rad(22 - 1 * math.cos(sine / 53)),math.rad(0),math.rad(-60 + 2 * math.cos(sine / 37))),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.1 * math.cos(sine / 28),-0.45)*angles(math.rad(26 - 2 * math.cos(sine / 58)),math.rad(0),math.rad(59 - 3 * math.cos(sine / 57) )),.1)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function EndLess_Power()
		attack = true
		hum.WalkSpeed = 0
		ModeOfGlitch = 0
		MAINRUINCOLOR = BrickColor.new("Bright orange")
		newThemeCust("rbxassetid://899090278",0,1.01,1.75)
		local vel = Instance.new("BodyPosition", root)
		vel.P = 10000
		vel.D = 1000
		vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
		vel.position = root.CFrame.p + vt(0,250,0)
		CFuncs["Sound"].Create("rbxassetid://1295446488", char, 5, 0.5)
		CFuncs["Sound"].Create("rbxassetid://1368598393", char, 7.5, 0.5)
		for i = 0, 49 do
			slash(math.random(10,100)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.01,0.05),math.random(25,500)/250,BrickColor.new("White"))
		end
		for i = 0, 5, 0.1 do
			swait()
			CamShakeAll(5,15,char)
			RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
		end
		local efec = Instance.new("ParticleEmitter",root)
		efec.Texture = "rbxassetid://0"
		efec.LightEmission = 1
		efec.Color = ColorSequence.new(Color3.new(math.random(0.6,1),0,0))
		efec.Rate = 5
		efec.Lifetime = NumberRange.new(3)
		efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.2,40,0),NumberSequenceKeypoint.new(0.6,150,0),NumberSequenceKeypoint.new(0.8,75,0),NumberSequenceKeypoint.new(1,25,0)})
		efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.25,0),NumberSequenceKeypoint.new(0.6,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
		efec.Drag = 5
		efec.LockedToPart = true
		efec.Rotation = NumberRange.new(-500,500)
		efec.VelocitySpread = 9000
		efec.RotSpeed = NumberRange.new(-500,500)
		local absval = 0
		local efec2 = efec:Clone()
		efec2.LightEmission = 1
		efec2.Texture = "rbxassetid://2092248396"
		efec2.Parent = root
		efec2.Rate = 10
		efec2.Lifetime = NumberRange.new(2)
		efec2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,175,0),NumberSequenceKeypoint.new(0.5,150,0),NumberSequenceKeypoint.new(0.8,500,0),NumberSequenceKeypoint.new(1,1500*absval/3,0)})
		efec2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
		efec2.Speed = NumberRange.new(0)
		efec2.RotSpeed = NumberRange.new(-100,100)
		local efec3 = efec:Clone()
		efec3.LightEmission = 1
		efec3.Color = ColorSequence.new(Color3.new(math.random(0.6,1),0,0))
		efec3.Texture = "rbxassetid://2273224484"
		efec3.Parent = root
		efec3.Rate = 10000
		efec3.Drag = 5
		efec3.LockedToPart = false
		efec3.Lifetime = NumberRange.new(2)
		efec3.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,5,0),NumberSequenceKeypoint.new(0.5,10,0),NumberSequenceKeypoint.new(0.8,15,0),NumberSequenceKeypoint.new(1,0,0)})
		efec3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
		efec3.Speed = NumberRange.new(50,1550)
		efec3.RotSpeed = NumberRange.new(-100,100)
		CFuncs["Sound"].Create("rbxassetid://1368583274", char, 7.5, 0.25)
		repeat
			swait()
			CamShakeAll(5,15,char)
			absval = absval + 0.006
			efec2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,175*absval/3,0),NumberSequenceKeypoint.new(0.5,150*absval/3,0),NumberSequenceKeypoint.new(0.8,500*absval/3,0),NumberSequenceKeypoint.new(1,1500*absval/3,0)})
			slash(math.random(50,100)/10,2,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(absval/3.25,0.01,absval/3.25),math.random(50,100)/500,BrickColor.new(math.random(0,1),0,0))
			for i = 0, 2 do
				slash(math.random(10,100)/10,2,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.075,0.01,0.075),absval/3,BrickColor.new(math.random(0,1),0,0))
			end
			sphere2(4,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(6.25,1.25,6.25),-0.15,absval*2.5,-0.15,BrickColor.new(math.random(0,1),0,0))
			RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
		until kan.TimePosition > 19
		for i = 0, 17.5, 0.1 do
			swait()
			CamShakeAll(5,17.5,char)
			slash(math.random(50,100)/10,2,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(absval/3,0.01,absval/3),math.random(50,100)/500,BrickColor.new(math.random(0,1),0,0))
			for i = 0, 2 do
				slash(math.random(10,100)/10,2,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.15,0.01,0.15),absval/3,BrickColor.new(math.random(0,1),0,0))
			end
			sphere2(4,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(12.5,2.5,12.5),-0.15,absval*2.5,-0.15,BrickColor.new(math.random(0,1),0,0))
			RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
		end
		ModeOfGlitch = 765688533321
		storehumanoidWS = 260
		hum.WalkSpeed = 260
		rainbowmode = false
		unstablemode = true
		chaosmode = false
		CRAZED = false
		RecolorTextAndRename("UNSTABLE",Color3.new(1,1,1),Color3.new(1,0,0),"Arcade")
		MAINRUINCOLOR = BrickColor.new("Really black")
		RecolorThing(BrickColor.new("Institutional white"),BrickColor.new("Really red"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,BrickColor.new("Crimson"),0,BrickColor.new("Really black"),true,true)
		disably = false
		warnedpeople("UNSTABLE POWER!!","Arcade",BrickColor.new("Really red").Color,BrickColor.new("White").Color)
		disably = true
		efec.Enabled = false
		efec2.Enabled = false
		efec3.Enabled = false
		CFuncs["Sound"].Create("rbxassetid://1368637781", char, 5, 0.25)
		CFuncs["Sound"].Create("rbxassetid://1368637781", char, 5, 0.5)
		CFuncs["Sound"].Create("rbxassetid://1368637781", char, 5, 0.75)
		CFuncs["Sound"].Create("rbxassetid://1368637781", char, 7.5, 1)
		CFuncs["Sound"].Create("rbxassetid://1368605755", char, 7.5, 1)
		CFuncs["Sound"].Create("rbxassetid://763718160", char, 10, 0.5)
		CFuncs["Sound"].Create("rbxassetid://763718160", char, 10, 0.25)
		CFuncs["Sound"].Create("rbxassetid://782353443", char, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://782353443", char, 10, 0.75)
		CFuncs["LongSound"].Create("rbxassetid://782353443", char, 10, 0.5)
		CFuncs["LongSound"].Create("rbxassetid://782353443", char, 10, 0.25)
		for i = 0, 2 do
			CFuncs["Sound"].Create("rbxassetid://763717897", char, 10, 0.5)
			CFuncs["Sound"].Create("rbxassetid://1664711478", char, 10, 1)
		end
		for i = 0, 99 do
			local dis = CreateParta(char,1,1,"Neon",BrickColor.new(math.random(0,1),0,0))
			dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-25000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(25000,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.FaceCamera = true
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(BrickColor.new(math.random(0,1),0,0).Color)
			trl.Lifetime = 5
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 15)
		end
		for i = 0, 49 do
			sphere2(1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(10,10,10),-0.1,absval*100,-0.1,BrickColor.new(math.random(0,1),0,0))
		end
		for i = 0, 9, 0.1 do
			swait()
			shakes(2.1,0.2)

			for i = 0, 4 do
				slash(math.random(10,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(absval/2,0.01,absval/2),math.random(50,5000)/100,BrickColor.new(math.random(0,1),0,0))
			end
			RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
		end
		vel:Destroy()
		efec:Destroy()
		efec2:Destroy()
		efec3:Destroy()
		hum.WalkSpeed = 200
		attack = false
	end

	function PowerBeams()
		attack = true
		hum.WalkSpeed = 0 
		CFuncs["Sound"].Create("rbxassetid://159882644", root, 15, 1)
		CFuncs["EchoSound"].Create("rbxassetid://159882644", char, 1.8, 1,0.1,10,0.15,0.5,1)
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("YOU WONT STAY FOR TOO LONG.",MAINRUINCOLOR.Color,2)
		elseif radm == 2 then
			bosschatfunc("HOW MANY MINUTE WILL YOU LAST?!",MAINRUINCOLOR.Color,2)
		elseif radm == 3 then
			bosschatfunc("YOUR DEATH IS HERE!",MAINRUINCOLOR.Color,2)
		end
		local keptcolor = BrickColor.new(math.random(0.35,1),0,0)
		coroutine.resume(coroutine.create(function()
			wait(1.25)
			CamShakeAll(30,35,char)
			for i = 0, 13 do
				swait(6)
				local orb = Instance.new("Part", char)
				CFuncs["Sound"].Create("rbxassetid://663361028", char, 0.8, 1)
				orb.BrickColor = BrickColor.new(math.random(0.35,1),0,0)
				orb.CanCollide = false
				orb.FormFactor = 3
				orb.Name = "Ring"
				orb.Material = "Neon"
				orb.Size = Vector3.new(1, 1, 1)
				orb.Transparency = 0
				orb.TopSurface = 0
				orb.BottomSurface = 0
				orb.Anchored = true
				local orbm = Instance.new("SpecialMesh", orb)
				orbm.MeshType = "Sphere"
				orbm.Name = "SizeMesh"
				orbm.Scale = vt(5,5,5)
				orb.CFrame = root.CFrame*CFrame.new(math.random(-90,90),math.random(45,85),math.random(-90,90))
				sphere2(6,"Add",orb.CFrame,vt(1.25,1.25,1.25),0.025,0.025,0.025,BrickColor.new(math.random(0.35,1),0,0))
				for i = 0, 4 do
					slash(math.random(10,20)/10,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(10,50)/250,BrickColor.new("White"))
				end
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",orb)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(BrickColor.new(math.random(0.35,1),0,0).Color)
					eff.Rate = 1500
					eff.Lifetime = NumberRange.new(0.5,1)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,4,0),NumberSequenceKeypoint.new(0.2,1,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(10,30)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-500,500)
					wait(0.25)
					eff.Enabled = false
				end))
				coroutine.resume(coroutine.create(function()
					wait(1)
					CFuncs["Sound"].Create("rbxassetid://161006182", char, 0.8, 1.1)
					sphere2(3,"Add",orb.CFrame,vt(5,5,5),0.025,0.025,0.025,BrickColor.new(math.random(0.35,1),0,0))
					sphere2(4,"Add",orb.CFrame,vt(5,5,5),0.025,0.025,0.025,BrickColor.new(math.random(0.35,1),0,0))
					orb.Transparency = 1
					local a = Instance.new("Part",char)
					a.Name = "Direction"	
					a.Anchored = true
					a.BrickColor = BrickColor.new(math.random(0.35,1),0,0)
					a.Material = "Neon"
					a.Transparency = 0.25
					a.Shape = "Cylinder"
					local ht = Instance.new("Part",char)
					ht.Name = "DirectionHit"	
					ht.Anchored = true
					ht.BrickColor = BrickColor.new(math.random(0.35,1),0,0)
					ht.CanCollide = false
					ht.Transparency = 1
					ht.Size = vt(0.1,0.1,0.1)
					CFuncs["Sound"].Create("rbxassetid://183763487", char, 0.95, 1.2)
					CFuncs["Sound"].Create("rbxassetid://183763487", ht, 5, 1.2)
					a.CanCollide = false
					local ray = Ray.new(
						orb.CFrame.p,                           -- origin
						(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
					) 
					local ignore = char
					local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
					a.BottomSurface = 10
					a.TopSurface = 10
					local distance = (orb.CFrame.p - position).magnitude
					a.Size = Vector3.new(distance,1,1)
					a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
					ht.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
					sphere2(2,"Add",ht.CFrame,vt(20,20,20),0.15,0.15,0.15,BrickColor.new(math.random(0.35,1),0,0))
					sphere2(4,"Add",ht.CFrame,vt(20,20,20),0.15,0.15,0.15,BrickColor.new(math.random(0.35,1),0,0))
					MagniDamage(ht, 17.5, 65,99, 0, "Normal")
					CamShakeAll(15,5,char)
					coroutine.resume(coroutine.create(function()
						for i = 0, 9 do
							local disr = CreateParta(char,1,1,"Neon",BrickColor.new(math.random(0.35,1),0,0))
							disr.CFrame = ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
							local at1 = Instance.new("Attachment",disr)
							at1.Position = vt(-2,0,0)
							local at2 = Instance.new("Attachment",disr)
							at2.Position = vt(2,0,0)
							local trl = Instance.new('Trail',disr)
							trl.Attachment0 = at1
							trl.FaceCamera = true
							trl.Attachment1 = at2
							trl.Texture = "rbxassetid://2325530138"
							trl.LightEmission = 1
							trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
							trl.Color = ColorSequence.new(BrickColor.new(math.random(0.35,1),0,0).Color)
							trl.Lifetime = 0.5
							local bv = Instance.new("BodyVelocity")
							bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
							bv.velocity = disr.CFrame.lookVector*math.random(25,100)
							bv.Parent = disr
							local val = 0
							coroutine.resume(coroutine.create(function()
								swait(20)
								for i = 0, 9 do
									swait()
									val = val + 0.1
									trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
								end
								game:GetService("Debris"):AddItem(disr, 3)
							end))
						end
						local eff = Instance.new("ParticleEmitter",ht)
						eff.Texture = "rbxassetid://2273224484"
						eff.LightEmission = 1
						eff.Color = ColorSequence.new(BrickColor.new(math.random(0.35,1),0,0).Color)
						eff.Rate = 5000
						eff.Lifetime = NumberRange.new(0.5,1.5)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,30,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(1,0,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.5,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(5,100)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.VelocitySpread = 9000
						eff.RotSpeed = NumberRange.new(-50,50)
						wait(0.25)
						eff.Enabled = false
					end))
					for i = 0, 4 do
						slash(math.random(10,60)/10,5,true,"Round","Add","Out",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(10,75)/125,BrickColor.new("White"))
						sphere2(8,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(6,6,6),-0.005,0.125,-0.005,BrickColor.new(math.random(0.35,1),0,0))
						sphere2(4,"Add",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(4,2,4),-0.01,0.5,-0.01,BrickColor.new(math.random(0.35,1),0,0))
						local rsiz = math.random(10,30)
						sphereMK(math.random(2,4),0.25,"Add",ht.CFrame*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/3,rsiz/3,rsiz/3,0,BrickColor.new(math.random(0.35,1),0,0),0)
					end
					a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
					local msh = Instance.new("SpecialMesh",a)
					msh.MeshType = "Cylinder"
					msh.Scale = vt(1,2.5,2.5)
					for i = 0, 49 do
						swait()
						msh.Scale = msh.Scale + vt(0,0.01,0.01)
						a.Transparency = a.Transparency + 0.02
					end
					wait(1)
					orb:Destroy()
					a:Destroy()
					ht:Destroy()
				end))
				game:GetService("Debris"):AddItem(orb, 10)
			end
		end))
		for i = 0,14,0.1 do
			swait()
			sphere2(7,"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.075,-0.01,MAINRUINCOLOR)
			local snap = math.random(1,12)
			if snap == 1 then
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1)
			end
			sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really red"),BrickColor.new("Really red").Color)
			sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.25 * math.cos(sine / 50),0 + 0.25 * math.cos(sine / 43),6 + 1 * math.cos(sine / 32))*angles(math.rad(-13 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(40)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-23 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-40 + 2 * math.cos(sine / 53))),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(170 + 6 * math.cos(sine / 72)),math.rad(2 - 4 * math.cos(sine / 58)),math.rad(35 + 1 * math.cos(sine / 45))),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(6 - 5 * math.cos(sine / 59)),math.rad(73 - 3 * math.cos(sine / 45))),.1)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function Unstable_Taunt()
		attack = true
		hum.WalkSpeed = 0
		chatfunc("I don't have all day..",Color3.new(0,0,0),"Inverted","Antique",0.75)
		CFuncs["Sound"].Create("rbxassetid://159882303", root, 25, 1)
		CFuncs["Sound"].Create("rbxassetid://159882303", char, 4.5, 1)
		for i = 0,9,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.25 * math.cos(sine / 50),0 + 0.25 * math.cos(sine / 43),6 + 1 * math.cos(sine / 32))*angles(math.rad(-3 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 15 * math.cos(sine / 6)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-40 + 2 * math.cos(sine / 53))),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(170 + 6 * math.cos(sine / 72)),math.rad(2 - 4 * math.cos(sine / 58)),math.rad(-12.5 + 1 * math.cos(sine / 45))),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(6 - 5 * math.cos(sine / 59)),math.rad(73 - 3 * math.cos(sine / 45))),.1)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function smiter()
		local targetted = nil
		if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			targetted = mouse.Target.Parent
		end
		if targetted ~= nil then
			attack = true
			hum.WalkSpeed = 0
			coroutine.resume(coroutine.create(function()
				CFuncs["Sound"].Create("rbxassetid://1117054464", targetted.Head, 2, 1)
				sphere2(4,"Add",targetted.Head.CFrame,vt(8,8,8),0.1,0.1,0.1,MAINRUINCOLOR)
				local vel = Instance.new("BodyPosition", targetted.Head)
				vel.P = 12500
				vel.D = 1000
				vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
				vel.position = targetted.Head.CFrame.p
			end))
			CFuncs["Sound"].Create("rbxassetid://671759140", sorb2, 1, 1.2)
			for i = 0,4,0.1 do
				swait()
				sphere2(4,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.125,-0.01,MAINRUINCOLOR)
				RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-60)),0.2)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(60)),.2)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.2)
				LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-40)), 0.2)
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(0)),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(20),math.rad(5)),.2)
			end
			coroutine.resume(coroutine.create(function()
				CamShakeAll(30,35,char)
				MagniDamage(targetted.Head, 18, 18,30, 0, "Normal")
				CFuncs["Sound"].Create("rbxassetid://1042705869", targetted.Head, 6.5, 0.8)
				CFuncs["Sound"].Create("rbxassetid://1042716828", targetted.Head, 6.25, 0.8)
				CFuncs["Sound"].Create("rbxassetid://1117054464", targetted.Head, 5, 0.8)
				for i = 0, 19 do
					slash(math.random(10,50)/10,5,true,"Round","Add","Out",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(50,250)/250,BrickColor.new("White"))
				end
				sphere2(3,"Add",targetted.Head.CFrame,vt(0,40000,0),0.25,0,0.25,MAINRUINCOLOR)
				sphere2(2,"Add",targetted.Head.CFrame,vt(0,40000,0),0.25,0,0.25,MAINRUINCOLOR)
				sphere2(4,"Add",targetted.Head.CFrame,vt(0,0,0),0.5,0.5,0.5,MAINRUINCOLOR)
				sphere2(5,"Add",targetted.Head.CFrame,vt(0,0,0),0.5,0.5,0.5,MAINRUINCOLOR)
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",targetted.Head)
					eff.Texture = "rbxassetid://363275192"
					eff.LightEmission = 0.95
					eff.Color = ColorSequence.new(MAINRUINCOLOR.Color)
					eff.Rate = 10000
					eff.Lifetime = NumberRange.new(1.5)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.8,25,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(25,150)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					local eff2 = eff:Clone()
					eff2.Parent = targetted.Head
					eff2.LightEmission = 1
					eff2.Color = ColorSequence.new(Color3.new(0.75,0.5,1))
					eff2.Texture = "rbxassetid://2273224484"
					eff2.Rate = 10000
					eff2.Lifetime = NumberRange.new(1,3)
					eff2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,10,0),NumberSequenceKeypoint.new(1,0,0)})
					eff2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
					eff2.Drag = 5
					eff2.Speed = NumberRange.new(50,250)
					eff2.Rotation = NumberRange.new(-500,500)
					eff2.VelocitySpread = 9000
					wait(0.5)
					eff2.Enabled = false
					eff.Enabled = false
				end))
				for i = 0, 9 do
					sphere2(3,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(2,1,2),-0.02,3,-0.02,MAINRUINCOLOR)
				end
				for i = 0, 49 do
					local rsiz = math.random(10,50)
					sphereMK(math.random(1,4),1,"Add",targetted.Head.CFrame*CFrame.new(math.random(-20,20)/50,math.random(-20,20)/50,math.random(-20,20)/50)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,MAINRUINCOLOR,0)
				end
				game:GetService("Debris"):AddItem(vel,1)
				dmg(targetted)
			end))
			for i = 0,1,0.1 do
				swait()
				RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-70)),0.5)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(70)),.5)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.5)
				LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(40), math.rad(0), math.rad(-50)), 0.5)
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(0)),.5)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(20),math.rad(5)),.5)
			end
			attack = false
			hum.WalkSpeed = storehumanoidWS
		end
	end

	local ast = {187744332,1426044282}
	local CardT = {"LET'S PLAY SOME CARD SHALL WE?","WANNA SEE SOME MAGIC?","YOU'RE GETTING TRICKY!!","NOW MY TURN.."}
	local IDTECC = {"MEAN WHILE...","DO YOU REMEMBER ME?","COME OUT..","ROCK 'N ROLL!"}
	-------------------------------------

	Humanoid.Animator.Parent = nil

	-------------------------------------

	local NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance,parent)
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end

	if script.MeshValue.Value == "true" then

		local Core = script.newCORE
		Core.Parent = Character
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rainbowmode == false and Error == false and CRAZED == false then
					for i,v in pairs(Core:GetChildren())do
						if v.Name ~= "CORE2" then
							v.BrickColor = MAINRUINCOLOR
						end
					end
				elseif Error == true then
					for i,v in pairs(Core:GetChildren())do
						if v.Name ~= "CORE2" then
							v.BrickColor = BrickColor.Random()
						end
					end
				elseif CRAZED == true then
					for i,v in pairs(Core:GetChildren())do
						if v.Name ~= "CORE2" then
							v.BrickColor = BrickColor.new(0,0,1)
						end
					end
					swait(5)
					for i,v in pairs(Core:GetChildren())do
						if v.Name ~= "CORE2" then
							v.BrickColor = BrickColor.new(0,0,0)
						end
					end
				elseif rainbowmode == true then
					for i,v in pairs(Core:GetChildren())do
						if v.Name ~= "CORE2" then
							v.Color = Color3.new(r/255,g/255,b/255)
						end
					end
				end
			end
		end))
		for i,v in pairs(Core:GetChildren())do
			if v.Name ~= "Weld" then
				v.Transparency = 0
			end
		end
		local HWz = NewInstance('Weld',Character,{Part0 = tors, Part1 = Core.Weld, C0 = CFrame.new(0,0,-0.35) * CFrame.Angles(-99,-100,0)})
	end

	mouse = game.Players.LocalPlayer:GetMouse()

	local attacktype = 1
	mouse.Button1Down:connect(function()
		if attack == false and attacktype == 1 then
			attacktype = 2
			attackone()
		elseif attack == false and attacktype == 2 then
			attacktype = 3
			attacktwo()
		elseif attack == false and attacktype == 3 then
			attacktype = 1
			attackthree()
		elseif attack == false and attacktype == 4 then
			attacktype = 1
			--attackfour()
		end
	end)
	mouse.KeyDown:connect(function(k)
		if Diversial == false then
			if k == "q" and attack == false and ModeOfGlitch ~= 1 then
				--normalmog() ---Disabled due to crashing... only in VSB
				ModeOfGlitch = 1
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				newTheme("rbxassetid://415898123",48.6,1,1.25)
				RecolorTextAndRename("MAYHEM",Color3.new(0.25,0,0),Color3.new(1,0,0),"Antique")
				MAINRUINCOLOR = BrickColor.new("Really red")
				RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
			end
			if k == "b" and attack == false and ModeOfGlitch == 1 and ModeOfGlitch ~= 453453484635345 then
				ModeOfGlitch = 453453484635345
				storehumanoidWS = 25
				hum.WalkSpeed = 25
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("DEATH",Color3.new(0.2,0.2,0.2),Color3.new(0,0,0),"Bodoni")
				newTheme("rbxassetid://318062766",0,1.01,0.85)
				MAINRUINCOLOR = BrickColor.new("Really black")
				chatfunc("Death is not an escape..",MAINRUINCOLOR.Color,"Inverted","Arcade",1.2)
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Dark stone grey"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "e" and attack == false and ModeOfGlitch ~= 2 then
				ModeOfGlitch = 2
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("PURITY",Color3.new(0,1,1),Color3.new(1,1,1),"Code")
				newTheme("rbxassetid://1119453744",0,1,1.25)
				MAINRUINCOLOR = BrickColor.new("Toothpaste")
				RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "r" and attack == false and ModeOfGlitch ~= 3 then
				ModeOfGlitch = 3
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("CORRUPTION",Color3.new(0,0,0),Color3.new(0.35,0,1),"Antique")
				newTheme("rbxassetid://1283869370",58.15,0.98,1.25)
				MAINRUINCOLOR = BrickColor.new("Royal purple")
				RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "b" and attack == false and ModeOfGlitch == 3 then
				ModeOfGlitch = 3434
				storehumanoidWS = 100
				hum.WalkSpeed = 100
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("UNKNOWN",Color3.new(1,1,1),BrickColor.new("New Yeller").Color,"Code")
				newTheme("rbxassetid://1861780345",0,1,1.25)
				MAINRUINCOLOR = BrickColor.new("New Yeller")
				RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0.8,MAINRUINCOLOR,0.8,MAINRUINCOLOR,true,true)
			end
			if k == "m" and attack == false and ModeOfGlitch == 3 then
				attack = true
				ModeOfGlitch = 259394695439876
				hum.WalkSpeed = 0
				newThemeCust("rbxassetid://190845741",9,1,1.25)
				wait(2)
				for i = 0, 15, 0.1 do
					swait()
					RH.C0=clerp(RH.C0,cf(1, -1 - 0.025 * math.cos(sine/12), -0.01)*angles(math.rad(0),math.rad(83),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
					LH.C0=clerp(LH.C0,cf(-1, -1 - 0.05 * math.cos(sine/12), -0.01)*angles(math.rad(0),math.rad(-83),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0, 0, 0 + 0.05 * math.cos(sine / 12))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0, 0, 0 + ((1) - 1))*angles(math.rad(15 - 2.5 * math.sin(sine / 12)),math.rad(0),math.rad(0)),0.1)
					RW.C0=clerp(RW.C0,cf(1,0.35 + 0.125 * math.cos(sine / 12),-0.45)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.125 * math.cos(sine / 12),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
				end
				CamShakeAll(25,90,char)
				sphere(2,"Add",root.CFrame,vt(0,0,0),12.5,MAINRUINCOLOR)
				sphere(3,"Add",root.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
				sphere(1,"Add",root.CFrame,vt(0,0,0),7.5,MAINRUINCOLOR)
				sphere(2,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
				sphere(3,"Add",root.CFrame,vt(0,0,0),2.5,MAINRUINCOLOR)
				CFuncs["Sound"].Create("rbxassetid://847061203", char, 2,1)
				ModeOfGlitch = 146536
				storehumanoidWS = 12
				hum.WalkSpeed = 12
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("VANTA-X",Color3.new(0.15,0.15,0.15),Color3.new(0.35,0,1),"Fantasy")
				MAINRUINCOLOR = BrickColor.new("Bright violet")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Dark indigo"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
				attack = false
			end
			if k == "t" and attack == false and ModeOfGlitch ~= 4 then
				ModeOfGlitch = 4
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				unstablemode = false
				chaosmode = true
				CRAZED = false
				RecolorTextAndRename("CHAOS",Color3.new(0,0,0),Color3.new(1,1,1),"Arcade")
				newTheme("rbxassetid://1369263130",0,1.01,1.25)
				MAINRUINCOLOR = BrickColor.new("Black")
				RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "m" and attack == false and ModeOfGlitch == 4 and ModeOfGlitch ~= 102341 then
				TheoriesTran()
			end
			if k == "y" and attack == false and ModeOfGlitch ~= 5 then
				ModeOfGlitch = 5
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("DIVINITY",Color3.new(1,1,1),Color3.new(1,1,0.5),"SciFi")
				newTheme("rbxassetid://661079869",0,1.02,1.25)
				MAINRUINCOLOR = BrickColor.new("Bright yellow")
				RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "u" and attack == false and ModeOfGlitch ~= 6 then
				ModeOfGlitch = 6
				storehumanoidWS = 100
				hum.WalkSpeed = 100
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("EQUALITY",Color3.new(0,0,0),Color3.new(1,1,1),"Fantasy")
				newTheme("rbxassetid://1347011178",0,1.01,1.25)
				MAINRUINCOLOR = BrickColor.new("White")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("White"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "f" and attack == false and ModeOfGlitch ~= 8 then
				ModeOfGlitch = 8
				storehumanoidWS = 140
				hum.WalkSpeed = 140
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("DESTINY",Color3.new(1,1,1),BrickColor.new("Alder").Color,"Code")
				newThemeCust("rbxassetid://1495032271",0,1.01,1.25)
				MAINRUINCOLOR = BrickColor.new("Alder")
				RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "g" and attack == false and ModeOfGlitch ~= 9 then
				ModeOfGlitch = 9
				storehumanoidWS = 150
				hum.WalkSpeed = 150
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("INFECTION X",Color3.new(0,1,0),Color3.new(0,0.7,0),"Bodoni")
				newTheme("rbxassetid://798163149",0,1,1.4)
				MAINRUINCOLOR = BrickColor.new("Camo")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Camo"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "n" and attack == false and ModeOfGlitch == 9 and ModeOfGlitch ~= 103 then
				ModeOfGlitch = 103
				storehumanoidWS = 200
				hum.WalkSpeed = 200
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				blush.Transparency = 0
				RecolorTextAndRename("ACE-OF-SPADES",BrickColor.new("Really black").Color,BrickColor.new("New Yeller").Color,"SciFi")
				newTheme("rbxassetid://1986375341",0,1.02,1.2)
				MAINRUINCOLOR = BrickColor.new("New Yeller")
				disably = false
				warnedpeople(CardT[math.random(1,4)],"SciFi",BrickColor.new("Really black").Color,BrickColor.new("New Yeller").Color)
				disably = true
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Really black"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,BrickColor.new("Deep orange"),0,BrickColor.new("White"),true,true)
			end
			if k == "m" and attack == false and ModeOfGlitch == 102 and ModeOfGlitch ~= 1236 then
				ModeOfGlitch = 1236
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				blush.Transparency = 0
				RecolorTextAndRename("Loost :>",BrickColor.new("Hot pink").Color,BrickColor.new("Carnation pink").Color,"SciFi")
				newTheme("rbxassetid://736003449",0,1.07,2)
				MAINRUINCOLOR = BrickColor.new("Hot pink")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Carnation pink"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,BrickColor.new("Really blue"),1,BrickColor.new("Hot pink"),true,false)
			end
			if k == "m" and attack == false and ModeOfGlitch == 9 and ModeOfGlitch ~= 6518594185 then
				ModeOfGlitch = 6518594185
				storehumanoidWS = 200
				hum.WalkSpeed = 200
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				blush.Transparency = 0
				RecolorTextAndRename("IDOLS",BrickColor.new("Hot pink").Color,BrickColor.new("New Yeller").Color,"SciFi")
				newTheme("rbxassetid://2415462372",0,1.02,1.2)
				MAINRUINCOLOR = BrickColor.new("New Yeller")
				disably = false
				IdolsWarn(IDTECC[math.random(1,4)],"SciFi",BrickColor.new("Hot pink").Color,BrickColor.new("New Yeller").Color)
				disably = true
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Deep orange"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,BrickColor.new("Really blue"),0,BrickColor.new("Hot pink"),true,true)
			end
			if k == "n" and attack == false and ModeOfGlitch == 8889 and ModeOfGlitch ~= 808080808080808080808080 then
				ModeOfGlitch = 808080808080808080808080
				storehumanoidWS = 250
				hum.WalkSpeed = 250
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				CFuncs["Sound"].Create("rbxassetid://763717897", char, 4, 0.75)
				CFuncs["Sound"].Create("rbxassetid://763717897", char, 8, 0.5)
				CFuncs["Sound"].Create("rbxassetid://1192402877", char, 10, 0.5)
				CFuncs["Sound"].Create("rbxassetid://1664711478", char, 6, 0.5)
				RecolorTextAndRename("MYTHICAL",BrickColor.new("Dark indigo").Color,BrickColor.new("Really blue").Color,"Bodoni")
				newThemeCust("rbxassetid://398455752",0,1.01,2)
				disably = false
				warnedpeople("SYNTH ONBOUND!!","Arcade",BrickColor.new("Alder").Color,BrickColor.new("Pastel light blue").Color)
				disably = true
				MAINRUINCOLOR = BrickColor.new("Really blue")
				bosschatfunc("Are you gonna stop now or what?",MAINRUINCOLOR.Color,1)
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Dark indigo"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,BrickColor.new("Alder"),0,BrickColor.new("Pastel light blue"),true,true)
			end
			if k == "b" and attack == false and ModeOfGlitch == 8889 and ModeOfGlitch ~= 88893333388 then
				attack = true
				hum.WalkSpeed = 0
				--7.725
				newThemeCust("rbxassetid://1504604335",0,1.01,1.5)
				bosschatfunc("I have been waiting for so long.",MAINRUINCOLOR.Color,10)
				coroutine.resume(coroutine.create(function()
					local locat = Instance.new("Part", char)
					locat.CanCollide = false
					locat.FormFactor = 3
					locat.Name = "Ring"
					locat.Material = "Neon"
					locat.Size = Vector3.new(1, 1, 1)
					locat.Transparency = 1
					locat.TopSurface = 0
					locat.BottomSurface = 0
					locat.Anchored = true
					locat.CFrame = root.CFrame*CFrame.new(0,-3,0)
					local poste = 0
					local rotation = 0
					local upperpos = 0
					local rate = 0
					local x = locat
					for i = 0, 38.5, 0.1 do
						swait()
						local rsiz = math.random(150,450)
						local rsiz2 = math.random(10,45)
						sphere2(math.random(1,2),"Add",x.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))*CFrame.new(math.random(-200,200),math.random(-200,200),math.random(-200,200)),vt(1,1,1),-0.01,math.random(50,250)/10,-0.01,BrickColor.new("Royal purple"))
						sphereMK(1,4,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz2/2,rsiz2/2,rsiz2/2,0,MAINRUINCOLOR,-200)	
					end
				end))
				for i = 0, 47, 0.1 do
					swait()
					RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 5 * math.cos(sine / 51))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 44))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),0.925 + 0.15 * math.cos(sine / 32))*angles(math.rad(20 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1.35,0.5 + 0.025 * math.cos(sine / 45),-0.3)*angles(math.rad(145 + 3 * math.cos(sine / 79)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 6 * math.cos(sine / 73))),.1)
					LW.C0=clerp(LW.C0,cf(-1.35,0.5 + 0.025 * math.cos(sine / 45),-0.3)*angles(math.rad(150 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(27 - 6 * math.cos(sine / 33))),.1)
				end
				bosschatfunc("This won't be more easier now.",MAINRUINCOLOR.Color,10)
				for i = 0, 3, 0.1 do
					swait()
					sphere2(8,"Add",sorb2.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
					sphere2(8,"Add",sorb.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
					RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 5 * math.cos(sine / 51))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 44))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),0.925 + 0.15 * math.cos(sine / 32))*angles(math.rad(10 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1.2,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(50 + 7 * math.cos(sine / 79)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-43 + 10 * math.cos(sine / 73))),.1)
					LW.C0=clerp(LW.C0,cf(-1.2,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(65 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(47 - 6 * math.cos(sine / 33))),.1)
				end
				for i = 0, 3, 0.1 do
					swait()
					sphere2(8,"Add",sorb2.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
					sphere2(8,"Add",sorb.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
					RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 5 * math.cos(sine / 51))),.2)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 44))),.2)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1.2 + 0.15 * math.cos(sine / 32))*angles(math.rad(-15.5 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.2)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.2)
					RW.C0=clerp(RW.C0,cf(1,0.6 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(155 + 7 * math.cos(sine / 79)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-43 + 10 * math.cos(sine / 73))),.2)
					LW.C0=clerp(LW.C0,cf(-1,0.6 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(160 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(57 - 6 * math.cos(sine / 33))),.2)
				end
				coroutine.resume(coroutine.create(function()
					local locat = Instance.new("Part", char)
					locat.CanCollide = false
					locat.FormFactor = 3
					locat.Name = "Ring"
					locat.Material = "Neon"
					locat.Size = Vector3.new(1, 1, 1)
					locat.Transparency = 1
					locat.TopSurface = 0
					locat.BottomSurface = 0
					locat.Anchored = true
					locat.CFrame = root.CFrame*CFrame.new(0,-3,0)
					local poste = 0
					local rotation = 0
					local upperpos = 0
					local rate = 0
					local x = locat
					local rsiz = math.random(150,450)
					local rsiz2 = math.random(10,45)
					for i = 0, 99 do
						slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(250,2500)/250,BrickColor.new("White"))
					end
					for i = 0, 49 do
						rsiz = math.random(150,450)
						sphere2(math.random(1,4),"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(15,1,15),-0.05,math.random(25,500)/25,-0.05,BrickColor.new("Royal purple"))
					end
				end))
				for i = 0, 55 do
					local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
					dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
					local at1 = Instance.new("Attachment",dis)
					at1.Position = vt(-25000,0,0)
					local at2 = Instance.new("Attachment",dis)
					at2.Position = vt(25000,0,0)
					local trl = Instance.new('Trail',dis)
					trl.Attachment0 = at1
					trl.FaceCamera = true
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(MAINRUINCOLOR.Color)
					trl.Lifetime = 5
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
					bv.Parent = dis
					game:GetService("Debris"):AddItem(dis, 10)
				end
				ModeOfGlitch = 88893333388
				storehumanoidWS = 200
				hum.WalkSpeed = 200
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("CATASTROPHE",BrickColor.new("Royal purple").Color,BrickColor.new("Really blue").Color,"Bodoni")
				bosschatfunc("Evenly with your rejection.",MAINRUINCOLOR.Color,1)
				MAINRUINCOLOR = BrickColor.new("Royal purple")
				CFuncs["Sound"].Create("rbxassetid://419447292", char, 4, 1)
				sphere2(2,"Add",root.CFrame*CFrame.new(0,0,0),vt(3,3,3),1.8*2,1.8*2,1.8*2,MAINRUINCOLOR)
				sphere2(4,"Add",root.CFrame*CFrame.new(0,0,0),vt(3,3,3),1.8*2,1.8*2,1.8*2,MAINRUINCOLOR)
				sphere2(6,"Add",root.CFrame*CFrame.new(0,0,0),vt(1.5,0.5,1.5),20,0,20,BrickColor.new("Lilac"))
				sphere2(4,"Add",root.CFrame*CFrame.new(0,0,0),vt(1.5,0.5,1.5),20,0,20,BrickColor.new("Really blue"))
				sphere2(2,"Add",root.CFrame*CFrame.new(0,0,0),vt(1.5,0.5,1.5),20,0,20,MAINRUINCOLOR)
				sphere2(6,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(1,10000,1),1.8*2,7,1.8*2,BrickColor.new("Really blue"))
				sphere2(5,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(1,10000,1),1.6*2,7,1.6*2,BrickColor.new("Royal purple"))
				sphere2(4,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(1,10000,1),1.2*2,7,1.2*2,BrickColor.new("Really blue"))
				sphere2(3,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(1,10000,1),1*2,7,1*2,BrickColor.new("Royal purple"))
				coroutine.resume(coroutine.create(function()
					for i = 0, 5, 0.1 do
						swait()
						shakes(2.1,0.2)
					end
				end))
				local effx = Instance.new("ParticleEmitter",root)
				effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
				effx.LightEmission = 1
				effx.Color = ColorSequence.new(BrickColor.new("Royal purple").Color)
				effx.Rate = 500000
				effx.Lifetime = NumberRange.new(0.25,0.75)
				effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
				effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
				effx.Speed = NumberRange.new(0,10)
				effx.Drag = 5
				effx.Rotation = NumberRange.new(-500,500)
				effx.VelocitySpread = 9000
				effx.RotSpeed = NumberRange.new(-50,50)
				local effx2 = Instance.new("ParticleEmitter",root)
				effx2.Texture = "rbxassetid://2273224484"
				effx2.LightEmission = 1
				effx2.Color = ColorSequence.new(BrickColor.new("Royal purple").Color)
				effx2.Rate = 500000
				effx2.Lifetime = NumberRange.new(1,2)
				effx2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,200,0),NumberSequenceKeypoint.new(0.1,50,0),NumberSequenceKeypoint.new(0.8,25,0),NumberSequenceKeypoint.new(1,0,0)})
				effx2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
				effx2.Speed = NumberRange.new(50,1200)
				effx2.Drag = 5
				effx2.Rotation = NumberRange.new(-500,500)
				effx2.VelocitySpread = 9000
				effx2.RotSpeed = NumberRange.new(-50,50)
				local effx3 = effx2:Clone()
				effx3.Parent = root
				effx3.Color = ColorSequence.new(BrickColor.new("Really blue").Color)
				symbolizeBlink(root,0,144580273,BrickColor.new("Royal purple").Color,40,0,0,0,root,true,-5,2)
				symbolizeBlink(root,0,144580273,BrickColor.new("Really blue").Color,50,0,0,0,root,true,-5,1)
				coroutine.resume(coroutine.create(function()
					wait(0.3)
					effx.Enabled = false
					effx2.Enabled = false
					effx3.Enabled = false
				end))
				for i = 0, 1 do
					CFuncs["Sound"].Create("rbxassetid://763717897", char, 5, 1.25)
					CFuncs["Sound"].Create("rbxassetid://1192402877", char, 5,0.75)
					CFuncs["Sound"].Create("rbxassetid://1664711478", char, 2.5,1)
					CFuncs["Sound"].Create("rbxassetid://763718160", char, 5, 0.75)
				end
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Really blue"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,BrickColor.new("Navy blue"),0,BrickColor.new("Dark indigo"),true,true)
				for i = 0, 3, 0.1 do
					swait()
					RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 5 * math.cos(sine / 51))),.3)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 44))),.3)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(35.5 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.3)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.3)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-35 + 7 * math.cos(sine / 79)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(33 + 10 * math.cos(sine / 73))),.3)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-22 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-27 - 6 * math.cos(sine / 33))),.3)
				end
				attack = false
			end
			if k == "m" and attack == false and ModeOfGlitch == 8 and ModeOfGlitch ~= 8889 then
				ModeOfGlitch = 8889
				storehumanoidWS = 180
				hum.WalkSpeed = 180
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("CALAMITY",BrickColor.new("Alder").Color,BrickColor.new("Lilac").Color,"Antique")
				newThemeCust("rbxassetid://1359036559",11.7,1.01,1.5)
				MAINRUINCOLOR = BrickColor.new("Lilac")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Alder"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "m" and attack == false and ModeOfGlitch == 1 and ModeOfGlitch ~= 664663666 then
				newThemeCust("rbxassetid://723652641",0,1,1.25)
				attack = true
				hum.WalkSpeed = 0
				RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
				chatfunc("I'm really done with you..",MAINRUINCOLOR.Color,"Inverted","Arcade",3)
				MAINRUINCOLOR = BrickColor.new("Maroon")
				local keptcolor = MAINRUINCOLOR
				local locat = Instance.new("Part", char)
				locat.CanCollide = false
				locat.FormFactor = 3
				locat.Name = "Ring"
				locat.Material = "Neon"
				locat.Size = Vector3.new(1, 1, 1)
				locat.Transparency = 1
				locat.TopSurface = 0
				locat.BottomSurface = 0
				locat.Anchored = true
				locat.CFrame = root.CFrame*CFrame.new(0,-3,0)
				local poste = 0
				local rotation = 0
				local upperpos = 0
				local rate = 0
				local x = locat
				for i = 0, 24, 0.1 do
					swait()
					slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,50)/250,BrickColor.new("White"))
					sphereMK(1,-2,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MAINRUINCOLOR,100)
					RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
					LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
				end
				coroutine.resume(coroutine.create(function()
					CamShakeAll(25,30,char)
					sphere(5,"Add",root.CFrame,vt(0,0,0),2.5,MAINRUINCOLOR)
					CFuncs["Sound"].Create("rbxassetid://847061203", char, 0.5,1)
					wait(0.55)
					CamShakeAll(25,60,char)
					sphere(5,"Add",root.CFrame,vt(0,0,0),7.5,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),2.5,MAINRUINCOLOR)
					CFuncs["Sound"].Create("rbxassetid://847061203", char, 1,1)
					wait(0.55)
					CamShakeAll(25,90,char)
					sphere(5,"Add",root.CFrame,vt(0,0,0),12.5,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),7.5,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),2.5,MAINRUINCOLOR)
					CFuncs["Sound"].Create("rbxassetid://847061203", char, 2,1)
					wait(0.55)
					CamShakeAll(60,120,char)
					CFuncs["Sound"].Create("rbxassetid://763717897", char, 4, 1)
					CFuncs["Sound"].Create("rbxassetid://1192402877", char, 2.5, 0.75)
					CFuncs["Sound"].Create("rbxassetid://1664711478", char, 4, 0.95)
					sphere2(1,"Add",x.CFrame*CFrame.new(0,0,0),vt(15,0,15),5,0,5,BrickColor.new("Really black"))
					sphere2(2,"Add",x.CFrame*CFrame.new(0,0,0),vt(15,0,15),5,0,5,keptcolor)
					sphere2(1,"Add",x.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.new("Maroon"))
					sphere2(2,"Add",x.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.new("Really black"))
					sphere2(4,"Add",x.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,keptcolor)
					coroutine.resume(coroutine.create(function()
						for i = 0, 99 do
							local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
							dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
							local at1 = Instance.new("Attachment",dis)
							at1.Position = vt(-25000,0,0)
							local at2 = Instance.new("Attachment",dis)
							at2.Position = vt(25000,0,0)
							local bv = Instance.new("BodyVelocity")
							bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
							bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
							bv.Parent = dis
							game:GetService("Debris"):AddItem(dis, 10)
						end
						attack = false
						hum.WalkSpeed = storehumanoidWS
						for i = 0, 99 do
							slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(250,2500)/250,BrickColor.new("Maroon"))
						end
						for i = 0, 49 do
							local rsiz = math.random(150,450)
							sphere2(math.random(1,4),"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(15,1,15),-0.05,math.random(25,500)/25,-0.05,BrickColor.new("Really black"))
							sphere2(math.random(1,2),"Add",x.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))*CFrame.new(math.random(-350,350),math.random(-350,350),math.random(-350,350)),vt(1,1,1),-0.01,math.random(50,250)/10,-0.01,BrickColor.new("Really black"))
							sphereMK(math.random(1,2),math.random(2,4),"Add",x.CFrame*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,BrickColor.new("Maroon"),0)
						end
						coroutine.resume(coroutine.create(function()
							local eff = Instance.new("ParticleEmitter",x)
							eff.Texture = "rbxassetid://2092248396"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(BrickColor.new("Maroon").Color)
							eff.Rate = 50000
							eff.Lifetime = NumberRange.new(6,12)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,120,0),NumberSequenceKeypoint.new(0.2,25,0),NumberSequenceKeypoint.new(1,0.1,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(250,1500)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.VelocitySpread = 9000
							eff.RotSpeed = NumberRange.new(-100,100)
							wait(1.25)
							eff.Enabled = false
						end))
						sphere2(3,"Add",tors.CFrame,vt(1,1,1),10,10,10,keptcolor)
						sphere2(2,"Add",tors.CFrame,vt(1,1,1),10,10,10,BrickColor.new("Really black"))
						sphere2(1,"Add",tors.CFrame,vt(1,1,1),10,10,10,BrickColor.new("Maroon"))
					end))
				end))
				for i = 0, 12.5, 0.1 do
					swait()
					slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,50)/250,BrickColor.new("White"))
					sphereMK(1,-2,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MAINRUINCOLOR,100)
					RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
					LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
				end
				ModeOfGlitch = 664663666 
				storehumanoidWS = 175
				hum.WalkSpeed = 175
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("STRESSED",Color3.new(0.1,0,0),Color3.new(0.25,0,0),"Antique")
				MAINRUINCOLOR = BrickColor.new("Maroon")
				chatfunc("YOU'RE EXISTING IS WASTED!!",MAINRUINCOLOR.Color,"Inverted","Arcade",3)
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Really black"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
				attack = false
				hum.WalkSpeed = storehumanoidWS
			end
			if k == "m" and attack == false and ModeOfGlitch == 6 then
				ModeOfGlitch = 3444
				storehumanoidWS = 100
				hum.WalkSpeed = 100
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("TWISTED",Color3.new(1,1,1),BrickColor.new("Storm blue").Color,"Code")
				newTheme("rbxassetid://919231299",0,1,1)
				MAINRUINCOLOR = BrickColor.new("Storm blue")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Storm blue"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "n" and attack == false and ModeOfGlitch == 6 and ModeOfGlitch ~= 765688533321 then
				EndLess_Power()
			end
			if k == "n" and attack == false and ModeOfGlitch == 1 and ModeOfGlitch ~= 55469696922 then
				ModeOfGlitch = 55469696922
				storehumanoidWS = 275
				hum.WalkSpeed = 275
				rainbowmode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("NATURE",Color3.new(1,1,1),BrickColor.new("Forest green").Color,"Code")
				newTheme("rbxassetid://181761264",0,1,1.4)
				MAINRUINCOLOR = BrickColor.new("Forest green")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Forest green"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "n" and attack == false and ModeOfGlitch == 2 and ModeOfGlitch ~= 4367677813 then
				ModeOfGlitch = 4367677813
				storehumanoidWS = 225
				hum.WalkSpeed = 225
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("SHD",Color3.new(0.75,0.9,1),BrickColor.new("Pink").Color,"Arcade")
				newTheme("rbxassetid://363284685",0,1.01,1.25)
				MAINRUINCOLOR = BrickColor.new("Baby blue")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Pink"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "b" and attack == false and ModeOfGlitch == 9999999921111 and ModeOfGlitch ~= 101 then
				ModeOfGlitch = 101
				storehumanoidWS = 350
				hum.WalkSpeed = 350
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("ALPHA",BrickColor.new("Black").Color,BrickColor.new("Storm blue").Color,"SciFi")
				disably = false
				warnedpeople("A L P H A.","Arcade",BrickColor.new("Black").Color,BrickColor.new("Storm blue").Color)
				disably = true
				newTheme("rbxassetid://1280010741",0,1.01,1.8)
				MAINRUINCOLOR = BrickColor.new("Storm blue")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Black"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,BrickColor.new("Bright bluish green"),0,BrickColor.new("Really black"),true,true)
			end
			if k == "n" and attack == false and ModeOfGlitch == 8 and ModeOfGlitch ~= 9999999921111 then
				ModeOfGlitch = 9999999921111
				storehumanoidWS = 300
				hum.WalkSpeed = 300
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("OMEGA",BrickColor.new("Really black").Color,BrickColor.new("Bright bluish green").Color,"SciFi")
				newTheme("rbxassetid://643309199",0,1.01,1.5)
				MAINRUINCOLOR = BrickColor.new("Bright bluish green")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Really black"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "h" and attack == false and ModeOfGlitch ~= 102 then
				ModeOfGlitch = 102
				storehumanoidWS = 18
				hum.WalkSpeed = 18
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("U-K-E",BrickColor.new("White").Color,BrickColor.new("Deep orange").Color,"Code")
				newTheme("rbxassetid://1426044282",0,1,1.15)
				MAINRUINCOLOR = BrickColor.new("Deep orange")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Pastel orange"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
			end
			if k == "l" and attack == false and ModeOfGlitch ~= 343434 then
				rainbowmode = false
				unstablemode = false
				sphere(0.9,"Add",root.CFrame,vt(0,100000,0),1,BrickColor.new("Neon orange"))
				for i = 0, 49 do
					PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),8,8,8,0.16,BrickColor.new("CGA brown"),0)
				end
				ModeOfGlitch = 343434
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("FIRE-FLARES",BrickColor.new("Gold").Color,BrickColor.new("Neon orange").Color,"Antique")
				newTheme("rbxassetid://1259692095",0,1,1.25)
				MAINRUINCOLOR = BrickColor.new("CGA brown")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Neon orange"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "m" and attack == false and ModeOfGlitch == 343434 then
				ModeOfGlitch = 343435
				storehumanoidWS = 125
				hum.WalkSpeed = 125
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("FALLENNIGHT",BrickColor.new("Navy blue").Color,BrickColor.new("Really blue").Color,"SciFi")
				newTheme("rbxassetid://561833161",0,1,1.25)
				MAINRUINCOLOR = BrickColor.new("Really blue")
				bosschatfunc("Night have been fallen..",MAINRUINCOLOR.Color,0.9)
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Navy blue"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,BrickColor.new("Dark blue"),0,BrickColor.new("Deep blue"),true,true)
			end
			if k == "n" and attack == false and ModeOfGlitch == 999 then
				ModeOfGlitch = 1055
				storehumanoidWS = 50
				hum.WalkSpeed = 50
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("PANDORA",BrickColor.new("White").Color,BrickColor.new("Lavender").Color,"Code")
				newTheme("rbxassetid://1382488262",0,1,1.25)
				MAINRUINCOLOR = BrickColor.new("Lavender")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("White"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
			end
			if k == "k" and attack == false and ModeOfGlitch ~= 999 then
				ModeOfGlitch = 999
				storehumanoidWS = 34
				hum.WalkSpeed = 34
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("ENBELEIVED",Color3.new(1,1,1),Color3.new(1,1,1),"SciFi")
				newTheme("rbxassetid://286050652",0,1,1)
				MAINRUINCOLOR = BrickColor.new("Cloudy grey")
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Cloudy grey"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "j" and attack == false and ModeOfGlitch ~= 090 then
				ModeOfGlitch = 090
				storehumanoidWS = 250
				hum.WalkSpeed = 250
				rainbowmode = true
				unstablemode = false
				chaosmode = false
				CRAZED = false
				RecolorTextAndRename("RAINBOW",Color3.new(0.5,1,1),BrickColor.new("Really red").Color,"Antique")
				newTheme("rbxassetid://1747430851",0,1,1.15)
				MAINRUINCOLOR = BrickColor.new("Pastel green")
				RecolorThing(BrickColor.new("Deep orange"),BrickColor.new("Toothpaste"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,BrickColor.new("Deep orange"),true,false)
			end
			if k == "m" and attack == false and ModeOfGlitch == 090 then
				ModeOfGlitch = 909090
				storehumanoidWS = 250
				hum.WalkSpeed = 250
				rainbowmode = true
				unstablemode = false
				chaosmode = false
				CRAZED = false
				disably = false
				warnedpeople("Let's relax..","Highway",Color3.new(1,1,1),Color3.new(1,1,1))
				disably = true
				RecolorTextAndRename("AESTHETIC",Color3.new(0.5,1,1),BrickColor.new("Really red").Color,"Antique")
				newTheme("rbxassetid://1416617454",0,1,1.15)
				MAINRUINCOLOR = BrickColor.new("Pastel green")
				RecolorThing(BrickColor.new("Deep orange"),BrickColor.new("Toothpaste"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,BrickColor.new("Deep orange"),true,false)
			end
			if k == "n" and attack == false and ModeOfGlitch == 4 and ModeOfGlitch ~= 999999999556 then
				ModeOfGlitch = 999999999556
				storehumanoidWS = 500
				hum.WalkSpeed = 500
				rainbowmode = false
				unstablemode = false
				chaosmode = false
				CRAZED = true
				RecolorTextAndRename("CRAZED",BrickColor.new("Really black").Color,BrickColor.new("Navy blue").Color,"Code")
				newTheme("rbxassetid://719008519",0,1.02,1.25)
				MAINRUINCOLOR = BrickColor.new("Navy blue")
				bosschatfunc("HAHAHAHAHAHA!!!",MAINRUINCOLOR.Color,3)
				RecolorThing(MAINRUINCOLOR,BrickColor.new("Really black"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,BrickColor.new("Navy blue"),0,BrickColor.new("Really blue"),true,true)
			end
			if k == "n" and attack == false and ModeOfGlitch == 5 and ModeOfGlitch ~= 1264532489 then
				newThemeCust("rbxassetid://1505487022",0,1.01,1.7)
				attack = true
				hum.WalkSpeed = 0
				chatfunc("The justice will never be fallen..",MAINRUINCOLOR.Color,"Inverted","Arcade",5)
				local keptcolor = MAINRUINCOLOR
				local locat = Instance.new("Part", char)
				locat.CanCollide = false
				locat.FormFactor = 3
				locat.Name = "Ring"
				locat.Material = "Neon"
				locat.Size = Vector3.new(1, 1, 1)
				locat.Transparency = 1
				locat.TopSurface = 0
				locat.BottomSurface = 0
				locat.Anchored = true
				locat.CFrame = root.CFrame*CFrame.new(0,-3,0)
				local poste = 0
				local rotation = 0
				local upperpos = 0
				local rate = 0
				local x = locat
				coroutine.resume(coroutine.create(function()
					wait(1.2)
					repeat
						wait(0.175)
						CFuncs["Sound"].Create("rbxassetid://1890951521", RootPart, 4, math.random(0.9,1.5))
					until kan.TimePosition > 6.55
				end))
				repeat
					swait()
					sphereMK(1,-2,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MAINRUINCOLOR,100)
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-35 - 1 * math.cos(sine / 28)),math.rad(0 + 10 * math.cos(sine / 79)),math.rad(25 + 4 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-2 - 4 * math.cos(sine / 28)),math.rad(-20),math.rad(18 + 8 * math.cos(sine / 28))),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(170 + 3 * math.cos(sine / 46)),math.rad(10 + 5 * math.cos(sine / 52)),math.rad(-10 - 2 * math.cos(sine / 28))),.1)
				until kan.TimePosition > 5.55
				coroutine.resume(coroutine.create(function()
					CamShakeAll(25,60,char)
					chatfunc("You are..",MAINRUINCOLOR.Color,"Inverted","Arcade",1)
					sphere(5,"Add",root.CFrame,vt(0,0,0),7.5,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),2.5,MAINRUINCOLOR)
					CFuncs["Sound"].Create("rbxassetid://847061203", char, 1,1)
					wait(0.55)
					chatfunc("JUST A DIRTY BAD GUY!!!",MAINRUINCOLOR.Color,"Inverted","Arcade",3)
					CamShakeAll(25,90,char)
					sphere(5,"Add",root.CFrame,vt(0,0,0),12.5,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),7.5,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(5,"Add",root.CFrame,vt(0,0,0),2.5,MAINRUINCOLOR)
					CFuncs["Sound"].Create("rbxassetid://847061203", char, 2,1)
					wait(0.55)
					ModeOfGlitch = 1264532489
					storehumanoidWS = 250
					hum.WalkSpeed = 250
					rainbowmode = false
					unstablemode = false
					chaosmode = false
					CRAZED = false
					RecolorTextAndRename("FALLENX",Color3.new(0.5,1,1),BrickColor.new("Deep orange").Color,"Antique")
					MAINRUINCOLOR = BrickColor.new("Pastel green")
					bosschatfunc("WHO'S DARE TO CHALLENGE ME?!",MAINRUINCOLOR.Color,3)
					RecolorThing(BrickColor.new("Deep orange"),BrickColor.new("Toothpaste"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,MAINRUINCOLOR,0,BrickColor.new("Deep orange"),true,true)
					CamShakeAll(60,120,char)
					CFuncs["Sound"].Create("rbxassetid://763717897", char, 4, 1)
					CFuncs["Sound"].Create("rbxassetid://1192402877", char, 2.5, 0.75)
					CFuncs["Sound"].Create("rbxassetid://1664711478", char, 4, 0.95)
					tbeam(BrickColor.new("Deep orange"),BrickColor.new("Toothpaste"))
				end))
				for i = 0, 9, 0.1 do
					swait()
					slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,50)/250,BrickColor.new("White"))
					RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(2),math.rad(0),math.rad(-16 + 4 * math.cos(sine / 34))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1.5),math.rad(10),math.rad(11 + 2 * math.cos(sine / 34))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 28))*angles(math.rad(-6 - 3 * math.cos(sine / 34)),math.rad(0),math.rad(-25 - 4 * math.cos(sine / 53))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 1 * math.cos(sine / 28)),math.rad(0 + 10 * math.cos(sine / 79)),math.rad(25 + 4 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-2 - 4 * math.cos(sine / 28)),math.rad(-20),math.rad(18 + 8 * math.cos(sine / 28))),.1)
				end
				attack = false
			end

		elseif Diversial == true then
			-- Diversial Glitcher Started

			if k == "q" and attack == false and ModeOfGlitch ~= 676767 then
				ModeOfGlitch = 676767
				storehumanoidWS = 250
				hum.WalkSpeed = 250
				rainbowmode = false
				chaosmode = false
				CRAZED = false
				Error = false
				RecolorTextAndRename("MULTI-DIVERSIAL",Color3.new(1,1,1),BrickColor.new("Royal purple").Color,"SciFi")
				newTheme("rbxassetid://603567552",0,1.02,1.25)
				MAINRUINCOLOR = BrickColor.new("Royal purple")
				RecolorThing2(BrickColor.new("Royal purple"),BrickColor.new("Royal purple"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,MAINRUINCOLOR,0,BrickColor.new("Royal purple"),true,true)
			end
			if k == "g" and attack == false and ModeOfGlitch ~= 71 then
				ModeOfGlitch = 71
				storehumanoidWS = 12
				hum.WalkSpeed = 12
				rainbowmode = false
				chaosmode = false
				Error = false
				CRAZED = false
				RecolorTextAndRename("PLAGUES",Color3.new(0,0.3,0),BrickColor.new("Lime green").Color,"Code")
				newTheme("rbxassetid://577543579",0,1,1.25)
				MAINRUINCOLOR = BrickColor.new("Lime green")
				chatfunc("The plague is already inside..",MAINRUINCOLOR.Color,"Inverted","Arcade",1.7)
				RecolorThing2(MAINRUINCOLOR,BrickColor.new("Earth green"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,false)
			end
			if k == "e" and attack == false and ModeOfGlitch ~= 2332 then
				ModeOfGlitch = 2332
				storehumanoidWS = 12
				hum.WalkSpeed = 12
				rainbowmode = false
				chaosmode = false
				Error = false
				CRAZED = false
				RecolorTextAndRename("NANNIIH",Color3.new(1,1,1),BrickColor.new("Pastel Blue").Color,"Fantasy")
				newTheme("rbxassetid://2482117221",0,1,1.25)
				MAINRUINCOLOR = BrickColor.new("Pastel Blue")
				RecolorThing2(MAINRUINCOLOR,BrickColor.new("Pastel Blue"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
			end
			if k == "r" and attack == false and ModeOfGlitch ~= 2334 then
				ModeOfGlitch = 2334
				storehumanoidWS = 12
				hum.WalkSpeed = 12
				rainbowmode = false
				chaosmode = false
				Error = false
				CRAZED = false
				RecolorTextAndRename("MEMER",BrickColor.new'Toothpaste'.Color,BrickColor.new'Dark blue'.Color,"Fantasy")
				newTheme("rbxassetid://1702473314",0,1,0.3)
				MAINRUINCOLOR = BrickColor.new("Dark blue")
				RecolorThing2(MAINRUINCOLOR,BrickColor.new("Pastel Blue"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
			end
			if k == "f" and attack == false and ModeOfGlitch ~= 666666 then

				ModeOfGlitch = 666666
				storehumanoidWS = 85
				hum.WalkSpeed = 85
				rainbowmode = false
				chaosmode = false
				Error = false
				CRAZED = false
				RecolorTextAndRename("L O S T  S O U L",BrickColor.new("Crimson").Color,BrickColor.new("Really black").Color,"Arcade")
				newTheme("rbxassetid://343860759",0,0.9,2)
				MAINRUINCOLOR = BrickColor.new("Crimson")
				bosschatfunc("I'  M  T H E  U N D Y I N G  S O U L .",MAINRUINCOLOR.Color,3)
				RecolorThing2(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,BrickColor.new("Crimson"),0,BrickColor.new("Crimson"),true,false)
			end
			if k == "t" and attack == false and ModeOfGlitch ~= 61 then
				ModeOfGlitch = 61
				storehumanoidWS = 850
				hum.WalkSpeed = 850
				rainbowmode = false
				chaosmode = false
				CRAZED = false
				Error = true
				RecolorTextAndRename("error",Color3.new(0,0,0),Color3.new(1,1,1),"Bodoni")
				disably = false
				warnedpeople("ERROR","Arcade",MAINRUINCOLOR.Color,MAINRUINCOLOR.Color)
				disably = true
				chatfunc("AGHHEUHUF#H(HHGDCVHH*I%H#$@($UF*GD",MAINRUINCOLOR.Color,"Inverted","Arcade",2)
				newTheme("rbxassetid://1138145518",0,1,1.25)
				MAINRUINCOLOR = BrickColor.new("Black")
				bosschatfunc("THIS CAN BE DELETED!!!",MAINRUINCOLOR.Color,3)
				RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true,true)
			end
		end
		if k == "p" and Diversial == false and attack == false then
			Diversial = true
			ModeFrame.Text = "Side: Diversial"
			TextFrame.Text = "Diversial Glitcher"
			ModeOfGlitch = 676767
			storehumanoidWS = 250
			hum.WalkSpeed = 250
			rainbowmode = false
			unstablemode = false
			chaosmode = false
			CRAZED = false
			RecolorTextAndRename("MULTI-DIVERSIAL",Color3.new(1,1,1),BrickColor.new("Royal purple").Color,"SciFi")
			newTheme("rbxassetid://603567552",0,1.02,1.25)
			MAINRUINCOLOR = BrickColor.new("Royal purple")
			RecolorThing2(BrickColor.new("Royal purple"),BrickColor.new("Royal purple"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,0,MAINRUINCOLOR,0,BrickColor.new("Royal purple"),true,true)
		elseif k == "p" and Diversial == true and attack == false then
			Error = false
			Diversial = false
			TextFrame.Text = "Spectrum Glitcher"
			ModeFrame.Text = "Side: Spectrum"
			--normalmog() ---Disabled due to crashing... only in VSB
			ModeOfGlitch = 1
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			chaosmode = false
			CRAZED = false
			newTheme("rbxassetid://415898123",48.6,1,1.25)
			RecolorTextAndRename("MAYHEM",Color3.new(0.25,0,0),Color3.new(1,0,0),"Antique")
			MAINRUINCOLOR = BrickColor.new("Really red")
			RecolorThing2(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
		end
		if k == "i" and mutedtog == false then
			mutedtog = true
			kan.Volume = 0
		elseif k == "i" and mutedtog == true then
			mutedtog = false
			kan.Volume = 1.25
		end
		if k == "o" and DoDamage == true then
			DoDamage = false
			DamageFrame.Text = "Damage = Disabled"
		elseif k == "o" and DoDamage == false then
			DoDamage = true
			DamageFrame.Text = "Damage = Enabled"
		end
		if k == "z" and attack == false and ModeOfGlitch == 1 then
			ExtinctiveHeartbreak()
		elseif k == "z" and attack == false and ModeOfGlitch == 2 then
			HeavenlyDisk()
		elseif k == "z" and attack == false and ModeOfGlitch == 71 then
			PlaguedJump()
		elseif k == "z" and attack == false and ModeOfGlitch == 8889 then
			CalMets()
		elseif k == "z" and attack == false and ModeOfGlitch == 88893333388 then
			CatMets()
		elseif k == "z" and attack == false and ModeOfGlitch == 9 then
			EternalChaosOrb()
		elseif k == "z" and attack == false and ModeOfGlitch == 2332 then
			ClearDisk()
		elseif k == "b" and attack == false and ModeOfGlitch == 999 then
			ColorEnbelived()
		elseif k == "c" and attack == false and ModeOfGlitch == 102 then
			hugg()
		elseif k == "z" and attack == false and ModeOfGlitch == 3 then
			CorruptionEvent()
		elseif k == "z" and attack == false and ModeOfGlitch == 4 then
			RapidBurst()
		elseif k == "z" and attack == false and ModeOfGlitch == 765688533321 then
			PowerBeams()
		elseif k == "b" and attack == false and ModeOfGlitch == 765688533321 then
			Unstable_Taunt()
		elseif k == "z" and attack == false and ModeOfGlitch == 103 then
			CardStorm()
		elseif k == "z" and attack == false and ModeOfGlitch == 664663666 then
			ViolentStrike()
		elseif k == "z" and attack == false and ModeOfGlitch == 5 then
			DivineSwarm()
		elseif k == "z" and attack == false and ModeOfGlitch == 6 then
			EquinoxOrbs()
		elseif k == "z" and attack == false and ModeOfGlitch == 1264532489 then
			FallenOrbs()
		elseif k == "x" and attack == false and ModeOfGlitch == 5 then
			HolyBarrier()
		elseif k == "x" and attack == false and ModeOfGlitch == 8889 then
			ExtCalbeam()
		elseif k == "x" and attack == false and ModeOfGlitch == 88893333388 then
			ExtCatbeam()
		elseif k == "z" and attack == false and ModeOfGlitch == 090 then
			RainbowBeam()
		elseif k == "z" and attack == false and ModeOfGlitch == 1236 then
			shytaunty()
		elseif k == "x" and attack == false and ModeOfGlitch == 1236 then
			lovesqueal()
		elseif k == "v" and attack == false and ModeOfGlitch == 999999999556 then
			CrazedInsanity()
		elseif k == "z" and attack == false and ModeOfGlitch == 4367677813 then
			SHDTwist()
		end
		if k == "v" and attack == false and ModeOfGlitch == 1264532489 then
			FallenDEMISE()
		end
		if k == "x" and attack == false and ModeOfGlitch == 1 then
			EndGROUND()
		end
	end)

	mouse.KeyUp:connect(function(k)
		if k == "x" and ModeOfGlitch == 5 then
			shielding = false
		end
	end)

	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeOfGlitch ~= 666666 and ModeOfGlitch ~= 102 and ModeOfGlitch ~= 2332 and ModeOfGlitch ~= 1 and ModeOfGlitch ~= 2334 then
				tr1.Enabled = true
				tr2.Enabled = true
				tr3.Enabled = true
				tl1.Enabled = true
				tl2.Enabled = true
				tl3.Enabled = true
				for i, v in pairs(mw1:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
				for i, v in pairs(mw2:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
				for i, v in pairs(m:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
				for i, v in pairs(m:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
				for i, v in pairs(extrawingmod1:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
				for i, v in pairs(extrawingmod2:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
			elseif ModeOfGlitch == 1 or ModeOfGlitch == 102 or ModeOfGlitch == 2332 or ModeOfGlitch == 2334 then
				for i, v in pairs(mw1:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
				for i, v in pairs(mw2:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
				for i, v in pairs(m:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
				for i, v in pairs(m:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
				for i, v in pairs(extrawingmod1:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
				for i, v in pairs(extrawingmod2:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Neon"
					end
				end
				tr1.Enabled = true
				tr2.Enabled = true
				tr3.Enabled = true
				tl1.Enabled = false
				tl2.Enabled = false
				tl3.Enabled = false
			elseif ModeOfGlitch == 666666 then
				tr1.Enabled = false
				tr2.Enabled = false
				tr3.Enabled = false
				tl1.Enabled = false
				tl2.Enabled = false
				tl3.Enabled = false
				for i, v in pairs(mw1:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Glass"
					end
				end
				for i, v in pairs(mw2:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Glass"
					end
				end
				for i, v in pairs(m:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Glass"
					end
				end
				for i, v in pairs(m:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Glass"
					end
				end
				for i, v in pairs(extrawingmod1:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Glass"
					end
				end
				for i, v in pairs(extrawingmod2:GetChildren()) do
					if v:IsA("Part") then
						v.Material = "Glass"
					end
				end
			end
		end
	end))

	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeOfGlitch ~= 102 then
				blush.Parent = nil
				blush.Transparency = 1
			elseif ModeOfGlitch == 102 then
				blush.Parent = hed
				blush.Transparency = 0
			end	
		end
	end))

	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeOfGlitch == 102 then
				sphereMK(7.5,math.random(-50,-15)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),45,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,BrickColor.new("Deep orange"),0)
			elseif ModeOfGlitch == 1236 then
				sphereMK(10,math.random(10,25)/45,"Add",root.CFrame*CFrame.new(math.random(-20,20),-5,math.random(-20,20))*CFrame.Angles(math.rad(90 + math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),0.25,0.25,8,0,MAINRUINCOLOR,0)
			end
		end
	end))

	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeOfGlitch == 765688533321 then
				sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-65,65),-10,math.random(-65,65))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,MAINRUINCOLOR,0)
				sphereMK(7.5,math.random(-50,-15)/45,"Add",root.CFrame*CFrame.new(math.random(-65,65),50,math.random(-65,65))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,BrickColor.new("Really red"),0)
				sphereMK(7.5,math.random(-50,-15)/45,"Add",root.CFrame*CFrame.new(math.random(-65,65),50,math.random(-65,65))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,BrickColor.new("Institutional white"),0)
			end
		end
	end))
	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeOfGlitch == 88893333388 then
				sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-65,65),-10,math.random(-65,65))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,MAINRUINCOLOR,0)
				sphereMK(7.5,math.random(-50,-15)/45,"Add",root.CFrame*CFrame.new(math.random(-65,65),50,math.random(-65,65))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,BrickColor.new("Really blue"),0)
			end
		end
	end))

	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeOfGlitch == 6 or ModeOfGlitch == 999 or ModeOfGlitch == 1055 or ModeOfGlitch == 453453484635345 or ModeOfGlitch == 3444 or ModeOfGlitch == 71 or ModeOfGlitch == 103 or ModeOfGlitch == 101 or ModeOfGlitch == 8 or ModeOfGlitch == 9 or ModeOfGlitch == 8889 or ModeOfGlitch == 664663666 or ModeOfGlitch == 1264532489 or ModeOfGlitch == 55469696922 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 999999999556 or ModeOfGlitch == 808080808080808080808080 then
				sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,MAINRUINCOLOR,0)
				if ModeOfGlitch == 71 then
					sphereMK(7.5,math.random(-50,-15)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),50,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,BrickColor.new("Earth green"),0)
				elseif ModeOfGlitch == 101 then
					sphereMK(7.5,math.random(-50,-15)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),50,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,BrickColor.new("Black"),0)
				elseif ModeOfGlitch == 103 then
					sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-125,125),-10,math.random(-125,125))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),3,3,50,-0.03,BrickColor.new("Deep orange"),0)
				elseif ModeOfGlitch == 808080808080808080808080 then
					sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-125,125),-10,math.random(-125,125))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),3,3,50,-0.03,BrickColor.new("Alder"),0)
				end
			end
		end
	end))

	local rotperm = 0
	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeOfGlitch == 2 or ModeOfGlitch == 999999999556 or ModeOfGlitch == 090 or ModeOfGlitch == 3 then
				swait(0.5)
				sphereMK(6,math.random(5,15)/45,"Add",root.CFrame*CFrame.new(math.random(-10,10),-5,math.random(-10,10))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.2,0.2,3,0,MAINRUINCOLOR,0)
			elseif ModeOfGlitch == 676767 or ModeOfGlitch == 146536 or ModeOfGlitch == 2332 then
				swait(0.5)
				sphereMK(5,math.random(8,14)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-10,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.75,0.75,20,-0.0075,MAINRUINCOLOR,0)
			elseif ModeOfGlitch == 6518594185 then
				sphereMK(5,math.random(8,14)/45,"Add",root.CFrame*CFrame.new(math.random(-85,85),-10,math.random(-85,85))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.75,0.75,20,-0.0075,MAINRUINCOLOR,0)
			elseif ModeOfGlitch == 5 then
				swait(0.5)
				local rsiz = math.random(1,3)
				sphereMK(math.random(3,6),math.random(-25,25)/750,"Add",sorb2.CFrame*CFrame.new(math.random(-20,20)/50,math.random(-20,20)/50,math.random(-20,20)/50)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,MAINRUINCOLOR,0)
				sphereMK(math.random(6,9),math.random(-10,10)/750,"Add",sorb2.CFrame*CFrame.new(math.random(-5,5)/50,math.random(-5,5)/50,math.random(-5,5)/50)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/3,rsiz/3,rsiz/3,0,MAINRUINCOLOR,0)
			elseif ModeOfGlitch == 9600000000 then
				swait(0.25)
				sphereMK(5,math.random(-14,-8)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.25,0.25,7.5,-0.0025,MAINRUINCOLOR,0)
			elseif ModeOfGlitch == 6000000000 then
				coroutine.resume(coroutine.create(function()
					swait(5)
					sphereMK(10,math.random(15,45)/45,"Add",root.CFrame*CFrame.new(math.random(-50,50),-40,math.random(-50,50))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1,1,60,-0.01,MAINRUINCOLOR,0)
				end))
				swait(1)
				rotperm = rotperm + 12
				sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(rotperm),0)*CFrame.new(0,0,10),vt(3,3,3),-0.03,-0.03,-0.03,MAINRUINCOLOR)
				sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(180 + rotperm),0)*CFrame.new(0,0,10),vt(3,3,3),-0.03,-0.03,-0.03,BrickColor.new("Cool yellow"))
			elseif ModeOfGlitch == 102 then
				swait(25)
				sphere2(4,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,1,1),0.25,0,0.25,MAINRUINCOLOR)
				sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,1,1),0.5,0,0.5,MAINRUINCOLOR)
				local notsp = Instance.new("Part", char)
				notsp.CanCollide = false
				notsp.FormFactor = 3
				notsp.Name = "Ring"
				notsp.Material = "Neon"
				notsp.Size = Vector3.new(10, 1, 10)
				if math.random(1,6) == 1 then
					notsp.Size = Vector3.new(25, 1, 25)
				end
				notsp.Transparency = 1
				notsp.TopSurface = 0
				notsp.BottomSurface = 0
				notsp.Anchored = true
				notsp.CFrame = root.CFrame*CFrame.new(0,-3,0)
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",notsp)
					eff.Texture = "rbxassetid://749327003"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000))
					eff.Rate = 300
					eff.Lifetime = NumberRange.new(1)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.5,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(20,40)
					eff.Acceleration = vt(0,-75,0)
					eff.Drag = 1
					eff.Rotation = NumberRange.new(-10,10)
					eff.VelocitySpread = 20
					eff.RotSpeed = NumberRange.new(-1,1)
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if eff.Parent ~= nil then
								if ModeOfGlitch == 102 then
									eff.Color = ColorSequence.new(Color3.new(1,0.7,0))
								elseif ModeOfGlitch ~= 102 then
									eff.Color = ColorSequence.new(MAINRUINCOLOR.Color)
								end
							else
								break
							end
						end
					end))
					wait(0.1)
					eff.Enabled = false
				end))
				game:GetService("Debris"):AddItem(notsp, 5)
			end
		end
	end))

	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeOfGlitch == 343434 or ModeOfGlitch == 909090 then
				sphereMK(10,math.random(10,25)/45,"Add",root.CFrame*CFrame.new(math.random(-20,20),-5,math.random(-20,20))*CFrame.Angles(math.rad(90 + math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),0.4,0.4,8,0,MAINRUINCOLOR,0)
			elseif ModeOfGlitch == 343435 then
				sphereMK(10,math.random(10,35)/45,"Add",root.CFrame*CFrame.new(math.random(-60,60),-5,math.random(-60,60))*CFrame.Angles(math.rad(90 + math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),0.4,0.4,8,0,MAINRUINCOLOR,0)
			end
		end
	end))
	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeOfGlitch ~= 343435 and ModeOfGlitch ~= 666666 then
				game.Lighting.TimeOfDay = "12:00:00"
			elseif ModeOfGlitch == 343435 then
				game.Lighting.TimeOfDay = "00:00:00"
			elseif ModeOfGlitch == 666666 then
				game.Lighting.TimeOfDay = "7:00:00"
			end
		end
	end))


--[[coroutine.resume(coroutine.create(function()
while true do
swait(2)
if chaosmode == true then
tl1.Color = ColorSequence.new(BrickColor.random().Color)
tl2.Color = ColorSequence.new(BrickColor.random().Color)
tl3.Color = ColorSequence.new(BrickColor.random().Color)
RecolorTextAndRename("CHAOS",Color3.new(0,0,0),BrickColor.random().Color,"Fantasy")
for i, v in pairs(mw1:GetChildren()) do
if v:IsA("Part") then
v.Transparency = 0.75
v.BrickColor = BrickColor.random()
v.Material = "Neon"
end
end
for i, v in pairs(m2:GetChildren()) do
if v:IsA("Part") then
v.BrickColor = BrickColor.random()
v.Material = "Neon"
end
end
end
end
end))]]--
	Humanoid.Name = "Humanoid"
	Humanoid.MaxHealth = math.huge
	Humanoid.Health = math.huge
	Instance.new("ForceField",char).Visible = false

	local bguis = Instance.new("BillboardGui",tors)
	bguis.Size = UDim2.new(25, 0, 25, 0)
	local bguis2 = Instance.new("BillboardGui",tors)
	bguis2.Size = UDim2.new(25, 0, 25, 0)
	local bguis3 = Instance.new("BillboardGui",tors)
	bguis3.Size = UDim2.new(25, 0, 25, 0)
	local bguis4 = Instance.new("BillboardGui",tors)
	bguis4.Size = UDim2.new(25, 0, 25, 0)
	local imgca = Instance.new("ImageLabel",bguis)
	imgca.BackgroundTransparency = 1
	imgca.ImageTransparency = 1
	imgca.Size = UDim2.new(1,0,1,0)
	imgca.Image = "rbxassetid://2344830904" --997291547,521073910,2312119891,2344830904
	imgca.ImageColor3 = Color3.new(0,0,0)
	local imgca2 = Instance.new("ImageLabel",bguis2)
	imgca2.BackgroundTransparency = 1
	imgca2.ImageTransparency = 1
	imgca2.Size = UDim2.new(1,0,1,0)
	imgca2.Image = "rbxassetid://2312119891" --997291547,521073910,2312119891,2344830904
	imgca2.ImageColor3 = Color3.new(0,0,0)
	local imgca3 = Instance.new("ImageLabel",bguis3)
	imgca3.BackgroundTransparency = 1
	imgca3.ImageTransparency = 1
	imgca3.Size = UDim2.new(1,0,1,0)
	imgca3.Image = "rbxassetid://2076519836" --997291547,521073910,2312119891,2344830904
	imgca3.ImageColor3 = Color3.new(0,0,0)
	local imgca4 = Instance.new("ImageLabel",bguis4)
	imgca4.BackgroundTransparency = 1
	imgca4.ImageTransparency = 1
	imgca4.Size = UDim2.new(1,0,1,0)
	imgca4.Image = "rbxassetid://2076458450" --997291547,521073910,2312119891,2344830904
	imgca4.ImageColor3 = Color3.new(0,0,0)

	idleanim=.4
	while true do
		if mutedtog == false then
			kan.Volume = currentVol
		elseif mutedtog == true then
			kan.Volume = 0
		end
		kan.PlaybackSpeed = currentPitch
		kan.Pitch = currentPitch
		kan.SoundId = currentThemePlaying
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		if ModeOfGlitch ~= 1264532489 and ModeOfGlitch ~= 101 and ModeOfGlitch ~= 090 and ModeOfGlitch ~= 103 and ModeOfGlitch ~= 55469696922 and ModeOfGlitch ~= 4367677813 and ModeOfGlitch ~= 9999999921111 and ModeOfGlitch ~= 999999999556 and ModeOfGlitch ~= 765688533321 and ModeOfGlitch ~= 88893333388 and ModeOfGlitch ~= 808080808080808080808080 then
			imgca.ImageTransparency = 1
		elseif ModeOfGlitch == 1264532489 or ModeOfGlitch == 101 or ModeOfGlitch == 103 or ModeOfGlitch == 55469696922 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 999999999556 or ModeOfGlitch == 765688533321 or ModeOfGlitch == 88893333388 or ModeOfGlitch == 808080808080808080808080 then
			imgca.ImageColor3 = MAINRUINCOLOR.Color
			imgca.ImageTransparency = 0 + 0.25 * math.cos(sine / 30)
		elseif ModeOfGlitch == 090 then
			imgca.ImageColor3 = Color3.new(r/255,g/255,b/255)
			imgca.ImageTransparency = 0 + 0.25 * math.cos(sine / 30)
		end
		if ModeOfGlitch ~= 71 and ModeOfGlitch ~= 61 then
			imgca2.ImageTransparency = 1
		elseif ModeOfGlitch == 61 then
			imgca2.ImageColor3 = MAINRUINCOLOR.Color
			imgca2.ImageTransparency = 0 + 0.25 * math.cos(sine / 30)
		elseif ModeOfGlitch == 71 then
			imgca2.ImageColor3 = Color3.new(0,0.4,0)
			imgca2.ImageTransparency = 0 + 0.25 * math.cos(sine / 30)
		end
		if ModeOfGlitch ~= 676767 and ModeOfGlitch ~= 6518594185 and ModeOfGlitch ~= 999 then
			imgca3.ImageTransparency = 1
		elseif ModeOfGlitch == 676767 or ModeOfGlitch == 6518594185 or ModeOfGlitch == 999 then
			imgca3.ImageColor3 = MAINRUINCOLOR.Color
			imgca3.ImageTransparency = 0 + 0.25 * math.cos(sine / 30)
		end
		if ModeOfGlitch ~= 664663666 and ModeOfGlitch ~= 6518594185 and ModeOfGlitch ~= 146536 then
			imgca4.ImageTransparency = 1
		elseif ModeOfGlitch == 664663666 or ModeOfGlitch == 6518594185 or ModeOfGlitch == 146536 then
			imgca4.ImageColor3 = MAINRUINCOLOR.Color
			imgca4.ImageTransparency = 0 + 0.25 * math.cos(sine / 30)
		end
		imgca.Rotation = imgca.Rotation + 5 + kan.PlaybackLoudness/100
		imgca2.Rotation = imgca.Rotation - 5 - kan.PlaybackLoudness/100
		imgca3.Rotation = imgca.Rotation + 5 + kan.PlaybackLoudness/100
		imgca4.Rotation = imgca.Rotation - 1 - kan.PlaybackLoudness/100
		bguis.Size = UDim2.new(15 + 3 * math.cos(sine / 30),0, 15 + 3 * math.cos(sine / 30),0)
		bguis3.Size = UDim2.new(10 + 3 * math.cos(sine / 40),0, 10 + 3 * math.cos(sine / 40),0)
		bguis4.Size = UDim2.new(15 + 3 * math.cos(sine / 40),0, 15 + 3 * math.cos(sine / 40),0)
		if Error == false and ModeOfGlitch ~= 61 then
			bguis2.Size = UDim2.new(12.5 + 3 * math.cos(sine / 60),0, 12.5 + 3 * math.cos(sine / 60),0)
		elseif Error == true and ModeOfGlitch == 61 then
			bguis2.Size = UDim2.new(17.5 + 4.5 * math.cos(sine / 12),0, 17.5 + 4.5 * math.cos(sine / 12),0)
		end

		coroutine.resume(coroutine.create(function()
			if Error == true then
				MAINRUINCOLOR = BrickColor.random()
				for i, v in pairs(extrawingmod1:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				for i, v in pairs(extrawingmod2:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				tl4.Color = ColorSequence.new(BrickColor.random().Color)
				tl5.Color = ColorSequence.new(BrickColor.random().Color)
				tl6.Color = ColorSequence.new(BrickColor.random().Color)
				tr4.Color = ColorSequence.new(BrickColor.random().Color)
				tr5.Color = ColorSequence.new(BrickColor.random().Color)
				tr6.Color = ColorSequence.new(BrickColor.random().Color)
				refec.Color = ColorSequence.new(BrickColor.Random().Color)
				RecolorTextAndRename(est[math.random(1,17)],Color3.new(0,0,0),Color3.new(MRANDOM(0,1),MRANDOM(0,1),MRANDOM(0,1)),"Bodoni")
			end
		end))
		coroutine.resume(coroutine.create(function()
			if CRAZED == true then
				MAINRUINCOLOR = BrickColor.new("Navy blue")
				refec.Color = ColorSequence.new(BrickColor.new("Really blue").Color)
				for i, v in pairs(extrawingmod1:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new("Navy blue")
						v.Material = "Neon"
					end
				end
				for i, v in pairs(extrawingmod2:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new("Really black")
						v.Material = "Neon"
					end
				end
				RecolorTextAndRename("CRAZED",Color3.new(0,0,math.random(0,0.6)),Color3.new(0,0,math.random(0.2,1)),"Code")
				if math.random(1,2) == 1 then
					MAINRUINCOLOR = BrickColor.new("Really black")
					refec.Color = ColorSequence.new(BrickColor.new("Really black").Color)
					for i, v in pairs(extrawingmod2:GetChildren()) do
						if v:IsA("Part") then
							v.Transparency = 0
							v.BrickColor = BrickColor.new("Navy blue")
							v.Material = "Neon"
						end
					end
					for i, v in pairs(extrawingmod1:GetChildren()) do
						if v:IsA("Part") then
							v.Transparency = 0
							v.BrickColor = BrickColor.new("Really black")
							v.Material = "Neon"
						end
					end
				end
			end
		end))

		coroutine.resume(coroutine.create(function()
			if Error == true then
				MAINRUINCOLOR = BrickColor.random()
				for i, v in pairs(extrawingmod1:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				for i, v in pairs(extrawingmod2:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				tl4.Color = ColorSequence.new(BrickColor.random().Color)
				tl5.Color = ColorSequence.new(BrickColor.random().Color)
				tl6.Color = ColorSequence.new(BrickColor.random().Color)
				tr4.Color = ColorSequence.new(BrickColor.random().Color)
				tr5.Color = ColorSequence.new(BrickColor.random().Color)
				tr6.Color = ColorSequence.new(BrickColor.random().Color)
				refec.Color = ColorSequence.new(BrickColor.Random().Color)
				RecolorTextAndRename(est[math.random(1,17)],Color3.new(0,0,0),Color3.new(MRANDOM(0,1),MRANDOM(0,1),MRANDOM(0,1)),"Bodoni")
			end
		end))
		coroutine.resume(coroutine.create(function()
			if unstablemode == true then
				MAINRUINCOLOR = BrickColor.new("Really black")
				refec.Color = ColorSequence.new(BrickColor.new("Really red").Color)
				for i, v in pairs(extrawingmod1:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new("Really red")
						v.Material = "Neon"
					end
				end
				for i, v in pairs(extrawingmod2:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new("Really black")
						v.Material = "Neon"
					end
				end
				RecolorTextAndRename("UNSTABLE",Color3.new(1,1,1),Color3.new(math.random(0.3,1),0,0),"Code")
				if math.random(1,8) == 1 then
					MAINRUINCOLOR = BrickColor.new(math.random(0.2,1),0,0)
				end
				if math.random(1,10) == 1 then
					RecolorTextAndRename("UNSTABLE",Color3.new(math.random(0.3,1),0,0),Color3.new(0,0,0),"Code")
					refec.Color = ColorSequence.new(BrickColor.new("Really black").Color)
					for i, v in pairs(extrawingmod2:GetChildren()) do
						if v:IsA("Part") then
							v.Transparency = 0
							v.BrickColor = BrickColor.new("Really red")
							v.Material = "Neon"
						end
					end
					for i, v in pairs(extrawingmod1:GetChildren()) do
						if v:IsA("Part") then
							v.Transparency = 0
							v.BrickColor = BrickColor.new("Really black")
							v.Material = "Neon"
						end
					end
				end
			end
		end))

		coroutine.resume(coroutine.create(function()
			if chaosmode == true then
				for i, v in pairs(mw1:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				tl1.Color = ColorSequence.new(BrickColor.random().Color)
				tl2.Color = ColorSequence.new(BrickColor.random().Color)
				tl3.Color = ColorSequence.new(BrickColor.random().Color)
				RecolorTextAndRename("CHAOS",Color3.new(0,0,0),BrickColor.random().Color,"Arcade")
			end
		end))

		if chaosmode == false and CRAZED == false and Error == false and unstablemode == false and ModeOfGlitch ~= 666666 then
			modet.Position = UDim2.new(0,0,0,0)
			modet.Rotation = -5 * math.cos(sine / 32)
			techc.Rotation = techc.Rotation + 1
			circl.Rotation = circl.Rotation - kan.PlaybackLoudness/100 - 1
			circl2.Rotation = circl2.Rotation + kan.PlaybackLoudness/75 + 1
			imgl2.Rotation = imgl2.Rotation - kan.PlaybackLoudness/75 + 1
			imgl2b.Rotation = imgl2b.Rotation + kan.PlaybackLoudness/50 - 1
			wobble.Rotation = 0 - 1 * math.cos(sine / 24)
			wobble.BackgroundColor3 = modet.TextColor3
			wobble.BorderColor3 = modet.TextStrokeColor3
			wobble.BorderSizePixel = 2
			wobble2.Rotation = 0 - 1 * math.cos(sine / 30)
			wobble2.BackgroundColor3 = modet.TextStrokeColor3
			wobble2.BorderColor3 = modet.TextColor3
			wobble2.BorderSizePixel = 2
			TextFrame.TextColor3 = modet.TextColor3
			TextFrame.TextStrokeColor3 = modet.TextStrokeColor3
			TextFrame.TextStrokeTransparency = 0
			TextFrame.Rotation = 0 - 2 * math.cos(sine / 30)
			TextFrame.Position = UDim2.new(0.48,0 - 10 * math.cos(sine / 50),0.867,0 - 10 * math.cos(sine / 50))
			DamageFrame.Rotation = 6 - 2 * math.cos(sine / 35)
			DamageFrame.TextColor3 = modet.TextColor3
			DamageFrame.TextStrokeColor3 = modet.TextStrokeColor3
			DamageFrame.TextStrokeTransparency = 0
			ModeFrame.Rotation = 6 - 2 * math.cos(sine / 35)
			ModeFrame.TextColor3 = modet.TextColor3
			ModeFrame.TextStrokeColor3 = modet.TextStrokeColor3
			ModeFrame.TextStrokeTransparency = 0
			Visuals.Rotation = Visuals.Rotation + 1
			Visuals.BackgroundColor3 = modet.TextStrokeColor3
			Visuals.BorderColor3 = modet.TextColor3
			Visuals.BorderSizePixel = 4
			glow.ImageColor3 = modet.TextStrokeColor3
			Visuals2.Rotation = Visuals2.Rotation - 1
			Visuals2.BackgroundColor3 = modet.TextStrokeColor3
			Visuals2.BorderColor3 = modet.TextColor3
			Visuals2.BorderSizePixel = 4
			ned.Rotation = 0 - 2 * math.cos(sine / 24)
			ned.Position = UDim2.new(0.7,0 - 10 * math.cos(sine / 32),0.8,0 - 10 * math.cos(sine / 45))
		elseif ModeOfGlitch == 666666 then
			modet.TextColor3 = Color3.new(0,0,0)
			modet.TextStrokeColor3 = BrickColor.new("Crimson").Color
			techc.Rotation = techc.Rotation + 3
			circl.Rotation = circl.Rotation + 1 - kan.PlaybackLoudness/25
			circl2.Rotation = circl2.Rotation + 1 + kan.PlaybackLoudness/50
			imgl2.Rotation = imgl2.Rotation + 1 - kan.PlaybackLoudness/50
			imgl2b.Rotation = imgl2b.Rotation + 1 + kan.PlaybackLoudness/25
			TextFrame.TextColor3 = modet.TextColor3
			TextFrame.TextStrokeColor3 = modet.TextStrokeColor3
			TextFrame.TextStrokeTransparency = 0
			TextFrame.Rotation = 0 + math.random(-3,3)
			TextFrame.Position = UDim2.new(0.48,0 + math.random(-1.5,1.5),0.867,0 + math.random(-1.5,1.5)) -- backori
			DamageFrame.Rotation = 6 + math.random(-2,2)
			DamageFrame.TextColor3 = modet.TextColor3
			DamageFrame.TextStrokeColor3 = modet.TextStrokeColor3
			DamageFrame.TextStrokeTransparency = 0
			ModeFrame.Rotation = 6 + math.random(-2,2)
			ModeFrame.TextColor3 = modet.TextColor3
			ModeFrame.TextStrokeColor3 = modet.TextStrokeColor3
			ModeFrame.TextStrokeTransparency = 0
			glow.ImageColor3 = modet.TextStrokeColor3
			wobble.Rotation = 0 - 2 * math.cos(sine / 24)
			wobble2.Rotation = 0 - 2 * math.cos(sine / 30)
			wobble2.BackgroundColor3 = modet.TextStrokeColor3
			wobble2.BorderColor3 = modet.TextColor3
			wobble2.BorderSizePixel = 2
			Visuals.Rotation = Visuals.Rotation + 2 + math.random(-2.5,2.5)
			Visuals2.Rotation = Visuals2.Rotation + 2 + math.random(-5,5)
			Visuals.BackgroundColor3 = modet.TextStrokeColor3
			Visuals.BorderColor3 = modet.TextColor3
			Visuals2.BackgroundColor3 = modet.TextStrokeColor3
			Visuals2.BorderColor3 = modet.TextColor3
			wobble.BackgroundColor3 = modet.TextColor3
			wobble.BorderColor3 = modet.TextStrokeColor3
			wobble.BorderSizePixel = 2
			ned.Rotation = 0 -2 * math.cos(sine / 1) + math.random(-1.5,1.5)
			ned.Position = UDim2.new(0.7,0 + math.random(-1.5,1.5),0.8,0 + math.random(-1.5,1.5))
			modet.Position = UDim2.new(0,math.random(-1,1),0,math.random(-1,1))
			modet.Rotation = -2 * math.cos(sine / 1) + math.random(-1.5,1.5)
		elseif unstablemode == true then
			modet.Position = UDim2.new(0,0,0,0)
			modet.Rotation = -5 * math.cos(sine / 12)
			techc.Rotation = techc.Rotation + 2
			circl.Rotation = circl.Rotation - kan.PlaybackLoudness/75 - 2
			circl2.Rotation = circl2.Rotation + kan.PlaybackLoudness/50 + 2
			imgl2.Rotation = imgl2.Rotation - kan.PlaybackLoudness/50 + 2
			imgl2b.Rotation = imgl2b.Rotation + kan.PlaybackLoudness/25 - 2
			wobble.Rotation = 0 - 2 * math.cos(sine / 24)
			wobble.BackgroundColor3 = modet.TextColor3
			wobble.BorderColor3 = modet.TextStrokeColor3
			wobble.BorderSizePixel = 2
			wobble2.Rotation = 0 - 2 * math.cos(sine / 30)
			wobble2.BackgroundColor3 = modet.TextStrokeColor3
			wobble2.BorderColor3 = modet.TextColor3
			wobble2.BorderSizePixel = 2
			TextFrame.TextColor3 = modet.TextColor3
			TextFrame.TextStrokeColor3 = modet.TextStrokeColor3
			TextFrame.TextStrokeTransparency = 0
			TextFrame.Rotation = 0 - 4 * math.cos(sine / 30)
			TextFrame.Position = UDim2.new(0.48,0 - 10 * math.cos(sine / 50),0.867,0 - 10 * math.cos(sine / 50))
			DamageFrame.Rotation = 6 - 4 * math.cos(sine / 35)
			DamageFrame.TextColor3 = modet.TextColor3
			DamageFrame.TextStrokeColor3 = modet.TextStrokeColor3
			DamageFrame.TextStrokeTransparency = 0
			ModeFrame.Rotation = 6 - 4 * math.cos(sine / 35)
			ModeFrame.TextColor3 = modet.TextColor3
			ModeFrame.TextStrokeColor3 = modet.TextStrokeColor3
			ModeFrame.TextStrokeTransparency = 0
			Visuals.Rotation = Visuals.Rotation + 2
			Visuals.BackgroundColor3 = modet.TextStrokeColor3
			Visuals.BorderColor3 = modet.TextColor3
			Visuals.BorderSizePixel = 4
			glow.ImageColor3 = modet.TextStrokeColor3
			Visuals2.Rotation = Visuals2.Rotation - 2
			Visuals2.BackgroundColor3 = modet.TextStrokeColor3
			Visuals2.BorderColor3 = modet.TextColor3
			Visuals2.BorderSizePixel = 4
			ned.Rotation = 0 - 6 * math.cos(sine / 24)
			ned.Position = UDim2.new(0.7,0 - 10 * math.cos(sine / 16),0.8,0 - 10 * math.cos(sine / 45))	
		elseif chaosmode == true then
			techc.Rotation = techc.Rotation + 1
			circl.Rotation = circl.Rotation - kan.PlaybackLoudness/50 + math.random(-5,5)
			circl2.Rotation = circl2.Rotation + kan.PlaybackLoudness/25 + math.random(-5,5)
			imgl2.Rotation = imgl2.Rotation - kan.PlaybackLoudness/25 + math.random(-5,5)
			imgl2b.Rotation = imgl2b.Rotation + kan.PlaybackLoudness/12.5 + math.random(-5,5)
			TextFrame.TextColor3 = modet.TextColor3
			TextFrame.TextStrokeColor3 = modet.TextStrokeColor3
			TextFrame.TextStrokeTransparency = 0
			TextFrame.Rotation = 0 + math.random(-3,3)
			TextFrame.Position = UDim2.new(0.48,0 + math.random(-3,3),0.867,0 + math.random(-3,3)) -- backori
			DamageFrame.Rotation = 6 + math.random(-2,2)
			DamageFrame.TextColor3 = modet.TextColor3
			DamageFrame.TextStrokeColor3 = modet.TextStrokeColor3
			DamageFrame.TextStrokeTransparency = 0
			ModeFrame.Rotation = 6 + math.random(-2,2)
			ModeFrame.TextColor3 = modet.TextColor3
			ModeFrame.TextStrokeColor3 = modet.TextStrokeColor3
			ModeFrame.TextStrokeTransparency = 0
			glow.ImageColor3 = modet.TextStrokeColor3
			wobble.Rotation = 0 - 2 * math.cos(sine / 24)
			wobble2.Rotation = 0 - 2 * math.cos(sine / 30)
			wobble2.BackgroundColor3 = modet.TextStrokeColor3
			wobble2.BorderColor3 = modet.TextColor3
			wobble2.BorderSizePixel = 2
			Visuals.Rotation = Visuals.Rotation + math.random(-5,5)
			Visuals2.Rotation = Visuals2.Rotation + math.random(-10,10)
			Visuals.BackgroundColor3 = modet.TextStrokeColor3
			Visuals.BorderColor3 = modet.TextColor3
			Visuals2.BackgroundColor3 = modet.TextStrokeColor3
			Visuals2.BorderColor3 = modet.TextColor3
			wobble.BackgroundColor3 = modet.TextColor3
			wobble.BorderColor3 = modet.TextStrokeColor3
			wobble.BorderSizePixel = 2
			ned.Rotation = 0 -2 * math.cos(sine / 1) + math.random(-3,3)
			ned.Position = UDim2.new(0.7,0 + math.random(-3,3),0.8,0 + math.random(-3,3))
			modet.Position = UDim2.new(0,math.random(-1,1),0,math.random(-1,1))
			modet.Rotation = -2 * math.cos(sine / 1) + math.random(-3,3)
		elseif Error == true then
			techc.Rotation = techc.Rotation + 15
			circl.Rotation = circl.Rotation - 15 - kan.PlaybackLoudness/50 + math.random(-11,11)
			circl2.Rotation = circl2.Rotation + 15 + kan.PlaybackLoudness/25 + math.random(-11,11)
			imgl2.Rotation = imgl2.Rotation - 15 - kan.PlaybackLoudness/25 + math.random(-11,11)
			imgl2b.Rotation = imgl2b.Rotation + 15 + kan.PlaybackLoudness/12.5 + math.random(-11,11)
			TextFrame.TextColor3 = modet.TextColor3
			TextFrame.TextStrokeColor3 = modet.TextStrokeColor3
			TextFrame.TextStrokeTransparency = 0
			TextFrame.Rotation = 0 + math.random(-11,11)
			TextFrame.Position = UDim2.new(0.48,0 + math.random(-9,9),0.867,0 + math.random(-9,9)) -- backori
			DamageFrame.Rotation = 18 + math.random(-9,9)
			DamageFrame.TextColor3 = modet.TextColor3
			DamageFrame.TextStrokeColor3 = modet.TextStrokeColor3
			DamageFrame.TextStrokeTransparency = 0
			ModeFrame.Rotation = 18 + math.random(-9,9)
			ModeFrame.TextColor3 = modet.TextColor3
			ModeFrame.TextStrokeColor3 = modet.TextStrokeColor3
			ModeFrame.TextStrokeTransparency = 0
			glow.ImageColor3 = modet.TextStrokeColor3
			wobble.Rotation = 0 - 7.5 * math.cos(sine / 24)
			wobble2.Rotation = 0 - 8 * math.cos(sine / 30)
			wobble2.BackgroundColor3 = modet.TextStrokeColor3
			wobble2.BorderColor3 = modet.TextColor3
			wobble2.BorderSizePixel = 2
			Visuals.Rotation = math.random(-35,35)
			Visuals2.Rotation = math.random(-45,45)
			Visuals.BackgroundColor3 = modet.TextStrokeColor3
			Visuals.BorderColor3 = modet.TextColor3
			Visuals2.BackgroundColor3 = modet.TextStrokeColor3
			Visuals2.BorderColor3 = modet.TextColor3
			wobble.BackgroundColor3 = modet.TextColor3
			wobble.BorderColor3 = modet.TextStrokeColor3
			wobble.BorderSizePixel = 2
			ned.Rotation = 0 -6 * math.cos(sine / 1) + math.random(-9,9)
			ned.Position = UDim2.new(0.7,0 + math.random(-3,3),0.8,0 + math.random(-9,9))
			modet.Position = UDim2.new(0,math.random(-1,1),0,math.random(-4,4))
			modet.Rotation = -6 * math.cos(sine / 1) + math.random(-9,9)
		elseif CRAZED == true then
			techc.Rotation = techc.Rotation + 3
			circl.Rotation = circl.Rotation - 5 - kan.PlaybackLoudness/125 + math.random(-2,2)
			circl2.Rotation = circl2.Rotation + 5 + kan.PlaybackLoudness/100 + math.random(-2,2)
			imgl2.Rotation = imgl2.Rotation - 5 - kan.PlaybackLoudness/100 + math.random(-2,2)
			imgl2b.Rotation = imgl2b.Rotation + 5 + kan.PlaybackLoudness/75 + math.random(-2,2)
			TextFrame.TextColor3 = modet.TextColor3
			TextFrame.TextStrokeColor3 = modet.TextStrokeColor3
			TextFrame.TextStrokeTransparency = 0
			TextFrame.Rotation = 0 + math.random(-4,4)
			TextFrame.Position = UDim2.new(0.48,0 + math.random(-4,4),0.867,0 + math.random(-4,4)) -- backori
			DamageFrame.Rotation = 6 + math.random(-4,4)
			DamageFrame.TextColor3 = modet.TextColor3
			DamageFrame.TextStrokeColor3 = modet.TextStrokeColor3
			DamageFrame.TextStrokeTransparency = 0
			ModeFrame.Rotation = 6 + math.random(-4,4)
			ModeFrame.TextColor3 = modet.TextColor3
			ModeFrame.TextStrokeColor3 = modet.TextStrokeColor3
			ModeFrame.TextStrokeTransparency = 0
			glow.ImageColor3 = modet.TextStrokeColor3
			wobble.Rotation = 0 - 4 * math.cos(sine / 24)
			wobble2.Rotation = 0 - 4 * math.cos(sine / 30)
			wobble2.BackgroundColor3 = modet.TextStrokeColor3
			wobble2.BorderColor3 = modet.TextColor3
			wobble2.BorderSizePixel = 2
			Visuals.Rotation = Visuals.Rotation + math.random(-7,7)
			Visuals2.Rotation = Visuals2.Rotation + math.random(-12,12)
			Visuals.BackgroundColor3 = modet.TextStrokeColor3
			Visuals.BorderColor3 = modet.TextColor3
			Visuals2.BackgroundColor3 = modet.TextStrokeColor3
			Visuals2.BorderColor3 = modet.TextColor3
			wobble.BackgroundColor3 = modet.TextColor3
			wobble.BorderColor3 = modet.TextStrokeColor3
			wobble.BorderSizePixel = 2
			ned.Rotation = 0 -4 * math.cos(sine / 1) + math.random(-4,4)
			ned.Position = UDim2.new(0.7,0 + math.random(-3,3),0.8,0 + math.random(-4,4))
			modet.Position = UDim2.new(0,math.random(-2,2),0,math.random(-2,2))
			modet.Rotation = -4 * math.cos(sine / 1) + math.random(-4,4)
		end
		if rainbowmode == true then
			RecolorTextAndRename("RAINBOW",Color3.new(r/255,g/255,b/255),Color3.new(1,1,1),"Highway")
			if ModeOfGlitch == 909090 then
				RecolorTextAndRename("AESTHETIC",Color3.new(r/255,g/255,b/255),Color3.new(r/255,g/255,b/255),"Fantasy")
			end
			MAINRUINCOLOR = BrickColor.new(r/255,g/255,b/255)
			modet.TextColor3 = Color3.new(r/255,g/255,b/255)
			refec.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			tr1.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			tr2.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			tr3.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			tl1.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			tl2.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			tl3.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r/255,g/255,b/255)
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r/255,g/255,b/255)
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r/255,g/255,b/255)
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r/255,g/255,b/255)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r/255,g/255,b/255)
					v.Material = "Neon"
				end
			end
		end

		CameraManager()

		swait()
		if ModeOfGlitch ~= 1264532489 and ModeOfGlitch ~= 666666 and ModeOfGlitch ~= 343434 and ModeOfGlitch ~= 343435 and ModeOfGlitch ~= 909090 and ModeOfGlitch ~= 1236 and ModeOfGlitch ~= 146536 and ModeOfGlitch ~= 6518594185 and ModeOfGlitch ~= 71 and ModeOfGlitch ~= 676767 and ModeOfGlitch ~= 102341 and ModeOfGlitch ~= 61 and ModeOfGlitch ~= 999 and ModeOfGlitch ~= 3434 and ModeOfGlitch ~= 453453484635345 and ModeOfGlitch ~= 3444 and ModeOfGlitch ~= 103 and ModeOfGlitch ~= 102 and ModeOfGlitch ~= 101 and ModeOfGlitch ~= 55469696922 and ModeOfGlitch ~= 4367677813 and ModeOfGlitch ~= 9999999921111 and ModeOfGlitch ~= 999999999556 and ModeOfGlitch ~= 765688533321 and ModeOfGlitch ~= 8889 and ModeOfGlitch ~= 664663666 and ModeOfGlitch ~= 88893333388 and ModeOfGlitch ~= 808080808080808080808080 then
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(2,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(5 + 10 * math.cos(sine / 32)),math.rad(0),math.rad(12.5 + 5 * math.cos(sine / 32))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(3,1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(10 + 15 * math.cos(sine / 32)),math.rad(0),math.rad(25 + 7.5 * math.cos(sine / 32))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(3.75,2,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(15 + 20 * math.cos(sine / 32)),math.rad(0),math.rad(37.5 + 10 * math.cos(sine / 32))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(-2,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(5 + 10 * math.cos(sine / 32)),math.rad(0),math.rad(-12.5 - 5 * math.cos(sine / 32))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(-3,1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(10 + 15 * math.cos(sine / 32)),math.rad(0),math.rad(-25 - 7.5 * math.cos(sine / 32))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(-3.75,2,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(15 + 20 * math.cos(sine / 32)),math.rad(0),math.rad(-37.5 - 10 * math.cos(sine / 32))),.3)
		elseif ModeOfGlitch == 676767 then
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(1 + 5 * math.cos(sine / 180),4 + 2.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 3600 * math.cos(sine / 360))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(1 + 5 * math.cos(sine / 180),4 + 2.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 + 3600 * math.cos(sine / 360))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(1 + 5 * math.cos(sine / 180),4 + 2.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 + 3600 * math.cos(sine / 360))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(1 + 5 * math.cos(sine / 180),4 + 2.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 + 3600 * math.cos(sine / 360))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(1 + 5 * math.cos(sine / 180),4 + 2.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 + 3600 * math.cos(sine / 360))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(1 + 5 * math.cos(sine / 180),4 + 2.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 + 3600 * math.cos(sine / 360))),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 3600 * math.cos(sine / 360))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 - 3600 * math.cos(sine / 360))),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 - 3600 * math.cos(sine / 360))),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 3600 * math.cos(sine / 360))),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 - 3600 * math.cos(sine / 360))),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 - 3600 * math.cos(sine / 360))),.3)
		elseif ModeOfGlitch == 55469696922 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 999 then
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 3600 * math.cos(sine / 360))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 + 3600 * math.cos(sine / 360))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 + 3600 * math.cos(sine / 360))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 + 3600 * math.cos(sine / 360))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 + 3600 * math.cos(sine / 360))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 + 3600 * math.cos(sine / 360))),.3)
		elseif ModeOfGlitch == 3434 then
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(2,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(5 + 10 * math.cos(sine / 32)),math.rad(0),math.rad(12.5 + 5 * math.cos(sine / 32))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(3,1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(10 + 15 * math.cos(sine / 32)),math.rad(0),math.rad(25 + 7.5 * math.cos(sine / 32))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(3.75,2,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(15 + 20 * math.cos(sine / 32)),math.rad(0),math.rad(37.5 + 10 * math.cos(sine / 32))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(-2,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(5 + 10 * math.cos(sine / 32)),math.rad(0),math.rad(-12.5 - 5 * math.cos(sine / 32))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(-3,1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(10 + 15 * math.cos(sine / 32)),math.rad(0),math.rad(-25 - 7.5 * math.cos(sine / 32))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(-3.75,2,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(15 + 20 * math.cos(sine / 32)),math.rad(0),math.rad(-37.5 - 10 * math.cos(sine / 32))),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 3600 * math.cos(sine / 360))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 - 3600 * math.cos(sine / 360))),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 - 3600 * math.cos(sine / 360))),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 3600 * math.cos(sine / 360))),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 - 3600 * math.cos(sine / 360))),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 - 3600 * math.cos(sine / 360))),.3)
		elseif ModeOfGlitch == 453453484635345 then
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 + 3600 * math.cos(sine / 360))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 + 3600 * math.cos(sine / 360))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 + 3600 * math.cos(sine / 360))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 - 3600 * math.cos(sine / 720))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 - 3600 * math.cos(sine / 720))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 - 3600 * math.cos(sine / 720))),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 3600 * math.cos(sine / 360))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 - 3600 * math.cos(sine / 360))),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 - 3600 * math.cos(sine / 360))),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 3600 * math.cos(sine / 360))),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 - 3600 * math.cos(sine / 360))),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 - 3600 * math.cos(sine / 360))),.3)
		elseif ModeOfGlitch == 8889 or ModeOfGlitch == 1236 or ModeOfGlitch == 343434 or ModeOfGlitch == 71 or ModeOfGlitch == 664663666 then
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 + 3600 * math.cos(sine / 360))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 + 3600 * math.cos(sine / 360))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 + 3600 * math.cos(sine / 360))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 - 3600 * math.cos(sine / 720))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 - 3600 * math.cos(sine / 720))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 - 3600 * math.cos(sine / 720))),.3)
		elseif ModeOfGlitch == 343435 or ModeOfGlitch == 88893333388 then
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 + 3600 * math.cos(sine / 360))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 + 3600 * math.cos(sine / 360))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 + 3600 * math.cos(sine / 360))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 - 3600 * math.cos(sine / 720))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 - 3600 * math.cos(sine / 720))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 - 3600 * math.cos(sine / 720))),.3)

			lwing4weld.C1=clerp(lwing4weld.C1,cf(2.5 + 5 * math.cos(sine / 180),0.5 + 1.5 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 - 3600 * math.cos(sine / 360))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(2.5 + 5 * math.cos(sine / 180),0.5 + 1.5 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 - 3600 * math.cos(sine / 360))),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(2.5 + 5 * math.cos(sine / 180),0.5 + 1.5 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 - 3600 * math.cos(sine / 360))),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(1.5 + 3 * math.cos(sine / 360),-0.25 - 1 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 + 3600 * math.cos(sine / 720))),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(1.5 + 3 * math.cos(sine / 360),-0.25 - 1 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 + 3600 * math.cos(sine / 720))),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(1.5 + 3 * math.cos(sine / 360),-0.25 - 1 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 + 3600 * math.cos(sine / 720))),.3)
		elseif ModeOfGlitch == 666666 then
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 320),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 5400 * math.cos(sine / 1008))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 320),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 + 5400 * math.cos(sine / 1008))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 320),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 + 5400 * math.cos(sine / 1008))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 320),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 + 5400 * math.cos(sine / 1008))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 320),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 + 5400 * math.cos(sine / 1008))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 320),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 + 5400 * math.cos(sine / 1008))),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(2.5 + 5 * math.cos(sine / 180),0.4 + 1.5 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 - 3600 * math.cos(sine / 540))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(2.5 + 5 * math.cos(sine / 180),0.4 + 1.5 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 - 3600 * math.cos(sine / 540))),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(2.5 + 5 * math.cos(sine / 180),0.4 + 1.5 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 - 3600 * math.cos(sine / 540))),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(1.5 + 3 * math.cos(sine / 504),-0.3 - 1.1 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 + 5400 * math.cos(sine / 1008))),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(1.5 + 3 * math.cos(sine / 504),-0.3 - 1.1 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 + 5400 * math.cos(sine / 1008))),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(1.5 + 3 * math.cos(sine / 504),-0.3 - 1.1 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 + 5400 * math.cos(sine / 1008))),.3)

		elseif ModeOfGlitch == 3444 then
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0.25)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50) - math.random(-60,60) * math.cos(sine / 1)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 3600 * math.cos(sine / 360) - 90 * math.cos(sine / 1))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70) - math.random(-60,60) * math.cos(sine / 1)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 + 3600 * math.cos(sine / 360) - 90 * math.cos(sine / 1))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60) - math.random(-60,60) * math.cos(sine / 1)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 + 3600 * math.cos(sine / 360) - 90 * math.cos(sine / 1))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50) - math.random(-60,60) * math.cos(sine / 1)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 + 3600 * math.cos(sine / 360) - 90 * math.cos(sine / 1))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70) - math.random(-60,60) * math.cos(sine / 1)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 + 3600 * math.cos(sine / 360) - 90 * math.cos(sine / 1))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60) - math.random(-60,60) * math.cos(sine / 1)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 + 3600 * math.cos(sine / 360) - 90 * math.cos(sine / 1))),.3)
		elseif ModeOfGlitch == 102 then
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handlexweld.C0=clerp(handlexweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),0 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 2 * math.cos(sine / 55)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 3 * math.cos(sine / 42)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 5 * math.cos(sine / 56))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 3 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 5 * math.cos(sine / 56))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 3 * math.cos(sine / 48)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 5 * math.cos(sine / 56))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 3 * math.cos(sine / 46)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 5 * math.cos(sine / 56))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 3 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 5 * math.cos(sine / 56))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 3 * math.cos(sine / 40)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 5 * math.cos(sine / 56))),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 + 3600 * math.cos(sine / 360))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 + 3600 * math.cos(sine / 360))),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 + 3600 * math.cos(sine / 360))),.3)
		elseif ModeOfGlitch == 103 then
			handleweld.C0=clerp(handleweld.C0,cf(0,-1.5,-1.5)*angles(math.rad(90),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 + 3600 * math.cos(sine / 360))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 + 3600 * math.cos(sine / 360))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 + 3600 * math.cos(sine / 360))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 - 3600 * math.cos(sine / 720))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 - 3600 * math.cos(sine / 720))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),1.5)*angles(math.rad(90 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 - 3600 * math.cos(sine / 720))),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 3600 * math.cos(sine / 360))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 - 3600 * math.cos(sine / 360))),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 - 3600 * math.cos(sine / 360))),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 3600 * math.cos(sine / 360))),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 - 3600 * math.cos(sine / 360))),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 - 3600 * math.cos(sine / 360))),.3)
		elseif ModeOfGlitch == 102341 then
			lwing1weld.C1=clerp(lwing1weld.C1,cf(2,0,-0.4)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(5 + 10 * math.cos(sine / 32)),math.rad(0),math.rad(12.5 + 5 * math.cos(sine / 32))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(3,1,-0.4)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(10 + 15 * math.cos(sine / 32)),math.rad(0),math.rad(25 + 7.5 * math.cos(sine / 32))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(3.75,2,-0.4)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(15 + 20 * math.cos(sine / 32)),math.rad(0),math.rad(37.5 + 10 * math.cos(sine / 32))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(-2,0,-0.4)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(5 + 10 * math.cos(sine / 32)),math.rad(0),math.rad(-12.5 - 5 * math.cos(sine / 32))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(-3,1,-0.4)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(10 + 15 * math.cos(sine / 32)),math.rad(0),math.rad(-25 - 7.5 * math.cos(sine / 32))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(-3.75,2,-0.3)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(15 + 20 * math.cos(sine / 32)),math.rad(0),math.rad(-37.5 - 10 * math.cos(sine / 32))),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(0,2 - 1.5 * math.cos(sine / 32.5),0)*angles(math.rad(0),math.rad(0),math.rad(360 + 720 * math.cos(sine / 65))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(0,0 - 1 * math.cos(sine / 32.5),-0.8)*angles(math.rad(0 + 5 * math.cos(sine / 32.5)),math.rad(0),math.rad(360)),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(0,2 - 1.5 * math.cos(sine / 32.5),0)*angles(math.rad(0),math.rad(0),math.rad(180 + 720 * math.cos(sine / 65))),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(0,2 - 1.5 * math.cos(sine / 32.5),0)*angles(math.rad(0),math.rad(0),math.rad(-90 + 720 * math.cos(sine / 65))),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(0,-1 + 1 * math.cos(sine / 32.5),-0.9)*angles(math.rad(0 + 5 * math.cos(sine / 32.5)),math.rad(0),math.rad(180)),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(0,2 - 1.5 * math.cos(sine / 32.5),-0.9)*angles(math.rad(0),math.rad(0),math.rad(90 + 720 * math.cos(sine / 65))),.3)
		elseif ModeOfGlitch == 101 then
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 + 3600 * math.cos(sine / 360))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 + 3600 * math.cos(sine / 360))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 + 3600 * math.cos(sine / 360))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 - 3600 * math.cos(sine / 720))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 - 3600 * math.cos(sine / 720))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0 + 1.5 * math.cos(sine / 360),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 - 3600 * math.cos(sine / 720))),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 3600 * math.cos(sine / 360))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 - 3600 * math.cos(sine / 360))),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 - 3600 * math.cos(sine / 360))),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 3600 * math.cos(sine / 360))),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 - 3600 * math.cos(sine / 360))),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 - 3600 * math.cos(sine / 360))),.3)
		elseif ModeOfGlitch == 61 then
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 + 3600 * math.cos(sine / 160))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 + 3600 * math.cos(sine / 160))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),0.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 + 3600 * math.cos(sine / 160))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0 + 1.5 * math.cos(sine / 230),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(0 - 3600 * math.cos(sine / 550))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0 + 1.5 * math.cos(sine / 230),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(120 - 3600 * math.cos(sine / 550))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0 + 1.5 * math.cos(sine / 230),-0.25 - 0.5 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-120 - 3600 * math.cos(sine / 550))),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 3600 * math.cos(sine / 160))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 - 3600 * math.cos(sine / 160))),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 - 3600 * math.cos(sine / 160))),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 3600 * math.cos(sine / 160))),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 - 3600 * math.cos(sine / 160))),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 - 3600 * math.cos(sine / 160))),.3)
		elseif ModeOfGlitch == 999999999556 then
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 4500 * math.cos(sine / 280))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 + 4500 * math.cos(sine / 280))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 + 4500 * math.cos(sine / 280))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 + 4500 * math.cos(sine / 280))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 + 4500 * math.cos(sine / 280))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 + 4500 * math.cos(sine / 280))),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 4500 * math.cos(sine / 280))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 - 4500 * math.cos(sine / 280))),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 - 4500 * math.cos(sine / 280))),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 4500 * math.cos(sine / 280))),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 - 4500 * math.cos(sine / 280))),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 - 4500 * math.cos(sine / 280))),.3)
		elseif ModeOfGlitch == 146536 then
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0,1.5 + 0.75 * math.cos(sine / 21),0)*angles(math.rad(0 + 1 + 1 * math.cos(sine / 1)),math.rad(0 - 1),1 + 1),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0,1.5 + 0.75 * math.cos(sine / 21),0)*angles(math.rad(0 + 1 * math.cos(sine / 1)),math.rad(0 - 2),1 + 2),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.5 + 0.75 * math.cos(sine / 21),0)*angles(math.rad(0 + 1 * math.cos(sine / 1)),math.rad(0 - 3),1 + 3),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0,1.5 + 0.75 * math.cos(sine / 21),0)*angles(math.rad(0 + 1 * math.cos(sine / 1)),math.rad(0 - 4),1 + 4),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0,1.5 + 0.75 * math.cos(sine / 21),0)*angles(math.rad(0 + 1 * math.cos(sine / 1)),math.rad(0 - 5),1 + 5),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.5 + 0.75 * math.cos(sine / 21),0)*angles(math.rad(0 + 1 * math.cos(sine / 1)),math.rad(0 - 6),1 + 6),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 27),-1)*angles(math.rad(0 + 1 * math.cos(sine / 1)),math.rad(0 - 7),1 + 7),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 28),-1)*angles(math.rad(0 + 1 * math.cos(sine / 1)),math.rad(0 - 8),1 + 8),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 29),-1)*angles(math.rad(0 + 1 * math.cos(sine / 1)),math.rad(0 - 9),1 + 9),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 30),-1)*angles(math.rad(0 + 1 * math.cos(sine / 1)),math.rad(0 - 10),1 + 10),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 31),-1)*angles(math.rad(0 + 1 * math.cos(sine / 1)),math.rad(0 - 11),1 + 11),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 32),-1)*angles(math.rad(0 + 1 * math.cos(sine / 1)),math.rad(0 - 12),1 + 12),.3)
		elseif ModeOfGlitch == 808080808080808080808080  or ModeOfGlitch == 909090 or ModeOfGlitch == 765688533321 or ModeOfGlitch == 1264532489 or ModeOfGlitch == 6518594185 then
			handlexweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 3600 * math.cos(sine / 360))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 + 3600 * math.cos(sine / 360))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 + 3600 * math.cos(sine / 360))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 + 3600 * math.cos(sine / 360))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 + 3600 * math.cos(sine / 360))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0 + 2.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),0)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 + 3600 * math.cos(sine / 360))),.3)
			lwing4weld.C1=clerp(lwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 3600 * math.cos(sine / 360))),.3)
			lwing5weld.C1=clerp(lwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(147.5 - 3600 * math.cos(sine / 360))),.3)
			lwing6weld.C1=clerp(lwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(32.5 - 3600 * math.cos(sine / 360))),.3)
			rwing4weld.C1=clerp(rwing4weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 50)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 3600 * math.cos(sine / 360))),.3)
			rwing5weld.C1=clerp(rwing5weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 70)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-147.5 - 3600 * math.cos(sine / 360))),.3)
			rwing6weld.C1=clerp(rwing6weld.C1,cf(0 - 7.5 * math.cos(sine / 180),1.5 + 0.75 * math.cos(sine / 25),-1)*angles(math.rad(0 + 1 * math.cos(sine / 60)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-32.5 - 3600 * math.cos(sine / 360))),.3)
		end
		sine = sine + change
		local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
		local velderp=RootPart.Velocity.y
		hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
		coroutine.resume(coroutine.create(function()
			if ModeOfGlitch == 666666 then
				slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-2.4,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.002,0.01),math.random(15,60)/250,BrickColor.new("Crimson"))
				PixelBlockX(2,math.random(60,190)/45,"Add",root.CFrame*CFrame.new(math.random(-20,20),-6,math.random(-20,20))*CFrame.Angles(math.rad(90 + math.random(-6,6)),math.rad(math.random(-6,6)),math.random(-6,6)),0.75,0.75,0.75,0,BrickColor.new("Really red"),0)
				PixelBlockX(5,0.25,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.65,0.65,0.65,0.0065,BrickColor.new(0.4,0,0),0)
				PixelBlockX(5,0.25,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.65,0.65,0.65,0.0065,BrickColor.new(0.4,0,0),0)
			end
		end))
		coroutine.resume(coroutine.create(function()
			if ModeOfGlitch == 71 then
				if hitfloor ~= nil then
					sphere2(3,"Add",root.CFrame*CFrame.new(0,-3,0),vt(3,0.55,3),0.025,-0.01,0.025,MAINRUINCOLOR)
				end
			end
		end))
		coroutine.resume(coroutine.create(function()
			if ModeOfGlitch == 343434 then
				if hitfloor ~= nil then
					slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,50)/250,BrickColor.new("Neon orange"))
				end
			end
		end))
		coroutine.resume(coroutine.create(function()
			if ModeOfGlitch == 6 or ModeOfGlitch == 343435 or ModeOfGlitch == 909090 or ModeOfGlitch == 102341 or ModeOfGlitch == 6518594185 or ModeOfGlitch == 999 or ModeOfGlitch == 453453484635345 or ModeOfGlitch == 3434 or ModeOfGlitch == 1055 or ModeOfGlitch == 103 or ModeOfGlitch == 61 or ModeOfGlitch == 3444 or ModeOfGlitch == 101 or ModeOfGlitch == 8 or ModeOfGlitch == 664663666 or ModeOfGlitch == 1264532489 or ModeOfGlitch == 55469696922 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 999999999556 or ModeOfGlitch == 8889 or ModeOfGlitch == 765688533321 or ModeOfGlitch == 88893333388 or ModeOfGlitch == 808080808080808080808080 then
				if hitfloor ~= nil then
					effar.Enabled = true
					effar.Color = ColorSequence.new(MAINRUINCOLOR.Color)
					slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,50)/250,BrickColor.new("White"))
					if ModeOfGlitch == 1264532489 or ModeOfGlitch == 343435 or ModeOfGlitch == 999 or ModeOfGlitch == 103 or ModeOfGlitch == 61 or ModeOfGlitch == 101 or ModeOfGlitch == 88893333388 or ModeOfGlitch == 55469696922 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 999999999556 or ModeOfGlitch == 765688533321 or ModeOfGlitch == 808080808080808080808080 then
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,150)/250,MAINRUINCOLOR)
					end
					if ModeOfGlitch == 808080808080808080808080 then
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,350)/250,BrickColor.new("Alder"))
					elseif ModeOfGlitch == 765688533321  then
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,350)/250,BrickColor.new("Really red"))
					elseif ModeOfGlitch == 88893333388 then
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,350)/250,BrickColor.new("Really blue"))
					elseif ModeOfGlitch == 103 then
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,350)/250,BrickColor.new("Really black"))	
					elseif ModeOfGlitch == 61 then
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,350)/250,MAINRUINCOLOR)	
					elseif ModeOfGlitch == 1264532489  then
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,350)/250,BrickColor.new("Deep orange"))
					elseif ModeOfGlitch == 102341 then
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,350)/250,BrickColor.new("New Yeller"))
					elseif ModeOfGlitch == 6518594185 then
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,350)/250,BrickColor.new("Hot pink"))
					elseif ModeOfGlitch == 999999999556  then
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,350)/250,BrickColor.new("Really black"))
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,350)/250,BrickColor.new("Really black")

						)end
				elseif hitfloor == nil then
					effar.Enabled = false
				end
			elseif ModeOfGlitch ~= 6 and ModeOfGlitch ~= 3444 and ModeOfGlitch ~= 103 and ModeOfGlitch ~= 101 and ModeOfGlitch ~= 8 and ModeOfGlitch ~= 664663666 and ModeOfGlitch ~= 88893333388 and ModeOfGlitch ~= 1264532489 and ModeOfGlitch ~= 55469696922 and ModeOfGlitch ~= 4367677813 and ModeOfGlitch ~= 9999999921111 and ModeOfGlitch ~= 999999999556 and ModeOfGlitch ~= 8889 and ModeOfGlitch ~= 765688533321 and ModeOfGlitch ~= 808080808080808080808080 then
				effar.Enabled = false
			end
		end))
		if equipped==true or equipped==false then
			if attack==false then
				idle=idle+1
			else
				idle=0
			end
			if idle>=500 then
				if attack==false then
					--Sheath()
				end
			end
			if RootPart.Velocity.y > 1 and hitfloor==nil then 
				Anim="Jump"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
				end
			elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
				Anim="Fall"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(10),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(55)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-55)),.1)
				end
			elseif torvel<1 and hitfloor~=nil then
				Anim="Idle"
				if attack==false then
					if ModeOfGlitch == 1 then
						local snap = math.random(1,10)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 + math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(22 + math.random(-5,5))),1)
						end
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(22 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 32),0 + 0.1 * math.cos(sine / 32))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-22 + 2 * math.cos(sine / 56))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 - 2 * math.cos(sine / 37)),math.rad(0 + 5 * math.cos(sine / 43) - 5 * math.cos(sine / 0.25)),math.rad(22 - 2 * math.cos(sine / 56))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 + 3 * math.cos(sine / 43)),math.rad(-16 - 5 * math.cos(sine / 52)),math.rad(13 + 9 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.35,1 + 0.025 * math.cos(sine / 45),-0.2)*angles(math.rad(148 - 2 * math.cos(sine / 51)),math.rad(0 - 4 * math.cos(sine / 64)),math.rad(22 - 2 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 676767 then
						local snap = math.random(1,10)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1)
						end
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Alder"),Color3.new(0.7,0.7,1))
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-14 - 5 * math.cos(sine / 48))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 7 * math.cos(sine / 51))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,6 + 0.5 * math.cos(sine / 24))*angles(math.rad(10 - 0.5 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 1 * math.cos(sine / 0.5265)),math.rad(0 - 1 * math.cos(sine / 0.25)),math.rad(0 - 1 * math.cos(sine / 0.465))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.3,0.7,0)*angles(math.rad(0 + 1 * math.cos(sine / 0.568)),math.rad(15 - 5 * math.cos(sine / 24)),math.rad(-145 - 15 * math.cos(sine / 24))),.1)
					elseif ModeOfGlitch == 2 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-0.5),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 + 3 * math.cos(sine / 42))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 58)),math.rad(0 + 1 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 453453484635345 then
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Institutional white"),BrickColor.new("Dark stone grey").Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-20)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(20 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 + 3 * math.cos(sine / 43)),math.rad(-16 - 5 * math.cos(sine / 52)),math.rad(13 + 9 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(90 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(90 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 3 then
						local snap = math.random(1,32)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1)
						end
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 146536 then
						RH.C0=clerp(RH.C0,cf(1, -1 - 0.025 * math.cos(sine/12), -0.01)*angles(math.rad(0),math.rad(83),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
						LH.C0=clerp(LH.C0,cf(-1, -1 - 0.05 * math.cos(sine/12), -0.01)*angles(math.rad(0),math.rad(-83),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0, 0, 0 + 0.05 * math.cos(sine / 12))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0, 0, 0 + ((1) - 1))*angles(math.rad(15 - 2.5 * math.sin(sine / 12)),math.rad(0),math.rad(0)),0.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.125 * math.cos(sine / 12),-0.45)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.125 * math.cos(sine / 12),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 909090 then --Aesthetic Idle
						RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(-60 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 + 3 * math.cos(sine / 43)),math.rad(-16 - 5 * math.cos(sine / 52)),math.rad(60 + 9 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-0.98,1 + 0.025 * math.cos(sine / 45),0.7)*angles(math.rad(90 - 7 * math.cos(sine / 66)),math.rad(50 - 3 * math.cos(sine / 59)),math.rad(90 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 3434 then -- bacc
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * CF(2 + Cos(sine / 70) * Cos(sine / 28) - 2, 0 , 5 + 1* Player_Size * Cos(sine / 24)) * angles(Rad(0 + 0.5 * Cos(sine / 20)), Rad(0), Rad(0)), 0.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(3 - 3 * Cos(sine / 16))), 0.1)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-14 - 5 * math.cos(sine / 48))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 7 * math.cos(sine / 51))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)

					elseif ModeOfGlitch == 102 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1.1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(-7),math.rad(-90),math.rad(0))*angles(math.rad(5 + 2 * math.cos(sine / 32)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 7 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.25)*angles(math.rad(33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.25)*angles(math.rad(23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 4 then
						local snap = math.random(1,5)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),0.6)
							RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 + 5 * math.cos(sine / 74) + math.random(-1,1)),math.rad(1 - 3 * math.cos(sine / 53) + math.random(-1,1)),math.rad(1 + 3 * math.cos(sine / 45) + math.random(-1,1))),.6)
							LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 - 3 * math.cos(sine / 73) + math.random(-1,1)),math.rad(2 - 1 * math.cos(sine / 55) + math.random(-1,1)),math.rad(-3 - 3 * math.cos(sine / 45) + math.random(-1,1))),.6)
						end
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(25 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-25 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(25 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(1 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-3 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 5 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(10 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(8 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-14 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 3444 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(8 - 6 * math.cos(sine / 67) - 5 * math.cos(sine / 1)),math.rad(0 - 1 * math.cos(sine / 56) - 5 * math.cos(sine / 1)),math.rad(-18 - 5 * math.cos(sine / 32) - 5 * math.cos(sine / 1))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15 - 8 * math.cos(sine / 74) - 5 * math.cos(sine / 1)),math.rad(0 - 1 * math.cos(sine / 56) - 5 * math.cos(sine / 1)),math.rad(31 + 8 * math.cos(sine / 38) - 5 * math.cos(sine / 1))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(-21 - 2 * math.cos(sine / 32) - 5 * math.cos(sine / 1)),math.rad(8 - 5 * math.cos(sine / 1)),math.rad(0 - 5 * math.cos(sine / 1))),.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko* cf(0, 0, 0 + ((1) - 1)) * angles(math.rad(15 - 2.5 * math.cos(sine / 30) - 5 * math.cos(sine / 1)), math.rad(20 - 5 * math.cos(sine / 1)), math.rad(0 - 5 * math.cos(sine / 1))), 0.08)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(3 + 7 * math.cos(sine / 79) - 5 * math.cos(sine / 1)),math.rad(1 - 3 * math.cos(sine / 53) - 5 * math.cos(sine / 1)),math.rad(33 + 10 * math.cos(sine / 73) - 5 * math.cos(sine / 1))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(15 - 3 * math.cos(sine / 73) - 5 * math.cos(sine / 1)),math.rad(2 - 1 * math.cos(sine / 55) - 5 * math.cos(sine / 1)),math.rad(-27 - 6 * math.cos(sine / 33) - 5 * math.cos(sine / 1))),.1)
					elseif ModeOfGlitch == 090 then --RAINBOW Idle
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-7.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(10 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(172 - 7 * math.cos(sine / 58)),math.rad(1 - 5 * math.cos(sine / 55)),math.rad(19 - 3 * math.cos(sine / 45))),.2)
					elseif ModeOfGlitch == 102341 then -- Theories --
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("New Yeller"),BrickColor.new("New Yeller").Color)
						sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
						sphereMK(2,-0.5,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-10,5),8)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),0.5,0.5,20,-0.0075,MAINRUINCOLOR,0)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.65)*angles(math.rad(-15),math.rad(84),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,-0.2)*angles(math.rad(-10),math.rad(-84),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),2 + 0.15 * math.cos(sine / 32))*angles(math.rad(-5 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-15 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(20 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-15 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-24.5 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 664663666 then --verybio
						local snap = math.random(1,5)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),0.6)
							RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 + 5 * math.cos(sine / 74) + math.random(-1,1)),math.rad(1 - 3 * math.cos(sine / 53) + math.random(-1,1)),math.rad(1 + 3 * math.cos(sine / 45) + math.random(-1,1))),.6)
						end
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25 + 0.02 * math.cos(sine / 32),1 + 0.1 * math.cos(sine / 32))*angles(math.rad(25 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(1 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(160),math.rad(0),math.rad(25)),.1)
					elseif ModeOfGlitch == 6 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 7 * math.cos(sine / 56))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 52))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(14 + 5 * math.cos(sine / 32))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-14 - 6 * math.cos(sine / 33))),.1)
					elseif ModeOfGlitch == 8 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-20)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(20 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 9 then
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Lime green"),Color3.new(0,1,0))
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-4 - 2 * math.cos(sine / 53)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(9 - 2 * math.cos(sine / 53)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 2 * math.cos(sine / 53))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(19 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(18 - 3 * math.cos(sine / 53)),math.rad(17 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(-11 - 1 * math.cos(sine / 55)),math.rad(-14 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 71 then
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28) - 0.04 * math.cos(sine / 50),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1 + 4 * math.cos(sine / 50)),math.rad(0),math.rad(0 - 2 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28) + 0.04 * math.cos(sine / 50),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5 - 4 * math.cos(sine / 50)),math.rad(18),math.rad(0 + 2 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.04 * math.cos(sine / 50),0 + 0.03 * math.cos(sine / 34),0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0 + 4 * math.cos(sine / 50)),math.rad(18)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 1 * math.cos(sine / 28)),math.rad(-5 - 2.5 * math.cos(sine / 57)),math.rad(-18)),.1)
						RW.C0=clerp(RW.C0,cf(0.85,0.5 + 0.05 * math.cos(sine / 28),-0.65)*angles(math.rad(36 - 7 * math.cos(sine / 34)),math.rad(0 - 6 * math.cos(sine / 45)),math.rad(-80 + 2 * math.cos(sine / 28))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(0 + 3 * math.cos(sine / 49)),math.rad(10 + 2 * math.cos(sine / 52)),math.rad(-5 - 3 * math.cos(sine / 39))),.1)
					elseif ModeOfGlitch == 8889 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 5 * math.cos(sine / 51))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 44))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-36)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(36 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(3 + 7 * math.cos(sine / 79)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(33 + 10 * math.cos(sine / 73))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(15 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-27 - 6 * math.cos(sine / 33))),.1)
					elseif ModeOfGlitch == 88893333388 then
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 9 * math.cos(sine / 51))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 7 * math.cos(sine / 44))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 43),0 - 0.25 * math.cos(sine / 53),6 + 1 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(13)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(24 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-13 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(68 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(82 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 103 then
						sphere2(8,"Add",LeftArm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really black"),BrickColor.new("Deep orange").Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 9 * math.cos(sine / 51))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 7 * math.cos(sine / 44))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 47),0 + 0.25 * math.cos(sine / 35),7 + 1 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(13)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(24 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-13 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(68 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(149 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-17 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 808080808080808080808080 then
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Pastel light blue"),BrickColor.new("Pastel light blue").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Alder"),BrickColor.new("Alder").Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 9 * math.cos(sine / 51))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 7 * math.cos(sine / 44))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 47),0 + 0.25 * math.cos(sine / 35),7 + 1 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(13)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(24 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-13 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(68 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(82 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 6518594185 then
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Hot pink"),BrickColor.new("Light blue").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("New Yeller"),BrickColor.new("Really blue").Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 9 * math.cos(sine / 51))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 7 * math.cos(sine / 44))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 47),0 + 0.25 * math.cos(sine / 35),7 + 1 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(13)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(24 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-13 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 14 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(35 - 8 * math.cos(sine / 51))),.1)
					elseif ModeOfGlitch == 1264532489 then
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Deep orange"),BrickColor.new("Deep orange").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Toothpaste"),BrickColor.new("Toothpaste").Color)
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-14 - 5 * math.cos(sine / 48))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 7 * math.cos(sine / 51))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 43),0 - 0.25 * math.cos(sine / 53),6 + 1 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(21 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(13 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(28 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 101 then
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Bright bluish green"),BrickColor.new("Bright bluish green").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really black"),BrickColor.new("Black").Color)
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Black"),BrickColor.new("Black").Color)
						sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-14 - 5 * math.cos(sine / 48))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 7 * math.cos(sine / 51))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 43),0 - 0.25 * math.cos(sine / 53),6 + 1 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(21 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(13 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(28 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(13 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-23 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 61 then
						local snap = math.random(1,4)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1)
						end
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(20),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-14 - 5 * math.cos(sine / 48))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(20),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 7 * math.cos(sine / 51))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 43),0 - 0.25 * math.cos(sine / 53),6 + 1 * math.cos(sine / 32))*angles(math.rad(20 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(21 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.2)*angles(math.rad(130 + 6 * math.cos(sine / 72) + MRANDOM(-20,20)),math.rad(3 - 2 * math.cos(sine / 58) + MRANDOM(-20,20)),math.rad(-38 + 2 * math.cos(sine / 45) + MRANDOM(-20,20))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.2)*angles(math.rad(130 - 7 * math.cos(sine / 66) + MRANDOM(-20,20)),math.rad(4 - 3 * math.cos(sine / 59) + MRANDOM(-20,20)),math.rad(33 - 4 * math.cos(sine / 45) + MRANDOM(-20,20))),.1)
					elseif ModeOfGlitch == 1055 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(8 - 6 * math.cos(sine / 67)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-18 - 5 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15 - 8 * math.cos(sine / 74)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(31 + 8 * math.cos(sine / 38))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(-21 - 2 * math.cos(sine / 32)),math.rad(8),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 6 * math.cos(sine / 37)),math.rad(-14 + 5 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)

					elseif ModeOfGlitch == 9999999921111 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(8 - 6 * math.cos(sine / 67)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-18 - 5 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15 - 8 * math.cos(sine / 74)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(31 + 8 * math.cos(sine / 38))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(-21 - 2 * math.cos(sine / 32)),math.rad(8),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 6 * math.cos(sine / 37)),math.rad(-14 + 5 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-24 + 9 * math.cos(sine / 72)),math.rad(3 - 5 * math.cos(sine / 58)),math.rad(38 + 7 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-0.8,0.35 + 0.025 * math.cos(sine / 45),-0.75)*angles(math.rad(160 - 2 * math.cos(sine / 66)),math.rad(5 - 8 * math.cos(sine / 59)),math.rad(87 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 4367677813 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(10)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 58)),math.rad(-10 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(4 + 3 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(19 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.25,0.5 + 0.025 * math.cos(sine / 45),-0.15)*angles(math.rad(10 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(13 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 2332 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-0.5),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 + 3 * math.cos(sine / 42))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 58)),math.rad(0 + 1 * math.cos(sine / 53))),.1)
						LW.C0 = aclerp(LW.C0,CFrame.new(-0.787155986, 0.248306945, -0.683226228, 0.0398273654, -0.999169707, 0.00859495346, 0.554963291, 0.0149663882, -0.831740201, 0.830920994, 0.0378959104, 0.555098593)*angles(math.rad(0+5*math.cos(sine/32)),0,0),Alpha)
						RW.C0 = aclerp(RW.C0,CFrame.new(0.787632346, 0.574486911, -0.794373989, 0.0789790228, 0.995851278, 0.0451963581, 0.631366551, -0.0148838377, -0.775341749, -0.771452367, 0.0897712111, -0.629922688)*angles(math.rad(0+5*math.cos(sine/32)),0,0),Alpha)
					elseif ModeOfGlitch == 2334 then
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
						tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
						RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
						LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-0.95,0.65 + 0.075 * math.cos(sine / 28),-0.65)*angles(math.rad(90 + 2 * math.cos(sine / 73)),math.rad(25 + 5 * math.cos(sine / 24)),math.rad(73 - 3 * math.cos(sine / 65))),.1)
					elseif ModeOfGlitch == 666666 then
						local snap = math.random(1,30)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 + math.random(-45,0)),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),1)
							RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.4 * math.cos(sine / 30),0 + 0.4 * math.cos(sine / 32),5.2 + 0.4 * math.cos(sine / 26))*angles(math.rad(20 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(math.random(-5,5))),1)
							RW.C0=clerp(RW.C0,cf(1.35,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(math.random(40,185) + 6 * math.cos(sine / 72)),math.rad(2 - 4 * math.cos(sine / 58)),math.rad(math.random(-35,-7) + 1 * math.cos(sine / 45))),1)
							LW.C0=clerp(LW.C0,cf(-1.35,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(math.random(40,187) - 7 * math.cos(sine / 66)),math.rad(6 - 5 * math.cos(sine / 59)),math.rad(math.random(9,31) - 3 * math.cos(sine / 45))),1)
						end
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(-15 - 5 * math.cos(sine / 32)),math.rad(100- 5 * math.cos(sine / 32)),math.rad(0))*angles(math.rad(-3 + math.random(-5,5)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(-15 - 2.5 * math.cos(sine / 32)),math.rad(-95),math.rad(0))*angles(math.rad(-3 + math.random(-5,5)),math.rad(0 - 1 * math.cos(sine / 56)+ math.random(-5,5)),math.rad(10 + 6 * math.cos(sine / 31) + math.random(-5,5))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.2 * math.cos(sine / 30),0 + 0.2 * math.cos(sine / 34),5.2 + 0.4 * math.cos(sine / 26))*angles(math.rad(0 - 2 * math.cos(sine / 32) + math.random(-5,5)),math.rad(0 + math.random(-5,5)),math.rad(math.random(-5,5))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37) + math.random(-5,5)),math.rad(0 + 1 * math.cos(sine / 58) + math.random(-5,5)),math.rad(0 + 2 * math.cos(sine / 53) + math.random(-5,5))),.1)
						RW.C0=clerp(RW.C0,cf(0.9,0.5 + 0.1 * math.cos(sine / 34),-0.5)*angles(math.rad(0 + math.random(-5,5)),math.rad(-20 - 7.5 * math.cos(sine / 26) + math.random(-5,5)),math.rad(-90 - 5 * math.cos(sine / 34) + math.random(-5,5))),.3)
						LW.C0=clerp(LW.C0,cf(-0.9,0.4 + 0.1 * math.cos(sine / 34),-0.5)*angles(math.rad(0 + math.random(-5,5)),math.rad(20 + 7.5 * math.cos(sine / 32) + math.random(-5,5)),math.rad(87.5 + 5 * math.cos(sine / 34) + math.random(-5,5))),.3)

					elseif ModeOfGlitch == 765688533321 then
						local snap = math.random(1,12)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1)
						end
						local snap2 = math.random(1,32)
						if snap2 == 1 then
							RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.25 * math.cos(sine / 50),0 + 0.25 * math.cos(sine / 43),6 + 1 * math.cos(sine / 32))*angles(math.rad(20 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),1)
							RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 - 2 * math.cos(sine / 39))),1)
							LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 + 6 * math.cos(sine / 31))),1)
							RW.C0=clerp(RW.C0,cf(1.5,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(185 + 6 * math.cos(sine / 72)),math.rad(2 - 4 * math.cos(sine / 58)),math.rad(-12 + 1 * math.cos(sine / 45))),1)
							LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(185 - 7 * math.cos(sine / 66)),math.rad(6 - 5 * math.cos(sine / 59)),math.rad(9 - 3 * math.cos(sine / 45))),1)
						end
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really red"),BrickColor.new("Really red").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.25 * math.cos(sine / 50),0 + 0.25 * math.cos(sine / 43),6 + 1 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(2 - 4 * math.cos(sine / 58)),math.rad(-65 + 1 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(6 - 5 * math.cos(sine / 59)),math.rad(73 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 55469696922 then
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-14 - 5 * math.cos(sine / 48))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 7 * math.cos(sine / 51))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.25 * math.cos(sine / 50),0 + 0.25 * math.cos(sine / 43),6 + 1 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 14 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(35 - 8 * math.cos(sine / 51))),.1)
					elseif ModeOfGlitch == 343434 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-10 + 2 * math.cos(sine / 43)),math.rad(0 - 2 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(0 + 2 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 34),0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 2 * math.cos(sine / 34)),math.rad(0),math.rad(10 - 2 * math.cos(sine / 43))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0 - 2 * math.cos(sine / 47)),math.rad(-10 + 2 * math.cos(sine / 43))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(10 + 3 * math.cos(sine / 48)),math.rad(-20 - 4 * math.cos(sine / 53)),math.rad(15 - 3 * math.cos(sine / 38))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-10 + 2 * math.cos(sine / 45)),math.rad(0),math.rad(-20 + 2 * math.cos(sine / 39))),.1)
					elseif ModeOfGlitch == 343435 then -- Lunar --
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-4 - 7 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 8 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 47),0 + 0.25 * math.cos(sine / 35),7 + 1 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(13)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(10 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.3+.2*math.cos(sine/32),-.65)*angles(math.rad(60),0,math.rad(-90)),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.6+.2*math.cos(sine/32),-.65)*angles(math.rad(40),0,math.rad(90)),.1)
					elseif ModeOfGlitch == 999 then
						sphere2(2.5,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						sphere2(2.5,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 9 * math.cos(sine / 51))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 7 * math.cos(sine / 44))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 47),0 + 0.25 * math.cos(sine / 35),3 + 1 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(13)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(24 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-13 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(8 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-14 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 664663666 then
						local snap = math.random(1,32)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(32 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1)
						end
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-4 - 7 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 8 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(32 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(32 + 6 * math.cos(sine / 72)),math.rad(2 - 4 * math.cos(sine / 58)),math.rad(14 + 1 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(32 - 7 * math.cos(sine / 66)),math.rad(6 - 5 * math.cos(sine / 59)),math.rad(-9 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 1236 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(3),math.rad(0 + 3 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(6),math.rad(0 + 3 * math.cos(sine / 56)),math.rad(3 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 6 * math.cos(sine / 56))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-3 - 5 * math.cos(sine / 37)),math.rad(0 + 14 * math.cos(sine / 58)),math.rad(0 + 3 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.45)*angles(math.rad(33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.45)*angles(math.rad(23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 999999999556 then
						local snap = math.random(1,8)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(32 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),1)
						end
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + MRANDOM(-3,3)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 6 * math.cos(sine / 39) + MRANDOM(-5,5))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + MRANDOM(-3,3)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 45) + MRANDOM(-5,5))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.25 * math.cos(sine / 47),0 - 0.25 * math.cos(sine / 40),7 + 1 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(17)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(29 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-17 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72) + MRANDOM(-10,10)),math.rad(3 - 2 * math.cos(sine / 58) + MRANDOM(-20,20)),math.rad(-82 + 2 * math.cos(sine / 45) + MRANDOM(-20,20))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(99 - 7 * math.cos(sine / 66) + MRANDOM(-20,20)),math.rad(4 - 3 * math.cos(sine / 59) + MRANDOM(-20,20)),math.rad(67 - 4 * math.cos(sine / 45) + MRANDOM(-20,20))),.1)
					end
				end
			elseif torvel>2 and torvel<22 and hitfloor~=nil then
				Anim="Walk"
				if attack==false then
					if ModeOfGlitch ~= 102 and ModeOfGlitch ~= 1236 and ModeOfGlitch ~= 2334 then
						RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 - 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 5 * math.cos(sine / 8))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 5 * math.cos(sine / 8))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
						if ModeOfGlitch == 71 then
							sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						end
					elseif ModeOfGlitch == 2334 then
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7) * angles(Rad(9-2.5 * Cos(sine / 3.5)), Rad(0), Rad(10 * Cos(sine / 7))), 0.15)
						tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
						RH.C0 = clerp(RH.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(sine / 7) / 2, 0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 - 35 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 2 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
						LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(sine / 7) / 2, -0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 + 35 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
						RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(70) * Cos(sine / 7) , Rad(0), Rad(5)), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-70) * Cos(sine / 7) , Rad(0),	Rad(-5)), 0.1)
					elseif ModeOfGlitch == 102 or ModeOfGlitch == 1236 then
						RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 - 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 5 * math.cos(sine / 8))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 5 * math.cos(sine / 8))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.25)*angles(math.rad(33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.25)*angles(math.rad(23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
					end
				end
			elseif torvel>=22 and hitfloor~=nil then
				Anim="Run"
				if attack==false then
					if ModeOfGlitch ~= 6 and ModeOfGlitch ~= 666666 and ModeOfGlitch ~= 343435 and ModeOfGlitch ~= 909090 and ModeOfGlitch ~= 102341 and ModeOfGlitch ~= 1055 and ModeOfGlitch ~= 6518594185 and ModeOfGlitch ~= 61 and ModeOfGlitch ~= 676767 and ModeOfGlitch ~= 3434 and ModeOfGlitch ~= 453453484635345 and ModeOfGlitch ~= 103 and ModeOfGlitch ~= 999 and ModeOfGlitch ~= 3444 and ModeOfGlitch ~= 101 and ModeOfGlitch ~= 8 and ModeOfGlitch ~= 1264532489 and ModeOfGlitch ~= 55469696922 and ModeOfGlitch ~= 4367677813 and ModeOfGlitch ~= 9999999921111 and ModeOfGlitch ~= 999999999556 and ModeOfGlitch ~= 8889 and ModeOfGlitch ~= 765688533321 and ModeOfGlitch ~= 664663666 and ModeOfGlitch ~= 88893333388 and ModeOfGlitch ~= 808080808080808080808080 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 95 * math.cos(sine / 6))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 95 * math.cos(sine / 6))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sine / 3))*angles(math.rad(25 - 4 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 1 * math.cos(sine / 6))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-6 + 2 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 1 * math.cos(sine / 6))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0.3)*angles(math.rad(-50 + 10 * math.cos(sine / 3)),math.rad(-10),math.rad(7 + 5 * math.cos(sine / 6))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.3)*angles(math.rad(-50 + 10 * math.cos(sine / 3)),math.rad(10),math.rad(-7 - 5 * math.cos(sine / 6))),.1)
						if ModeOfGlitch == 9 then
							sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
							sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Lime green"),Color3.new(0,1,0))
							sphereMK(2,-0.5,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),8)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.5,0.5,20,-0.0075,MAINRUINCOLOR,0)
						end
					elseif ModeOfGlitch == 102341 then -- theories 
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("New Yeller"),BrickColor.new("New Yeller").Color)
						sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
						sphereMK(2,-0.5,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),8)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),0.5,0.5,20,-0.0075,MAINRUINCOLOR,0)
					elseif ModeOfGlitch == 666666 then
						local snap = math.random(1,30)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 + math.random(-45,0)),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),1)
						end
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(-15 - 5 * math.cos(sine / 32)),math.rad(100- 5 * math.cos(sine / 32)),math.rad(0))*angles(math.rad(-3 + math.random(-5,5)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(-15 - 2.5 * math.cos(sine / 32)),math.rad(-95),math.rad(0))*angles(math.rad(-3 + math.random(-5,5)),math.rad(0 - 1 * math.cos(sine / 56)+ math.random(-5,5)),math.rad(10 + 6 * math.cos(sine / 31) + math.random(-5,5))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.2 * math.cos(sine / 30),0 + 0.2 * math.cos(sine / 34),5.2 + 0.4 * math.cos(sine / 26))*angles(math.rad(50 - 2 * math.cos(sine / 32) + math.random(-5,5)),math.rad(0 + math.random(-5,5)),math.rad(math.random(-5,5))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37) + math.random(-5,5)),math.rad(0 + 1 * math.cos(sine / 58) + math.random(-5,5)),math.rad(0 + 2 * math.cos(sine / 53) + math.random(-5,5))),.1)
						RW.C0=clerp(RW.C0,cf(0.9,0.5 + 0.1 * math.cos(sine / 34),-0.5)*angles(math.rad(0 + math.random(-5,5)),math.rad(-20 - 7.5 * math.cos(sine / 26) + math.random(-5,5)),math.rad(-90 - 5 * math.cos(sine / 34) + math.random(-5,5))),.3)
						LW.C0=clerp(LW.C0,cf(-0.9,0.4 + 0.1 * math.cos(sine / 34),-0.5)*angles(math.rad(0 + math.random(-5,5)),math.rad(20 + 7.5 * math.cos(sine / 32) + math.random(-5,5)),math.rad(87.5 + 5 * math.cos(sine / 34) + math.random(-5,5))),.3)
					elseif ModeOfGlitch == 6518594185 then
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Hot pink"),BrickColor.new("Light blue").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("New Yeller"),BrickColor.new("Really blue").Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 9 * math.cos(sine / 51))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 7 * math.cos(sine / 44))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 47),0 + 0.25 * math.cos(sine / 35),7 + 1 * math.cos(sine / 32))*angles(math.rad(28 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-24 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 14 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(35 - 8 * math.cos(sine / 51))),.1)
					elseif ModeOfGlitch == 999 then
						sphere2(2.5,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						sphere2(2.5,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 9 * math.cos(sine / 51))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 7 * math.cos(sine / 44))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 47),0 + 0.25 * math.cos(sine / 35),3 + 1 * math.cos(sine / 32))*angles(math.rad(34 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-13 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(8 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-14 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 6 or ModeOfGlitch == 3444 or ModeOfGlitch == 8 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 8889 or ModeOfGlitch == 664663666  then
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,1 + 0.25 * math.cos(sine / 28))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.05)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
					elseif ModeOfGlitch == 453453484635345 then
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Institutional white"),BrickColor.new("Medium stone grey").Color)
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,1 + 0.25 * math.cos(sine / 28))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.05)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-50 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-20 - 20 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(110 + 5 * math.cos(sine / 50))),.2)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(90 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(90 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 103 then
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,6.5 + 0.25 * math.cos(sine / 28))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.05)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
					elseif ModeOfGlitch == 1055 then
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,1 + 0.25 * math.cos(sine / 28))*angles(math.rad(40),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.05)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
					elseif ModeOfGlitch == 909090 then
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,0.5 + 0.1 * math.cos(sine / 12))*angles(math.rad(40),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
						RW.C0=clerp(RW.C0,cf(1.4,0.5 + 0.025 * math.cos(sine / 45),-0.1)*angles(math.rad(160 + 3 * math.cos(sine / 74)),math.rad(0 - 1 * math.cos(sine / 53)),math.rad(-15 + 5 * math.cos(sine / 32))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),-0)*angles(math.rad(-5 - 5 * math.cos(sine / 73)),math.rad(0 - 2.25 * math.cos(sine / 55)),math.rad(-15 - 6 * math.cos(sine / 33))),.1)
					elseif ModeOfGlitch == 1264532489 or ModeOfGlitch == 88893333388 or ModeOfGlitch == 343435 or ModeOfGlitch == 61 or ModeOfGlitch == 3434 or ModeOfGlitch == 676767 or ModeOfGlitch == 101 or ModeOfGlitch == 999999999556 or ModeOfGlitch == 765688533321 or ModeOfGlitch == 55469696922 or ModeOfGlitch == 808080808080808080808080 then
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,6.5 + 0.25 * math.cos(sine / 28))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.05)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
						if ModeOfGlitch == 765688533321 or ModeOfGlitch == 101 or ModeOfGlitch == 090 then
							sphereMK(2,-0.5,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),8)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.5,0.5,20,-0.0075,MAINRUINCOLOR,0)
						end
					end
				end
			end
		end
	end


end)

Button_11.MouseButton1Down:Connect(function()
	wait(0.2)

	local script = game:GetObjects("rbxassetid://6035538952")[1]

	warn([[SpectrumGlitcher v5 AWAKENED Loaded.
The super switcher.
Velnorum is one of the first wielders.

Created, Reworked by NoobyGames12
Edited by GodzPlaysRB
Edited by wanTH092 (Gam_Filano CH)
SpectrumGlitcher Developers ^^^
]])


	------------- ORIGINAL WIELDER OC: Velnorum
	print([[Icons:
! = New
? = Spoilers
* = Exclusivity
C = Changes

]])
	warn([[V 4.35 Update Log:
! - Added Betrayal mode (Chaos M)

!? - Added z move to destiny
!c? = Added calamity transition
!? - upcoming transition for some mode..
- Removed some voice sound effects because they didnt sound right
]])
	--- its obs smooth af do not touch 
	---- Sources and functions might be taken from others

	-- Nebula stuff --
	local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
	local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
	local C3 = {tRGB= function(c3) return c3.r*255,c3.g*255,c3.b*255 end,N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
	local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
	local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
	local R3 = {N=Region3.new}
	local De = S.Debris
	local WS = workspace
	local Lght = S.Lighting
	local RepS = S.ReplicatedStorage
	local IN = Instance.new
	local Plrs = S.Players
	local FXFolder = script:FindFirstChild'Effects'
	FXFolder.Parent = nil
	local Alpha = .3

	NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance)
		inst.Parent = parent
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end
	-- Script --

	plr = game.Players.LocalPlayer
	char = plr.Character["Dummy"]
	hum = char.Humanoid
	local cam = game.Workspace.CurrentCamera
	Camera = cam
	local CamInterrupt = false
	local TwoD = false
	local TargetInfo = {nil, nil}
	cam.CameraType = "Custom"
	t = char.Torso
	h = char.Head
	ra = char["Right Arm"]
	la = char["Left Arm"]
	rl = char["Right Leg"]
	ll = char["Left Leg"]
	tors = char.Torso
	lleg = char["Left Leg"]
	root = char.HumanoidRootPart
	hed = char.Head
	rleg = char["Right Leg"]
	rarm = char["Right Arm"]
	larm = char["Left Arm"]
	radian = math.rad
	random = math.random
	Vec3 = Vector3.new
	Inst = Instance.new
	cFrame = CFrame.new
	Euler = CFrame.fromEulerAnglesXYZ
	vt = Vector3.new
	bc = BrickColor.new
	br = BrickColor.random
	it = Instance.new
	cf = CFrame.new
	local Player_Size = 0
	cam = game.Workspace.CurrentCamera
	CF = CFrame.new
	angles = CFrame.Angles
	attack = false
	Euler = CFrame.fromEulerAnglesXYZ
	Rad = math.rad
	IT = Instance.new
	BrickC = BrickColor.new
	Cos = math.cos
	Acos = math.acos
	Sin = math.sin
	Asin = math.asin
	Abs = math.abs
	Mrandom = math.random
	Floor = math.floor
	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor
	local SINE = 0

	local Booleans = {
		CamFollow = true,
		GyroUse = true
	}

	function lerp(object, newCFrame, alpha)
		return object:lerp(newCFrame, alpha)
	end

	local Directer = Inst("BodyGyro", root)
	Directer.MaxTorque = Vec3(0, 0, 0)
	Directer.P = 600000
	local CPart = Inst("Part")
	CPart.Anchored = true
	CPart.CanCollide = false
	CPart.Locked = true
	CPart.Transparency = 1

	local rainbowmode = false
	local chaosmode = false

	local kan = Instance.new("Sound",tors)
	kan.Volume = 0.85
	kan.TimePosition = 0
	kan.PlaybackSpeed = 1
	kan.Pitch = 1
	kan.SoundId = "rbxassetid://3271126110"
	kan.Name = "wrecked"
	kan.Looped = true
	kan:Play()

	local currentThemePlaying = kan.SoundId
	local currentPitch = kan.Pitch
	local currentVol = kan.Volume
	function newTheme(ID,timepos,pitch,vol)
		local kanz = kan
		--kanz:Stop()
		kanz.Volume = vol
		--kanz.TimePosition = timepos
		kanz.PlaybackSpeed = pitch
		kanz.Pitch = pitch
		kanz.SoundId = ID
		kanz.Name = "wrecked"
		kanz.Looped = true
		currentThemePlaying = kanz.SoundId
		currentVol = kanz.Volume
		currentPitch = kanz.Pitch
		--kanz:Play()
		--coroutine.resume(coroutine.create(function()
		--wait(0.05)
		--end))
	end


	function newThemeCust(ID,timepos,pitch,vol)
		local kanz = kan
		kanz:Stop()
		kanz.Volume = vol
		kanz.TimePosition = timepos
		kanz.PlaybackSpeed = pitch
		kanz.Pitch = pitch
		kanz.SoundId = ID
		kanz.Name = "wrecked"
		kanz.Looped = true
		currentThemePlaying = kanz.SoundId
		currentVol = kanz.Volume
		currentPitch = kanz.Pitch
		kanz:Play()
		coroutine.resume(coroutine.create(function()
			wait(0.05)
		end))
	end

	local mutedtog = false

	function CameraEnshaking(Length,Intensity)
		coroutine.resume(coroutine.create(function()
			local intensity = 1*Intensity
			local rotM = 0.01*Intensity
			for i = 0, Length, 0.1 do
				swait()
				intensity = intensity - 0.05*Intensity/Length
				rotM = rotM - 0.0005*Intensity/Length
				hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
				cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
			end
			Humanoid.CameraOffset = Vec3(0, 0, 0)
		end))
	end
	CamShake=function(Part,Distan,Power,Times) 
		local de=Part.Position
		for i,v in pairs(workspace:children()) do
			if v:IsA("Model") and v:findFirstChild("Humanoid") then
				for _,c in pairs(v:children()) do
					if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
						local Noob=v.Humanoid
						if Noob~=nil then
							coroutine.resume(coroutine.create(function()
								FV = Instance.new("BoolValue", Noob)
								FV.Name = "CameraShake"
								for ShakeNum=1,Times do
									swait()
									local ef=Power
									if ef>=1 then
										Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
									else
										ef=Power*10
										Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
									end	
								end
								Humanoid.CameraOffset = Vector3.new(0,0,0)
								FV:Destroy()
							end))
							CameraShake(Times, Power, Noob)
						end
					end
				end
			end
		end
	end

	local toggleTag = true
	local bilguit = Instance.new("BillboardGui", hed)
	bilguit.Adornee = nil
	bilguit.Name = "ModeName"
	bilguit.Size = UDim2.new(4, 0, 1.2, 0)
	bilguit.StudsOffset = Vector3.new(-8, 8/1.5, 0)
	local modet = Instance.new("TextLabel", bilguit)
	modet.Size = UDim2.new(10/2, 0, 7/2, 0)
	modet.FontSize = "Size8"
	modet.TextScaled = true
	modet.TextTransparency = 0
	modet.BackgroundTransparency = 1 
	modet.TextTransparency = 0
	modet.TextStrokeTransparency = 0
	modet.Font = "Antique"
	modet.TextStrokeColor3 = Color3.new(1,1,1)
	modet.TextColor3 = Color3.new(0,0,0)
	modet.Text = "Peculiarity"


	function chatfunc(text,color,typet,font,timeex)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard")~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end
			local naeeym2 = Instance.new("BillboardGui",Character)
			naeeym2.Size = UDim2.new(0,100,0,40)
			naeeym2.StudsOffset = Vector3.new(0,3,0)
			naeeym2.Adornee = Character.Head
			naeeym2.Name = "TalkingBillBoard"
			local tecks2 = Instance.new("TextLabel",naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.BorderSizePixel = 0
			tecks2.Text = ""
			tecks2.Font = font
			tecks2.TextSize = 30
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = color
			tecks2.TextStrokeColor3 = Color3.new(0,0,0)
			tecks2.Size = UDim2.new(1,0,0.5,0)
			local tecks3 = Instance.new("TextLabel",naeeym2)
			tecks3.BackgroundTransparency = 1
			tecks3.BorderSizePixel = 0
			tecks3.Text = ""
			tecks3.Font = font
			tecks3.TextSize = 30
			tecks3.TextStrokeTransparency = 0
			if typet == "Inverted" then
				tecks3.TextColor3 = Color3.new(0,0,0)
				tecks3.TextStrokeColor3 = color
			elseif typet == "Normal" then
				tecks3.TextColor3 = color
				tecks3.TextStrokeColor3 = Color3.new(0,0,0)
			end
			tecks3.Size = UDim2.new(1,0,0.5,0)
			coroutine.resume(coroutine.create(function()
				while true do
					swait(1)
					if chaosmode == true then
						tecks2.TextColor3 = BrickColor.random().Color
						tecks3.TextStrokeColor3 = BrickColor.random().Color
					end
				end
			end))
			modet.TextTransparency = modet.TextTransparency  + 1
			modet.TextStrokeTransparency = modet.TextStrokeTransparency + 1
			for i = 0, 74*timeex do
				swait()
				modet.TextTransparency = 1
				modet.TextStrokeTransparency = 1
				tecks2.Text = text
				tecks3.Text = text
			end
			local randomrot = math.random(1,2)
			if randomrot == 1 then
				for i = 1, 50 do
					swait()
					tecks2.Text = text
					tecks3.Text = text
					modet.TextTransparency = modet.TextTransparency - .02
					modet.TextStrokeTransparency = modet.TextStrokeTransparency - .02
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			elseif randomrot == 2 then
				for i = 1, 50 do
					swait()
					tecks2.Text = text
					tecks3.Text = text
					modet.TextTransparency = modet.TextTransparency - .02
					modet.TextStrokeTransparency = modet.TextStrokeTransparency - .02
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			end
			modet.TextTransparency = 0
			modet.TextStrokeTransparency = 0
			if toggleTag == false then
				modet.TextTransparency = 1
				modet.TextStrokeTransparency = 1
			end
			naeeym2:Destroy()
		end)
		chat()
	end


	loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()

	local Create = LoadLibrary("RbxUtility").Create

	CFuncs = {	
		["Part"] = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part"){
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material,
				}
				RemoveOutlines(Part)
				return Part
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Weld"] = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld"){
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1,
				}
				return Weld
			end;
		};

		["Sound"] = {
			Create = function(id, par, vol, pit) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 10)
				end))
			end;
		};

		["TimeSound"] = {
			Create = function(id, par, vol, pit, timepos) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						TimePosition = timepos,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 10)
				end))
			end;
		};
		["EchoSound"] = {
			Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
				coroutine.resume(coroutine.create(function()
					local Sas = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						TimePosition = timepos,
						Parent = par or workspace,
					}
					local E = Create("EchoSoundEffect"){
						Delay = echodelay,
						Name = "Echo",
						Feedback = fedb,
						DryLevel = dryl,
						Parent = Sas,
					}
					wait() 
					Sas:play() 
					game:GetService("Debris"):AddItem(Sas, delays)
				end))
			end;
		};

		["LongSound"] = {
			Create = function(id, par, vol, pit) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 60)
				end))
			end;
		};

		["ParticleEmitter"] = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter"){
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread,
				}
				return fp
			end;
		};

		CreateTemplate = {

		};
	}



	New = function(Object, Parent, Name, Data)
		local Object = Instance.new(Object)
		for Index, Value in pairs(Data or {}) do
			Object[Index] = Value
		end
		Object.Parent = Parent
		Object.Name = Name
		return Object
	end
	local halocolor = BrickColor.new("Pastel light blue")
	local halocolor2 = BrickColor.new("Cool yellow")
	local starcolor = BrickColor.new("Bright yellow")
	local lunacolor = BrickColor.new("Navy blue")
	local lunacolor2 = BrickColor.new("Bright blue")
	local wepcolor = BrickColor.new("Really black")
	local maincolor = BrickColor.new("Really black")
	local m = Instance.new("Model",char)
	local m2 = Instance.new("Model",char)
	local m3 = Instance.new("Model",char)
	local mw1 = Instance.new("Model",char)
	local mw2 = Instance.new("Model",char)


	gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
		local gui = it(GuiType)
		gui.Parent = parent
		gui.Text = text
		gui.BackgroundTransparency = backtrans
		gui.BackgroundColor3 = backcol
		gui.SizeConstraint = "RelativeXY"
		gui.TextXAlignment = "Center"
		gui.TextYAlignment = "Center"
		gui.Position = pos
		gui.Size = size
		gui.Font = "SourceSans"
		gui.FontSize = "Size14"
		gui.TextWrapped = false
		gui.TextStrokeTransparency = 0
		gui.TextColor = BrickColor.new("White")
		return gui
	end
	--------------------------- GUI STUFF
	local basgui = it("GuiMain")
	basgui.Parent = plr.PlayerGui
	basgui.Name = "VISgui"
	local fullscreenz = it("Frame")
	fullscreenz.Parent = basgui
	fullscreenz.BackgroundColor3 = Color3.new(255, 255, 255)
	fullscreenz.BackgroundTransparency = 1
	fullscreenz.BorderColor3 = Color3.new(17, 17, 17)
	fullscreenz.Size = UDim2.new(1, 0, 1, 0)
	fullscreenz.Position = UDim2.new(0, 0, 0, 0)
	local ned = Instance.new("TextLabel",fullscreenz)
	ned.ZIndex = 2
	ned.Font = "Arcade"
	ned.BackgroundTransparency = 1
	ned.BorderSizePixel = 0.65
	ned.Size = UDim2.new(0.3,0,0.2,0)
	ned.Position = UDim2.new(0.35,0,0.8,0)
	ned.TextColor3 = BrickColor.new("Lily white").Color
	ned.TextStrokeColor3 = BrickColor.new("Really black").Color
	ned.TextScaled = false
	ned.TextStrokeTransparency = 0
	ned.Text = "Peculiarity"
	ned.TextSize = 24
	ned.Rotation = 1
	ned.TextXAlignment = "Center"
	ned.TextYAlignment = "Center"
	local XD = Instance.new("TextLabel",fullscreenz)
	XD.ZIndex = 2
	XD.Font = "Arcade"
	XD.BackgroundTransparency = 1
	XD.BorderSizePixel = 0.65
	XD.Size = UDim2.new(0.3,0,0.2,0)
	XD.Position = UDim2.new(0.35,0,0,0)
	XD.TextColor3 = BrickColor.new("Lily white").Color
	XD.TextStrokeColor3 = BrickColor.new("Really black").Color
	XD.TextScaled = false
	XD.TextStrokeTransparency = 0
	XD.Text = "Mode: Star"
	XD.TextSize = 24
	XD.Rotation = 1
	XD.TextXAlignment = "Center"
	XD.TextYAlignment = "Center"
	local NAMET = Instance.new("TextLabel",fullscreenz)
	NAMET.ZIndex = 2
	NAMET.Font = "Arcade"
	NAMET.BackgroundTransparency = 1
	NAMET.BorderSizePixel = 0.65
	NAMET.Size = UDim2.new(0.3,0,0.2,0)
	NAMET.Position = UDim2.new(0,0,0.3,0)
	NAMET.TextColor3 = BrickColor.new("Lily white").Color
	NAMET.TextStrokeColor3 = BrickColor.new("Really black").Color
	NAMET.TextScaled = false
	NAMET.TextStrokeTransparency = 0
	NAMET.Text = "Edit by fcsrz"
	NAMET.TextSize = 24
	NAMET.Rotation = 15
	NAMET.TextXAlignment = "Center"
	NAMET.TextYAlignment = "Center"

	local extrawingmod1 = Instance.new("Model",char)
	local extrawingmod2 = Instance.new("Model",char)

	function CreateParta(parent,transparency,reflectance,material,brickcolor)
		local p = Instance.new("Part")
		p.TopSurface = 0
		p.BottomSurface = 0
		p.Parent = parent
		p.Size = Vector3.new(0.1,0.1,0.1)
		p.Transparency = transparency
		p.Reflectance = reflectance
		p.CanCollide = false
		p.Locked = true
		p.BrickColor = brickcolor
		p.Material = material
		return p
	end

	function CreateMesh(parent,meshtype,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = meshtype
		mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
		return mesh
	end

	function CreateSpecialMesh(parent,meshid,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.Scale = Vector3.new(x1,y1,z1)
		return mesh
	end


	function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
		mesh.Scale = Vector3.new(x1,y1,z1)
		mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
		return mesh
	end

	function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
		local weld = Instance.new("Weld")
		weld.Parent = parent
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
		weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
		return weld
	end


	--------------
	local maincolg = Model0
	local seccolg = Model0

	---- WEAPON OR STUFF
	local rarmor = CreateParta(m,1,0,"SmoothPlastic",BrickColor.Random())
	local weaponweld = CreateWeld(rarmor,tors,rarmor,-3,0,-0.5,math.rad(0),math.rad(0),math.rad(-40),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local MainWeldS = CreateWeld(Part475,rarmor,Part475,0,0,0,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local A0 = Instance.new("Attachment",rarmor)
	A0.Position = Vector3.new(-2.5,0.25,0)
	local A1 = Instance.new("Attachment",rarmor)
	A1.Position = Vector3.new(-7.5,0.4,0)
	tl1 = Instance.new('Trail',rarmor)
	tl1.Attachment0 = A0
	tl1.Attachment1 = A1
	tl1.Texture = "http://www.roblox.com/asset/?id=1978704853"
	tl1.LightEmission = 1
	tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl1.Color = ColorSequence.new(BrickColor.new('Royal purple').Color)
	tl1.Lifetime = 0.6
	tl1.Enabled = false

	--------------
	local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWeld(sorb,rarm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWeld(sorb2,larm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local handlex = CreateParta(m2,1,1,"Neon",BrickColor.random())
	CreateMesh(handle,"Brick",0,0,0)
	local handlexweld = CreateWeld(handlex,Torso,handlex,0,0,-1.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local handlex2 = CreateParta(m2,1,1,"Neon",BrickColor.random())
	CreateMesh(handle,"Brick",0,0,0)
	local handlexweld2 = CreateWeld(handlex2,Torso,handlex2,0,0,-1.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local valuaring = 10

	handlex = CreateParta(mw2,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0,0,0)
	CreateWeld(handlex,tors,handlex,0,-3,-2.1,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))


	local refec = Instance.new("ParticleEmitter",handlex)
	refec.Texture = "rbxassetid://284205403"
	refec.LightEmission = 0.95
	refec.Color = ColorSequence.new(BrickColor.new("White").Color)
	refec.Rate = 50
	refec.Lifetime = NumberRange.new(0.5)
	refec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.5,0.75,0),NumberSequenceKeypoint.new(1,0.1,0)})
	refec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
	refec.Speed = NumberRange.new(0,2)
	refec.Drag = 5
	refec.LockedToPart = true
	refec.Rotation = NumberRange.new(-500,500)
	refec.VelocitySpread = 9000
	refec.RotSpeed = NumberRange.new(-500,500)
	local refec2 = refec:Clone()
	refec2.LightEmission = 0.75
	refec2.Texture = "rbxassetid://254287058"
	refec2.Parent = handlex
	refec2.Rate = 25
	refec2.Lifetime = NumberRange.new(0.75)
	refec2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.5,0),NumberSequenceKeypoint.new(0.15,1,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,0.1,0)})
	refec2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.65,0),NumberSequenceKeypoint.new(1,1,0)})
	refec2.Speed = NumberRange.new(0)
	local refec3 = refec:Clone()
	refec3.LightEmission = 0.75
	refec3.Texture = "rbxassetid://363275192"
	refec3.Parent = handlex
	refec3.Rate = 25
	refec3.Lifetime = NumberRange.new(1)
	refec3.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0.1,0)})
	refec3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.65,0),NumberSequenceKeypoint.new(1,1,0)})
	refec3.Speed = NumberRange.new(0)
	refec3.RotSpeed = NumberRange.new(-50,50)

	for i = 0, 8.75 do
		valuaring = valuaring + 60
		rn = CreateParta(mw2,0,0,"Neon",BrickColor.random())
		CreateMesh(rn,"Wedge",0.1,0.5,0.1)
		CreateWeld(rn,handlex,rn,0,0.75,0,math.rad(0),math.rad(-90),math.rad(valuaring),0,0,0,math.rad(0),math.rad(0),math.rad(0))
		rn = CreateParta(mw2,0,0,"Neon",BrickColor.random())
		CreateMesh(rn,"Wedge",0.1,0.5,0.1)
		CreateWeld(rn,handlex,rn,0,0.75,0,math.rad(0),math.rad(90),math.rad(valuaring),0,0,0,math.rad(0),math.rad(0),math.rad(0))
		rn = CreateParta(mw2,0,0,"Neon",BrickColor.random())
		CreateMesh(rn,"Wedge",0.1,0.2,0.05)
		CreateWeld(rn,handlex,rn,0,-1.1,0.025,math.rad(0),math.rad(-90),math.rad(valuaring),0,0,0,math.rad(0),math.rad(0),math.rad(0))
		rn = CreateParta(mw2,0,0,"Neon",BrickColor.random())
		CreateMesh(rn,"Wedge",0.1,0.2,0.05)
		CreateWeld(rn,handlex,rn,0,-1.1,0.025,math.rad(0),math.rad(90),math.rad(valuaring),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	end

	for i = 0, 17.5 do
		valuaring = valuaring + 20
		rn = CreateParta(mw4,0,0,"Neon",BrickColor.random())
		CreateMesh(rn,"Wedge",0.1,0.5,0.1)
		CreateWeld(rn,handlex2,rn,0,1.125,0,math.rad(0),math.rad(-90),math.rad(valuaring),0,0,0,math.rad(0),math.rad(0),math.rad(0))
		rn = CreateParta(mw4,0,0,"Neon",BrickColor.random())
		CreateMesh(rn,"Wedge",0.1,0.5,0.1)
		CreateWeld(rn,handlex2,rn,0,1.125,0,math.rad(0),math.rad(90),math.rad(valuaring),0,0,0,math.rad(0),math.rad(0),math.rad(0))
		rn = CreateParta(mw4,0,0,"Neon",BrickColor.random())
		CreateMesh(rn,"Wedge",0.1,0.2,0.05)
		CreateWeld(rn,handlex2,rn,0,-1.475,0.025,math.rad(0),math.rad(-90),math.rad(valuaring),0,0,0,math.rad(0),math.rad(0),math.rad(0))
		rn = CreateParta(mw4,0,0,"Neon",BrickColor.random())
		CreateMesh(rn,"Wedge",0.1,0.2,0.05)
		CreateWeld(rn,handlex2,rn,0,-1.475,0.025,math.rad(0),math.rad(90),math.rad(valuaring),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	end

	local handle = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local handleweld = CreateWeld(handle,tors,handle,0,-1.5,-1.05,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	--- Left wing.

	local MPASword = {}
	for _,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
		if v:IsA("Accessory") and v.Name:find("MeshPartAccessory") and v.Handle.Size == Vector3.new(4,4,1) then
			table.insert(MPASword,v)
		end
	end

	local lwing1 = script.Things.Wing:Clone()
	lwing1.Parent = m
	local lwing1weld = CreateWeld(lwing1.MainWelder,handle,lwing1.MainWelder,0,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,1,1,math.rad(-90),math.rad(0),math.rad(0))

	local function align(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(1, 1, 0) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(-50, 80, 80) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = false
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end





	local lwing1top = lwing1.Top
	local lwing1topweld = CreateWeld(lwing1top.Welder,lwing1.MainWelder,lwing1top.Welder,0,0,-1.1,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if MPASword[1] then

		local HatChoice = MPASword[1]

		align(HatChoice.Handle, lwing1.Top.Welder)

		table.remove(MPASword,1)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	local lwing1right = lwing1.Right
	local lwing1rightweld = CreateWeld(lwing1right.Welder,lwing1.MainWelder,lwing1right.Welder,-1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local lwing1left = lwing1.Left
	local lwing1leftweld = CreateWeld(lwing1left.Welder,lwing1.MainWelder,lwing1left.Welder,1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local lwing2 = script.Things.Wing:Clone()
	lwing2.Parent = m
	local lwing2weld = CreateWeld(lwing2.MainWelder,handle,lwing2.MainWelder,0,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,1,1,math.rad(-90),math.rad(0),math.rad(0))



	local lwing2top = lwing2.Top
	local lwing2topweld = CreateWeld(lwing2top.Welder,lwing2.MainWelder,lwing2top.Welder,0,0,-1.1,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if MPASword[1] then

		local HatChoice = MPASword[1]

		align(HatChoice.Handle, lwing2.Top.Welder)

		table.remove(MPASword,1)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	local lwing2right = lwing2.Right
	local lwing2rightweld = CreateWeld(lwing2right.Welder,lwing2.MainWelder,lwing2right.Welder,-1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local lwing2left = lwing2.Left
	local lwing2leftweld = CreateWeld(lwing2left.Welder,lwing2.MainWelder,lwing2left.Welder,1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local lwing3 = script.Things.Wing:Clone()
	lwing3.Parent = m
	local lwing3weld = CreateWeld(lwing3.MainWelder,handle,lwing3.MainWelder,0,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,1,1,math.rad(-90),math.rad(0),math.rad(0))



	local lwing3top = lwing3.Top
	local lwing3topweld = CreateWeld(lwing3top.Welder,lwing3.MainWelder,lwing3top.Welder,0,0,-1.1,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if game.Players.LocalPlayer.Character:FindFirstChild("BladeMasterAccessory") then

		local HatChoice = game.Players.LocalPlayer.Character:FindFirstChild("BladeMasterAccessory")

		align(HatChoice.Handle, lwing3.Top.Welder)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	local lwing3right = lwing3.Right
	local lwing3rightweld = CreateWeld(lwing3right.Welder,lwing3.MainWelder,lwing3right.Welder,-1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local lwing3left = lwing3.Left
	local lwing3leftweld = CreateWeld(lwing3left.Welder,lwing3.MainWelder,lwing3left.Welder,1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	-- Right wing --

	local rwing1 = script.Things.Wing:Clone()
	rwing1.Parent = m
	local rwing1weld = CreateWeld(rwing1.MainWelder,handle,rwing1.MainWelder,0,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,1,1,math.rad(-90),math.rad(0),math.rad(0))



	local rwing1top = rwing1.Top
	local rwing1topweld = CreateWeld(rwing1top.Welder,rwing1.MainWelder,rwing1top.Welder,0,0,-1.1,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if MPASword[1] then

		local HatChoice = MPASword[1]

		align(HatChoice.Handle, rwing1.Top.Welder)

		table.remove(MPASword,1)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	local rwing1right = rwing1.Right
	local rwing1rightweld = CreateWeld(rwing1right.Welder,rwing1.MainWelder,rwing1right.Welder,-1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local rwing1left = rwing1.Left
	local rwing1leftweld = CreateWeld(rwing1left.Welder,rwing1.MainWelder,rwing1left.Welder,1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local rwing2 = script.Things.Wing:Clone()
	rwing2.Parent = m
	local rwing2weld = CreateWeld(rwing2.MainWelder,handle,rwing2.MainWelder,0,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,1,1,math.rad(-90),math.rad(0),math.rad(0))



	local rwing2top = rwing2.Top
	local rwing2topweld = CreateWeld(rwing2top.Welder,rwing2.MainWelder,rwing2top.Welder,0,0,-1.1,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if MPASword[1] then

		local HatChoice = MPASword[1]

		align(HatChoice.Handle, rwing2.Top.Welder)

		table.remove(MPASword,1)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	local rwing2right = rwing2.Right
	local rwing2rightweld = CreateWeld(rwing2right.Welder,rwing2.MainWelder,rwing2right.Welder,-1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local rwing2left = rwing2.Left
	local rwing2leftweld = CreateWeld(rwing2left.Welder,rwing2.MainWelder,rwing2left.Welder,1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local rwing3 = script.Things.Wing:Clone()
	rwing3.Parent = m
	local rwing3weld = CreateWeld(rwing3.MainWelder,handle,rwing3.MainWelder,0,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,1,1,math.rad(-90),math.rad(0),math.rad(0))



	local rwing3top = rwing3.Top
	local rwing3topweld = CreateWeld(rwing3top.Welder,rwing3.MainWelder,rwing3top.Welder,0,0,-1.1,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	if game.Players.LocalPlayer.Character:FindFirstChild("ShadowBladeMasterAccessory") then

		local HatChoice = game.Players.LocalPlayer.Character:FindFirstChild("ShadowBladeMasterAccessory")

		align(HatChoice.Handle, rwing3.Top.Welder)

		HatChoice.Handle.AccessoryWeld:Destroy()
		HatChoice.Handle.Size = Vector3.new(1,1,1)
	end

	local rwing3right = rwing3.Right
	local rwing3rightweld = CreateWeld(rwing3right.Welder,rwing3.MainWelder,rwing3right.Welder,-1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local rwing3left = rwing3.Left
	local rwing3leftweld = CreateWeld(rwing3left.Welder,rwing3.MainWelder,rwing3left.Welder,1.1,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	--------------- Trails
	local A0 = Instance.new("Attachment",lwing1.MainWelder)
	A0.Position = Vector3.new(0,0,-0.35)
	local A1 = Instance.new("Attachment",lwing1.MainWelder)
	A1.Position = Vector3.new(0,0,-4.25)
	tl1 = Instance.new('Trail',lwing1.MainWelder)
	tl1.Attachment0 = A0
	tl1.Attachment1 = A1
	tl1.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tl1.LightEmission = 0.5
	tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl1.Color = ColorSequence.new(BrickColor.random().Color)
	tl1.Lifetime = 0.9

	local A0 = Instance.new("Attachment",lwing2.MainWelder)
	A0.Position = Vector3.new(0,0,-0.35)
	local A1 = Instance.new("Attachment",lwing2.MainWelder)
	A1.Position = Vector3.new(0,0,-4.25)
	tl2 = Instance.new('Trail',lwing2.MainWelder)
	tl2.Attachment0 = A0
	tl2.Attachment1 = A1
	tl2.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tl2.LightEmission = 0.5
	tl2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl2.Color = ColorSequence.new(BrickColor.random().Color)
	tl2.Lifetime = 0.9

	local A0 = Instance.new("Attachment",lwing3.MainWelder)
	A0.Position = Vector3.new(0,0,-0.35)
	local A1 = Instance.new("Attachment",lwing3.MainWelder)
	A1.Position = Vector3.new(0,0,-4.25)
	tl3 = Instance.new('Trail',lwing3.MainWelder)
	tl3.Attachment0 = A0
	tl3.Attachment1 = A1
	tl3.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tl3.LightEmission = 0.5
	tl3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tl3.Color = ColorSequence.new(BrickColor.random().Color)
	tl3.Lifetime = 0.9

	local A0 = Instance.new("Attachment",rwing1.MainWelder)
	A0.Position = Vector3.new(0,0,-0.35)
	local A1 = Instance.new("Attachment",rwing1.MainWelder)
	A1.Position = Vector3.new(0,0,-4.25)
	tr1 = Instance.new('Trail',rwing1.MainWelder)
	tr1.Attachment0 = A0
	tr1.Attachment1 = A1
	tr1.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tr1.LightEmission = 0.5
	tr1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr1.Color = ColorSequence.new(BrickColor.random().Color)
	tr1.Lifetime = 0.9

	local A0 = Instance.new("Attachment",rwing2.MainWelder)
	A0.Position = Vector3.new(0,0,-0.35)
	local A1 = Instance.new("Attachment",rwing2.MainWelder)
	A1.Position = Vector3.new(0,0,-4.25)
	tr2 = Instance.new('Trail',rwing2.MainWelder)
	tr2.Attachment0 = A0
	tr2.Attachment1 = A1
	tr2.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tr2.LightEmission = 0.5
	tr2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr2.Color = ColorSequence.new(BrickColor.random().Color)
	tr2.Lifetime = 0.9

	local A0 = Instance.new("Attachment",rwing3.MainWelder)
	A0.Position = Vector3.new(0,0,-0.35)
	local A1 = Instance.new("Attachment",rwing3.MainWelder)
	A1.Position = Vector3.new(0,0,-4.25)
	tr3 = Instance.new('Trail',rwing3.MainWelder)
	tr3.Attachment0 = A0
	tr3.Attachment1 = A1
	tr3.Texture = "http://www.roblox.com/asset/?id=1049219073"
	tr3.LightEmission = 0.5
	tr3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
	tr3.Color = ColorSequence.new(BrickColor.random().Color)
	tr3.Lifetime = 0.9

	--HERES THE RING

	gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateMesh(gan,"Brick",1.075,0.1,1.075)
	CreateWeld(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateMesh(gan,"Brick",1.075,0.1,1.075)
	CreateWeld(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



	gan = CreateParta(m2,0,0,"Neon",halocolor2)
	CreateMesh(gan,"Brick",1.095,0.035,1.095)
	CreateWeld(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gan = CreateParta(m2,0,0,"Neon",halocolor2)
	CreateMesh(gan,"Brick",1.095,0.035,1.095)
	CreateWeld(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
	CreateMesh(gane,"Brick",1.0625,0.2,1.0625)
	CreateWeld(gane,larm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateSpecialMesh(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
	CreateWeld(star,larm,star,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
	CreateSpecialMesh(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
	CreateWeld(starl,larm,starl,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateMesh(gan,"Brick",1.075,0.1,1.075)
	CreateWeld(gan,lleg,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateMesh(gan,"Brick",1.075,0.1,1.075)
	CreateWeld(gan,lleg,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



	gan = CreateParta(m2,0,0,"Neon",halocolor2)
	CreateMesh(gan,"Brick",1.095,0.035,1.095)
	CreateWeld(gan,lleg,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gan = CreateParta(m2,0,0,"Neon",halocolor2)
	CreateMesh(gan,"Brick",1.095,0.035,1.095)
	CreateWeld(gan,lleg,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
	CreateMesh(gane,"Brick",1.0625,0.2,1.0625)
	CreateWeld(gane,lleg,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateSpecialMesh(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
	CreateWeld(star,lleg,star,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
	CreateSpecialMesh(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
	CreateWeld(starl,lleg,starl,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	--- second ring


	gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateMesh(gan,"Brick",1.075,0.1,1.075)
	CreateWeld(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateMesh(gan,"Brick",1.075,0.1,1.075)
	CreateWeld(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



	gan = CreateParta(m2,0,0,"Neon",halocolor2)
	CreateMesh(gan,"Brick",1.095,0.035,1.095)
	CreateWeld(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gan = CreateParta(m2,0,0,"Neon",halocolor2)
	CreateMesh(gan,"Brick",1.095,0.035,1.095)
	CreateWeld(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
	CreateMesh(gane,"Brick",1.0625,0.2,1.0625)
	CreateWeld(gane,rarm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateSpecialMesh(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
	CreateWeld(star,rarm,star,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
	CreateSpecialMesh(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
	CreateWeld(starl,rarm,starl,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateMesh(gan,"Brick",1.075,0.1,1.075)
	CreateWeld(gan,rleg,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateMesh(gan,"Brick",1.075,0.1,1.075)
	CreateWeld(gan,rleg,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



	gan = CreateParta(m2,0,0,"Neon",halocolor2)
	CreateMesh(gan,"Brick",1.095,0.035,1.095)
	CreateWeld(gan,rleg,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gan = CreateParta(m2,0,0,"Neon",halocolor2)
	CreateMesh(gan,"Brick",1.095,0.035,1.095)
	CreateWeld(gan,rleg,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
	CreateMesh(gane,"Brick",1.0625,0.2,1.0625)
	CreateWeld(gane,rleg,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
	CreateSpecialMesh(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
	CreateWeld(star,rleg,star,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
	CreateSpecialMesh(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
	CreateWeld(starl,rleg,starl,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))


	for i, v in pairs(m:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Really black")
			v.Material = "Glass"
		end
	end
	for i, v in pairs(m2:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Lily white")
			v.Material = "Granite"
		end
	end
	for i, v in pairs(m3:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Lily white")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(mw2:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Lily white")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(mw1:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("Lily white")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(extrawingmod1:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("White")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(extrawingmod2:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("White")
			v.Material = "Neon"
		end
	end
	local MAINRUINCOLOR = BrickColor.new("Lily white")
	------


	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part")({
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material
		})
		Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
		RemoveOutlines(Part)
		return Part
	end
	function CreateMesha(Mesh, Part, MeshType, MeshId, OffSet, Scale)
		local Msh = Create(Mesh)({
			Parent = Part,
			Offset = OffSet,
			Scale = Scale
		})
		if Mesh == "SpecialMesh" then
			Msh.MeshType = MeshType
			Msh.MeshId = MeshId
		end
		return Msh
	end
	function CreateWeld(Parent, Part0, Part1, C0, C1)
		local Weld = Create("Weld")({
			Parent = Parent,
			Part0 = Part0,
			Part1 = Part1,
			C0 = C0,
			C1 = C1
		})
		return Weld
	end

	Player = plr
	Character=Player.Character["Dummy"]
	PlayerGui=Player.PlayerGui 
	Backpack=Player.Backpack 
	Torso=Character.Torso 
	Head=Character.Head 
	Humanoid=Character.Humanoid
	m=Instance.new('Model',Character)
	LeftArm=Character["Left Arm"] 
	LeftLeg=Character["Left Leg"] 
	RightArm=Character["Right Arm"] 
	RightLeg=Character["Right Leg"] 
	LS=Torso["Left Shoulder"] 
	LH=Torso["Left Hip"] 
	RS=Torso["Right Shoulder"] 
	RH=Torso["Right Hip"] 
	Face = Head.face
	Neck=Torso.Neck
	it=Instance.new
	attacktype=1
	vt=Vector3.new
	cf=CFrame.new
	euler=CFrame.fromEulerAnglesXYZ
	angles=CFrame.Angles
	cloaked=false
	necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
	LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
	RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
	RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
	RootPart=Character.HumanoidRootPart
	RootJoint=RootPart.RootJoint
	RootCF=euler(-1.57,0,3.14)
	attack = false 
	attackdebounce = false 
	deb=false
	equipped=true
	hand=false
	combo=0
	mana=0
	trispeed=.2
	attackmode='none'
	local idle=0
	local Anim="Idle"
	local Effects={}
	local gun=false
	local shoot=false
	local sine = 0
	local change = 1

	function RecolorTextAndRename(name,col1,col2,font)
		modet.TextStrokeColor3 = col2
		modet.TextColor3 = col1
		XD.TextStrokeColor3 = col2
		XD.TextColor3 = col1
		XD.Font = font
		NAMET.TextStrokeColor3 = col2
		NAMET.TextColor3 = col1
		NAMET.Font = font
		modet.Font = font
		modet.Text = name
		ned.Text = name
		ned.Font = font
		ned.TextColor3 = col1
		ned.TextStrokeColor3 = col2
	end

	function newbosschatfunc(text,color,watval)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("Dialog")~= nil then
					v.PlayerGui:FindFirstChild("Dialog"):destroy()
				end
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
				CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
				CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
				scrg.Name = "Dialog"  --coolai
				local txtlb6 = Instance.new("TextLabel",scrg)
				txtlb6.Text = " "
				txtlb6.Font = "Arcade"
				txtlb6.TextColor3 = Color3.new(1,1,1)
				txtlb6.TextStrokeTransparency = 0
				txtlb6.BackgroundTransparency = 0
				txtlb6.BackgroundColor3 = Color3.new(1,1,1)
				txtlb6.TextStrokeColor3 = color
				txtlb6.TextScaled = true
				txtlb6.Size = UDim2.new(229,233,240.25,221.5)
				txtlb6.TextXAlignment = "Left"
				txtlb6.Position = UDim2.new(32,42,11.75 + 622,22)
				local txtlb = Instance.new("TextLabel",scrg)
				txtlb.Text = ""
				txtlb.Font = "Arcade"
				txtlb.TextColor3 = Color3.new(1,1,1)
				txtlb.TextStrokeTransparency = 1
				txtlb.BackgroundTransparency = 0
				txtlb.BackgroundColor3 = Color3.new(1,1,1)
				txtlb.TextStrokeColor3 = color
				txtlb.TextScaled = true
				txtlb.Size = UDim2.new(2,2,2.25,2)
				txtlb.TextXAlignment = "Center"
				txtlb.Position = UDim2.new(1,1,1.75 + 2,1)
				local txtlb2 = Instance.new("TextLabel",scrg)
				txtlb2.Text = "Gek:"
				txtlb2.Font = "Arcade"
				txtlb2.TextColor3 = Color3.new(0,0,0)
				txtlb2.TextStrokeTransparency = 0
				txtlb2.BackgroundTransparency = 1
				txtlb2.TextStrokeColor3 = color
				txtlb2.TextSize = 40
				txtlb2.Size = UDim2.new(1,0,0.25,0)
				txtlb2.TextXAlignment = "Left"
				txtlb2.Position = UDim2.new(0,0,1,0)
				local fvalen = 0.55
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if insanemode == true then
							txtlb.Rotation = math.random(-1,1)
							txtlb2.Rotation = math.random(-1,1)
							txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb.TextStrokeColor3 = BrickColor.random().Color
							txtlb2.TextStrokeColor3 = BrickColor.random().Color
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if scrg.Parent ~= nil then
							fvalen = fvalen - 0.0001
						elseif scrg.Parent == nil then
							break
						end
					end
				end))
				local flol = 1.75
				local flil = 1.6
				coroutine.resume(coroutine.create(function()
					for i = 0, 9 do
						swait()
						fval = fval + 0.15
						flol = flol - 0.3
						flil = flil - 0.3
						txtlb.Text = ""
						txtlb.Position = UDim2.new(0,0,flol,0)
						txtlb2.Position = UDim2.new(0,0,flil,0)
					end
					txtlb.Text = text
					wait(watval)
					local valinc = 0
					for i = 0, 99 do
						swait()
						valinc = valinc + 0.0001
						flol = flol + valinc
						flil = flil + valinc
						txtlb.Position = UDim2.new(0,0,flol,0)
						txtlb2.Position = UDim2.new(0,0,flil,0)
						txtlb.TextStrokeTransparency = txtlb.TextStrokeTransparency + 0.05
						txtlb.TextTransparency = txtlb.TextTransparency + 0.05
						txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.05
						txtlb2.TextTransparency = txtlb2.TextTransparency + 0.05
						txtlb.BackgroundTransparency = txtlb.BackgroundTransparency + 0.0025
					end
					scrg:Destroy()
				end))
			end))
		end
	end

	function bosschatfunc2(text,color,watval)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("Dialog")~= nil then
					v.PlayerGui:FindFirstChild("Dialog"):destroy()
				end
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
				CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
				CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
				scrg.Name = "Dialog"  --coolai
				local txtlb6 = Instance.new("TextLabel",scrg)
				txtlb6.Text = " "
				txtlb6.Font = "Arcade"
				txtlb6.TextColor3 = Color3.new(0,0,0)
				txtlb6.TextStrokeTransparency = 1
				txtlb6.BackgroundTransparency = 0
				txtlb6.BackgroundColor3 = Color3.new(0,0,0)
				txtlb6.TextStrokeColor3 = color
				txtlb6.TextScaled = true
				txtlb6.Size = UDim2.new(9,3,0.25,1.5)
				txtlb6.TextXAlignment = "Left"
				txtlb6.Position = UDim2.new(2,2,1.75 + 22,2)
				local txtlb = Instance.new("TextLabel",scrg)
				txtlb.Text = ""
				txtlb.Font = "Arcade"
				txtlb.TextColor3 = Color3.new(0,0,0)
				txtlb.TextStrokeTransparency = 1
				txtlb.BackgroundTransparency = 0
				txtlb.BackgroundColor3 = Color3.new(0,0,0)
				txtlb.TextStrokeColor3 = color
				txtlb.TextScaled = true
				txtlb.Size = UDim2.new(1,4.5,-1.3,0)
				txtlb.TextXAlignment = "Center"
				txtlb.Position = UDim2.new(2,2,1.75 + 22,2)
				local txtlb2 = Instance.new("TextLabel",scrg)
				txtlb2.Text = "Star:"
				txtlb2.Font = "Arcade"
				txtlb2.TextColor3 = Color3.new(0,0,0)
				txtlb2.TextStrokeTransparency = 0
				txtlb2.BackgroundTransparency = 1
				txtlb2.TextStrokeColor3 = color
				txtlb2.TextSize = 40
				txtlb2.Size = UDim2.new(1,0,0.25,0)
				txtlb2.TextXAlignment = "Left"
				txtlb2.Position = UDim2.new(0,0,1,0)
				local fvalen = 0.55
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						swait(1)
						if insanemode == false then
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if insanemode == true then
							txtlb6.Rotation = math.random(-1,1)
							txtlb2.Rotation = math.random(-1,1)
							txtlb6.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)

							txtlb.Rotation = math.random(-1,1)
							txtlb2.Rotation = math.random(-1,1)
							txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb.TextStrokeColor3 = BrickColor.random().Color
							txtlb2.TextStrokeColor3 = BrickColor.random().Color
						end
					end
				end))
				local flol = 1.75
				local flil = 1.6
				coroutine.resume(coroutine.create(function()
					for i = 0, 9 do
						swait()
						fval = fval + 0.05
						flol = flol - 0.1
						flil = flil - 0.1
						txtlb.Text = ""
						txtlb.Position = UDim2.new(0,0,flol,0)
						txtlb6.Position = UDim2.new(0,0,flol,0)
						txtlb2.Position = UDim2.new(0,0,flil,0)
					end
					txtlb.Text = text
					wait(watval)
					local valinc = 0
					for i = 0, 99 do
						swait()
						valinc = valinc + 0.0001
						flol = flol + valinc
						flil = flil + valinc
						txtlb.Rotation = txtlb.Rotation + valinc*180
						txtlb2.Rotation = txtlb2.Rotation - valinc*180
						txtlb.Position = UDim2.new(5,5,flol,5)
						txtlb2.Position = UDim2.new(0,0,flil,0)
						txtlb6.Rotation = txtlb.Rotation + valinc*180
						txtlb2.Rotation = txtlb2.Rotation - valinc*180
						txtlb6.Position = UDim2.new(5,5,flol,5)
						txtlb2.Position = UDim2.new(0,0,flil,0)
						txtlb.TextStrokeTransparency = txtlb.TextStrokeTransparency + 0.01
						txtlb.TextTransparency = txtlb.TextTransparency + 0.01
						txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
						txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
						txtlb.BackgroundTransparency = txtlb.BackgroundTransparency + 0.01
					end
					scrg:Destroy()
				end))
			end))
		end
	end




	function newbosschatfunc(text,color1,delay)
		for _,v in next, game:service'Players':players() do
			coroutine.wrap(function()
				if(FXFolder:FindFirstChild'BossChat' and v.Character)then
					local cha = FXFolder.BossChat:Clone()
					cha.Color1.Value= Color3.new(0,0,0)
					cha.Color2.Value= color1
					cha.Text.Value=text
					cha.Ghghghghgh.Value=delay
					cha.Mode.Value=ModeOfGlitch
					cha.ModeName.Value=modet.Text
					cha.Music.Value=kan
					cha.Parent=v.Character
					wait()
					cha.Disabled = false
					game:service'Debris':AddItem(cha,(delay/60)*4)
				end
			end)()
		end
	end
	plr.Chatted:connect(function(message)
		newbosschatfunc(message,MAINRUINCOLOR.Color,200)
	end)


	--save shoulders 
	RSH, LSH=nil, nil 
	--welds 
	RW, LW=Instance.new("Weld"), Instance.new("Weld") 
	RW.Name="Right Shoulder" LW.Name="Left Shoulder"
	LH=Torso["Left Hip"]
	RH=Torso["Right Hip"]
	TorsoColor=Torso.BrickColor
	function NoOutline(Part)
		Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
	end
	ch=Character
	RSH=ch.Torso["Right Shoulder"] 
	LSH=ch.Torso["Left Shoulder"] 
	-- 
	RSH.Parent=nil 
	LSH.Parent=nil 
	-- 
	RW.Name="Right Shoulder"
	RW.Part0=ch.Torso 
	RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
	RW.C1=cf(0, 0.5, 0) 
	RW.Part1=ch["Right Arm"] 
	RW.Parent=ch.Torso 
	-- 
	LW.Name="Left Shoulder"
	LW.Part0=ch.Torso 
	LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
	LW.C1=cf(0, 0.5, 0) 
	LW.Part1=ch["Left Arm"] 
	LW.Parent=ch.Torso 

	local Stats=Instance.new("BoolValue")
	Stats.Name="Stats"
	Stats.Parent=Character
	local Atk=Instance.new("NumberValue")
	Atk.Name="Damage"
	Atk.Parent=Stats
	Atk.Value=1
	local Def=Instance.new("NumberValue")
	Def.Name="Defense"
	Def.Parent=Stats
	Def.Value=1
	local Speed=Instance.new("NumberValue")
	Speed.Name="Speed"
	Speed.Parent=Stats
	Speed.Value=1
	local Mvmt=Instance.new("NumberValue")
	Mvmt.Name="Movement"
	Mvmt.Parent=Stats
	Mvmt.Value=1

	local donum=0
	local ast = {744586075,385254610}

	function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
		local fp=it("Part")
		fp.formFactor=formfactor 
		fp.Parent=parent
		fp.Reflectance=reflectance
		fp.Transparency=transparency
		fp.CanCollide=false 
		fp.Locked=true
		fp.BrickColor=brickcolor
		fp.Name=name
		fp.Size=size
		fp.Position=Torso.Position 
		NoOutline(fp)
		fp.Material="SmoothPlastic"
		fp:BreakJoints()
		return fp 
	end 

	function mesh(Mesh,part,meshtype,meshid,offset,scale)
		local mesh=it(Mesh) 
		mesh.Parent=part
		if Mesh=="SpecialMesh" then
			mesh.MeshType=meshtype
			if meshid~="nil" then
				mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
			end
		end
		mesh.Offset=offset
		mesh.Scale=scale
		return mesh
	end

	function weld(parent,part0,part1,c0)
		local weld=it("Weld") 
		weld.Parent=parent
		weld.Part0=part0 
		weld.Part1=part1 
		weld.C0=c0
		return weld
	end

	local Color1=Torso.BrickColor

	local bodvel=Instance.new("BodyVelocity")
	local bg=Instance.new("BodyGyro")

	--------- SazEreno's Artificial HB --------------
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")
	Frame_Speed = 1 / 60
	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	------------------
	function swait(num)
		if num == 0 or num == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, num do
				ArtificialHB.Event:wait()
			end
		end
	end
	-------- RAINBOW LEAVE IT TO ME
	local r = 255
	local g = 0
	local b = 0
	coroutine.resume(coroutine.create(function()
		while wait() do
			for i = 0, 254/5 do
				swait()
				g = g + 5
			end
			for i = 0, 254/5 do
				swait()
				r = r - 5
			end
			for i = 0, 254/5 do
				swait()
				b = b + 5
			end
			for i = 0, 254/5 do
				swait()
				g = g - 5
			end
			for i = 0, 254/5 do
				swait()
				r = r + 5
			end
			for i = 0, 254/5 do
				swait()
				b = b - 5
			end
		end
	end))


	so = function(id,par,vol,pit) 
		coroutine.resume(coroutine.create(function()
			local sou = Instance.new("Sound",par or workspace)
			sou.Volume=vol
			sou.Pitch=pit or 1
			sou.SoundId=id
			swait() 
			sou:play() 
			game:GetService("Debris"):AddItem(sou,6)
		end))
	end

	function clerp(a,b,t) 
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)} 
		local ax, ay, az = a.x, a.y, a.z 
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1-t
		return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
	end 

	function QuaternionFromCFrame(cf) 
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
		local trace = m00 + m11 + m22 
		if trace > 0 then 
			local s = math.sqrt(1 + trace) 
			local recip = 0.5/s 
			return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
		else 
			local i = 0 
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then 
				i = 2 
			end 
			if i == 0 then 
				local s = math.sqrt(m00-m11-m22+1) 
				local recip = 0.5/s 
				return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
			elseif i == 1 then 
				local s = math.sqrt(m11-m22-m00+1) 
				local recip = 0.5/s 
				return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
			elseif i == 2 then 
				local s = math.sqrt(m22-m00-m11+1) 
				local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
			end 
		end 
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w) 
		local xs, ys, zs = x + x, y + y, z + z 
		local wx, wy, wz = w*xs, w*ys, w*zs 
		local xx = x*xs 
		local xy = x*ys 
		local xz = x*zs 
		local yy = y*ys 
		local yz = y*zs 
		local zz = z*zs 
		return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
	end

	function QuaternionSlerp(a, b, t) 
		local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
		local startInterp, finishInterp; 
		if cosTheta >= 0.0001 then 
			if (1 - cosTheta) > 0.0001 then 
				local theta = math.acos(cosTheta) 
				local invSinTheta = 1/math.sin(theta) 
				startInterp = math.sin((1-t)*theta)*invSinTheta 
				finishInterp = math.sin(t*theta)*invSinTheta  
			else 
				startInterp = 1-t 
				finishInterp = t 
			end 
		else 
			if (1+cosTheta) > 0.0001 then 
				local theta = math.acos(-cosTheta) 
				local invSinTheta = 1/math.sin(theta) 
				startInterp = math.sin((t-1)*theta)*invSinTheta 
				finishInterp = math.sin(t*theta)*invSinTheta 
			else 
				startInterp = t-1 
				finishInterp = t 
			end 
		end 
		return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
	end

	local function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CFrame.new(at.x, at.y, at.z,
			right.x, top.x, back.x,
			right.y, top.y, back.y,
			right.z, top.z, back.z)
	end

	function Triangle(a, b, c)
		local edg1 = (c-a):Dot((b-a).unit)
		local edg2 = (a-b):Dot((c-b).unit)
		local edg3 = (b-c):Dot((a-c).unit)
		if edg1 <= (b-a).magnitude and edg1 >= 0 then
			a, b, c = a, b, c
		elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
			a, b, c = b, c, a
		elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
			a, b, c = c, a, b
		else
			assert(false, "unreachable")
		end

		local len1 = (c-a):Dot((b-a).unit)
		local len2 = (b-a).magnitude - len1
		local width = (a + (b-a).unit*len1 - c).magnitude

		local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)

		local list = {}

		if len1 > 0.01 then
			local w1 = Instance.new('WedgePart', m)
			game:GetService("Debris"):AddItem(w1,5)
			w1.Material = "SmoothPlastic"
			w1.FormFactor = 'Custom'
			w1.BrickColor = BrickColor.new("Really red")
			w1.Transparency = 0
			w1.Reflectance = 0
			w1.Material = "SmoothPlastic"
			w1.CanCollide = false
			local l1 = Instance.new("PointLight",w1)
			l1.Color = Color3.new(170,0,0)
			NoOutline(w1)
			local sz = Vector3.new(0.2, width, len1)
			w1.Size = sz
			local sp = Instance.new("SpecialMesh",w1)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
			w1:BreakJoints()
			w1.Anchored = true
			w1.Parent = workspace
			w1.Transparency = 0.7
			table.insert(Effects,{w1,"Disappear",.01})
			w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
			table.insert(list,w1)
		end

		if len2 > 0.01 then
			local w2 = Instance.new('WedgePart', m)
			game:GetService("Debris"):AddItem(w2,5)
			w2.Material = "SmoothPlastic"
			w2.FormFactor = 'Custom'
			w2.BrickColor = BrickColor.new("Really red")
			w2.Transparency = 0
			w2.Reflectance = 0
			w2.Material = "SmoothPlastic"
			w2.CanCollide = false
			local l2 = Instance.new("PointLight",w2)
			l2.Color = Color3.new(170,0,0)
			NoOutline(w2)
			local sz = Vector3.new(0.2, width, len2)
			w2.Size = sz
			local sp = Instance.new("SpecialMesh",w2)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
			w2:BreakJoints()
			w2.Anchored = true
			w2.Parent = workspace
			w2.Transparency = 0.7
			table.insert(Effects,{w2,"Disappear",.01})
			w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
			table.insert(list,w2)
		end
		return unpack(list)
	end


	function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
		if hit.Parent == nil then
			return
		end
		local h = hit.Parent:FindFirstChildOfClass("Humanoid")
		for _, v in pairs(hit.Parent:children()) do
			if v:IsA("Humanoid") then
				h = v
			end
		end
		if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Head") ~= nil then
			if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
				return
			end
			local c = Create("ObjectValue")({
				Name = "creator",
				Value = game:GetService("Players").fcsrz,
				Parent = h
			})
			game:GetService("Debris"):AddItem(c, 0.5)
			if HitSound ~= nil and HitPitch ~= nil then
				CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
			end
			local Damage = math.random(minim, maxim)
			local blocked = false
			local block = hit.Parent:findFirstChild("Block")
			if block ~= nil and block.className == "IntValue" and block.Value > 0 then
				blocked = true
				block.Value = block.Value - 1
				print(block.Value)
			end
			if blocked == false then
				HitHealth = h.Health
				h.MaxHealth = 100
				h.Health = h.Health - Damage
				if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
					print("gained kill")
					dmg(h.Parent)
				end
				ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
			else
				h.Health = h.Health - Damage / 2
				ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
			end
			if Type == "Knockdown" then
				local hum = hit.Parent.Humanoid
				hum.PlatformStand = true
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(1)
					HHumanoid.PlatformStand = false
				end), hum)
				local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
				local bodvol = Create("BodyVelocity")({
					velocity = angle * knockback,
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				local rl = Create("BodyAngularVelocity")({
					P = 3000,
					maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
					angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodvol, 0.5)
				game:GetService("Debris"):AddItem(rl, 0.5)
			elseif Type == "Normal" then
				local vp = Create("BodyVelocity")({
					P = 500,
					maxForce = Vector3.new(math.huge, 0, math.huge),
					velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
				})
				if knockback > 0 then
					vp.Parent = hit.Parent.Head
				end
				game:GetService("Debris"):AddItem(vp, 0.5)
			elseif Type == "Up" then
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Leech" then
				local hum = hit.Parent.Humanoid
				if hum ~= nil then
					for i = 0, 2 do
						Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
					end
					Humanoid.Health = Humanoid.Health + 10
				end
			elseif Type == "UpKnock" then
				local hum = hit.Parent.Humanoid
				hum.PlatformStand = true
				if hum ~= nil then
					hitr = true
				end
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(5)
					HHumanoid.PlatformStand = false
					hitr = false
				end), hum)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Snare" then
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Slashnare" then
				Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
				for i = 1, math.random(4, 5) do
					Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
				end
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Spike" then
				CreateBigIceSword(hit.Parent.Torso.CFrame)
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Freeze" then
				local BodPos = Create("BodyPosition")({
					P = 50000,
					D = 1000,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				local BodGy = Create("BodyGyro")({
					maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
					P = 20000,
					Parent = hit.Parent.Torso,
					cframe = hit.Parent.Torso.CFrame
				})
				hit.Parent.Torso.Anchored = true
				coroutine.resume(coroutine.create(function(Part)
					swait(1.5)
					Part.Anchored = false
				end), hit.Parent.Torso)
				game:GetService("Debris"):AddItem(BodPos, 3)
				game:GetService("Debris"):AddItem(BodGy, 3)
			end
			local debounce = Create("BoolValue")({
				Name = "DebounceHit",
				Parent = hit.Parent,
				Value = true
			})
			game:GetService("Debris"):AddItem(debounce, Delay)
			c = Instance.new("ObjectValue")
			c.Name = "creator"
			c.Value = Player
			c.Parent = h
			game:GetService("Debris"):AddItem(c, 0.5)
		end
	end
	function ShowDamage(Pos, Text, Time, Color)
		local Rate = 0.03333333333333333
		local Pos = Pos or Vector3.new(0, 0, 0)
		local Text = Text or ""
		local Time = Time or 2
		local Color = Color or Color3.new(1, 0, 1)
		local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
		EffectPart.Anchored = true
		local BillboardGui = Create("BillboardGui")({
			Size = UDim2.new(3, 0, 3, 0),
			Adornee = EffectPart,
			Parent = EffectPart
		})
		local TextLabel = Create("TextLabel")({
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			TextColor3 = Color,
			TextScaled = true,
			Font = Enum.Font.ArialBold,
			Parent = BillboardGui
		})
		game.Debris:AddItem(EffectPart, Time + 0.1)
		EffectPart.Parent = game:GetService("Workspace")
		delay(0, function()
			local Frames = Time / Rate
			for Frame = 1, Frames do
				wait(Rate)
				local Percent = Frame / Frames
				EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
				TextLabel.TextTransparency = Percent
			end
			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end)
	end
	function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChildOfClass("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Head")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
					end
				end
			end
		end
	end

	function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChild("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Torso")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
						Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
					end
				end
			end
		end
	end

	function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
	end 

	function SkullEffect(brickcolor,cframe,x1,y1,z1,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=4770583",vt(0,0,0),vt(x1,y1,z1))
		--http://www.roblox.com/asset/?id=4770560
		game:GetService("Debris"):AddItem(prt,2)
		CF=prt.CFrame
		coroutine.resume(coroutine.create(function(Part,Mesh,TehCF) 
			for i=0,1,0.2 do
				wait()
				Part.CFrame=CF*cf(0,0,-0.4)
			end
			for i=0,1,delay do
				wait()
				--Part.CFrame=CF*cf((math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5)
				Mesh.Scale=Mesh.Scale
			end
			for i=0,1,0.1 do
				wait()
				Part.Transparency=i
			end
			Part.Parent=nil
		end),prt,msh,CF)
	end

	function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				swait()
				Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicSphere(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShock(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
		local prt=part(3,char,1,1,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		local dec = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
		local dec2 = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				dec.Transparency=i
				dec2.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockAlt(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockAltCircle(brickcolor,cframe,x1,z1,x3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0.1,0)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,-0.1,0)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,0,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockTrailAlt(brickcolor,cframe,x1,y1,z1,x3,y3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockTrailAlt2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlock2(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=false
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		local wld=weld(prt,prt,Parent,cframe)
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
			for i=0,1,delay do
				wait()
				Weld.C0=euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))*cframe
				--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,wld)
	end

	function MagicBlock3(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=false
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		local wld=weld(prt,prt,Parent,euler(0,0,0)*cf(0,0,0))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
			for i=0,1,delay do
				wait()
				Weld.C0=euler(i*20,0,0)
				--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,wld)
	end

	function MagicCircle2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("CylinderMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
				local prt2=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
				prt2.Anchored=true
				prt2.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				local msh2=mesh("SpecialMesh",prt2,"Sphere","",vt(0,0,0),vt(0.5,0.5,0.5))
				game:GetService("Debris"):AddItem(prt2,2)
				coroutine.resume(coroutine.create(function(Part,Mesh) 
					for i=0,1,0.1 do
						wait()
						Part.CFrame=Part.CFrame*cf(0,0.5,0)
					end
					Part.Parent=nil
				end),prt2,msh2)
			end
			for i=0,1,delay*2 do
				wait()
				Part.CFrame=Part.CFrame
				Mesh.Scale=vt((x1+x3)-(x1+x3)*i,(y1+y3)-(y1+y3)*i,(z1+z3)-(z1+z3)*i)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function BreakEffect(brickcolor,cframe,x1,y1,z1)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,CF,Numbb,randnumb) 
			CF=Part.CFrame
			Numbb=0
			randnumb=math.random()/10
			rand1=math.random()/10
			for i=0,1,rand1 do
				wait()
				CF=CF*cf(0,math.random()/2,0)
				--Part.CFrame=Part.CFrame*euler(0.5,0,0)*cf(0,1,0)
				Part.CFrame=CF*euler(Numbb,0,0)
				Part.Transparency=i
				Numbb=Numbb+randnumb
			end
			Part.Parent=nil
		end),prt,CF,Numbb,randnumb)
	end

	function MagicWaveThing(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=1051557",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame*euler(0,0.7,0)
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function WaveEffect(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=20329976",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame*cf(0,y3/2,0)
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function StravEffect(brickcolor,cframe,x,y,z,x1,y1,z1,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe*cf(x,y,z)
		msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://168892363",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,ex,why,zee) 
			local num=math.random()
			local num2=math.random(-3,2)+math.random()
			local numm=0
			for i=0,1,delay*2 do
				swait()
				Part.CFrame=cframe*euler(0,numm*num*10,0)*cf(ex,why,zee)*cf(-i*10,num2,0)
				Part.Transparency=i
				numm=numm+0.01
			end
			Part.Parent=nil
			Mesh.Parent=nil
		end),prt,msh,x,y,z)
	end

	function dmgstart(dmg,what)
		hitcon = what.Touched:connect(function(hit)
			local hum = hit.Parent:FindFirstChild("Humanoid")
			if hum and not hum:IsDescendantOf(Character) then
				hum:TakeDamage(dmg)
			end
		end)
	end

	function dmgstop()
		hitcon:disconnect()
	end

	function Cloak()
		Face.Parent=nil
		cloaked=true
		for _,v in pairs(Torso.Parent:children()) do
			if v.className=="Part" and v.Name~="HumanoidRootPart" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.2 do
						wait()
						v.Transparency=i
					end
					v.Transparency=1
				end))
			end
			if v.className=="Hat" then
				hatp=v.Handle
				coroutine.resume(coroutine.create(function(derp) 
					for i=0,1,0.2 do
						wait()
						derp.Transparency=i
					end
					derp.Transparency=1
				end),hatp)
			end
		end
		for _,v in pairs(m:children()) do
			if v.className=="Part" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.2 do
						wait()
						v.Transparency=i
					end
					v.Transparency=1
				end))
			end
		end
	end

	function UnCloak()
		so("http://roblox.com/asset/?id=2767090",Torso,1,1.1) 
		Face.Parent=Head 
		cloaked=false
		for _,v in pairs(Torso.Parent:children()) do
			if v.className=="Part" and v.Name~="HumanoidRootPart" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.1 do
						wait()
						v.Transparency=v.Transparency-0.1
					end
					v.Transparency=0
				end))
			end
			if v.className=="Hat" then
				hatp=v.Handle
				coroutine.resume(coroutine.create(function(derp) 
					for i=0,1,0.1 do
						wait()
						derp.Transparency=derp.Transparency-0.1
					end
					derp.Transparency=0
				end),hatp)
			end
		end
		for _,v in pairs(m:children()) do
			if v.className=="Part" and v.Name~="hitbox" and v.Name~='tip' then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.1 do
						wait()
						v.Transparency=v.Transparency-0.1
					end
					v.Transparency=0
				end))
				v.Transparency=0
			end
		end
	end

	local origcolor = BrickColor.new("Pastel light blue")
	---- This section of explosions.

	----


	function ring(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
			end
			rng:Destroy()
		end))
	end


	function wave(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function wind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function groundwind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
			end
			rng:Destroy()
		end))
	end

	function CameraManager()
		if TwoD and not CamInterrupt then
			if Humanoid.Health > 0 then
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Scriptable"
				Humanoid.AutoRotate = false
				if Booleans.GyroUse then
					Directer.MaxTorque = Vec3(0, huge, 0)
				else
					Directer.MaxTorque = Vec3(0, 0, 0)
				end
				if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
					if Booleans.CamFollow then
						CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
						Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
					else
						CPart.Position = RootPart.Position
					end
				else
					local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
					CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
				end
				Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
			else
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Custom"
				Controller.Disabled = false
			end
		end
	end

	function ring(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
			end
			rng:Destroy()
		end))
	end


	function wave(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function sphere(bonuspeed,type,pos,scale,value,color)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		if ModeOfGlitch ~= 9 then
			rng.BrickColor = color
		elseif ModeOfGlitch == 9 then
			rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
		end
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = scale
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		if ModeOfGlitch == 9 then
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if rng.Parent ~= nil then
						rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
					else
						break
					end
				end
			end))
		end
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function RandomCaps(str)
		local new = ""
		for i = 1, #str do
			if(math.random(0,2) == 1)then
				new = new .. (str:sub(i,i):upper())
			else
				new = new .. str:sub(i,i)
			end
		end
		return new
	end

	function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		if ModeOfGlitch ~= 9 then
			rng.BrickColor = color
		elseif ModeOfGlitch == 9 then
			rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
		end
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = scale
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		if ModeOfGlitch == 9 then
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if rng.Parent ~= nil then
						rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
					else
						break
					end
				end
			end))
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
		local type = type
		local rotenable = rotatingop
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		if typeoftrans == "In" then
			rng.Transparency = 1
		end
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "FileMesh"
		if typeofshape == "Normal" then
			rngm.MeshId = "rbxassetid://662586858"
		elseif typeofshape == "Round" then
			rngm.MeshId = "rbxassetid://662585058"
		end
		rngm.Scale = scale
		local scaler2 = 1/10
		if type == "Add" then
			scaler2 = 1*value/10
		elseif type == "Divide" then
			scaler2 = 1/value/10
		end
		local randomrot = math.random(1,2)
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed/10
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed/10
				end
				if rotenable == true then
					if randomrot == 1 then
						rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
					elseif randomrot == 2 then
						rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
					end
				end
				if typeoftrans == "Out" then
					rng.Transparency = rng.Transparency + 0.01*bonuspeed
				elseif typeoftrans == "In" then
					rng.Transparency = rng.Transparency - 0.01*bonuspeed
				end
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
			end
			rng:Destroy()
		end))
	end

	function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 0
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder + 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.Color = color3
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = scale
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		if ModeOfGlitch ~= 9 then
			rng.BrickColor = color
		elseif ModeOfGlitch == 9 then
			rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
		end
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		if ModeOfGlitch == 9 then
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if rng.Parent ~= nil then
						rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
					else
						break
					end
				end
			end))
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end


	function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		if ModeOfGlitch ~= 9 then
			rng.BrickColor = color
		elseif ModeOfGlitch == 9 then
			rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
		end
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 1
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		if ModeOfGlitch == 9 then
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if rng.Parent ~= nil then
						rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
					else
						break
					end
				end
			end))
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end

	function dmg(dude)
		if dude.Name ~= Character then
			local keptcolor = MAINRUINCOLOR
			local bgf = Instance.new("BodyGyro",dude.Head)
			bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
--[[local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"]]--
			local ds = coroutine.wrap(function()
				dude:WaitForChild("Head"):BreakJoints()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Part") or v:IsA("MeshPart") then
						v.Name = "DEMINISHED"
					end
				end
				wait(0.5)
				targetted = nil
				CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.75, 0.285)
				coroutine.resume(coroutine.create(function()
					for i, v in pairs(dude:GetChildren()) do
						if v:IsA("Accessory") then
							v:Destroy()
						end
						if v:IsA("Humanoid") then
							v:Destroy()
						end
						if v:IsA("CharacterMesh") then
							v:Destroy()
						end
						if v:IsA("Model") then
							v:Destroy()
						end
						if v:IsA("Part") or v:IsA("MeshPart") then
							for x, o in pairs(v:GetChildren()) do
								if o:IsA("Decal") then
									o:Destroy()
								end
							end
							coroutine.resume(coroutine.create(function()
								v.Material = "Neon"
								v.CanCollide = false
								v.Anchored = false
								local bld = Instance.new("ParticleEmitter",v)
								bld.LightEmission = 0.75
								bld.Texture = "rbxassetid://363275192" ---284205403
								bld.Color = ColorSequence.new(keptcolor.Color)
								bld.Rate = 500
								bld.Lifetime = NumberRange.new(1)
								bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0,0)})
								bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
								bld.Speed = NumberRange.new(2,5)
								bld.VelocitySpread = 50000
								bld.Rotation = NumberRange.new(-500,500)
								bld.RotSpeed = NumberRange.new(-500,500)
								local sbs = Instance.new("BodyPosition", v)
								sbs.P = 3000
								sbs.D = 1000
								sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
								sbs.position = v.Position + Vector3.new(math.random(-2,2),10 + math.random(-2,2),math.random(-2,2))
								v.Color = keptcolor.Color
								coroutine.resume(coroutine.create(function()
									for i = 0, 49 do
										swait(1)
										v:BreakJoints()
										v.Transparency = v.Transparency + 0.02
									end
									v:BreakJoints()
									sphere2(1,"Add",v.CFrame,vt(0,0,0),0.1,0.1,0.1,keptcolor)
									CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.5, 0.75)
									bld.Speed = NumberRange.new(10,25)
									bld.Drag = 5
									bld.Acceleration = vt(0,2,0)
									wait(0.5)
									bld.Enabled = false
									wait(8)
									v:Destroy()
									dude:Destroy()
								end))
							end))
						end
					end
				end))
			end)
			ds()
		end
	end


	function FindNearestHead(Position, Distance, SinglePlayer)
		if SinglePlayer then
			return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
		end
		local List = {}
		for i, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") then
				if v:findFirstChild("Head") then
					if v ~= Character then
						if (v.Head.Position - Position).magnitude <= Distance then
							table.insert(List, v)
						end 
					end 
				end 
			end 
		end
		return List
	end

	function FaceMouse()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end

	function FaceMouse2()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end

	local ModeOfGlitch = 1
	-- Functions are ready.
	local storehumanoidWS = 16

	function bosschatfunc(text,color,watval)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("Dialog")~= nil then
					v.PlayerGui:FindFirstChild("Dialog"):destroy()
				end
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
				scrg.Name = "Dialog"
				local txtlb = Instance.new("TextLabel",scrg)
				txtlb.Text = ""
				txtlb.Font = "Arcade"
				txtlb.TextColor3 = Color3.new(0,0,0)
				txtlb.TextStrokeTransparency = 0
				txtlb.BackgroundTransparency = 0.75
				txtlb.BackgroundColor3 = Color3.new(0,0,0)
				txtlb.TextStrokeColor3 = color
				txtlb.TextScaled = true
				txtlb.Size = UDim2.new(1,0,0.15,0)
				txtlb.TextXAlignment = "Center"
				txtlb.Position = UDim2.new(0,0,0.20 + 1,0)
				local txtlb2 = Instance.new("TextLabel",scrg)
				txtlb2.Text = plr.Name..":"
				txtlb2.Font = "Arcade"
				txtlb2.TextColor3 = Color3.new(0,0,0)
				txtlb2.TextStrokeTransparency = 0
				txtlb2.BackgroundTransparency = 1
				txtlb2.TextStrokeColor3 = color
				txtlb2.TextSize = 40
				txtlb2.Size = UDim2.new(1,0,0.25,0)
				txtlb2.TextXAlignment = "Center"
				txtlb2.Position = UDim2.new(0,0,1,0)
				local fvalen = 0.55
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if chaosmode == true then
							txtlb.Rotation = math.random(-5,5)
							txtlb2.Rotation = math.random(-5,5)
							txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb.TextStrokeColor3 = BrickColor.random().Color
							txtlb2.TextStrokeColor3 = BrickColor.random().Color
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if ModeOfGlitch == 3 then
							txtlb.Rotation = math.random(-10,10)
							txtlb2.Rotation = math.random(-10,10)
							txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-5,5)/5,0,math.random(-5,5)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-5,5)/5,0,math.random(-5,5)/5)
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if scrg.Parent ~= nil then
							fvalen = fvalen - 0.0001
							txtlb.Rotation = math.random(-1,1)
							txtlb2.Rotation = math.random(-1,1)
						elseif scrg.Parent == nil then
							break
						end
					end
				end))
				local flol = 1.75
				local flil = 1.6
				coroutine.resume(coroutine.create(function()
					for i = 0, 9 do
						swait()
						fval = fval + 0.05
						flol = flol - 0.1
						flil = flil - 0.1
						txtlb.Text = ""
						txtlb.Rotation = math.random(-1,1)
						txtlb2.Rotation = math.random(-1,1)
						txtlb.Position = UDim2.new(0,0,flol,0)
						txtlb2.Position = UDim2.new(0,0,flil,0)
					end
					txtlb.Text = text
					wait(watval)
					local valinc = 0
					for i = 0, 99 do
						swait()
						valinc = valinc + 0.0001
						flol = flol + valinc
						flil = flil + valinc
						txtlb.Rotation = math.random(-1,1)
						txtlb2.Rotation = math.random(-1,1)
						txtlb.Rotation = txtlb.Rotation + valinc*20
						txtlb2.Rotation = txtlb2.Rotation - valinc*50
						txtlb.Position = UDim2.new(0,0,flol,0)
						txtlb2.Position = UDim2.new(0,0,flil,0)
						txtlb.TextStrokeTransparency = txtlb.TextStrokeTransparency + 0.01
						txtlb.TextTransparency = txtlb.TextTransparency + 0.01
						txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
						txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
						txtlb.BackgroundTransparency = txtlb.BackgroundTransparency + 0.0025
					end
					scrg:Destroy()
				end))
			end))
		end
	end

	function CorruptBlink()
		for i = 0, 14 do
			PixelBlock(3,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.03,MAINRUINCOLOR,0)
		end
		sphere(10,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		CFuncs["Sound"].Create("rbxassetid://1177785010", root, 10,1)
		RootPart.CFrame = mouse.Hit *CFrame.new(0,2,0)
		CameraEnshaking(2,10)
		for i, v in pairs(FindNearestHead(Torso.CFrame.p, 20)) do
			if v:FindFirstChild('Head') then
				dmg(v)
			end
		end
		for i = 0, 14 do
			PixelBlock(3,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.03,MAINRUINCOLOR,0)
		end
		sphere(10,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
	end
	function PureBomb()
		attack = true
		hum.WalkSpeed = 0
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = BrickColor.new("Toothpaste")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(0,0,0)
		local scaled = 0.1
		local posid = 0
		CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1,1)
		for i = 0, 5, 0.1 do
			swait()
			scaled = scaled - 0.001
			posid = posid - scaled
			orb.CFrame = rarm.CFrame*CFrame.new(0,-0.1+posid/1.05,0)
			local scaled = 0.1
			orbm.Scale = orbm.Scale + vt(scaled,scaled,scaled)
			sphereMKCharge(5,-0.25,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.5,0.5,5,-0.005,BrickColor.new("Toothpaste"),10)
			PixelBlockNeg(2,1,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,BrickColor.new("Toothpaste"),0)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(180),math.rad(20),math.rad(0)),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.1)
		end
		for i = 0, 2, 0.1 do
			swait()
			orb.CFrame = rarm.CFrame*CFrame.new(0,-0.1+posid/1.05,0)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(-50)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(20)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(220),math.rad(20),math.rad(0)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.4)
		end
		coroutine.resume(coroutine.create(function()
			orb.Anchored = false
			CFuncs["Sound"].Create("rbxassetid://260433768", root, 1.25,1)
			local a = Instance.new("Part",workspace)
			a.Name = "Direction"	
			a.Anchored = true
			a.BrickColor = bc("Bright red")
			a.Material = "Neon"
			a.Transparency = 1
			a.CanCollide = false
			local ray = Ray.new(
				orb.CFrame.p,                           -- origin
				(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
			) 
			local ignore = orb
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			local distance = (orb.CFrame.p - position).magnitude
			a.Size = Vector3.new(0.1, 0.1, 0.1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
			orb.CFrame = a.CFrame
			a:Destroy()
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = orb.CFrame.lookVector*125
			bv.Parent = orb
			local hitted = false
			game:GetService("Debris"):AddItem(orb, 15)
			wait()
			local hit =orb.Touched:connect(function(hit) 
				if hitted == false then
					hitted = true
					CameraEnshaking(10,2.5)
					CFuncs["Sound"].Create("rbxassetid://151304356", orb, 5,1)
					MagniDamage(orb, 65, 65,90, 0, "Normal")
					sphere(1,"Add",orb.CFrame,vt(orbm.Scale.x,orbm.Scale.y,orbm.Scale.z),1,BrickColor.new("Toothpaste"))
					sphere(2,"Add",orb.CFrame,vt(orbm.Scale.x,orbm.Scale.y,orbm.Scale.z),2,BrickColor.new("Toothpaste"))
					for i = 0, 49 do
						PixelBlock(1,math.random(1,30),"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),4,4,4,0.08,BrickColor.new("Toothpaste"),0)
					end
					for i = 0, 9 do
						sphereMK(1,2.5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,50,-0.05,BrickColor.new("Toothpaste"),0)
						sphereMK(2,5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,50,-0.05,BrickColor.new("Toothpaste"),0)
					end
					orb.Anchored = true
					orb.Transparency = 1
					wait(8)
					orb:Destroy()
				end
			end)
		end))
		for i = 0, 1, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(50)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-50)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(60),math.rad(20),math.rad(50)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.4)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function BanishingOrb()
		attack = true
		hum.WalkSpeed = 0
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Let it's go..",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("So this is it..",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("I have enough thing..",MAINRUINCOLOR.Color,1)
		end
		CFuncs["EchoSound"].Create("rbxassetid://1535994940", char, 5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1535994940", root, 60, 1,0,10,0.15,0.5,1)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = BrickColor.new("Lime green")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(0,0,0)
		local scaled = 0.1
		local posid = 0
		CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1.5,0.9)
		for i = 0, 5, 0.1 do
			swait()
			scaled = scaled - 0.001
			posid = posid - scaled
			orb.CFrame = rarm.CFrame*CFrame.new(0,-0.1+posid/1.05,0)
			local scaled = 0.1
			orbm.Scale = orbm.Scale + vt(scaled,scaled,scaled)
			sphereMKCharge(5,-0.25,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.5,0.5,5,-0.005,BrickColor.new("Cool yellow"),10)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(180),math.rad(20),math.rad(0)),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.1)
		end
		for i = 0, 2, 0.1 do
			swait()
			orb.CFrame = rarm.CFrame*CFrame.new(0,-0.1+posid/1.05,0)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(-50)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(20)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(220),math.rad(20),math.rad(0)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.4)
		end
		coroutine.resume(coroutine.create(function()
			orb.Anchored = false
			CFuncs["Sound"].Create("rbxassetid://260433768", root, 1.25,0.75)
			local a = Instance.new("Part",workspace)
			a.Name = "Direction"	
			a.Anchored = true
			a.BrickColor = bc("Lime green")
			a.Material = "Neon"
			a.Transparency = 1
			a.CanCollide = false
			local ray = Ray.new(
				orb.CFrame.p,                           -- origin
				(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
			) 
			local ignore = orb
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			local distance = (orb.CFrame.p - position).magnitude
			a.Size = Vector3.new(0.1, 0.1, 0.1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
			orb.CFrame = a.CFrame
			a:Destroy()
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = orb.CFrame.lookVector*0
			bv.Parent = orb
			local hitted = false
			local rate = 0
			coroutine.resume(coroutine.create(function()
				for i = 0, 24 do
					wait(0.1)
					rate = rate + 0.25
					bv.velocity = bv.velocity + orb.CFrame.lookVector*rate
					for i, v in pairs(FindNearestHead(orb.CFrame.p, 15)) do
						if v:FindFirstChild('Head') then
							dmg(v)
						end
					end
					CFuncs["Sound"].Create("rbxassetid://1177785010", orb, 2.5,0.9)
					sphere(2,"Add",orb.CFrame,vt(0,0,0),0.5,bc"Lime green")
					sphere(3,"Add",orb.CFrame,vt(0,0,0),0.75,MAINRUINCOLOR)
				end
				orb.Anchored = true
				orb.Transparency = 1
				for i, v in pairs(FindNearestHead(orb.CFrame.p, 32)) do
					if v:FindFirstChild('Head') then
						dmg(v)
					end
				end
				local eff = Instance.new("ParticleEmitter",orb)
				eff.Texture = "rbxassetid://296874871"
				eff.LightEmission = 0.95
				eff.Color = ColorSequence.new(MAINRUINCOLOR.Color)
				eff.Rate = 1000000000
				eff.Lifetime = NumberRange.new(3)
				eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.1,10,0),NumberSequenceKeypoint.new(0.8,9,0),NumberSequenceKeypoint.new(1,0,0)})
				eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
				eff.Speed = NumberRange.new(30)
				eff.Acceleration = vt(0,-15,0)
				eff.Rotation = NumberRange.new(-500,500)
				eff.VelocitySpread = 100000
				eff.RotSpeed = NumberRange.new(-500,500)
				coroutine.resume(coroutine.create(function()
					wait(0.6)
					eff.Enabled = false
				end))
				CFuncs["Sound"].Create("rbxassetid://1177785010", orb, 8,0.6)
				CFuncs["Sound"].Create("rbxassetid://438666141", orb, 7.5,0.9)
				sphere(1,"Add",orb.CFrame,vt(0,0,0),0.75,bc"Lime green")
				sphere(1.5,"Add",orb.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
				sphere(2,"Add",orb.CFrame,vt(0,0,0),1.25,MAINRUINCOLOR)
				game:GetService("Debris"):AddItem(orb, 15)
			end))
		end))
		for i = 0, 1, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(50)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-50)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(60),math.rad(20),math.rad(50)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.4)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end


	function ChaosGroundStrike()
		attack = true
		for i = 0, 2, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(140),math.rad(0),math.rad(-20)),.2)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(140),math.rad(0),math.rad(20)),.2)
		end
		CFuncs["Sound"].Create("rbxassetid://438666141", root, 7.5,1)
		CFuncs["Sound"].Create("rbxassetid://1208650519", root, 7.5, 1)
		CameraEnshaking(4,12)
		for i, v in pairs(FindNearestHead(Torso.CFrame.p, 52.5)) do
			if v:FindFirstChild('Head') then
				dmg(v)
			end
		end
		sphere(5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0,0,0),1,BrickColor.random())
		sphere(10,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0,0,0),2,BrickColor.random())
		sphere(1,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(100,0.1,100),0.01,BrickColor.random())
		for i = 0, 2, 0.1 do
			swait()
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5,52.5),-5,math.random(-52.5,52.5))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5,52.5),-5,math.random(-52.5,52.5))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
			RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(0)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(30)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-30)),.4)
		end
		attack = false
	end



	function Starfall()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 5, 1)
		for i = 0, 5, 0.1 do
			swait()
			PixelBlockNeg(1,math.random(1,2),"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			PixelBlockNeg(1,math.random(1,2),"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(-5 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(130),math.rad(0),math.rad(70 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(130),math.rad(0),math.rad(-70 - 2.5 * math.cos(sine / 28))),.1)
		end
		local Overed = false
		CameraEnshaking(2,20)
		sphere(1.5,"Add",sorb.CFrame,vt(0,0,0),0.25,MAINRUINCOLOR)
		sphere(1.5,"Add",sorb2.CFrame,vt(0,0,0),0.25,MAINRUINCOLOR)
		sphere(5,"Add",root.CFrame,vt(0,0,0),12.5,MAINRUINCOLOR)
		CFuncs["Sound"].Create("rbxassetid://1177785010", char, 1, 1)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = BrickColor.new("Toothpaste")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Remenant"
		orb.Material = "Neon"
		orb.CFrame = root.CFrame*CFrame.new(0,150,0)
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 1
		orb.TopSurface = 0
		orb.BottomSurface = 0
		hum.WalkSpeed = storehumanoidWS
		coroutine.resume(coroutine.create(function()
			for i = 0, 9 do
				swait(10)
				local lb = Instance.new("Part")
				lb.Color = MAINRUINCOLOR.Color
				lb.CanCollide = false
				lb.Material = "Neon"
				lb.Anchored = true
				lb.TopSurface = 0
				lb.BottomSurface = 0
				lb.Transparency = 0
				lb.Size = vt(1,1,1)
				lb.CFrame = orb.CFrame*CFrame.new(math.random(-150,150),0,math.random(-150,150))*CFrame.Angles(math.rad(-90 + math.random(-15,15)),0,math.rad(math.random(-15,15)))
				lb.Anchored = false
				lb.Parent = char
				local thingery = Instance.new("SpecialMesh",lb)
				thingery.MeshType = "Sphere"
				thingery.Scale = vt(20,20,20)
				game:GetService("Debris"):AddItem(lb, 10)
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = lb.CFrame.lookVector*math.random(75,250)
				bv.Parent = lb
				sphere(2.5,"Add",lb.CFrame,vt(50,50,0),0.25,MAINRUINCOLOR)
				sphere(5,"Add",lb.CFrame,vt(50,50,0),0.5,MAINRUINCOLOR)
				CFuncs["Sound"].Create("rbxassetid://633627961",lb, 5, 1)
				CFuncs["Sound"].Create("rbxassetid://1002081188", lb, 5, 1)
				CFuncs["Sound"].Create("rbxassetid://741272936", lb, 5, 1)
				CFuncs["Sound"].Create("rbxassetid://1192402877", lb, 5, 1)
				local hitted = false
				coroutine.resume(coroutine.create(function()
					while true do
						swait(1)
						if lb.Parent ~= nil and hitted == false then
							PixelBlockNeg(5,math.random(1,2),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),10,10,10,0.1,MAINRUINCOLOR,-2)
						elseif lb.Parent == nil then
							break
						end
					end
				end))

				game:GetService("Debris"):AddItem(a, 0.1)

				coroutine.resume(coroutine.create(function()
					swait(1)
					lb.Touched:connect(function(hit)
						if hitted == false then
							hitted = true
							lb.Transparency = 1
							lb.Anchored = true
							CFuncs["Sound"].Create("rbxassetid://1177785010", lb, 5, 1)
							CFuncs["Sound"].Create("rbxassetid://192410089", lb, 5, 0.7)
							CFuncs["Sound"].Create("rbxassetid://579687077", lb, 2.5, 0.75)
							CFuncs["Sound"].Create("rbxassetid://1060191237", lb, 3, 0.75)
							CFuncs["Sound"].Create("rbxassetid://164881112", lb, 5, 1)
							CFuncs["Sound"].Create("rbxassetid://429123896", lb, 3.5, 0.85)
							MagniDamage(lb, 45, 45,85, 0, "Normal")
							CameraEnshaking(1,5)
							sphere(8,"Add",lb.CFrame,vt(20,20,20),1,MAINRUINCOLOR)
							sphere(16,"Add",lb.CFrame,vt(20,20,20),2,MAINRUINCOLOR)
							for i = 0, 9 do
								sphereMK(1,math.random(1,3),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,50,-0.1,MAINRUINCOLOR,0)
							end
							for i = 0, 49 do
								swait()
								MagniDamage(lb, 30, 2,4, 0, "Normal")
								PixelBlock(4,math.random(1,30),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),16,16,16,0.16,MAINRUINCOLOR,0)
							end
						end
					end)
				end))
			end
			Overed = true
			orb:Destroy()
		end))

		attack = false
	end

	function StarfallEX()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 5, 0.7)
		for i = 0, 10, 0.1 do
			swait()
			PixelBlockNeg(1,math.random(1,2),"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			PixelBlockNeg(1,math.random(1,2),"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(-5 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(130),math.rad(0),math.rad(70 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(130),math.rad(0),math.rad(-70 - 2.5 * math.cos(sine / 28))),.1)
		end
		local Overed = false
		CameraEnshaking(2,20)
		sphere(1.5,"Add",sorb.CFrame,vt(0,0,0),0.5,MAINRUINCOLOR)
		sphere(1.5,"Add",sorb2.CFrame,vt(0,0,0),0.5,MAINRUINCOLOR)
		sphere(5,"Add",root.CFrame,vt(0,0,0),2.5,MAINRUINCOLOR)
		CFuncs["Sound"].Create("rbxassetid://1177785010", char, 1, 0.9)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = BrickColor.new("Toothpaste")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Remenant"
		orb.Material = "Neon"
		orb.CFrame = root.CFrame*CFrame.new(0,250,0)
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 1
		orb.TopSurface = 0
		orb.BottomSurface = 0
		hum.WalkSpeed = storehumanoidWS
		coroutine.resume(coroutine.create(function()
			for i = 0, 4 do
				swait(15)
				local lb = Instance.new("Part")
				lb.Color = MAINRUINCOLOR.Color
				lb.CanCollide = false
				lb.Material = "Neon"
				lb.Anchored = true
				lb.TopSurface = 0
				lb.BottomSurface = 0
				lb.Transparency = 0
				lb.Size = vt(1,1,1)
				lb.CFrame = orb.CFrame*CFrame.new(math.random(-150,150),0,math.random(-150,150))*CFrame.Angles(math.rad(-90 + math.random(-15,15)),0,math.rad(math.random(-15,15)))
				lb.Anchored = false
				lb.Parent = char
				local thingery = Instance.new("SpecialMesh",lb)
				thingery.MeshType = "Sphere"
				thingery.Scale = vt(50,50,50)
				game:GetService("Debris"):AddItem(lb, 10)
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = lb.CFrame.lookVector*math.random(50,420)
				bv.Parent = lb
				sphere(2.5,"Add",lb.CFrame,vt(100,100,0),0.25,MAINRUINCOLOR)
				sphere(5,"Add",lb.CFrame,vt(100,100,0),0.5,MAINRUINCOLOR)
				CFuncs["Sound"].Create("rbxassetid://633627961",lb, 5, 0.9)
				CFuncs["Sound"].Create("rbxassetid://1002081188", lb, 5, 0.9)
				CFuncs["Sound"].Create("rbxassetid://741272936", lb, 5, 0.9)
				CFuncs["Sound"].Create("rbxassetid://1192402877", lb, 5, 0.9)
				local hitted = false
				coroutine.resume(coroutine.create(function()
					while true do
						swait(1)
						if lb.Parent ~= nil and hitted == false then
							PixelBlockNeg(5,math.random(1,2),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),25,25,25,0.25,MAINRUINCOLOR,-2)
						elseif lb.Parent == nil then
							break
						end
					end
				end))

				game:GetService("Debris"):AddItem(a, 0.1)

				coroutine.resume(coroutine.create(function()
					swait(1)
					lb.Touched:connect(function(hit)
						if hitted == false then
							hitted = true
							lb.Transparency = 1
							lb.Anchored = true
							CFuncs["Sound"].Create("rbxassetid://1177785010", lb, 5, 0.9)
							CFuncs["Sound"].Create("rbxassetid://192410089", lb, 5, 0.6)
							CFuncs["Sound"].Create("rbxassetid://579687077", lb, 2.5, 0.65)
							CFuncs["Sound"].Create("rbxassetid://1060191237", lb, 3, 0.65)
							CFuncs["Sound"].Create("rbxassetid://164881112", lb, 5, 0.9)
							CFuncs["Sound"].Create("rbxassetid://429123896", lb, 3.5, 0.75)
							MagniDamage(lb, 50, 60,99, 0, "Normal")
							CameraEnshaking(1,5)
							sphere(4,"Add",lb.CFrame,vt(50,50,50),2,MAINRUINCOLOR)
							sphere(8,"Add",lb.CFrame,vt(50,50,50),4,MAINRUINCOLOR)
							for i = 0, 9 do
								sphereMK(1,math.random(1,3),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,100,-0.1,MAINRUINCOLOR,0)
							end
							for i = 0, 99 do
								swait()
								MagniDamage(lb, 30, 6,18, 0, "Normal")
								PixelBlock(4,math.random(1,30),"Add",lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),32,32,32,0.32,MAINRUINCOLOR,0)
							end
						end
					end)
				end))
			end
			Overed = true
			orb:Destroy()
		end))

		attack = false
	end

	function DivineBlast()
		attack = true
		bosschatfunc("Justice Beam!!",MAINRUINCOLOR.Color,0.7)
		hum.WalkSpeed = 0
		local elocacenter = CreateParta(sorb,1,1,"SmoothPlastic",BrickColor.random())
		elocacenter.Anchored = true
		elocacenter.CFrame = sorb.CFrame
		local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca1.Anchored = true
		eloca1.CFrame = elocacenter.CFrame
		local eloca2 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca2.Anchored = true
		eloca2.CFrame = elocacenter.CFrame
		local eloca3 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca3.Anchored = true
		eloca3.CFrame = elocacenter.CFrame
		local eloca4 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca4.Anchored = true
		eloca4.CFrame = elocacenter.CFrame
		local lookavec = 0 
		local speeds = 0
		CFuncs["Sound"].Create("rbxassetid://1192402877", sorb, 1.5, 1)
		for i = 0, 3, 0.1 do
			swait()
			---
			lookavec = lookavec + 0.1
			speeds = speeds + 10
			elocacenter.CFrame = sorb.CFrame*CFrame.Angles(0,math.rad(speeds),0)
			eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)

			eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)

			eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)

			eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)
			---
			root.CFrame = FaceMouse()[1]
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.1 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.1 * math.cos(sine / 28),0.45)*angles(math.rad(-30),math.rad(0),math.rad(30)),.1)
		end
		for i = 0, 3, 0.1 do
			swait()
			---
			speeds = speeds + 10
			elocacenter.CFrame = sorb.CFrame*CFrame.Angles(0,math.rad(speeds),0)
			eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)

			eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)

			eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)

			eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)
			---
			root.CFrame = FaceMouse()[1]
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.1 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.1 * math.cos(sine / 28),0.45)*angles(math.rad(-30),math.rad(0),math.rad(30)),.1)
		end
		CFuncs["Sound"].Create("rbxassetid://136007472", sorb, 1,1)
		CFuncs["Sound"].Create("rbxassetid://1436239652", char, 40,1)
		for i = 0, 3, 0.1 do
			swait()
			---
			speeds = speeds + 10
			elocacenter.CFrame = sorb.CFrame*CFrame.Angles(0,math.rad(speeds),0)
			eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)

			eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)

			eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)

			eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.5,0.5,0.5,0.005,MAINRUINCOLOR,-2)
			---
			root.CFrame = FaceMouse()[1]
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.1 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(40)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(-40)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(40)),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.1 * math.cos(sine / 28),0.45)*angles(math.rad(-30),math.rad(0),math.rad(30)),.1)
		end
		coroutine.resume(coroutine.create(function()
			local a = Instance.new("Part",Character)
			a.Name = "Direction"	
			a.Anchored = true
			a.BrickColor = bc("White")
			a.Material = "Neon"
			a.Transparency = 0
			a.Shape = "Cylinder"
			a.CanCollide = false
			local a2 = Instance.new("Part",Character)
			a2.Name = "Direction"	
			a2.Anchored = true
			a2.BrickColor = bc("Bright yellow")
			a2.Material = "Neon"
			a2.Transparency = 0
			a2.Shape = "Cylinder"
			a2.CanCollide = false
			local b = Instance.new("Part",Character)
			b.Name = "HitDirect"	
			b.Anchored = true
			b.BrickColor = bc("Cool yellow")
			b.Material = "Neon"
			b.Transparency = 1
			b.CanCollide = false
			local ray = Ray.new(
				elocacenter.CFrame.p,                           -- origin
				(mouse.Hit.p - elocacenter.CFrame.p).unit * 1000 -- direction
			) 
			local ignore = Character
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			a2.BottomSurface = 10
			a2.TopSurface = 10
			local distance = (elocacenter.CFrame.p - position).magnitude
			a.Size = Vector3.new(distance, 1, 1)
			a.CFrame = CFrame.new(elocacenter.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			a2.Size = Vector3.new(distance, 1, 1)
			a2.CFrame = CFrame.new(elocacenter.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			b.CFrame = CFrame.new(elocacenter.CFrame.p, position) * CFrame.new(0, 0, -distance)
			a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
			a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
			game:GetService("Debris"):AddItem(a, 10)
			game:GetService("Debris"):AddItem(a2, 10)
			game:GetService("Debris"):AddItem(b, 10)
			local eff = Instance.new("ParticleEmitter",b)
			eff.Texture = "rbxassetid://2273224484"
			eff.LightEmission = 1
			eff.Color = ColorSequence.new(Color3.new(1,1,0))
			eff.Rate = 500000
			eff.Lifetime = NumberRange.new(0.5,2)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(20,250)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.VelocitySpread = 9000
			eff.RotSpeed = NumberRange.new(-50,50)
			coroutine.resume(coroutine.create(function()
				wait(0.25)
				eff.Enabled = false
			end))
			local msh = Instance.new("SpecialMesh",a)
			msh.MeshType = "Cylinder"
			msh.Scale = vt(1,2,2)
			local msh2 = Instance.new("SpecialMesh",a2)
			msh2.MeshType = "Cylinder"
			msh2.Scale = vt(1,2.5,2.5)
			CFuncs["Sound"].Create("rbxassetid://376970418", sorb, 2, 0.75)
			coroutine.resume(coroutine.create(function()
				for i = 0,10,0.1 do
					swait()
					msh.Scale = msh.Scale + vt(0,0.05,0.05)
					a.Transparency = a.Transparency + 0.025
					msh2.Scale = msh2.Scale + vt(0,0.25,0.25)
					a2.Transparency = a2.Transparency + 0.05
				end
				a:Destroy()
				a2:Destroy()
			end))
			CFuncs["Sound"].Create("rbxassetid://1177785010", b, 3, 1)
			CFuncs["Sound"].Create("rbxassetid://192410089", b, 3, 0.7)
			CFuncs["Sound"].Create("rbxassetid://579687077", b, 0.5, 0.75)
			CFuncs["Sound"].Create("rbxassetid://1060191237", b, 1, 0.75)
			CFuncs["Sound"].Create("rbxassetid://164881112", b, 3, 1)
			CFuncs["Sound"].Create("rbxassetid://429123896", b, 1.5, 0.85)
			MagniDamage(b, 25, 40,65, 0, "Normal")
			for i = 0, 49 do
				PixelBlock(2,math.random(10,20),"Add",b.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),4,4,4,0.04,BrickColor.new("Bright yellow"),0)
				PixelBlock(1,math.random(1,10),"Add",b.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),4,4,4,0.08,BrickColor.new("Bright yellow"),0)
			end
			sphere(1,"Add",b.CFrame,vt(4,4,4),0.1,BrickColor.new("White"))
			sphere(1,"Add",b.CFrame,vt(5,5,5),0.25,BrickColor.new("Bright yellow"))
			sphere(1,"Add",b.CFrame,vt(5,5,5),0.5,BrickColor.new("Bright yellow"))
			sphere(2,"Add",b.CFrame,vt(5,5,5),0.5,BrickColor.new("Bright yellow"))
			sphere(3,"Add",b.CFrame,vt(5,5,5),0.5,BrickColor.new("Bright yellow"))
			sphere(4,"Add",b.CFrame,vt(5,5,5),0.5,BrickColor.new("Bright yellow"))
		end))
		game:GetService("Debris"):AddItem(elocacenter, 5)
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function StarDivision()
		attack = true
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 2, 1.5)
		for i = 0, 2, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(0)),.1)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.6)
			LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.1 * math.cos(sine / 28),0.45)*angles(math.rad(-30),math.rad(0),math.rad(30)),.1)
		end
		local orb = Instance.new("Part", char)
		orb.BrickColor = MAINRUINCOLOR
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(2,2,2)
		local a = Instance.new("Part",workspace)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			sorb.CFrame.p,                           -- origin
			(mouse.Hit.p - sorb.CFrame.p).unit * 500 -- direction
		) 
		local ignore = sorb
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (sorb.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(sorb.CFrame.p, position) * CFrame.new(0, 0, 0)
		orb.CFrame = a.CFrame
		a:Destroy()
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = orb.CFrame.lookVector*100
		bv.Parent = orb
		local hitted = false
		game:GetService("Debris"):AddItem(orb, 10)
		CFuncs["Sound"].Create("rbxassetid://376970418",orb, 1.5, 1.15)
		CFuncs["Sound"].Create("rbxassetid://633627961",orb, 1, 1.15)
		CFuncs["Sound"].Create("rbxassetid://1002081188", orb, 1, 1.15)
		CFuncs["Sound"].Create("rbxassetid://741272936", orb, 1, 1.15)
		CFuncs["Sound"].Create("rbxassetid://1192402877", orb, 1, 1.15)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				if orb.Parent ~= nil and hitted == false then
					PixelBlockNeg(1,math.random(1,2),"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1,1,1,0.02,MAINRUINCOLOR,-2)
				elseif orb.Parent == nil then
					break
				end
			end
		end))
		coroutine.resume(coroutine.create(function()
			swait(1)
			orb.Touched:connect(function(hit)
				if hitted == false then
					hitted = true
					game:GetService("Debris"):AddItem(orb, 5)
					orb.Transparency = 1
					orb.Anchored = true
					local elocacenter = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					elocacenter.Anchored = true
					elocacenter.CFrame = orb.CFrame
					elocacenter.Orientation = vt(0,0,0)
					local eloca1 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					eloca1.Anchored = true
					eloca1.CFrame = elocacenter.CFrame
					local eloca2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					eloca2.Anchored = true
					eloca2.CFrame = elocacenter.CFrame
					local eloca3 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					eloca3.Anchored = true
					eloca3.CFrame = elocacenter.CFrame
					local eloca4 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
					eloca4.Anchored = true
					eloca4.CFrame = elocacenter.CFrame
					local lookavec = 0 
					local speeds = 0
					CameraEnshaking(1,1)
					CFuncs["Sound"].Create("rbxassetid://419447292", elocacenter, 10,1)
					sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
					sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
					sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
					sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
					sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
					for i = 0, 99 do
						swait()
						lookavec = lookavec + 1
						speeds = speeds + 0.1
						elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
						eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)
					end

					for i = 0, 149 do
						swait()
						speeds = speeds + 0.1
						elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
						eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

						eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
						PixelBlockNeg(2,math.random(1,2),"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)
					end
					for i, v in pairs(FindNearestHead(elocacenter.CFrame.p, 125)) do
						if v:FindFirstChild('Head') then
							dmg(v)
						end
					end
					CameraEnshaking(7,30)
					MagniDamage(elocacenter, 225, 50,75, 0, "Normal")
					CFuncs["Sound"].Create("rbxassetid://468991944", char, 4, 1)
					CFuncs["Sound"].Create("rbxassetid://533636230", char, 5, 0.75)
					CFuncs["Sound"].Create("rbxassetid://419447292", char, 1,1)
					CFuncs["Sound"].Create("rbxassetid://421328847", char, 1,1)
					sphere(1,"Add",elocacenter.CFrame,vt(125,90000,125),-0.25,MAINRUINCOLOR)
					sphere(1,"Add",elocacenter.CFrame,vt(125,90000,125),0.5,MAINRUINCOLOR)
					sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
					for i = 0, 24 do
						sphereMK(1,2,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,100,-0.5,MAINRUINCOLOR,0)
						sphereMK(2,4,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,75,-0.25,MAINRUINCOLOR,0)
						sphereMK(3,6,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,50,-0.25,MAINRUINCOLOR,0)
						sphereMK(4,8,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,25,-0.25,MAINRUINCOLOR,0)
					end
					coroutine.resume(coroutine.create(function()
						for i = 0, 499 do
							swait(1)
							MagniDamage(elocacenter, 90, 1,5, 0, "Normal")
							PixelBlockNeg(2,math.random(1,10),"Add",elocacenter.CFrame*CFrame.new(math.random(-75,75),0,math.random(-75,75))*CFrame.Angles(math.rad(90 + math.random(-30,30)),math.rad(math.random(-30,30)),math.rad(math.random(-30,30))),15,15,15,0.15,MAINRUINCOLOR,-5)
						end
						elocacenter:Destroy()
						eloca1:Destroy()
						eloca2:Destroy()
						eloca3:Destroy()
						eloca4:Destroy()
					end))
				end
			end)
		end))
		attack = false
	end


	function THE_TRUE_POWER_OF_VIOLENCE()
		attack = true
		hum.WalkSpeed = 0
		bosschatfunc("ALL YOUR DESTINY...",MAINRUINCOLOR.Color,4)
		for i = 0, 10, 0.1 do
			swait()
			PixelBlockNeg(1,math.random(1,2),"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(40)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-40)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(170),math.rad(0),math.rad(0)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-10),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.4)
		end
		local orb = Instance.new("Part", char)
		orb.BrickColor = MAINRUINCOLOR
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		orb.CFrame = sorb.CFrame
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(0,0,0)
		local sbs = Instance.new("BodyPosition", orb)
		sbs.P = 3000
		sbs.D = 1000
		sbs.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
		sbs.position = RootPart.CFrame.p + Vector3.new(0, 250, 0)
		CFuncs["Sound"].Create("rbxassetid://419447292", rarm, 5,1)
		sphere(1,"Add",sorb.CFrame,vt(0,0,0),0.25,MAINRUINCOLOR)
		sphere(2,"Add",sorb.CFrame,vt(0,0,0),0.25,MAINRUINCOLOR)
		sphere(3,"Add",sorb.CFrame,vt(0,0,0),0.25,MAINRUINCOLOR)
		sphere(4,"Add",sorb.CFrame,vt(0,0,0),0.25,MAINRUINCOLOR)
		sphere(5,"Add",sorb.CFrame,vt(0,0,0),0.25,MAINRUINCOLOR)
		for i = 0, 10, 0.1 do
			swait()
			PixelBlockNeg(1,0.01,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),6,6,6,0.12,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(60)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-60)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(170),math.rad(0),math.rad(0)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-10),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.6)
		end
		orb.Anchored = true
		local elocacenter = CreateParta(orb,1,1,"SmoothPlastic",BrickColor.random())
		elocacenter.Anchored = true
		elocacenter.CFrame = orb.CFrame
		elocacenter.Orientation = vt(0,0,0)
		local eloca1 = CreateParta(orb,1,1,"SmoothPlastic",BrickColor.random())
		eloca1.Anchored = true
		eloca1.CFrame = elocacenter.CFrame
		local eloca2 = CreateParta(orb,1,1,"SmoothPlastic",BrickColor.random())
		eloca2.Anchored = true
		eloca2.CFrame = elocacenter.CFrame
		local eloca3 = CreateParta(orb,1,1,"SmoothPlastic",BrickColor.random())
		eloca3.Anchored = true
		eloca3.CFrame = elocacenter.CFrame
		local eloca4 = CreateParta(orb,1,1,"SmoothPlastic",BrickColor.random())
		eloca4.Anchored = true
		eloca4.CFrame = elocacenter.CFrame
		local lookavec = 0 
		local speeds = 0
		CameraEnshaking(1,1)
		CFuncs["Sound"].Create("rbxassetid://1208650519", char, 3,1)
		CFuncs["Sound"].Create("rbxassetid://419447292", char, 1.5,1)
		CFuncs["Sound"].Create("rbxassetid://468991944", char, 2.5, 1)
		CFuncs["Sound"].Create("rbxassetid://164881112", char, 2.5, 1)
		sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		for i = 0, 99 do
			swait()
			lookavec = lookavec + 2.5
			speeds = speeds + 0.25
			elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
			eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
			PixelBlockNeg(2,0,"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

			eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
			PixelBlockNeg(2,0,"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

			eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
			PixelBlockNeg(2,0,"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

			eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
			PixelBlockNeg(2,0,"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)
		end

		for i = 0, 149 do
			swait()
			speeds = speeds + 0.25
			elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
			eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
			PixelBlockNeg(2,0,"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

			eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
			PixelBlockNeg(2,0,"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

			eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
			PixelBlockNeg(2,0,"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

			eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
			PixelBlockNeg(2,0,"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)
		end
		CFuncs["Sound"].Create("rbxassetid://1192402877", char, 5, 0.75)
		for i = 0, 99 do
			swait()
			lookavec = lookavec - 2.5
			speeds = speeds + 0.25
			elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
			eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
			PixelBlockNeg(2,0,"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

			eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
			PixelBlockNeg(2,0,"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

			eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
			PixelBlockNeg(2,0,"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

			eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
			PixelBlockNeg(2,0,"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)
		end
		local scaled = 0.1*75
		CFuncs["Sound"].Create("rbxassetid://289315275", char, 2.5,1)
		CFuncs["Sound"].Create("rbxassetid://1208650519", char, 2.5,1)
		CFuncs["Sound"].Create("rbxassetid://419447292", char, 2.5,0.5)
		CFuncs["Sound"].Create("rbxassetid://151304356", char, 1,0.5)
		CFuncs["Sound"].Create("rbxassetid://164881112", char, 3.5, 0.75)
		CFuncs["Sound"].Create("rbxassetid://1192402877", char, 2.5, 0.5)
		sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
		sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
		sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
		sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
		sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)

		for i = 0, 10, 0.1 do
			swait()
			scaled = scaled - 0.001*75
			orbm.Scale = orbm.Scale + vt(scaled,scaled,scaled)
			PixelBlockNeg(1,math.random(1,2),"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(60)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-60)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(170),math.rad(0),math.rad(0)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-10),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.6)
		end
		bosschatfunc("WILL BE MINE!!!!",MAINRUINCOLOR.Color,2)
		CFuncs["EchoSound"].Create("rbxassetid://1690476035", char, 10, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1690476035", root, 60, 1,0,10,0.15,0.5,1)
		for x = 0, 4 do
			for i = 0, 9 do
				sphereMK(0.5,0,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10,10,100000,0,MAINRUINCOLOR,0)
			end
			CFuncs["Sound"].Create("rbxassetid://419447292", char, 5,0.75)
			CFuncs["Sound"].Create("rbxassetid://164881112", char, 2.5, 0.5)
			sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
			sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
			sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
			sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
			sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
			for i = 0, 5, 0.1 do
				swait()
				PixelBlockNeg(1,math.random(1,2),"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
				PixelBlockNeg(1,math.random(1,2),"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.1)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(170),math.rad(0),math.rad(-10)),.1)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(170),math.rad(0),math.rad(10)),.1)
			end
		end
		local speedearn = 0
		CFuncs["Sound"].Create("rbxassetid://136007472", char, 5,0.2)
		CFuncs["Sound"].Create("rbxassetid://289315275", char, 5,0.75)
		CFuncs["Sound"].Create("rbxassetid://163619849", char, 2.5, 0.25)
		for i = 0, 30, 0.1 do
			swait()
			scaled = scaled - 0.001*75/10
			speedearn = speedearn + 0.5
			for i = 0, 4 do 
				sphereMK(1+speedearn,speedearn,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			end
			PixelBlock(1,speedearn,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1*speedearn/10,1*speedearn/10,1*speedearn/10,0.02*speedearn/10,MAINRUINCOLOR,0)
			orbm.Scale = orbm.Scale + vt(scaled,scaled,scaled)
			PixelBlockNeg(1,math.random(1,2),"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			PixelBlockNeg(1,math.random(1,2),"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(0)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(170),math.rad(0),math.rad(-10)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(170),math.rad(0),math.rad(10)),.6)
		end
		orb.Transparency = 1
		for i, v in pairs(FindNearestHead(elocacenter.CFrame.p, 125000000)) do
			if v:FindFirstChild('Head') then
				dmg(v)
			end
		end
		CameraEnshaking(7,30)
		MagniDamage(elocacenter, 9999999, 5000000,99999999, 0, "Normal")
		CFuncs["Sound"].Create("rbxassetid://167115397", char, 5,1)
		CFuncs["Sound"].Create("rbxassetid://289315275", char, 5,0.5)
		CFuncs["Sound"].Create("rbxassetid://163619849", char, 3, 0.25)
		CFuncs["Sound"].Create("rbxassetid://468991944", char, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://533636230", char, 10, 0.75)
		CFuncs["Sound"].Create("rbxassetid://419447292", char, 6,1)
		CFuncs["Sound"].Create("rbxassetid://421328847", char, 1,1)
		CFuncs["Sound"].Create("rbxassetid://741272936", char, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://164881112", char, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://1192402877", char, 7.5, 0.5)
		CFuncs["Sound"].Create("rbxassetid://429123896", char, 5, 0.85)
		CFuncs["Sound"].Create("rbxassetid://1208650519", char, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://919941001", char, 5,1.05)
		sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
		sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
		sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
		sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
		sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
		for i = 0, 99 do
			PixelBlock(1,math.random(50,1000),"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),20,20,20,0.4,MAINRUINCOLOR,0)
			PixelBlock(2,math.random(250,1000),"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10,10,10,0.2,MAINRUINCOLOR,0)
		end
		for i = 0, 24 do
			sphereMK(0.5,0,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10,10,100000,0,MAINRUINCOLOR,0)
			sphereMK(1,2,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,100,-0.5,MAINRUINCOLOR,0)
			sphereMK(2,4,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,75,-0.25,MAINRUINCOLOR,0)
			sphereMK(3,6,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,50,-0.25,MAINRUINCOLOR,0)
			sphereMK(4,8,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,25,-0.25,MAINRUINCOLOR,0)
		end
		game:GetService("Debris"):AddItem(orb, 10)
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end


	function ViolentRing()
		attack = true
		CFuncs["Sound"].Create("rbxassetid://136007472", rarm, 1, 1)
		bosschatfunc("SHOULD I TAKE THAT EASIER?!",MAINRUINCOLOR.Color,0.7)
		CFuncs["EchoSound"].Create("rbxassetid://1535994137", char, 4, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1535994137", root, 7, 1,0,10,0.15,0.5,1)
		for i = 0, 2, 0.1 do
			swait()
			local snap = math.random(1,10)
			if snap == 1 then
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(-50 + math.random(-10,10))),1)
			end
			PixelBlockX(5,0.5,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,MAINRUINCOLOR,0)
			PixelBlockNeg(5,0.5,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,MAINRUINCOLOR,0)
			PixelBlockX(5,0.25,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.65,0.65,0.65,0.0065,MAINRUINCOLOR,0)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(50)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-50)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(70),math.rad(20),math.rad(50)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.6)
			RootPart.CFrame = FaceMouse()[1]
		end
		local orb = Instance.new("Part", char)
		orb.BrickColor = MAINRUINCOLOR
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(2,2,2)
		orb.CFrame = mouse.Hit
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = orb.CFrame.lookVector*100
		bv.Parent = orb
		local hitted = false
		coroutine.resume(coroutine.create(function()
			game:GetService("Debris"):AddItem(orb, 5)
			orb.Transparency = 1
			orb.Anchored = true
			local elocacenter = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			elocacenter.Anchored = true
			elocacenter.CFrame = orb.CFrame
			elocacenter.Orientation = vt(0,0,0)
			local eloca1 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			eloca1.Anchored = true
			eloca1.CFrame = elocacenter.CFrame
			local eloca2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			eloca2.Anchored = true
			eloca2.CFrame = elocacenter.CFrame
			local eloca3 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			eloca3.Anchored = true
			eloca3.CFrame = elocacenter.CFrame
			local eloca4 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
			eloca4.Anchored = true
			eloca4.CFrame = elocacenter.CFrame
			local lookavec = 0 
			local speeds = 0
			CameraEnshaking(1,1)
			CFuncs["Sound"].Create("rbxassetid://419447292", elocacenter, 10,1)
			sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
			sphere(6,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
			sphere(7,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
			sphere(8,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
			sphere(9,"Add",elocacenter.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
			for i = 0, 24 do
				swait()
				lookavec = lookavec + 3.5
				speeds = speeds + 1
				elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
				eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
				PixelBlockNeg(2,math.random(1,2),"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

				eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
				PixelBlockNeg(2,math.random(1,2),"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

				eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
				PixelBlockNeg(2,math.random(1,2),"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

				eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
				PixelBlockNeg(2,math.random(1,2),"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)
			end

			local risen = 0
			for i = 0, 49 do
				swait()
				risen = risen + 0.05
				speeds = speeds + 0.1
				elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(speeds),0)
				eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
				PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

				eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
				PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

				eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
				PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)

				eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
				PixelBlockNeg(2,math.random(1+risen,2+risen),"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),5,5,5,0.05,MAINRUINCOLOR,-2)
			end
			for i, v in pairs(FindNearestHead(elocacenter.CFrame.p, 100)) do
				if v:FindFirstChild('Head') then
					dmg(v)
				end
			end
			CameraEnshaking(4,10)
			MagniDamage(elocacenter, 150, 50,75, 0, "Normal")
			CFuncs["Sound"].Create("rbxassetid://468991944", char, 2, 1)
			CFuncs["Sound"].Create("rbxassetid://533636230", char, 2.5, 0.75)
			CFuncs["Sound"].Create("rbxassetid://419447292", char, 0.25,1)
			CFuncs["Sound"].Create("rbxassetid://421328847", char, 0.25,1)
			CFuncs["Sound"].Create("rbxassetid://919941001", char, 1.5,1.05)
			local eff = Instance.new("ParticleEmitter",elocacenter)
			eff.Texture = "rbxassetid://2273224484"
			eff.LightEmission = 1
			eff.Color = ColorSequence.new(Color3.new(1,1,0))
			eff.Rate = 1000000
			eff.Lifetime = NumberRange.new(0.5,2)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(20,250)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.VelocitySpread = 5000000
			eff.RotSpeed = NumberRange.new(-50,50)
			coroutine.resume(coroutine.create(function()
				wait(1)
				eff.Enabled = false
			end))
			sphere(1,"Add",elocacenter.CFrame,vt(100,90000,100),-0.25,MAINRUINCOLOR)
			sphere(1,"Add",elocacenter.CFrame,vt(100,90000,100),0.5,MAINRUINCOLOR)
			sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
			sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
			sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
			sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
			sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
			sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),500,MAINRUINCOLOR)
			for i = 0, 24 do
				sphereMK(2,2,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,100,-0.25,MAINRUINCOLOR,0)
				sphereMK(4,4,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,75,-0.25,MAINRUINCOLOR,0)
				sphereMK(6,6,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,50,-0.25,MAINRUINCOLOR,0)
				sphereMK(8,8,"Add",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,25,-0.25,MAINRUINCOLOR,0)
			end
			coroutine.resume(coroutine.create(function()
				wait(10)
				elocacenter:Destroy()
				eloca1:Destroy()
				eloca2:Destroy()
				eloca3:Destroy()
				eloca4:Destroy()
			end))
		end))
		attack = false
	end

	function UniversalCollapse()
		attack = true
		local speedearn = 0
		hum.WalkSpeed = 0
		local sbs = Instance.new("BodyPosition", root)
		sbs.P = 3000
		sbs.D = 1000
		sbs.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
		sbs.position = RootPart.CFrame.p + Vector3.new(0, 200, 0)
		CFuncs["Sound"].Create("rbxassetid://1208650519", char, 10, 1)
		for i = 0, 85, 0.1 do
			swait()
			speedearn = speedearn + 0.1
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphere(25,"Add",root.CFrame,vt(speedearn*2,speedearn*2,speedearn*2),0.01,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
		end
		bosschatfunc("Universary..",MAINRUINCOLOR.Color,1)
		CFuncs["EchoSound"].Create("rbxassetid://1448032598", char, 5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1448032598", root, 20, 1,0,10,0.15,0.5,1)
		for i = 0, 25, 0.1 do
			swait()
			speedearn = speedearn + 0.1
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,10*speedearn,-0.05,MAINRUINCOLOR,0)
			sphere(25,"Add",root.CFrame,vt(speedearn*2,speedearn*2,speedearn*2),0.01,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
		end
		bosschatfunc("COLLAPSE!!!",MAINRUINCOLOR.Color,1)
		CFuncs["EchoSound"].Create("rbxassetid://1436241883", char, 5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1436241883", root, 20, 1,0,10,0.15,0.5,1)
		CameraEnshaking(5,50)
		sphere(5,"Add",root.CFrame,vt(0,0,0),25,MAINRUINCOLOR)
		for i = 0, 2 do 
			CFuncs["Sound"].Create("rbxassetid://1177785010", char, 10, 1)
			CFuncs["Sound"].Create("rbxassetid://533636230", char, 10, 0.75)
			CFuncs["Sound"].Create("rbxassetid://419447292", char, 5,1)
			CFuncs["Sound"].Create("rbxassetid://421328847", char, 5,1)
		end
		for i = 0, 49 do
			sphereMK(1,3,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),50,50,200,-1,MAINRUINCOLOR,0)
			sphereMK(2,6,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),50,50,150,-0.5,MAINRUINCOLOR,0)
			sphereMK(3,9,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),50,50,100,-0.5,MAINRUINCOLOR,0)
			sphereMK(4,12,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),50,50,50,-0.5,MAINRUINCOLOR,0)
		end
		sphere(1,"Add",root.CFrame,vt(0,0,0),15,MAINRUINCOLOR)
		sphere(2,"Add",root.CFrame,vt(0,0,0),15,MAINRUINCOLOR)
		sphere(3,"Add",root.CFrame,vt(0,0,0),15,MAINRUINCOLOR)
		sphere(4,"Add",root.CFrame,vt(0,0,0),15,MAINRUINCOLOR)
		sphere(5,"Add",root.CFrame,vt(0,0,0),15,MAINRUINCOLOR)
		sphere(6,"Add",root.CFrame,vt(0,0,0),15,MAINRUINCOLOR)
		sphere(1,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
		sphere(2,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
		sphere(3,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
		sphere(4,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
		sphere(5,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
		sphere(6,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
		for i = 0, 99 do
			PixelBlock(1,math.random(50,1000),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),20,20,20,0.4,MAINRUINCOLOR,0)
			PixelBlock(2,math.random(250,1000),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10,10,10,0.2,MAINRUINCOLOR,0)
		end
		for i, v in pairs(FindNearestHead(root.CFrame.p, 9999999)) do
			if v:FindFirstChild('Head') then
				dmg(v)
			end
		end
		MagniDamage(root, 9999999, 1000000,9999999, 0, "Normal")
		sbs:Destroy()
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end


	function ChaosEND()
		attack = true
		local speedearn = 0
		bosschatfunc("THIS IS..",MAINRUINCOLOR.Color,0.8)
		CFuncs["EchoSound"].Create("rbxassetid://1548599511", char, 4.5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1548599511", root, 30, 1,0,10,0.15,0.5,1)
		CFuncs["Sound"].Create("rbxassetid://1208650519", char, 4, 1)
		for i = 0, 15, 0.1 do
			swait()
			speedearn = speedearn + 0.25
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,10*speedearn,-0.25,BrickColor.random(),0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,10*speedearn,-0.25,BrickColor.random(),0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,10*speedearn,-0.25,BrickColor.random(),0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,10*speedearn,-0.25,BrickColor.random(),0)
			sphereMK(1+speedearn,speedearn,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),25,25,10*speedearn,-0.25,BrickColor.random(),0)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(140),math.rad(0),math.rad(-20)),.2)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(140),math.rad(0),math.rad(20)),.2)
		end
		CFuncs["Sound"].Create("rbxassetid://438666141", char, 3,1)
		CFuncs["Sound"].Create("rbxassetid://1208650519", char, 4, 1)
		bosschatfunc("THE END!!!",MAINRUINCOLOR.Color,2)
		CFuncs["EchoSound"].Create("rbxassetid://1548599962", char, 8, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1548599962", root, 40, 1,0,10,0.15,0.5,1)
		CameraEnshaking(5,25)
		for i, v in pairs(FindNearestHead(Torso.CFrame.p, 1234567890)) do
			if v:FindFirstChild('Head') then
				dmg(v)
			end
		end
		sphere(5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0,0,0),1*1000,BrickColor.random())
		sphere(10,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0,0,0),2*1000,BrickColor.random())
		sphere(1,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(100*1000,0.1,100*1000),0.01,BrickColor.random())
		for i = 0, 3, 0.1 do
			swait()
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5*10,52.5*10),-5,math.random(-52.5*10,52.5*10))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),25,25,250,-0.25,BrickColor.random(),0)
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5*10,52.5*10),-5,math.random(-52.5*10,52.5*10))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),25,25,250,-0.25,BrickColor.random(),0)
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5*10,52.5*10),-5,math.random(-52.5*10,52.5*10))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),25,25,250,-0.25,BrickColor.random(),0)
			sphereMK(2.5,0.75,"Add",root.CFrame*CFrame.new(math.random(-52.5*10,52.5*10),-5,math.random(-52.5*10,52.5*10))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),25,25,250,-0.25,BrickColor.random(),0)
			RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(0)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(30)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-30)),.4)
		end
		attack = false
	end

	function orb_spawn_norm(positted,timer,color,MagniBoost,min,max,volEx,ShakePower,volSummon)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = color
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orb.CFrame = positted
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(1,1,1)
		CFuncs["Sound"].Create("rbxassetid://183763506", orb, volSummon, 1)
		sphere(2.5,"Add",orb.CFrame,vt(1,1,1),0.05,orb.BrickColor)
--[[for i = 0, 2 do
sphereMK(5,0.15,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1.5,1.5,7.5,-0.015,orb.BrickColor,0)
end]]--
		coroutine.resume(coroutine.create(function()
			wait(timer)
			CameraEnshaking(3,ShakePower)
			orb.Transparency = 1
			MagniDamage(orb, 3.5*MagniBoost, min,max, 0, "Normal")
			sphere(5,"Add",orb.CFrame,vt(1,1,1),0.1*MagniBoost,orb.BrickColor)
--[[for i = 0, 4 do
sphereMK(5,0.15*MagniBoost,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,orb.BrickColor,0)
end]]--
			CFuncs["Sound"].Create("rbxassetid://192410089", orb, volEx, 0.7)
			wait(3)
			orb:Destroy()
		end))
	end

	function orb_spawn(positted,timer)
		local randomcol = math.random(1,2)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		if randomcol == 1 then
			orb.BrickColor = BrickColor.new("White")
		elseif randomcol == 2 then
			orb.BrickColor = BrickColor.new("Really black")
		end
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orb.CFrame = positted
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(1,1,1)
		CFuncs["Sound"].Create("rbxassetid://183763506", orb, 0.15, 1)
		sphere(2.5,"Add",orb.CFrame,vt(1,1,1),0.025,orb.BrickColor)
		for i = 0, 2 do
			sphereMK(5,0.15,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1.5,1.5,7.5,-0.015,orb.BrickColor,0)
		end
		coroutine.resume(coroutine.create(function()
			wait(timer)
			CameraEnshaking(3,2)
			orb.Transparency = 1
			MagniDamage(orb, 17.5, 10,50, 0, "Normal")
			sphere(5,"Add",orb.CFrame,vt(1,1,1),0.5,orb.BrickColor)
			for i = 0, 4 do
				sphereMK(5,0.65,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,orb.BrickColor,0)
			end
			CFuncs["Sound"].Create("rbxassetid://192410089", orb, 0.15, 0.7)
			wait(3)
			orb:Destroy()
		end))
	end

	function scattercorrupt()
		attack = true
		hum.WalkSpeed = 0
		for i = 0, 2, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(30)),.2)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-30)),.2)
		end
		local rot = 0
		local randomrotations = math.random(1,2)
		local lookv = 2.5
		local power = 7
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("HOW LONG CAN YOU TAKE THIS?",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("SWAMP!!",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("SCATTER!!",MAINRUINCOLOR.Color,1)
		end
		CFuncs["Sound"].Create("rbxassetid://183763506", RightLeg, 2, 1)
		for i = 0, 1, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(15),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),.15)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(15),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),.15)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(15),math.rad(0),math.rad(0)),.15)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(0)),.15)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-25),math.rad(0),math.rad(40)),.15)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-25),math.rad(0),math.rad(-40)),.15)
		end
		CFuncs["EchoSound"].Create("rbxassetid://1535994669", char, 5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1535994669", root, 20, 1,0,10,0.15,0.5,1)
		sphere(1,"Add",root.CFrame,vt(1,100000,1),0.5,BrickColor.new("Royal purple"))
		sphere(1,"Add",root.CFrame,vt(1,1,1),0.75,BrickColor.new("Royal purple"))
		for i = 0, 9 do
			sphereMK(1,1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10,10,45,-0.1,BrickColor.new("Royal purple"),0)
		end
		local hite = Instance.new("Part", char)
		hite.Anchored = true
		hite.CanCollide = false
		hite.FormFactor = 3
		hite.Name = "Ring"
		hite.Material = "Neon"
		hite.Size = Vector3.new(1, 1, 1)
		hite.Transparency = 1
		hite.TopSurface = 0
		hite.BottomSurface = 0
		hite.CFrame = root.CFrame*CFrame.new(0,-2.5,0)
		local rem = Instance.new("Part", char)
		rem.Anchored = true
		rem.CanCollide = false
		rem.FormFactor = 3
		rem.Name = "Ring"
		rem.Material = "Neon"
		rem.Size = Vector3.new(1, 1, 1)
		rem.Transparency = 1
		rem.TopSurface = 0
		rem.BottomSurface = 0
		rem.CFrame = hite.CFrame
		local rem2 = rem:Clone()
		rem2.Parent = char
		rem2.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(90),0)
		local rem3 = rem:Clone()
		rem3.Parent = char
		rem3.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(180),0)
		local rem4 = rem:Clone()
		rem4.Parent = char
		rem4.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(270),0)
		hite:Destroy()
		coroutine.resume(coroutine.create(function()
			for i = 0, 24 do
				swait(1)
				if randomrotations == 1 then
					rot = rot + 1
				elseif randomrotations == 2 then
					rot = rot - 1
				end
				power = power + 0.5
				lookv = lookv + 7.5
				rem.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(rot),0)
				rem2.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(90),0)
				rem3.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(180),0)
				rem4.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(270),0)
				orb_spawn_norm(rem.CFrame + rem.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,1)
				orb_spawn_norm(rem2.CFrame + rem2.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,1)
				orb_spawn_norm(rem3.CFrame + rem3.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,1)
				orb_spawn_norm(rem4.CFrame + rem4.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,1)
			end
		end))
		wait(2)
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end
	function yinyangi()
		attack = true
		for i = 0, 2, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(75),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.2)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.2)
		end
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = root.CFrame.lookVector*175
		bv.Parent = root
		for Rotations = 0, 9 do
			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector*175
				RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.5)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.5)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(90),math.rad(0),math.rad(90)),.5)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.5)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.5)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.5)
			end
			orb_spawn(rarm.CFrame*CFrame.new(0,-1,0),2.5)
			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector*175
				RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.5)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.5)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(90),math.rad(0),math.rad(180)),.5)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.5)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.5)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.5)
			end
			orb_spawn(rarm.CFrame*CFrame.new(0,-1,0),2.5)
			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector*175
				RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.5)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.5)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(90),math.rad(0),math.rad(270)),.5)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.5)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.5)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.5)
			end
			orb_spawn(rarm.CFrame*CFrame.new(0,-1,0),2.5)
			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector*175
				RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.5)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.5)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(90),math.rad(0),math.rad(360)),.5)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.5)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.5)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.5)
			end
			orb_spawn(rarm.CFrame*CFrame.new(0,-1,0),2.5)
		end
		bv:Destroy()
		attack = false
	end

	function createBGCircle(size,parent,color)
		local bgui = Instance.new("BillboardGui",parent)
		bgui.Size = UDim2.new(size, 0, size, 0)
		local imgc = Instance.new("ImageLabel",bgui)
		imgc.BackgroundTransparency = 1
		imgc.ImageTransparency = 0
		imgc.Size = UDim2.new(1,0,1,0)
		imgc.Image = "rbxassetid://997291547" --997291547,521073910
		imgc.ImageColor3 = color
		return bgui,imgc
	end

	function symbolizeBlink(guipar,size,img,color,bonussize,vol,pit,soundid,spar,rotationenabled,rotsp,delay)
		local bgui,imgc = createBGCircle(size,guipar,color)
		bgui.AlwaysOnTop = true
		imgc.Image = "rbxassetid://" ..img
		local rrot = math.random(1,2)
		CFuncs["Sound"].Create("rbxassetid://" ..soundid, spar, vol,pit)
		coroutine.resume(coroutine.create(function()
			for i = 0, 24*delay do
				swait()
				if rotationenabled == true then
					if rrot == 1 then
						imgc.Rotation = imgc.Rotation + rotsp
					elseif rrot == 2 then
						imgc.Rotation = imgc.Rotation - rotsp
					end
				end
				bgui.Size = bgui.Size + UDim2.new(1*bonussize/delay,0,1*bonussize/delay,0)
				imgc.ImageTransparency = imgc.ImageTransparency + 0.04/delay
			end
			bgui:Destroy()
		end))
	end
	function RecolorThing(one,two,three,four,five,exonetran,exone,extwotran,extwo,secondaryenabled)
		for i, v in pairs(mw2:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = one
				v.Material = "Neon"
			end
		end
		CFuncs["EchoSound"].Create("rbxassetid://847061203", root, 1, 1,0,10,0.25,0.25,1)
		symbolizeBlink(root,0,2109052855,one.Color,1,3,1,1614005837,root,true,10,1)
		symbolizeBlink(root,0,2109052855,two.Color,1.1,2,1,1923591005,root,true,10,1)
		symbolizeBlink(root,0,2344870656,one.Color,3,0,0,0,root,true,10,1)
		symbolizeBlink(root,0,2092248396,one.Color,3,0,0,0,root,true,10,1)
		tr1.Color = ColorSequence.new(one.Color)
		tr2.Color = ColorSequence.new(one.Color)
		tr3.Color = ColorSequence.new(one.Color)
		for i, v in pairs(mw1:GetChildren()) do
			if v:IsA("Part") then
				if secondaryenabled == false then
					v.Transparency = 1
				elseif secondaryenabled == true then
					v.Transparency = 0
				end
				v.BrickColor = two
				v.Material = "Neon"
			end
			for i, v in pairs(maincolg:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = three
				end
			end
			for i, v in pairs(seccolg:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = two
				end
			end
		end
		if secondaryenabled == false then
			tl1.Enabled = false
			tl2.Enabled = false
			tl3.Enabled = false
		elseif secondaryenabled == true then
			tl1.Enabled = true
			tl2.Enabled = true
			tl3.Enabled = true
			rwing1.MainWelder.Emitter1.Enabled = true
			rwing1.MainWelder.Emitter2.Enabled = true
			rwing2.MainWelder.Emitter1.Enabled = true
			rwing2.MainWelder.Emitter2.Enabled = true
			rwing3.MainWelder.Emitter1.Enabled = true
			rwing3.MainWelder.Emitter2.Enabled = true
			rwing1.MainWelder.Emitter1.Color = ColorSequence.new(one.Color)
			rwing1.MainWelder.Emitter2.Color = ColorSequence.new(one.Color)
			rwing2.MainWelder.Emitter1.Color = ColorSequence.new(one.Color)
			rwing2.MainWelder.Emitter2.Color = ColorSequence.new(one.Color)
			rwing3.MainWelder.Emitter1.Color = ColorSequence.new(one.Color)
			rwing3.MainWelder.Emitter2.Color = ColorSequence.new(one.Color)
			lwing1.MainWelder.Emitter1.Color = ColorSequence.new(two.Color)
			lwing1.MainWelder.Emitter2.Color = ColorSequence.new(two.Color)
			lwing2.MainWelder.Emitter1.Color = ColorSequence.new(two.Color)
			lwing2.MainWelder.Emitter2.Color = ColorSequence.new(two.Color)
			lwing3.MainWelder.Emitter1.Color = ColorSequence.new(two.Color)
			lwing3.MainWelder.Emitter2.Color = ColorSequence.new(two.Color)
		end
		tl1.Color = ColorSequence.new(two.Color)
		tl2.Color = ColorSequence.new(two.Color)
		tl3.Color = ColorSequence.new(two.Color)
		for i, v in pairs(m:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = three
				v.Material = "Ice"
			end
		end
		for i, v in pairs(m2:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = four
				v.Material = "Ice"
			end
		end
		for i, v in pairs(m3:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = five
				v.Material = "Neon"
			end
		end
		for i, v in pairs(mw1:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = two
				v.Material = "Neon"
			end
		end
		for i, v in pairs(rwing1top:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(rwing1left:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(rwing1right:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(rwing1.Buttom:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(rwing2top:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(rwing2left:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(rwing2right:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(rwing2.Buttom:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(rwing3top:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(rwing3left:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(rwing3right:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(rwing3.Buttom:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = one
			end
		end
		for i, v in pairs(lwing1top:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
		for i, v in pairs(lwing1left:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
		for i, v in pairs(lwing1right:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
		for i, v in pairs(lwing1.Buttom:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
		for i, v in pairs(lwing2top:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
		for i, v in pairs(lwing2left:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
		for i, v in pairs(lwing2right:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
		for i, v in pairs(lwing2.Buttom:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
		for i, v in pairs(lwing3top:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
		for i, v in pairs(lwing3left:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
		for i, v in pairs(lwing3right:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
		for i, v in pairs(lwing3.Buttom:GetChildren()) do
			if v:IsA("WedgePart") then
				v.Transparency = 0
				v.BrickColor = two
			end
		end
	end


	function REE()
		attack = true
		hum.WalkSpeed = 0
		for i = 0,2,0.1 do
			swait()
			sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
			slash(math.random(30,60)/10,5,true,"Round","Add","In",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.01,0.5),-0.5,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.15)*angles(math.rad(30),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(0 - 5 * math.cos(sine / 0.2))),.2)
			RW.C0=clerp(RW.C0,cf(1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(-50)),.2)
			LW.C0=clerp(LW.C0,cf(-1.05,0.4,-0.5)*angles(math.rad(140),math.rad(0),math.rad(50)),.2)
		end
		CFuncs["Sound"].Create("rbxassetid://206082327", root, 3.5,1)
		CFuncs["Sound"].Create("rbxassetid://847061203", root, 5,1)
		CFuncs["Sound"].Create("rbxassetid://239000203", root, 6.5,1)
		storehumanoidWS = 16
		CameraEnshaking(5,2.5)
		sphere(2.5,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		for i = 0, 49 do
			PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2,2,2,0.04,MAINRUINCOLOR,0)
		end
		for i = 0, 24 do
			sphere2(2,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,7,-0.01,MAINRUINCOLOR)
			slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,350)/250,BrickColor.new("White"))
		end
		for i = 0,3,0.1 do
			sphereMK(2.5,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,MAINRUINCOLOR,0)
		end
		RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false)
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.5)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.3,-0.15)*angles(math.rad(-30),math.rad(0),math.rad(0)),.5)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0 - 2.5 * math.cos(sine / 0.2))),.5)
			RW.C0=clerp(RW.C0,cf(1.45,0.4,0)*angles(math.rad(-20),math.rad(0 - 2 * math.cos(sine / 0.2)),math.rad(80 + 2 * math.cos(sine / 0.2))),.5)
			LW.C0=clerp(LW.C0,cf(-1.45,0.4,0)*angles(math.rad(-20),math.rad(0 + 2 * math.cos(sine / 0.2)),math.rad(-80 - 2 * math.cos(sine / 0.2))),.5)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function attackone()
		attack = true
		local keptcolor = MAINRUINCOLOR
		for i = 0,1,0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(-10),math.rad(-20)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(10),math.rad(20)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(30)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-15),math.rad(0),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(2.5),math.rad(0),math.rad(0)),.3)
		end
		local distlook = 5
		coroutine.resume(coroutine.create(function()
			for i = 0, 4 do
				swait(2)
				CameraEnshaking(2,3)
				local hite = Instance.new("Part", char)
				hite.Anchored = true
				hite.CanCollide = false
				hite.FormFactor = 3
				hite.Name = "Ring"
				hite.Material = "Neon"
				hite.Size = Vector3.new(1, 1, 1)
				hite.Transparency = 1
				hite.TopSurface = 0
				hite.BottomSurface = 0
				hite.CFrame = root.CFrame*CFrame.new(0,-3,-distlook)
				sphere2(4,"Add",hite.CFrame*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),vt(0,1,0),0.2,0.001,0.2,keptcolor)
				sphere2(4,"Add",hite.CFrame*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),vt(8,1,8),-0.045,0.15,-0.045,keptcolor)
				sphere2(4,"Add",hite.CFrame*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),vt(4,1,4),-0.025,0.25,-0.025,keptcolor)
				sphere2(4,"Add",hite.CFrame*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),vt(2,1,2),-0.015,0.35,-0.015,keptcolor)
				MagniDamage(hite, 9, 10,25, 0, "Normal")
				for i = 0, 14 do
					local rsiz = math.random(5,20)
					sphereMK(math.random(1,3),0.25,"Add",hite.CFrame*CFrame.new(math.random(-20,20)/50,math.random(-20,20)/50,math.random(-20,20)/50)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,keptcolor,0)
				end
				CFuncs["Sound"].Create("rbxassetid://178452221", hite, 1, 1)
				CFuncs["Sound"].Create("rbxassetid://1042722746", hite, 0.5, 1)
				game:GetService("Debris"):AddItem(hite, 5)
				distlook = distlook + 10
			end
		end))
		for i = 0,1,0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(5),math.rad(90)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-90)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(120)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(-10)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.5)
		end
		attack = false
	end

	function attacktwo()
		attack = true
		hum.WalkSpeed = 2
		local keptcolor = MAINRUINCOLOR
		CFuncs["Sound"].Create("rbxassetid://847061203", root, 2, 1)
		sphere2(5,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.1,0.1,0.1,keptcolor,keptcolor.Color)
		sphere2(5,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.2,0.2,0.2,keptcolor,keptcolor.Color)
		for i = 0, 14 do
			PixelBlock(1,math.random(1,3),"Add",rarm.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,keptcolor,0)
		end
		for i = 0,1,0.1 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.3)
			RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.3)
		end
		for i = 0, 1 do
			CFuncs["Sound"].Create("rbxassetid://763755889", root, 3,1.1)
			for i = 0,1,0.6 do
				swait()
				sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
				slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.6)
				RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-60)),.6)
				LW.C0=clerp(LW.C0,cf(-1.15,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.6)
			end
			for i = 0,1,0.6 do
				swait()
				sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
				slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.6)
				RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-60)),.6)
				LW.C0=clerp(LW.C0,cf(-1.15,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.6)
			end
			for i = 0,1,0.6 do
				swait()
				sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
				slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-180)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.6)
				RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-60)),.6)
				LW.C0=clerp(LW.C0,cf(-1.15,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.6)
			end
			for i = 0,1,0.6 do
				swait()
				sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
				slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-270)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.6)
				RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-60)),.6)
				LW.C0=clerp(LW.C0,cf(-1.15,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.6)
			end
			local rot = 0
			local dis = CreateParta(char,0.5,1,"Neon",keptcolor)
			CFuncs["EchoSound"].Create("rbxassetid://763718160", dis, 3, 1.1,0,10,0.15,0.5,1)
			dis.CFrame = root.CFrame*CFrame.new(0,2,-3)
			CreateMesh(dis,"Sphere",10,1,10)
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-5,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(5,0,0)
			local trl = Instance.new('Trail',wed)
			trl.Attachment0 = at1
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 0.6
			local a = Instance.new("Part",workspace)
			a.Name = "Direction"	
			a.Anchored = true
			a.BrickColor = bc("Bright red")
			a.Material = "Neon"
			a.Transparency = 1
			a.CanCollide = false
			local ray = Ray.new(
				dis.CFrame.p,                           -- origin
				(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
			) 
			local ignore = dis
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			local distance = (dis.CFrame.p - position).magnitude
			a.Size = Vector3.new(0.1, 0.1, 0.1)
			a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
			dis.CFrame = a.CFrame
			dis.CFrame = dis.CFrame*CFrame.Angles(0,math.rad(rot),0)
			a:Destroy()
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*250
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 5)
			local hitted = false
			coroutine.resume(coroutine.create(function()
				dis.Touched:connect(function(hit) 
					if hitted == false and hit.Parent ~= char then
						hitted = true
						CFuncs["EchoSound"].Create("rbxassetid://782200047", dis, 7, 1.1,0,10,0.15,0.5,1)
						MagniDamage(dis, 30, 33,56, 0, "Normal")
						sphere2(8,"Add",dis.CFrame,vt(10,1,10),1,0.1,1,keptcolor,keptcolor.Color)
						sphere2(4,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,keptcolor,keptcolor.Color)
						sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,keptcolor,keptcolor.Color)
						coroutine.resume(coroutine.create(function()
							for i = 0, 9 do
								local disr = CreateParta(char,1,1,"Neon",keptcolor)
								disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
								local at1 = Instance.new("Attachment",disr)
								at1.Position = vt(-5,0,0)
								local at2 = Instance.new("Attachment",disr)
								at2.Position = vt(5,0,0)
								local trl = Instance.new('Trail',disr)
								trl.Attachment0 = at1
								trl.FaceCamera = true
								trl.Attachment1 = at2
								trl.Texture = "rbxassetid://2342682798"
								trl.LightEmission = 1
								trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
								trl.Color = ColorSequence.new(keptcolor.Color)
								trl.Lifetime = 0.5
								local bv = Instance.new("BodyVelocity")
								bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
								bv.velocity = disr.CFrame.lookVector*math.random(50,200)
								bv.Parent = disr
								local val = 0
								coroutine.resume(coroutine.create(function()
									swait(30)
									for i = 0, 9 do
										swait()
										val = val + 0.1
										trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
									end
									game:GetService("Debris"):AddItem(disr, 3)
								end))
							end
							local eff = Instance.new("ParticleEmitter",dis)
							eff.Texture = "rbxassetid://2273224484"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(keptcolor.Color)
							eff.Rate = 500000
							eff.Lifetime = NumberRange.new(0.5,2)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(20,250)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.VelocitySpread = 9000
							eff.RotSpeed = NumberRange.new(-50,50)
							wait(0.25)
							eff.Enabled = false
						end))
						for i = 0, 9 do
							slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(100,200)/250,BrickColor.new("White"))
						end
						for i = 0, 19 do
							PixelBlock(1,math.random(5,20),"Add",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),4,4,4,0.08,keptcolor,0)
						end
						coroutine.resume(coroutine.create(function()
							for i = 0, 19 do
								swait()
								hum.CameraOffset = vt(math.random(-10,10)/70,math.random(-10,10)/70,math.random(-10,10)/70)
							end
							hum.CameraOffset = vt(0,0,0)
						end))
						dis.Anchored = true
						dis.Transparency = 1
						wait(8)
						dis:Destroy()
					end
				end)
			end))
			rot = rot - 15
		end
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-30),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(5)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(50)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(60)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-10)),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function attackthree()
		attack = true
		local keptcolor = MAINRUINCOLOR
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 2, 1.5)
		for i = 0,2,0.1 do
			swait()
			sphere2(5,"Add",larm.CFrame*CFrame.new(0,-1.5,0),vt(1,1,1),0.025,0.025,0.025,MAINRUINCOLOR,MAINRUINCOLOR.Color)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(10),math.rad(0),math.rad(50)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-50)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(80), math.rad(10), math.rad(60)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(140), math.rad(0), math.rad(-70)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(-50),math.rad(-10)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(40)),.3)
		end
		CFuncs["Sound"].Create("rbxassetid://763716870", root, 3,1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 5,0.9)
		CFuncs["Sound"].Create("rbxassetid://782225570", root, 4,0.5)
		CFuncs["Sound"].Create("rbxassetid://763717569", root, 3,1)
		sphere2(5,"Add",root.CFrame,vt(1,1,1),1,1,1,MAINRUINCOLOR)
		sphere2(5,"Add",root.CFrame,vt(1,1,1),0.5,0.5,0.5,MAINRUINCOLOR)
		for i = 0, 24 do
			slash(math.random(10,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),math.rad(0)),vt(0.01,0.01,0.01),math.random(50,200)/250,BrickColor.new("White"))
		end
		for i = 0,4,0.1 do
			swait()
			root.CFrame = root.CFrame + root.CFrame.lookVector*5
			local dis = CreateParta(char,0.25,1,"Neon",MAINRUINCOLOR)
			CreateMesh(dis,"Sphere",1,1,1)
			dis.Anchored = true
			dis.CFrame = larm.CFrame*CFrame.new(0,-3,0)
			sphere2(5,"Add",dis.CFrame,vt(1,1,1),0.1,0.1,0.1,dis.BrickColor,dis.Color)
			coroutine.resume(coroutine.create(function()
				swait(30)
				dis.Transparency = 1
				coroutine.resume(coroutine.create(function()
					for i = 0, 19 do
						swait()
						hum.CameraOffset = vt(math.random(-10,10)/40,math.random(-10,10)/40,math.random(-10,10)/40)
					end
					hum.CameraOffset = vt(0,0,0)
				end))
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",dis)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(dis.Color)
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(0.5,2)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(50,450)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					wait(0.125)
					eff.Enabled = false
				end))
				MagniDamage(dis, 30, 45,50, 0, "Normal")
				for i = 0, 2 do
					slash(math.random(10,80)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(50,150)/250,dis.BrickColor)
				end
				CFuncs["Sound"].Create("rbxassetid://782353117", dis, 1,1)
				CFuncs["Sound"].Create("rbxassetid://1666361078", dis, 1,1.5)
				CFuncs["Sound"].Create("rbxassetid://782353443", dis, 2,1.65)
				sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.4,0.4,0.4,dis.BrickColor,dis.Color)
			end))
			game:GetService("Debris"):AddItem(dis, 5)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(89),math.rad(-8),math.rad(-5)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-30),math.rad(0),math.rad(8)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-14), math.rad(1), math.rad(17)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.85, 0) * angles(math.rad(180), math.rad(0), math.rad(-8)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-8),math.rad(0),math.rad(-20)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(9),math.rad(0),math.rad(20)),.5)
		end
		attack = false
	end
	----------------------------------- Abilities

	function ExtinctiveHeartbreak()
		local targetted = nil
		if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			targetted = mouse.Target.Parent
		end
		if targetted ~= nil then
			attack = true
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			local originalpos = root.CFrame
			RootPart.CFrame = targetted.Head.CFrame * CFrame.new(0,-2,2)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			hum.WalkSpeed = 0
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			local radm = math.random(1,3)
			if radm == 1 then
				bosschatfunc("YOU WONT BE NECCESSARY.",MAINRUINCOLOR.Color,2)
			elseif radm == 2 then
				bosschatfunc("YOUR EXISTANCE WILL BE GONE.",MAINRUINCOLOR.Color,2)
			elseif radm == 3 then
				bosschatfunc("DIE!",MAINRUINCOLOR.Color,2)
			end
			for i = 0,2,0.1 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-10),math.rad(0)),.4)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.4)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(80)),.4)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(10)),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(10)),.4)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(90),math.rad(0),math.rad(60)),.4)
			end
			CFuncs["Sound"].Create("rbxassetid://153092227", root, 0.5,1)
			CFuncs["EchoSound"].Create("rbxassetid://153092227", root, 2, 1,0,10,0.25,0.5,1)
			for i = 0,2,0.1 do
				swait()
				coroutine.resume(coroutine.create(function()
					targetted.Head.CFrame = larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(-90),0,0)
					for i,v in pairs(targetted:GetChildren()) do
						if v:IsA("Part") or v:IsA("MeshPart") then
							v.Velocity = vt(0,0,0)
						end
					end
				end))
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.8)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.8)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(-80)),.8)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(80)),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(10)),.8)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(90),math.rad(0),math.rad(-80)),.8)
			end
			CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 0.5, 1,0,10,0.25,0.5,1)
			CFuncs["EchoSound"].Create("rbxassetid://153092227", char, 0.5, 0.9,0,10,0.25,0.5,1)
			for i = 0, 1 do
				CFuncs["EchoSound"].Create("rbxassetid://159882598", char, 2, 1,0.1,10,0.15,0.5,1)
			end
			CFuncs["EchoSound"].Create("rbxassetid://159882598", root, 15, 1,0.1,10,0.15,0.5,1)
			--chatfunc("RRRRROOAGHH!",Color3.new(1,0,0),"Inverted","Antique",0.75)
			for i = 0,4,0.1 do
				swait()
				coroutine.resume(coroutine.create(function()
					local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
					dis.CFrame = targetted.Head.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
					local at1 = Instance.new("Attachment",dis)
					at1.Position = vt(-25000,0,0)
					local at2 = Instance.new("Attachment",dis)
					at2.Position = vt(25000,0,0)
					local trl = Instance.new('Trail',dis)
					trl.Attachment0 = at1
					trl.FaceCamera = true
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(Color3.new(1,0,0))
					trl.Lifetime = 5
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
					bv.Parent = dis
					game:GetService("Debris"):AddItem(dis, 5)
					targetted.Head.CFrame = larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(-90),0,0)
					CFuncs["Sound"].Create("rbxassetid://782353443", targetted.Head, 4,1)
					CFuncs["Sound"].Create("rbxassetid://824687369", targetted.Head, 6, 1)
					CFuncs["Sound"].Create("rbxassetid://153092227", targetted.Head,6,math.random(75,150)/150)
					CFuncs["Sound"].Create("rbxassetid://163680447", targetted.Head, 3,math.random(75,150)/150)
					CFuncs["Sound"].Create("rbxassetid://782354021", targetted.Head, 2.5,0.75)
					sphere2(5,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,3,3),-0.03,15,-0.03,MAINRUINCOLOR)
					targetted:FindFirstChildOfClass("Humanoid").CameraOffset = vt(math.random(-10,10)/5,math.random(-10,10)/5,math.random(-10,10)/5)
					for i = 0, 2 do
						slash(5,5,true,"Round","Add","Out",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(50,350)/250,BrickColor.new("Crimson"))
					end
					symbolizeBlink(targetted.Head,0,2092248396,Color3.new(1,0,0),math.random(3,35),0,0,0,targetted.Head,true,math.random(3,9),0.25)
					for i,v in pairs(targetted:GetChildren()) do
						if v:IsA("Part") or v:IsA("MeshPart") then
							v.Velocity = vt(0,0,0)
						end
					end
				end))
				hum.CameraOffset = vt(math.random(-10,10)/25,math.random(-10,10)/25,math.random(-10,10)/25)
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.8)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.8)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(-80)),.8)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(80)),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(40)),.8)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(170),math.rad(0),math.rad(-30)),.8)
			end
			hum.CameraOffset = vt(0,0,0)
			for i = 0, 49 do
				local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
				dis.CFrame = targetted.Head.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				local at1 = Instance.new("Attachment",dis)
				at1.Position = vt(-50000,0,0)
				local at2 = Instance.new("Attachment",dis)
				at2.Position = vt(50000,0,0)
				local trl = Instance.new('Trail',dis)
				trl.Attachment0 = at1
				trl.FaceCamera = true
				trl.Attachment1 = at2
				trl.Texture = "rbxassetid://1049219073"
				trl.LightEmission = 1
				trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
				trl.Color = ColorSequence.new(Color3.new(1,0.1,0.1))
				trl.Lifetime = 5
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
				bv.Parent = dis
				game:GetService("Debris"):AddItem(dis, 5)
			end
			for i = 0, 49 do
				sphere2(math.random(10,75)/10,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(5,5,5),-0.05,50,-0.05,MAINRUINCOLOR)
				slash(math.random(10,30)/15,5,true,"Round","Add","Out",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(40,500)/250,BrickColor.new("Really red"))
			end
			CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 2, 0.9,0,10,0.25,0.5,1)
			for i = 0, 1 do
				CFuncs["Sound"].Create("rbxassetid://221920821", targetted.Head, 5,0.9)
				CFuncs["Sound"].Create("rbxassetid://221920821", targetted.Head, 7.5,0.75)
			end
			for i = 0, 4 do
				CFuncs["Sound"].Create("rbxassetid://824687369", targetted.Head, 10, 1)
			end
			symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,1)
			symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,2)
			symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,4)
			dmg(targetted)
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			root.CFrame = originalpos
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			attack = false
			hum.WalkSpeed = storehumanoidWS
		end
	end

	function CorruptionEvent()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://838392947", root, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
		local keptcolor = MAINRUINCOLOR
		for i = 0,4,0.1 do
			swait()
			hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
			block(10,"Add",rleg.CFrame*CFrame.new(0,-1,0),vt(1,1,1),0.01,0.01,0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
			RH.C0=clerp(RH.C0,cf(1,-0.15,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5),math.rad(-20)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,-0.05)*angles(math.rad(-20),math.rad(0),math.rad(10)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-10)),.1)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-5),math.rad(-10),math.rad(20)),.1)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-5),math.rad(10),math.rad(-20)),.1)
		end
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,1)
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,1.5)
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,3)
		CFuncs["Sound"].Create("rbxassetid://1368637781", root, 3,1)
		CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 1.1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", root, 10, 1.1,0,10,0.25,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 1.5, 1.1,0,10,0.25,0.5,1)
		hum.CameraOffset = vt(0,0,0)
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),1,0.01,1,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),2,0.01,2,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		for i = 0, 24 do
			slash(math.random(15,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.new("Really black"))
		end
		local rrot = 0
		coroutine.resume(coroutine.create(function()
			for i = 0, 4 do
				rrot = rrot + 45
				local xa = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xa.Anchored = true
				local xb = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xb.Anchored = true
				local xc = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xc.Anchored = true
				local xd = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xd.Anchored = true
				CFuncs["Sound"].Create("rbxassetid://824687369", xa, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xa, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xa, 3,1)
				CFuncs["Sound"].Create("rbxassetid://824687369", xb, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xb, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xb, 3,1)
				CFuncs["Sound"].Create("rbxassetid://824687369", xc, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xc, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xc, 3,1)
				CFuncs["Sound"].Create("rbxassetid://824687369", xd, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xd, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xd, 3,1)
				xa.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(0,-3,-rrot/1.75)
				xb.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(0,-3,rrot/1.75)
				xc.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(-rrot/1.75,-3,0)
				xd.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(rrot/1.75,-3,0)
				MagniDamage(xa, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				MagniDamage(xb, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				MagniDamage(xc, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				MagniDamage(xd, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				for i = 0, 9 do
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xb.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xc.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xd.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
				end
				block(1.5,"Add",xa.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				block(1.5,"Add",xb.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				block(1.5,"Add",xc.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				block(1.5,"Add",xd.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xc.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xd.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(4,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				sphere2(4,"Add",xb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				sphere2(4,"Add",xc.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				sphere2(4,"Add",xd.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				game:GetService("Debris"):AddItem(xa, 5)
				game:GetService("Debris"):AddItem(xb, 5)
				game:GetService("Debris"):AddItem(xc, 5)
				game:GetService("Debris"):AddItem(xd, 5)
				coroutine.resume(coroutine.create(function()
					for i = 0, 19 do
						swait()
						hum.CameraOffset = vt(math.random(-10,10)/50,math.random(-10,10)/50,math.random(-10,10)/50)
					end
					hum.CameraOffset = vt(0,0,0)
				end))
				swait(9)
			end
		end))
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(10)),.8)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(10)),.8)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,-0.05)*angles(math.rad(10),math.rad(0),math.rad(0)),.8)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(40),math.rad(0),math.rad(0)),.8)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-35),math.rad(-10),math.rad(60)),.8)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-35),math.rad(10),math.rad(-50)),.8)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function EndGROUND()
		attack = true
		hum.WalkSpeed = 0
		bosschatfunc("THIS IS IT!",MAINRUINCOLOR.Color,1)
		--CFuncs["Sound"].Create("rbxassetid://838392947", root, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
		CFuncs["EchoSound"].Create("rbxassetid://1690475123", char, 1.5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1690475123", root, 10, 1,0,10,0.15,0.5,1)
		local keptcolor = MAINRUINCOLOR
		for i = 0,4,0.1 do
			swait()
			hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
			block(10,"Add",rarm.CFrame*CFrame.new(0,-6,0),vt(4,4,4),0.05,0.05,0.05,MAINRUINCOLOR,MAINRUINCOLOR.Color)
			slash(math.random(25,50)/10,5,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-6,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.01,0.1),-0.1,BrickColor.new("Really black"))
			RH.C0=clerp(RH.C0,cf(1,-0.15,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-15),math.rad(-20)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,-0.05)*angles(math.rad(-20),math.rad(0),math.rad(30)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.1)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(170),math.rad(-5),math.rad(10)),.1)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-5),math.rad(10),math.rad(-20)),.1)
		end
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,1)
		CFuncs["Sound"].Create("rbxassetid://1368637781", root, 3,1)
		CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 1.1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", root, 10, 1,0,10,0.25,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 2, 1,0,10,0.25,0.5,1)
		coroutine.resume(coroutine.create(function()
			local shval = 10
			for i = 0, 99 do
				swait()
				shval = shval - 0.1
				hum.CameraOffset = vt(math.random(-shval,shval)/15,math.random(-shval,shval)/15,math.random(-shval,shval)/15)
			end
			hum.CameraOffset = vt(0,0,0)
		end))
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),1,0.01,1,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),2,0.01,2,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		for i = 0, 24 do
			slash(math.random(15,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.new("Really black"))
		end
		local rrot = 0
		local xam = 1
		coroutine.resume(coroutine.create(function()
			for i = 0, 14 do
				--swait()
				rrot = rrot + 40*xam
				xam = xam + 0.25
				local bonus = xam
				local xa = CreateParta(char,0.5,1,"Neon",BrickColor.random())
				xa.Anchored = true
				xa.Color = Color3.new(0,0,0)
				xa.CFrame = root.CFrame*CFrame.new(0,-3,-rrot/1.75)
				CreateMesh(xa,"Sphere",30*bonus,1,30*bonus)
				local xc = 0
				coroutine.resume(coroutine.create(function()
					for i = 0, 99 do
						swait()
						xc = xc + 0.01
						xa.Color = Color3.new(xc,0,0)
					end
					xa.Transparency = 1
					CFuncs["Sound"].Create("rbxassetid://331666100", xa, 5,0.75)
					MagniDamage(xa, 30*bonus, 78*bonus,99*bonus, 0, "Normal")
					for i = 0, 9 do
						slash(math.random(15,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01*bonus,0.01,0.01*bonus),math.random(50,125)/250*bonus,BrickColor.new("Really black"))
					end
					block(1.5,"Add",xa.CFrame*CFrame.new(0,-10,0),vt(30*bonus,30*bonus,30*bonus),0.3,0.3,0.3,keptcolor,keptcolor.Color)
					sphere2(2,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25*bonus,1,25*bonus),0.05*bonus,1.5*bonus,0.05*bonus,keptcolor,keptcolor.Color)
					sphere2(4,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30*bonus,1,30*bonus),0.05*bonus,1.5*bonus,0.05*bonus,BrickColor.new("Really black"),Color3.new(0,0,0))
					game:GetService("Debris"):AddItem(xa, 5)
					coroutine.resume(coroutine.create(function()
						for i = 0, 19 do
							swait()
							hum.CameraOffset = vt(math.random(-10,10)/50,math.random(-10,10)/50,math.random(-10,10)/50)
						end
						hum.CameraOffset = vt(0,0,0)
					end))
				end))
			end
		end))
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-25),math.rad(30)),.8)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.8)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,-0.5)*angles(math.rad(30),math.rad(0),math.rad(50)),.8)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-50)),.8)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(35),math.rad(-10),math.rad(30)),.8)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-35),math.rad(10),math.rad(-50)),.8)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function HeavenlyDisk()
		attack = true
		hum.WalkSpeed = 2
		local keptcolor = MAINRUINCOLOR
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Dont make this too easy for you.",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("Heavenly Disks!",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("Take it!",MAINRUINCOLOR.Color,1)
		end
		CFuncs["Sound"].Create("rbxassetid://847061203", root, 2, 1)
		CFuncs["EchoSound"].Create("rbxassetid://1625448638", char, 4, 1,0,10,0.15,0.5,1)
		sphere2(5,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.1,0.1,0.1,keptcolor,keptcolor.Color)
		sphere2(5,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.2,0.2,0.2,keptcolor,keptcolor.Color)
		for i = 0, 14 do
			PixelBlock(1,math.random(1,3),"Add",larm.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,BrickColor.new("Toothpaste"),0)
		end
		for i = 0,2,0.1 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.3)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.3)
		end
		CFuncs["Sound"].Create("rbxassetid://763755889", root, 2.5,1.1)
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(180)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(270)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		local rot = 15
		for i = 0, 2 do
			local dis = CreateParta(char,0.5,1,"Neon",BrickColor.new("Toothpaste"))
			CFuncs["EchoSound"].Create("rbxassetid://763718160", dis, 3, 1.1,0,10,0.15,0.5,1)
			dis.CFrame = root.CFrame*CFrame.new(0,2,-3)
			CreateMesh(dis,"Sphere",10,1,10)
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-5,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(5,0,0)
			local trl = Instance.new('Trail',wed)
			trl.Attachment0 = at1
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 0.6
			local a = Instance.new("Part",workspace)
			a.Name = "Direction"	
			a.Anchored = true
			a.BrickColor = bc("Bright red")
			a.Material = "Neon"
			a.Transparency = 1
			a.CanCollide = false
			local ray = Ray.new(
				dis.CFrame.p,                           -- origin
				(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
			) 
			local ignore = dis
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			local distance = (dis.CFrame.p - position).magnitude
			a.Size = Vector3.new(0.1, 0.1, 0.1)
			a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
			dis.CFrame = a.CFrame
			dis.CFrame = dis.CFrame*CFrame.Angles(0,math.rad(rot),0)
			a:Destroy()
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*250
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 5)
			local hitted = false
			coroutine.resume(coroutine.create(function()
				dis.Touched:connect(function(hit) 
					if hitted == false and hit.Parent ~= char then
						hitted = true
						CFuncs["EchoSound"].Create("rbxassetid://782200047", dis, 7, 1.1,0,10,0.15,0.5,1)
						MagniDamage(dis, 30, 82,34575, 0, "Normal")
						sphere2(8,"Add",dis.CFrame,vt(10,1,10),1,0.1,1,keptcolor,keptcolor.Color)
						sphere2(4,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,keptcolor,keptcolor.Color)
						sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,BrickColor.new("White"),Color3.new(1,1,1))
						coroutine.resume(coroutine.create(function()
							for i = 0, 9 do
								local disr = CreateParta(char,1,1,"Neon",keptcolor)
								disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
								local at1 = Instance.new("Attachment",disr)
								at1.Position = vt(-2,0,0)
								local at2 = Instance.new("Attachment",disr)
								at2.Position = vt(2,0,0)
								local trl = Instance.new('Trail',disr)
								trl.Attachment0 = at1
								trl.FaceCamera = true
								trl.Attachment1 = at2
								trl.Texture = "rbxassetid://2342682798"
								trl.LightEmission = 1
								trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
								trl.Color = ColorSequence.new(Color3.new(0.3,1,1))
								trl.Lifetime = 0.5
								local bv = Instance.new("BodyVelocity")
								bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
								bv.velocity = disr.CFrame.lookVector*math.random(50,200)
								bv.Parent = disr
								local val = 0
								coroutine.resume(coroutine.create(function()
									swait(30)
									for i = 0, 9 do
										swait()
										val = val + 0.1
										trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
									end
									game:GetService("Debris"):AddItem(disr, 3)
								end))
							end
							local eff = Instance.new("ParticleEmitter",dis)
							eff.Texture = "rbxassetid://2273224484"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(Color3.new(0.3,1,1))
							eff.Rate = 500000
							eff.Lifetime = NumberRange.new(0.5,2)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(20,250)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.VelocitySpread = 9000
							eff.RotSpeed = NumberRange.new(-50,50)
							wait(0.25)
							eff.Enabled = false
						end))
						for i = 0, 9 do
							slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(100,200)/250,BrickColor.new("White"))
						end
						for i = 0, 19 do
							PixelBlock(1,math.random(5,20),"Add",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),4,4,4,0.08,BrickColor.new("Toothpaste"),0)
						end
						coroutine.resume(coroutine.create(function()
							for i = 0, 19 do
								swait()
								hum.CameraOffset = vt(math.random(-10,10)/70,math.random(-10,10)/70,math.random(-10,10)/70)
							end
							hum.CameraOffset = vt(0,0,0)
						end))
						dis.Anchored = true
						dis.Transparency = 1
						wait(8)
						dis:Destroy()
					end
				end)
			end))
			rot = rot - 15
		end
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-30),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(5)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(-50)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function FuckMeSidewaysAndCallMeGay()
		local whom = (mouse.Target and mouse.Target.Parent)
	--[[local fuckThisBoi = false
	if(whom and whom:FindFirstChildOfClass'Humanoid')then
		for _,v in next, ODers do
			if(v == whom)then
				fuckThisBoi = false
			end
		end
	end
	if(not fuckThisBoi)then
		attack = false
		warn'to fuck that boi you need to target them with z'
	else]]
		if(whom and whom:FindFirstChildOfClass'Humanoid' and whom:FindFirstChild'Torso' or whom:FindFirstChild'UpperTorso')then
			local hed = whom:FindFirstChild'Torso' or whom:FindFirstChild'UpperTorso'
			local hum = whom:FindFirstChildOfClass'Humanoid'
			local ocf = RootPart.CFrame
			hum.WalkSpeed = 0 

			hed.Anchored = true
			RootPart.Anchored = true
			RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Pink"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Pink"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Pink"))
			attack = true
			bosschatfunc("I love you <3",MAINRUINCOLOR.Color,1)
			local speed = 1
			local heck;
			local stopitlol = false;
			heck = mouse.KeyUp:connect(function(k)
				if(k:lower() == 'x')then
					stopitlol = true
					heck:disconnect()
				end
			end)
			local times = 0
			repeat swait()
				speed = speed - .01
				times = times + 1
				if(speed < .1)then
					speed = .1
				end
				for i = 0, speed, .05 do
					RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
					swait()
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(50),0,0)*angles(0,math.rad(90),0),.4)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(50),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
					RootJoint.C0=clerp(RootJoint.C0,cf(0,-.1,0)*angles(math.rad(-25),0,0)*RootCF,.4)	
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.8)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(75),0,0),.4)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(75),0,0),.4)
				end
				CameraEnshaking(5,5)

				CFuncs["Sound"].Create("rbxassetid://836796971", Torso, 10,1)	

				for i = 0, speed, .05 do
					RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
					swait()
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-50),0,0)*angles(0,math.rad(90),0),.4)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(-50),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
					RootJoint.C0=clerp(RootJoint.C0,cf(0,-.1,0)*angles(math.rad(25),0,0)*RootCF,.4)	
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.8)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
				end
			until stopitlol and times >= 3
			for i = 1, 3 do
				for i = 0, 1.5, .05 do
					RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
					swait()
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(50),0,0)*angles(0,math.rad(90),0),.4)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(50),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
					RootJoint.C0=clerp(RootJoint.C0,cf(0,-.1,0)*angles(math.rad(-25),0,0)*RootCF,.4)	
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.8)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(75),0,0),.4)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(75),0,0),.4)
				end
				CameraEnshaking(5,25)

				CFuncs["Sound"].Create("rbxassetid://1430568042", Torso, 10,.75)


				coroutine.resume(coroutine.create(function()
					bld = Instance.new("ParticleEmitter",whom:WaitForChild("Torso"))
					bld.LightEmission = 0.1
					bld.Texture = "rbxassetid://284205403"
					bld.Color = ColorSequence.new(Color3.new(1,1,1))
					bld.Rate = 500
					bld.Lifetime = NumberRange.new(1)
					bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
					bld.Acceleration = vt(0,-25,0)
					bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
					bld.Speed = NumberRange.new(10,50)
					bld.EmissionDirection = "Back"
					bld.VelocitySpread = 25
					bld.Rotation = NumberRange.new(-500,500)
					bld.RotSpeed = NumberRange.new(-500,500)
					bld.Enabled = false
					bld:Emit(250)
				end))
				coroutine.resume(coroutine.create(function()
					bld = Instance.new("ParticleEmitter",whom:WaitForChild("LowerTorso"))
					bld.LightEmission = 0.1
					bld.Texture = "rbxassetid://284205403"
					bld.Color = ColorSequence.new(Color3.new(1,1,1))
					bld.Rate = 500
					bld.Lifetime = NumberRange.new(1)
					bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
					bld.Acceleration = vt(0,-25,0)
					bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
					bld.Speed = NumberRange.new(10,50)
					bld.EmissionDirection = "Back"
					bld.VelocitySpread = 25
					bld.Rotation = NumberRange.new(-500,500)
					bld.RotSpeed = NumberRange.new(-500,500)
					bld.Enabled = false
					bld:Emit(250)
				end))
				for i = 0, 1.5, .05 do
					RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
					swait()
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-50),0,0)*angles(0,math.rad(90),0),.4)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(-50),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
					RootJoint.C0=clerp(RootJoint.C0,cf(0,-.1,0)*angles(math.rad(25),0,0)*RootCF,.4)	
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.8)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
				end
			end
			for i = 0, 4, .05 do
				RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(100),0,0)*angles(0,math.rad(90),0),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(100),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.1)
				RootJoint.C0=clerp(RootJoint.C0,cf(0,-.75,0)*angles(math.rad(-50),0,0)*RootCF,.1)	
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.1)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(75),0,0),.1)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(75),0,0),.1)
			end
			CameraEnshaking(5,25)
			CFuncs["Sound"].Create("rbxassetid://429400881", hed, 3,1)
			CFuncs["Sound"].Create("rbxassetid://1430568042", Torso, 10,.75)

			dmg(whom)
			coroutine.resume(coroutine.create(function()
				bld = Instance.new("ParticleEmitter",whom:WaitForChild("Torso"))
				bld.LightEmission = 0.1
				bld.Texture = "rbxassetid://284205403"
				bld.Color = ColorSequence.new(Color3.new(1,1,1))
				bld.Rate = 500
				bld.Lifetime = NumberRange.new(1)
				bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Acceleration = vt(0,-25,0)
				bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Speed = NumberRange.new(10,50)
				bld.EmissionDirection = "Back"
				bld.VelocitySpread = 25
				bld.Rotation = NumberRange.new(-500,500)
				bld.RotSpeed = NumberRange.new(-500,500)
				bld.Enabled = true
			end))
			coroutine.resume(coroutine.create(function()
				bld = Instance.new("ParticleEmitter",whom:WaitForChild("LowerTorso"))
				bld.LightEmission = 0.1
				bld.Texture = "rbxassetid://284205403"
				bld.Color = ColorSequence.new(Color3.new(1,1,1))
				bld.Rate = 500
				bld.Lifetime = NumberRange.new(1)
				bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Acceleration = vt(0,-25,0)
				bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
				bld.Speed = NumberRange.new(10,50)
				bld.EmissionDirection = "Back"
				bld.VelocitySpread = 25
				bld.Rotation = NumberRange.new(-500,500)
				bld.RotSpeed = NumberRange.new(-500,500)
				bld.Enabled = true
			end))
			for i = 0, 3, .05 do
				RootPart.CFrame = hed.CFrame*cf(0,0,1.35)
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-100),0,0)*angles(0,math.rad(90),0),.4)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(-100),0,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
				RootJoint.C0=clerp(RootJoint.C0,cf(0,-.75,0)*angles(math.rad(50),0,0)*RootCF,.4)	
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,0),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-75),0,0),.4)
			end

			RootPart.CFrame = ocf
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Pink"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Pink"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Pink"))
			RootPart.Anchored = false
			Humanoid.WalkSpeed = storehumanoidWS
			bosschatfunc("Hehehehehe <3",MAINRUINCOLOR.Color,0.5)
			attack = false
		end
	end

	function RapidBurst()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://1368598393", char, 2.5, 0.5)
		CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 0.5)
		CFuncs["EchoSound"].Create("rbxassetid://1718412034", char, 4, 1,0,10,0.15,0.5,1)
		bosschatfunc("SHATTER!",MAINRUINCOLOR.Color,1.8)
		bosschatfunc("SHATTER!",MAINRUINCOLOR.Color,1.9)
		bosschatfunc("SHATTER!",MAINRUINCOLOR.Color,2)
		local keptcolor = MAINRUINCOLOR
		for i = 0,8,0.1 do
			swait()
			hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
			slash(math.random(25,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,25,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(2,0.01,2),-2,BrickColor.random())
			block(10,"Add",root.CFrame*CFrame.new(0,25,0),vt(0,0,0),0.5,0.5,0.5,BrickColor.random(),BrickColor.random().Color)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-15 - 2 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 2 * math.cos(sine / 32))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.15 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(-15 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-25 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
			RW.C0=clerp(RW.C0,cf(1.35,1 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-10 + 3 * math.cos(sine / 45))),.1)
			LW.C0=clerp(LW.C0,cf(-1.35,1 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(13 - 3 * math.cos(sine / 45))),.1)
		end
		for i = 0, 99 do
			local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
			dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-25000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(25000,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.FaceCamera = true
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(BrickColor.random().Color)
			trl.Lifetime = 5
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 5)
		end
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,125,0,0,0,root,false,0,1)
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,125,0,0,0,root,false,0,1.5)
		symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,125,0,0,0,root,false,0,3)
		sphere2(2,"Add",root.CFrame,vt(1,1,1),1,1,1,BrickColor.random(),BrickColor.random().Color)
		sphere2(2,"Add",root.CFrame,vt(1,1,1),2,2,2,BrickColor.random(),BrickColor.random().Color)
		sphere2(2,"Add",root.CFrame,vt(1,1,1),4,4,4,BrickColor.random(),BrickColor.random().Color)
		sphere2(2,"Add",root.CFrame,vt(1,1,1),8,8,8,BrickColor.random(),BrickColor.random().Color)
		CFuncs["Sound"].Create("rbxassetid://1841058541", root, 10,1)
		CFuncs["Sound"].Create("rbxassetid://2095993595", char, 5,0.8)
		CFuncs["Sound"].Create("rbxassetid://1841058541", char, 5,1)
		hum.CameraOffset = vt(0,0,0)
		for i = 0, 24 do
			slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(500,1500)/250,BrickColor.random())
		end
		local distam = 0
		coroutine.resume(coroutine.create(function()
			for i = 0, 99 do
				wait()
				distam = distam + 1
				local xa = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xa.Anchored = true
				xa.CFrame = root.CFrame*CFrame.new(math.random(-distam,distam),math.random(-distam,distam),math.random(-distam,distam))
				game:GetService("Debris"):AddItem(xa, 5)
				for i = 0, 4 do
					slash(math.random(25,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.random())
				end
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",xa)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(BrickColor.random().Color)
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(1,3)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,30,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(50,500)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					wait(0.25)
					eff.Enabled = false
				end))
				coroutine.resume(coroutine.create(function()
					for i = 0, 19 do
						swait()
						hum.CameraOffset = vt(math.random(-10,10)/10,math.random(-10,10)/10,math.random(-10,10)/10)
					end
					hum.CameraOffset = vt(0,0,0)
				end))
				CFuncs["Sound"].Create("rbxassetid://675172759", xa, 7,math.random(100,200)/200)
				sphere2(5,"Add",xa.CFrame,vt(1,1,1),1,1,1,BrickColor.random(),BrickColor.random().Color)
				sphere2(5,"Add",xa.CFrame,vt(1,1,1),2,2,2,BrickColor.random(),BrickColor.random().Color)
				MagniDamage(xa, 60, 9999,99999, 0, "Normal")
			end
		end))
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end


	function FallenOrbs()
		attack = true
		hum.WalkSpeed = 2
		local keptcolor = MAINRUINCOLOR
		CFuncs["EchoSound"].Create("rbxassetid://1448033299", char, 5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1448033299", root, 60, 1,0,10,0.15,0.5,1)
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("This wont be easy to you.",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("How about this?",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("Swarm!",MAINRUINCOLOR.Color,1)
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 29 do
				swait(2)
				local dis = CreateParta(char,0.5,1,"Neon",MAINRUINCOLOR)
				dis.Anchored = true
				CFuncs["Sound"].Create("rbxassetid://137463716", dis, 2.5,1.5)
				dis.CFrame = root.CFrame*CFrame.new(math.random(-35,35),math.random(5,35),math.random(-35,35))
				CreateMesh(dis,"Sphere",2,2,2)
				sphere2(5,"Add",dis.CFrame,vt(1,1,1),0.1,0.1,0.1,keptcolor,keptcolor.Color)
				slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(10,50)/250,BrickColor.new("White"))
				coroutine.resume(coroutine.create(function()
					wait(0.5)
					dis.Anchored = false
					CFuncs["EchoSound"].Create("rbxassetid://1602800656", dis, 9, 1,0,2,0.15,0.1,1)
					local at1 = Instance.new("Attachment",dis)
					at1.Position = vt(-1,0,0)
					local at2 = Instance.new("Attachment",dis)
					at2.Position = vt(1,0,0)
					local trl = Instance.new('Trail',dis)
					trl.Attachment0 = at1
					trl.FaceCamera = true
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(dis.Color)
					trl.Lifetime = 0.6
					local a = Instance.new("Part",workspace)
					a.Name = "Direction"	
					a.Anchored = true
					a.BrickColor = bc("Bright red")
					a.Material = "Neon"
					a.Transparency = 1
					a.CanCollide = false
					local ray = Ray.new(
						dis.CFrame.p,                           -- origin
						(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
					) 
					local ignore = dis
					local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
					a.BottomSurface = 10
					a.TopSurface = 10
					local distance = (dis.CFrame.p - position).magnitude
					a.Size = Vector3.new(0.1, 0.1, 0.1)
					a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
					dis.CFrame = a.CFrame
					a:Destroy()
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = dis.CFrame.lookVector*500
					bv.Parent = dis
					game:GetService("Debris"):AddItem(dis, 5)
					local hitted = false
					coroutine.resume(coroutine.create(function()
						dis.Touched:connect(function(hit) 
							if hitted == false and hit.Parent ~= char then
								hitted = true
								CFuncs["EchoSound"].Create("rbxassetid://675172759", dis, 5, 0.8,0,10,0.15,0.5,1)
								MagniDamage(dis, 60, 25456,124672, 0, "Normal")
								sphere2(1,"Add",dis.CFrame,vt(1,1,1),1,1,1,keptcolor,keptcolor.Color)
								sphere2(8,"Add",dis.CFrame,vt(1,1,1),1.25,1.25,1.25,BrickColor.new("White"),Color3.new(1,1,1))
								coroutine.resume(coroutine.create(function()
									for i = 0, 4 do
										local disr = CreateParta(char,1,1,"Neon",keptcolor)
										disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
										local at1 = Instance.new("Attachment",disr)
										at1.Position = vt(-10,0,0)
										local at2 = Instance.new("Attachment",disr)
										at2.Position = vt(10,0,0)
										local trl = Instance.new('Trail',disr)
										trl.Attachment0 = at1
										trl.FaceCamera = true
										trl.Attachment1 = at2
										trl.Texture = "rbxassetid://2342682798"
										trl.LightEmission = 1
										trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
										trl.Color = ColorSequence.new(disr.Color)
										trl.Lifetime = 0.5
										local bv = Instance.new("BodyVelocity")
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
										bv.velocity = disr.CFrame.lookVector*math.random(125,250)
										bv.Parent = disr
										local val = 0
										coroutine.resume(coroutine.create(function()
											swait(30)
											for i = 0, 9 do
												swait()
												val = val + 0.1
												trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
											end
											game:GetService("Debris"):AddItem(disr, 3)
										end))
									end
									local eff = Instance.new("ParticleEmitter",dis)
									eff.Texture = "rbxassetid://1049219073"
									eff.LightEmission = 1
									eff.Color = ColorSequence.new(dis.Color)
									eff.Rate = 500000
									eff.Lifetime = NumberRange.new(0.5,2)
									eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
									eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
									eff.Speed = NumberRange.new(20,250)
									eff.Drag = 5
									eff.Rotation = NumberRange.new(-500,500)
									eff.VelocitySpread = 9000
									eff.RotSpeed = NumberRange.new(-50,50)
									wait(0.5)
									eff.Enabled = false
								end))
								for i = 0, 4 do
									slash(math.random(20,50)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,200)/250,BrickColor.new("White"))
								end
								coroutine.resume(coroutine.create(function()
									for i = 0, 19 do
										swait()
										hum.CameraOffset = vt(math.random(-10,10)/70,math.random(-10,10)/70,math.random(-10,10)/70)
									end
									hum.CameraOffset = vt(0,0,0)
								end))
								dis.Anchored = true
								dis.Transparency = 1
								wait(8)
								dis:Destroy()
							end
						end)
					end))
				end))
			end
		end))
		for i = 0,9,0.1 do
			swait()
			sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(90)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(-15 + 1 * math.cos(sine / 58)),math.rad(-90 + 2 * math.cos(sine / 53))),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(90 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(90 + 2 * math.cos(sine / 45))),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(8 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-9 - 4 * math.cos(sine / 45))),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function CyberSlash()
		local posit = -2
		attack = true
		hum.WalkSpeed = 5
		CFuncs["EchoSound"].Create("rbxassetid://1448033920", char, 5, 1,0,10,0.15,0.5,1)
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("FIBER!!!",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("SLASHED!!",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("TAKE MY CLAW!!",MAINRUINCOLOR.Color,1)
		end
		CFuncs["Sound"].Create("rbxassetid://169380495", sorb2, 1, 1)
		for i = 0,2,0.1 do
			swait()
			sphere2(7,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.075,-0.01,MAINRUINCOLOR)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,1)* angles(math.rad(0),math.rad(0),math.rad(30)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(-30)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(20)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(45), math.rad(6), math.rad(-30)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(8 - 6 * math.cos(sine / 67)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-18 - 5 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15 - 8 * math.cos(sine / 74)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(31 + 8 * math.cos(sine / 38))),.1)
		end
		for i = 0, 2 do
			CameraEnshaking(1,2)
			local hite = Instance.new("Part", char)
			hite.Anchored = true
			hite.CanCollide = false
			hite.FormFactor = 3
			hite.Name = "Ring"
			hite.Material = "Neon"
			hite.Size = Vector3.new(1, 1, 1)
			hite.Transparency = 1
			hite.TopSurface = 0
			hite.BottomSurface = 0
			hite.CFrame = root.CFrame*CFrame.new(0,posit,-5)
			CFuncs["Sound"].Create("rbxassetid://231917856", hite, 0.5, 0.9)
			CFuncs["Sound"].Create("rbxassetid://231917758", hite, 0.25, 0.8)
			coroutine.resume(coroutine.create(function()
				for i = 0, 1 do
					swait()
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MAINRUINCOLOR)
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MAINRUINCOLOR)
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MAINRUINCOLOR)
				end
			end))
			sphere2(6,"Add",hite.CFrame*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),vt(2,2,2),0.5,-0.01,-0.01,MAINRUINCOLOR)
			MagniDamage(hite, 3, 30,40, 0, "Normal")
			game:GetService("Debris"):AddItem(hite, 5)
			posit = posit + 2
		end
		for i = 0,1,0.1 do
			swait()
			sphere2(7,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.075,-0.01,MAINRUINCOLOR)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,1)* angles(math.rad(0),math.rad(0),math.rad(-80)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(80)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(20)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(110), math.rad(6), math.rad(40)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(-20),math.rad(0)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(0)),.5)
		end
		for i = 0,1,0.1 do
			swait()
			sphere2(7,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.075,-0.01,MAINRUINCOLOR)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,-0.2,1)* angles(math.rad(20),math.rad(0),math.rad(60)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-60)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(60)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(60), math.rad(6), math.rad(-50)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(-20),math.rad(30)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(40)),.5)
		end
		posit = -6
		for i = 0, 6 do
			CameraEnshaking(1,3)
			local hite = Instance.new("Part", char)
			hite.Anchored = true
			hite.CanCollide = false
			hite.FormFactor = 3
			hite.Name = "Ring"
			hite.Material = "Neon"
			hite.Size = Vector3.new(1, 1, 1)
			hite.Transparency = 1
			hite.TopSurface = 0
			hite.BottomSurface = 0
			hite.CFrame = root.CFrame*CFrame.new(posit,0,-5)
			CFuncs["Sound"].Create("rbxassetid://231917856", hite, 0.5, 1.2)
			CFuncs["Sound"].Create("rbxassetid://231917758", hite, 0.25, 1)
			sphere2(6,"Add",hite.CFrame*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),vt(1,1,1),-0.01,1,-0.01,MAINRUINCOLOR)
			coroutine.resume(coroutine.create(function()
				for i = 0, 2 do
					swait()
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MAINRUINCOLOR)
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MAINRUINCOLOR)
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MAINRUINCOLOR)
				end
			end))
			MagniDamage(hite, 5, 40,70, 0, "Normal")
			game:GetService("Debris"):AddItem(hite, 5)
			posit = posit + 2
		end
		for i = 0,1,0.1 do
			swait()
			sphere2(7,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.075,-0.01,MAINRUINCOLOR)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0.1,1.5)* angles(math.rad(-10),math.rad(0),math.rad(-60)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(50)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(30)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(140), math.rad(6), math.rad(-50)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(10),math.rad(-10)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(60)),.5)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function EquinoxOrbs()
		hum.WalkSpeed = 0
		attack = true
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("NOX-DASH!!!",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("Beware from behind",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("I'M COMING!!",MAINRUINCOLOR.Color,1)
		end
		for i = 0,1,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5)*angles(math.rad(90),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(5),math.rad(40)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-5),math.rad(-40)),.3)
		end
		sphere2(5,"Add",root.CFrame,vt(1,1,1),1.5,1.5,1.5,MAINRUINCOLOR)
		sphere2(5,"Add",root.CFrame,vt(1,1,1),1,1,1,MAINRUINCOLOR)
		for i = 0, 24 do
			slash(math.random(10,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),math.rad(0)),vt(0.01,0.01,0.01),math.random(100,400)/250,BrickColor.new("White"))
		end
		CFuncs["Sound"].Create("rbxassetid://763716870", root, 8,1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 10,0.8)
		CFuncs["Sound"].Create("rbxassetid://782225570", root, 9,0.5)
		CFuncs["Sound"].Create("rbxassetid://763717569", root, 8,0.9)
		for i = 0,4,0.1 do
			swait()
			root.CFrame = root.CFrame + root.CFrame.lookVector*7.5
			local dis = CreateParta(char,0.25,1,"Neon",MAINRUINCOLOR)
			CreateMesh(dis,"Sphere",1,1,1)
			dis.Anchored = true
			dis.CFrame = larm.CFrame*CFrame.new(0,-3,0)
			local dis2 = CreateParta(char,0.25,1,"Neon",BrickColor.new("Really black"))
			CreateMesh(dis2,"Sphere",1,1,1)
			dis2.Anchored = true
			dis2.CFrame = rarm.CFrame*CFrame.new(0,-3,0)
			sphere2(5,"Add",dis.CFrame,vt(1,1,1),0.1,0.1,0.1,dis.BrickColor,dis.Color)
			sphere2(5,"Add",dis2.CFrame,vt(1,1,1),0.1,0.1,0.1,dis2.BrickColor,dis2.Color)
			coroutine.resume(coroutine.create(function()
				swait(60)
				dis.Transparency = 1
				dis2.Transparency = 1
				coroutine.resume(coroutine.create(function()
					for i = 0, 19 do
						swait()
						hum.CameraOffset = vt(math.random(-10,10)/40,math.random(-10,10)/40,math.random(-10,10)/40)
					end
					hum.CameraOffset = vt(0,0,0)
				end))
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",dis)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(dis.Color)
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(0.5,2)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(50,450)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					local eff2 = eff:Clone()
					eff2.Parent = dis2
					eff2.LightEmission = 0
					eff2.Color = ColorSequence.new(dis2.Color)
					wait(0.25)
					eff.Enabled = false
					eff2.Enabled = false
				end))
				MagniDamage(dis, 55, 89,219788936, 0, "Normal")
				MagniDamage(dis2, 55, 89,219788936, 0, "Normal")
				for i = 0, 2 do
					slash(math.random(10,80)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,300)/250,dis.BrickColor)
					slash(math.random(10,80)/10,5,true,"Round","Add","Out",dis2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,300)/250,dis2.BrickColor)
				end
				CFuncs["Sound"].Create("rbxassetid://782353117", dis, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://782353117", dis2, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://1666361078", dis, 1,1.25)
				CFuncs["Sound"].Create("rbxassetid://1666361078", dis2, 1,1.25)
				CFuncs["Sound"].Create("rbxassetid://782353443", dis, 2,1.15)
				CFuncs["Sound"].Create("rbxassetid://782353443", dis2, 2,1.15)
				sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.8,0.8,0.8,dis.BrickColor,dis.Color)
				sphere2(3,"Add",dis2.CFrame,vt(1,1,1),0.8,0.8,0.8,dis2.BrickColor,dis2.Color)
			end))
			game:GetService("Debris"):AddItem(dis, 5)
			game:GetService("Debris"):AddItem(dis2, 5)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5)*angles(math.rad(90),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.4,1.5,0)*angles(math.rad(0),math.rad(5),math.rad(210)),.1)
			LW.C0=clerp(LW.C0,cf(-1.4,1.5,0)*angles(math.rad(0),math.rad(-5),math.rad(-210)),.1)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end
	function FallenDEMISE()
		attack = true
		hum.WalkSpeed = 0
		local keptcolor = MAINRUINCOLOR
		bosschatfunc("ALL OF YOUR EXISTANCE WILL BE GONE.",MAINRUINCOLOR.Color,3)
		CFuncs["Sound"].Create("rbxassetid://289315275", char, 2.5,0.75)
		CFuncs["Sound"].Create("rbxassetid://136007472", char, 2,0.5)
		for i = 0, 15, 0.1 do
			swait()
			local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
			dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-25000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(25000,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.FaceCamera = true
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 5
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 1)
			sphere2(15,"Add",root.CFrame,vt(8,8,8),2,2,2,MAINRUINCOLOR)
			slash(math.random(30,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(1,0.01,1),math.random(100,500)/250,BrickColor.new("Toothpaste"))
			slash(math.random(30,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(1,0.01,1),math.random(100,500)/250,BrickColor.new("Deep orange"))
			RH.C0=clerp(RH.C0,cf(1,-0.35,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-35)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.45,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(35)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(92),math.rad(0),math.rad(-67)),.1)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(68)),.1)
		end
		CFuncs["Sound"].Create("rbxassetid://294188875", char, 10,1)
		for i = 0, 30, 0.1 do
			swait()
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(FindNearestHead(root.CFrame.p, 10000000)) do
					if v:FindFirstChild('Head') then
						dmg(v)
					end
				end
			end))
			local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
			dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-50000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(50000,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.FaceCamera = true
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 10
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(1500,10000)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, math.random(1,4))
			sphere2(15,"Add",root.CFrame,vt(8,80000,8),5,1,5,MAINRUINCOLOR)
			sphere2(15,"Add",root.CFrame,vt(8,8,8),8,8,8,MAINRUINCOLOR)
			sphere2(2,"Add",root.CFrame*CFrame.new(math.random(-2000,2000),math.random(-2000,2000),math.random(-2000,2000)),vt(0,0,0),5,5,5,BrickColor.new("Deep orange"))
			sphere2(2,"Add",root.CFrame*CFrame.new(math.random(-2000,2000),math.random(-2000,2000),math.random(-2000,2000)),vt(0,0,0),5,5,5,BrickColor.new("Toothpaste"))
			slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(5,0.01,5),math.random(500,5000)/250,BrickColor.new("Deep orange"))
			slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(5,0.01,5),math.random(500,5000)/250,BrickColor.new("Toothpaste"))
			for i = 0, 2 do
				slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,math.random(-3,1000),0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(2,0.01,2),math.random(250,750)/250,MAINRUINCOLOR)
			end
			RH.C0=clerp(RH.C0,cf(1,-0.35,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-35)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.45,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(35)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(92),math.rad(0),math.rad(-67)),.1)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(68)),.1)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function SpeedDrop()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://1208650519", tors, 5, 1)
		local poste = 3
		local rotation = 0
		local rate = 0
		bosschatfunc("AUFHHIGYBIBYHHIHIGHGI",MAINRUINCOLOR.Color,2)
		for i = 0, 124 do
			swait()
			rotation = rotation + rate
			poste = poste + 0.1
			rate = rate + 0.1
			sphere2(8,"Add",root.CFrame*CFrame.new(0,-3,0),vt(poste,1,poste),0.05*poste/3,0,0.05*poste/3,MAINRUINCOLOR)
			sphere2(8,"Add",root.CFrame*CFrame.new(math.random(-20,20),-3,math.random(-20,20)),vt(1,1,1),-0.01,0.5,-0.01,MAINRUINCOLOR)
			sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-3,poste)*CFrame.Angles(math.rad(40),0,0),vt(1,1,1),0.025,0.25,0.025,MAINRUINCOLOR)
			sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(90 + rotation),0)*CFrame.new(0,-3,poste)*CFrame.Angles(math.rad(40),0,0),vt(1,1,1),0.025,0.25,0.025,MAINRUINCOLOR)
			sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(180 + rotation),0)*CFrame.new(0,-3,poste)*CFrame.Angles(math.rad(40),0,0),vt(1,1,1),0.025,0.25,0.025,MAINRUINCOLOR)
			sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(270 + rotation),0)*CFrame.new(0,-3,poste)*CFrame.Angles(math.rad(40),0,0),vt(1,1,1),0.025,0.25,0.025,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-0.35,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-20),math.rad(30)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.5)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.75)*angles(math.rad(30),math.rad(0),math.rad(20)),.5)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(-20)),.5)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(40),math.rad(-8),math.rad(-10)),.5)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-30)),.5)
		end
		CameraEnshaking(3,7)
		bosschatfunc("AN ERROR HAS OCCURED",MAINRUINCOLOR.Color,2)
		local loc = Instance.new("Part", char)
		loc.BrickColor = MAINRUINCOLOR
		loc.CanCollide = false
		loc.FormFactor = 3
		loc.Name = "Ring"
		loc.Material = "Neon"
		loc.Size = Vector3.new(1, 1, 1)
		loc.Transparency = 1
		loc.TopSurface = 0
		loc.BottomSurface = 0
		loc.Anchored = true
		loc.CFrame = root.CFrame + root.CFrame.lookVector*100
		CFuncs["Sound"].Create("rbxassetid://782353443", loc, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://1177785010", loc, 6, 1)
		MagniDamage(loc, 95, 500,6000, 0, "Normal")
		sphere2(10,"Add",loc.CFrame,vt(5,5,5),-0.05,-0.05,5,MAINRUINCOLOR)
		sphere2(8,"Add",loc.CFrame,vt(5,5,5),2.5,2.5,2.5,MAINRUINCOLOR)
		sphere2(4,"Add",loc.CFrame,vt(5,5,5),2.5,2.5,2.5,MAINRUINCOLOR)
		sphere2(2,"Add",loc.CFrame,vt(5,5,5),2.5,2.5,2.5,MAINRUINCOLOR)
		coroutine.resume(coroutine.create(function()
			local eff = Instance.new("ParticleEmitter",loc)
			eff.Texture = "rbxassetid://363275192"
			eff.LightEmission = 0.95
			eff.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			eff.Rate = 10000
			eff.Lifetime = NumberRange.new(1)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.8,75,0),NumberSequenceKeypoint.new(1,0,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(100,500)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.VelocitySpread = 9000
			eff.RotSpeed = NumberRange.new(-50,50)
			wait(0.5)
			eff.Enabled = false
		end))
		for i = 0, 49 do
			sphere2(math.random(100,300)/100,"Add",loc.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,5),-0.01,-0.01,5,MAINRUINCOLOR)
		end
		for i = 0, 9 do
			sphere2(3,"Add",loc.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),0),vt(1,1,5),-0.01,-0.01,5,MAINRUINCOLOR)
		end
		game:GetService("Debris"):AddItem(loc, 5)
		root.CFrame = root.CFrame + root.CFrame.lookVector*200
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function cutesigh()
		attack = true
		hum.WalkSpeed = 0
		bosschatfunc("sigh~~",MAINRUINCOLOR.Color,2)
		local blush = Instance.new("Decal",hed)
		blush.Texture = "rbxassetid://898404027"
		blush.Face = "Front"
		CFuncs["Sound"].Create("rbxassetid://294861193", char, 9,1)
		for i = 0, 9, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(19 + 8 * math.cos(sine / 62)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-20 - 3 * math.cos(sine / 34))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(3 - 1 * math.cos(sine / 55)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(26 + 5 * math.cos(sine / 41))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(-13 - 2 * math.cos(sine / 32)),math.rad(3),math.rad(10 - 4 * math.cos(sine / 67))),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 - 8 * math.cos(sine / 37)),math.rad(-21 + 2 * math.cos(sine / 58)),math.rad(-10 + 2 * math.cos(sine / 53))),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(0 + 0 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(33 + 5 * math.cos(sine / 51))),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(0 - 0 * math.cos(sine / 73)),math.rad(2 - 3 * math.cos(sine / 53)),math.rad(-33 - 5 * math.cos(sine / 51))),.1)
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 49 do
				swait()
				blush.Transparency = blush.Transparency + 0.02
			end
			blush:Destroy()
		end))
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function smiter()
		local targetted = nil
		if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			targetted = mouse.Target.Parent
		end
		if targetted ~= nil then
			RootPart.CFrame = FaceMouse()[1]
			attack = true
			local radm = math.random(1,3)
			if radm == 1 then
				bosschatfunc("SMITED!!",MAINRUINCOLOR.Color,1)
			elseif radm == 2 then
				bosschatfunc("FROM ABOVE!!",MAINRUINCOLOR.Color,1)
			elseif radm == 3 then
				bosschatfunc("LOOK UP!!",MAINRUINCOLOR.Color,1)
			end
			hum.WalkSpeed = 0
			coroutine.resume(coroutine.create(function()
				CFuncs["Sound"].Create("rbxassetid://1117054464", targetted.Head, 2, 1)
				sphere2(4,"Add",targetted.Head.CFrame,vt(8,8,8),0.1,0.1,0.1,MAINRUINCOLOR)
				local vel = Instance.new("BodyPosition", targetted.Head)
				vel.P = 12500
				vel.D = 1000
				vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
				vel.position = targetted.Head.CFrame.p
			end))
			CFuncs["Sound"].Create("rbxassetid://671759140", sorb2, 1, 1.2)
			CFuncs["EchoSound"].Create("rbxassetid://1436242685", char, 4, 1,0,10,0.15,0.5,1)
			CFuncs["EchoSound"].Create("rbxassetid://1436242685", root, 60, 1,0,10,0.15,0.5,1)
			for i = 0,4,0.1 do
				swait()
				sphere2(4,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.125,-0.01,MAINRUINCOLOR)
				RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,1)* angles(math.rad(0),math.rad(0),math.rad(-60)),0.2)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(60)),.2)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.2)
				LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-40)), 0.2)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.1)
			end
			coroutine.resume(coroutine.create(function()
				CameraEnshaking(6,5)
				MagniDamage(targetted.Head, 18, 18,30, 0, "Normal")
				CFuncs["Sound"].Create("rbxassetid://1042705869", targetted.Head, 6.5, 0.8)
				CFuncs["Sound"].Create("rbxassetid://1042716828", targetted.Head, 6.25, 0.8)
				CFuncs["Sound"].Create("rbxassetid://1117054464", targetted.Head, 5, 0.8)
				sphere2(3,"Add",targetted.Head.CFrame,vt(0,40000,0),0.25,0,0.25,MAINRUINCOLOR)
				sphere2(2,"Add",targetted.Head.CFrame,vt(0,40000,0),0.25,0,0.25,MAINRUINCOLOR)
				sphere2(4,"Add",targetted.Head.CFrame,vt(0,0,0),0.5,0.5,0.5,MAINRUINCOLOR)
				sphere2(5,"Add",targetted.Head.CFrame,vt(0,0,0),0.5,0.5,0.5,MAINRUINCOLOR)
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",targetted.Head)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(Color3.new(0.3,1,1))
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(0.5,2)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(20,250)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					wait(0.25)
					eff.Enabled = false
					local eff = Instance.new("ParticleEmitter",targetted.Head)
					eff.Texture = "rbxassetid://363275192"
					eff.LightEmission = 0.95
					eff.Color = ColorSequence.new(MAINRUINCOLOR.Color)
					eff.Rate = 10000
					eff.Lifetime = NumberRange.new(1.5)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.8,25,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(25,150)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					local eff2 = eff:Clone()
					eff2.Parent = targetted.Head
					eff2.Texture = "rbxassetid://284205403"
					eff2.Rate = 10000
					eff2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
					eff2.Drag = 5
					eff2.Rotation = NumberRange.new(-500,500)
					eff2.VelocitySpread = 9000
					wait(0.5)
					eff2.Enabled = false
					eff.Enabled = false
				end))
				for i = 0, 9 do
					sphere2(3,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(2,1,2),-0.02,3,-0.02,MAINRUINCOLOR)
				end
				for i = 0, 49 do
					local rsiz = math.random(10,50)
					sphereMK(math.random(1,4),1,"Add",targetted.Head.CFrame*CFrame.new(math.random(-20,20)/50,math.random(-20,20)/50,math.random(-20,20)/50)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,MAINRUINCOLOR,0)
				end
				game:GetService("Debris"):AddItem(vel,1)
				dmg(targetted)
			end))
			for i = 0,1,0.1 do
				swait()
				RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,1)* angles(math.rad(0),math.rad(0),math.rad(-70)),0.5)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(70)),.5)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.2)
				LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-40)), 0.2)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.1)
			end
			attack = false
			hum.WalkSpeed = storehumanoidWS
		end
	end

	function shytaunty()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://543623779", char, 1, 1)
		local blush = Instance.new("Decal",hed)
		blush.Texture = "rbxassetid://898404027"
		blush.Face = "Front"
		for i = 0, 13, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28) + 0.05 * math.cos(sine / 44),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7 - 5 * math.cos(sine / 44)),math.rad(0),math.rad(-6 - 3 * math.cos(sine / 34))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28) - 0.05 * math.cos(sine / 44),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(3 + 5 * math.cos(sine / 44)),math.rad(0),math.rad(0 + 3 * math.cos(sine / 34))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.05 * math.cos(sine / 44),0 + 0.03 * math.cos(sine / 34),1 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0 - 5 * math.cos(sine / 44)),math.rad(-5)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2 - 2.5 * math.cos(sine / 28)),math.rad(20 + 5 * math.cos(sine / 62)),math.rad(35 + 5 * math.cos(sine / 59))),.1)
			RW.C0=clerp(RW.C0,cf(1,0.5 + 0.1 * math.cos(sine / 28),-0.45)*angles(math.rad(22 - 1 * math.cos(sine / 53)),math.rad(0),math.rad(-60 + 2 * math.cos(sine / 37))),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.1 * math.cos(sine / 28),-0.45)*angles(math.rad(26 - 2 * math.cos(sine / 58)),math.rad(0),math.rad(59 - 3 * math.cos(sine / 57) )),.1)
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 49 do
				swait()
				blush.Transparency = blush.Transparency + 0.02
			end
			blush:Destroy()
		end))
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function PureBomb()
		attack = true
		CFuncs["EchoSound"].Create("rbxassetid://1436241485", char, 5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1436241485", root, 60, 1,0,10,0.15,0.5,1)
		bosschatfunc("Purified..",MAINRUINCOLOR.Color,2)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = BrickColor.new("Toothpaste")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(0,0,0)
		local scaled = 0.1
		local posid = 0
		CFuncs["Sound"].Create("rbxassetid://136007472", orb, 30,1)
		for i = 0, 5, 0.1 do
			swait()
			scaled = scaled - 0.001
			posid = posid - scaled
			orb.CFrame = rarm.CFrame*CFrame.new(0,-0.1+posid/1.05,0)
			orbm.Scale = orbm.Scale + vt(scaled,scaled,scaled)
			sphereMKCharge(5,-0.25,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.5,0.5,5,-0.005,BrickColor.new("Toothpaste"),10)
			PixelBlockNeg(2,1,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.01,BrickColor.new("Toothpaste"),0)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(180),math.rad(20),math.rad(0)),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.1)
		end
		for i = 0, 2, 0.1 do
			swait()
			orb.CFrame = rarm.CFrame*CFrame.new(0,-0.1+posid/1.05,0)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(-50)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(20)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(220),math.rad(20),math.rad(0)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.4)
		end
		CFuncs["EchoSound"].Create("rbxassetid://1436240026", char, 4, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1436240026", root, 60, 1,0,10,0.15,0.5,1)
		bosschatfunc("BOMB!!",MAINRUINCOLOR.Color,2)
		coroutine.resume(coroutine.create(function()
			orb.Anchored = false
			CFuncs["Sound"].Create("rbxassetid://260433768", root, 555,1)
			local a = Instance.new("Part",workspace)
			a.Name = "Direction"	
			a.Anchored = true
			a.BrickColor = bc("Bright red")
			a.Material = "Neon"
			a.Transparency = 1
			a.CanCollide = false
			local ray = Ray.new(
				orb.CFrame.p,                           -- origin
				(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
			) 
			local ignore = orb
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			local distance = (orb.CFrame.p - position).magnitude
			a.Size = Vector3.new(0.1, 0.1, 0.1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
			orb.CFrame = a.CFrame
			a:Destroy()
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = orb.CFrame.lookVector*125
			bv.Parent = orb
			local hitted = false
			game:GetService("Debris"):AddItem(orb, 15)
			wait()
			local hit =orb.Touched:connect(function(hit) 
				if hitted == false then
					hitted = true
					CameraEnshaking(10,2.5)
					MagniDamage(orb, 65, 65,90, 0, "Normal")
					sphere(1,"Add",orb.CFrame,vt(orbm.Scale.x,orbm.Scale.y,orbm.Scale.z),1,BrickColor.new("Toothpaste"))
					sphere(2,"Add",orb.CFrame,vt(orbm.Scale.x,orbm.Scale.y,orbm.Scale.z),2,BrickColor.new("Toothpaste"))
					for i = 0, 49 do
						PixelBlock(1,math.random(1,30),"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),4,4,4,0.08,BrickColor.new("Toothpaste"),0)
					end
					local eff = Instance.new("ParticleEmitter",orb)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(Color3.new(4/255,175/255,236/255))
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(0.5,2)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(20,250)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					coroutine.resume(coroutine.create(function()
						wait(0.25)
						eff.Enabled = false
					end))
					CFuncs["Sound"].Create("rbxassetid://1666361078", orb, 30,1)
					for i = 0, 9 do
						sphereMK(1,2.5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,50,-0.05,BrickColor.new("Toothpaste"),0)
						sphereMK(2,5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,50,-0.05,BrickColor.new("Toothpaste"),0)
					end
					orb.Anchored = true
					orb.Transparency = 1
					local eff = Instance.new("ParticleEmitter",orb)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(Color3.new(M))
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(0.5,2)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(20,250)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					coroutine.resume(coroutine.create(function()
						wait(1)
						eff.Enabled = false
					end))
					wait(8)
					orb:Destroy()
				end
			end)
		end))
		for i = 0, 1, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(0),math.rad(0),math.rad(50)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-50)),.4)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(60),math.rad(20),math.rad(50)),.4)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-30 + 5 * math.cos(sine / 30)),math.rad(-20)),.4)
		end
		attack = false
	end


	function BeamOfDeath()
		coroutine.resume(coroutine.create(function()
			attack = true
			hum.WalkSpeed = 0 
			for i = 0, 11, 0.1 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(8 - 6 * math.cos(sine / 67)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-18 - 5 * math.cos(sine / 32))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15 - 8 * math.cos(sine / 74)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(31 + 8 * math.cos(sine / 38))),.1)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(-16 - 2 * math.cos(sine / 32)),math.rad(3),math.rad(10 - 4 * math.cos(sine / 67))),.1)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-23 - 8 * math.cos(sine / 37)),math.rad(-21 + 2 * math.cos(sine / 58)),math.rad(-10 + 2 * math.cos(sine / 53))),.1)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),-0.15)*angles(math.rad(125 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(33 + 14 * math.cos(sine / 45))),.1)
				LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(35 - 8 * math.cos(sine / 51))),.1)
			end
			for i = 0, 1, 0.1 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(8 - 6 * math.cos(sine / 67)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-18 - 5 * math.cos(sine / 32))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15 - 8 * math.cos(sine / 74)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(31 + 8 * math.cos(sine / 38))),.1)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(16 - 2 * math.cos(sine / 32)),math.rad(3),math.rad(10 - 4 * math.cos(sine / 67))),.1)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 - 8 * math.cos(sine / 37)),math.rad(-21 + 2 * math.cos(sine / 58)),math.rad(-10 + 2 * math.cos(sine / 53))),.1)
				RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.15)*angles(math.rad(-5 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(33 + 14 * math.cos(sine / 45))),.1)
				LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(35 - 8 * math.cos(sine / 51))),.1)
			end
			hum.WalkSpeed = storehumanoidWS
			attack = false
		end))
		CFuncs["Sound"].Create("rbxassetid://430315987", char, 5, 1,0,10,0.10,0.25,1)
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("YAHHHH!!!",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("TAKE THAT!!",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("CONSUMED!!!",MAINRUINCOLOR.Color,1)
		end
		local keptcolor = MAINRUINCOLOR
		local orb = Instance.new("Part", char)
		orb.BrickColor = keptcolor
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 1
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(22.5,10000,22.5)
		orb.CFrame = mouse.Hit
		orb.Anchored = true
		orb.Orientation = vt(0,0,0)
		orb.CFrame = orb.CFrame*CFrame.new(0,1,0)
		CFuncs["LongSound"].Create("rbxassetid://1545630949", char, 0.5, 1.2)
		coroutine.resume(coroutine.create(function()
			coroutine.resume(coroutine.create(function()
				for i = 0, 175 do
					swait()
					orbm.Scale = orbm.Scale - vt(0.1,0,0.1)
					orb.Transparency = orb.Transparency - 0.005
				end
			end))
			wait(2)
			coroutine.resume(coroutine.create(function()
				local hfr,pfr=rayCast(orb.Position,(CFrame.new(orb.Position,orb.Position - Vector3.new(0,1,0))).lookVector,4,char)
				if hfr ~= nil then
					for i = 0, 24.5 do
						local deb = Instance.new("Part", char)
						deb.Anchored = true
						deb.CanCollide = false
						deb.FormFactor = 3
						deb.Name = "Ring"
						deb.Material = hitfloor.Material
						deb.Color = hitfloor.Color
						deb.Size = vt(math.random(50,55),math.random(50,55),math.random(50,55))
						deb.Transparency = 0
						deb.TopSurface = 0
						deb.BottomSurface = 0
						deb.CFrame = orb.CFrame*CFrame.new(math.random(-150,150),-5,math.random(-150,150))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
						local deb2 = Instance.new("Part", char)
						deb2.CanCollide = false
						deb2.FormFactor = 3
						deb2.Name = "Ring"
						deb2.Material = hitfloor.Material
						deb2.Color = hitfloor.Color
						deb2.Size = vt(math.random(34,38),math.random(34,38),math.random(34,38))
						deb2.Transparency = 0
						deb2.TopSurface = 0
						deb2.BottomSurface = 0
						deb2.Velocity = vt(math.random(-150,150),math.random(250,650),math.random(-150,150))
						deb2.CFrame = orb.CFrame*CFrame.new(math.random(-60,60),-5,math.random(-60,60))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
						local eff = Instance.new("ParticleEmitter",deb)
						eff.Texture = "rbxassetid://363275192"
						eff.LightEmission = 0.95
						eff.Color = ColorSequence.new(keptcolor.Color)
						eff.Rate = 100
						eff.Lifetime = NumberRange.new(1)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,40,0),NumberSequenceKeypoint.new(1,45,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(0,5)
						eff.Rotation = NumberRange.new(-500,500)
						eff.VelocitySpread = 9000
						eff.RotSpeed = NumberRange.new(-10,10)
						local at1 = Instance.new('Attachment',deb2)
						at1.Position = vt(0,15,0)
						local at2 = Instance.new('Attachment',deb2)
						at2.Position = vt(0,-15,0)
						local tl = Instance.new('Trail',deb2)
						tl.Attachment0 = at1
						tl.Attachment1 = at2
						tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
						tl.Color = ColorSequence.new(BrickColor.new('White').Color)
						tl.Lifetime = 1
						game:GetService("Debris"):AddItem(deb,30)
						game:GetService("Debris"):AddItem(deb2,30)
						coroutine.resume(coroutine.create(function()
							wait(15)
							eff.Enabled = false
							for i = 0, 49 do
								swait()
								deb.Transparency = deb.Transparency + 0.02
							end
							wait(1)
							deb:Destroy()
						end))
					end
				end
			end))
			for i = 0, 199 do
				swait(1.5)
				for i, v in pairs(FindNearestHead(orb.CFrame.p, 175)) do
					if v:FindFirstChild('Head') then
						dmg(v)
					end
				end
				CFuncs["Sound"].Create("rbxassetid://1666361078", orb, 30,1)
				sphere2(5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(10,10,10),5,5,5,keptcolor)
				sphere2(5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(10,10,10),1,35,1,keptcolor)
				sphere2(5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(10,10,10),0,50,0,keptcolor)
				sphere2(5,"Add",orb.CFrame,vt(10,100000,10),2,2,2,keptcolor)
			end
			orb:Destroy()
		end))
	end

	function Beams()
		attack = true
		hum.WalkSpeed = 0 
		CFuncs["EchoSound"].Create("rbxassetid://1436242274", char, 8, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1436242274", root, 60, 1,0,10,0.15,0.5,1)
		bosschatfunc("You'll gone..",MAINRUINCOLOR.Color,2)
		local keptcolor = MAINRUINCOLOR
		coroutine.resume(coroutine.create(function()
			for i = 0, 96 do
				swait(5)
				local orb = Instance.new("Part", char)
				CFuncs["Sound"].Create("rbxassetid://663361028", orb, 2, 1)
				orb.BrickColor = keptcolor
				orb.CanCollide = false
				orb.FormFactor = 3
				orb.Name = "Ring"
				orb.Material = "Neon"
				orb.Size = Vector3.new(1, 1, 1)
				orb.Transparency = 0
				orb.TopSurface = 0
				orb.BottomSurface = 0
				orb.Anchored = true
				local orbm = Instance.new("SpecialMesh", orb)
				orbm.MeshType = "Sphere"
				orbm.Name = "SizeMesh"
				orbm.Scale = vt(1.25,1.25,1.25)
				orb.CFrame = root.CFrame*CFrame.new(math.random(-6,6),math.random(3,9),math.random(-6,6))
				sphere2(6,"Add",orb.CFrame,vt(1.25,1.25,1.25),0.025,0.025,0.025,keptcolor)
				coroutine.resume(coroutine.create(function()
					wait(0.5)
					CFuncs["Sound"].Create("rbxassetid://161006182", orb, 2.5, 1.1)
					sphere2(3,"Add",orb.CFrame,vt(1.25,1.25,1.25),0.025,0.025,0.025,keptcolor)
					sphere2(4,"Add",orb.CFrame,vt(1.25,1.25,1.25),0.025,0.025,0.025,keptcolor)
					orb.Transparency = 1
					local a = Instance.new("Part",char)
					a.Name = "Direction"	
					a.Anchored = true
					a.BrickColor = keptcolor
					a.Material = "Neon"
					a.Transparency = 0.25
					a.Shape = "Cylinder"
					local ht = Instance.new("Part",char)
					ht.Name = "DirectionHit"	
					ht.Anchored = true
					ht.BrickColor = keptcolor
					ht.CanCollide = false
					ht.Transparency = 1
					ht.Size = vt(0.1,0.1,0.1)
					CFuncs["Sound"].Create("rbxassetid://183763487", ht, 2, 1.6)
					a.CanCollide = false
					local ray = Ray.new(
						orb.CFrame.p,                           -- origin
						(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
					) 
					local ignore = char
					local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
					a.BottomSurface = 10
					a.TopSurface = 10
					local distance = (orb.CFrame.p - position).magnitude
					a.Size = Vector3.new(distance,1,1)
					a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
					ht.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
					sphere2(2,"Add",ht.CFrame,vt(1.25,1.25,1.25),0.15,0.15,0.15,keptcolor)
					sphere2(4,"Add",ht.CFrame,vt(1.25,1.25,1.25),0.15,0.15,0.15,keptcolor)
					MagniDamage(ht, 9, 30,60, 0, "Normal")
					coroutine.resume(coroutine.create(function()
						local eff = Instance.new("ParticleEmitter",ht)
						eff.Texture = "rbxassetid://284205403"
						eff.LightEmission = 0.95
						eff.Color = ColorSequence.new(keptcolor.Color)
						eff.Rate = 500
						eff.Lifetime = NumberRange.new(0.5)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,5,0),NumberSequenceKeypoint.new(0.2,2.5,0),NumberSequenceKeypoint.new(1,0.1,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(10,50)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.VelocitySpread = 9000
						eff.RotSpeed = NumberRange.new(-500,500)
						wait(0.25)
						eff.Enabled = false
					end))
					for i = 0, 4 do
						sphere2(8,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.005,0.125,-0.005,keptcolor)
						sphere2(4,"Add",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(2,1,2),-0.01,0.5,-0.01,keptcolor)
						local rsiz = math.random(10,30)
						sphereMK(math.random(2,4),0.25,"Add",ht.CFrame*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,keptcolor,0)
					end
					a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
					local msh = Instance.new("SpecialMesh",a)
					msh.MeshType = "Cylinder"
					msh.Scale = vt(1,1,1)
					for i = 0, 49 do
						swait()
						msh.Scale = msh.Scale + vt(0,0.01,0.01)
						a.Transparency = a.Transparency + 0.02
					end
					orb:Destroy()
					a:Destroy()
					ht:Destroy()
				end))
				game:GetService("Debris"):AddItem(orb, 10)
			end
		end))
		for i = 0,6,0.1 do
			swait()
			sphere2(7,"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.075,-0.01,keptcolor)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.2 * math.cos(sine / 35))* angles(math.rad(0),math.rad(0),math.rad(40)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(-40)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(10)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(6), math.rad(20), math.rad(-10)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 6 * math.cos(sine / 39))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 45))),.1)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function CalamityTrans()
		attack = true
		rainbowmode = false
		chaosmode = false
		ModeOfGlitch = 8889
		hum.WalkSpeed = 0
		newThemeCust("rbxassetid://1359036559",0,1,1.25)
		local elocacenter = CreateParta(root,1,1,"SmoothPlastic",BrickColor.random())
		elocacenter.Anchored = true
		elocacenter.CFrame = root.CFrame
		local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca1.Anchored = true
		eloca1.CFrame = elocacenter.CFrame
		local eloca2 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca2.Anchored = true
		eloca2.CFrame = elocacenter.CFrame
		local eloca3 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca3.Anchored = true
		eloca3.CFrame = elocacenter.CFrame
		local eloca4 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca4.Anchored = true
		eloca4.CFrame = elocacenter.CFrame
		local lookavec = 0 
		local speeds = 0
		CameraEnshaking(3,2.5)
		sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),0.75,MAINRUINCOLOR)
		sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),0.75,MAINRUINCOLOR)
		sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),0.75,MAINRUINCOLOR)
		sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),0.75,MAINRUINCOLOR)
		sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),0.75,MAINRUINCOLOR)
		CFuncs["Sound"].Create("rbxassetid://419447292", root, 10,1)
		CFuncs["Sound"].Create("rbxassetid://1192402877", root, 10, 1)
		for i = 0, 5, 0.1 do
			swait()
			---
			lookavec = lookavec + 1
			speeds = speeds + 10
			elocacenter.CFrame = root.CFrame*CFrame.Angles(0,math.rad(speeds),0)
			eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			---
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-1.45,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90 - 2.5 * math.cos(sine / 28))),.1)
		end
		for i = 0, 5, 0.1 do
			swait()
			---
			speeds = speeds + 10
			elocacenter.CFrame = root.CFrame*CFrame.Angles(0,math.rad(speeds),0)
			eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			---
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-1.45,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90 - 2.5 * math.cos(sine / 28))),.1)
		end
		MAINRUINCOLOR = BrickColor.new("Bright violet")
		CFuncs["Sound"].Create("rbxassetid://468991944", eloca1, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://468991944", eloca2, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://468991944", eloca3, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://468991944", eloca4, 5, 1)
		CameraEnshaking(1,3)
		for i = 0, 24 do
			PixelBlock(1,math.random(5,25),"Add",eloca1.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,5,0.1,MAINRUINCOLOR,0)
			PixelBlock(1,math.random(5,25),"Add",eloca2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,5,0.1,MAINRUINCOLOR,0)
			PixelBlock(1,math.random(5,25),"Add",eloca3.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,5,0.1,MAINRUINCOLOR,0)
			PixelBlock(1,math.random(5,25),"Add",eloca4.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,5,0.1,MAINRUINCOLOR,0)
		end
		sphere(1,"Add",eloca1.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(2,"Add",eloca1.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(3,"Add",eloca1.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(1,"Add",eloca2.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(2,"Add",eloca2.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(3,"Add",eloca2.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(1,"Add",eloca3.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(2,"Add",eloca3.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(3,"Add",eloca3.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(1,"Add",eloca4.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(2,"Add",eloca4.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		sphere(3,"Add",eloca4.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
		for i = 0, 5, 0.1 do
			swait()
			---
			lookavec = lookavec - 1
			speeds = speeds + 10
			elocacenter.CFrame = root.CFrame*CFrame.Angles(0,math.rad(speeds),0)
			eloca1.CFrame = elocacenter.CFrame*CFrame.new(lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca1.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			eloca2.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
			PixelBlockNeg(2,0.1,"Add",eloca2.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,0,lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca3.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,0,-lookavec)
			PixelBlockNeg(2,0.1,"Add",eloca4.CFrame*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2.5,2.5,2.5,0.025,MAINRUINCOLOR,-2)
			---
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-1.45,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90 - 2.5 * math.cos(sine / 28))),.1)
		end
		sphere(1,"Add",elocacenter.CFrame,vt(0,0,0),2,MAINRUINCOLOR)
		sphere(2,"Add",elocacenter.CFrame,vt(0,0,0),2,MAINRUINCOLOR)
		sphere(3,"Add",elocacenter.CFrame,vt(0,0,0),2,MAINRUINCOLOR)
		sphere(4,"Add",elocacenter.CFrame,vt(0,0,0),2,MAINRUINCOLOR)
		sphere(5,"Add",elocacenter.CFrame,vt(0,0,0),2,MAINRUINCOLOR)
		for i = 0, 49 do
			PixelBlock(1,math.random(8,16),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10,10,10,0.2,MAINRUINCOLOR,0)
			PixelBlock(2,math.random(16,32),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,5,0.05,MAINRUINCOLOR,0)
		end
		CameraEnshaking(5,6)
		CFuncs["Sound"].Create("rbxassetid://419447292", root, 10,1)
		CFuncs["Sound"].Create("rbxassetid://151304356", root, 5,1)
		CFuncs["Sound"].Create("rbxassetid://741272936", root, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://164881112", root, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://1192402877", root, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://429123896", root, 5, 0.85)
		CFuncs["Sound"].Create("rbxassetid://1208650519", root, 5, 1)
		storehumanoidWS = 100
		hum.WalkSpeed = 100
		rainbowmode = false
		chaosmode = false
		tl1.Enabled = true
		tl2.Enabled = true
		tl3.Enabled = true
		RecolorTextAndRename("CALAMITY",Color3.new(10,1,1),Color3.new(0.5,0,1),"Code")
		tl1.Color = ColorSequence.new(MAINRUINCOLOR.Color)
		tl2.Color = ColorSequence.new(MAINRUINCOLOR.Color)
		tl3.Color = ColorSequence.new(MAINRUINCOLOR.Color)
		for i, v in pairs(mw2:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = MAINRUINCOLOR
				v.Material = "Neon"
			end
		end
		for i, v in pairs(mw1:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = 0
				v.BrickColor = MAINRUINCOLOR
				v.Material = "Neon"
			end
		end
		for i, v in pairs(m:GetChildren()) do
			if v:IsA("Part") then
				v.Color = Color3.new(0.5,0,1)
				v.Material = "Neon"
			end
		end
		for i, v in pairs(m2:GetChildren()) do
			if v:IsA("Part") then
				v.Color = Color3.new(0.25,0,1)
				v.Material = "Neon"
			end
		end
		for i, v in pairs(m3:GetChildren()) do
			if v:IsA("Part") then
				v.Color = Color3.new(0.45,0,1)
				v.Material = "Neon"
			end
		end
		for i, v in pairs(extrawingmod1:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = 0.75
				v.Color = Color3.new(0.25,0,1)
				v.Material = "Neon"
			end
		end
		for i, v in pairs(extrawingmod2:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = 0.75
				v.Color = Color3.new(0.5,0,1)
				v.Material = "Neon"
			end
		end
		attack = false
	end

	function GleamingBeam()
		attack = true
		bosschatfunc("IT ENDS NOW!!!",MAINRUINCOLOR.Color,3)
		CFuncs["EchoSound"].Create("rbxassetid://1535995570", char, 8, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1535995570", root, 60, 1,0,10,0.15,0.5,1)
		local rsiz = math.random(1,15)
		local hb = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
		hb.Anchored = true
		hb.CFrame = sorb.CFrame*CFrame.new(0,-3,0)
		CFuncs["Sound"].Create("rbxassetid://1042700914", sorb, 8,0.25)
		for i = 0, 16, 0.1 do
			swait()
			rsiz = math.random(5,15)
			hb.CFrame = sorb.CFrame*CFrame.new(0,-3,0)
			sphereMK(math.random(3,9),0.25,"Add",sorb.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,MAINRUINCOLOR,-15)	
			sphere2(5,"Add",sorb.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(4,4,4),0.01,0.01,0.01,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(40)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(-40)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(40)),.1)
			LW.C0=clerp(LW.C0,cf(-1.25,0.5,0.5)*angles(math.rad(-20),math.rad(0),math.rad(20)),.1)
		end
		CFuncs["Sound"].Create("rbxassetid://1042693018", sorb, 10,0.6)
		CFuncs["Sound"].Create("rbxassetid://1042695469", sorb, 10,0.5)
		for i = 0, 2 do
			CFuncs["Sound"].Create("rbxassetid://1042696115", sorb, 10,1)
		end
		sphere2(3,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		sphere2(6,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		sphere2(9,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		for i = 0, 49 do 
			local rsiza = math.random(1,15)
			sphereMK(math.random(1,5),0.75,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiza/10,rsiza/10,rsiza/10,0,MAINRUINCOLOR,0)	
		end
		local a = Instance.new("Part",Character)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = MAINRUINCOLOR
		a.Material = "Neon"
		a.Transparency = 0
		a.Shape = "Cylinder"
		a.CanCollide = false
		local ba = Instance.new("Part",Character)
		ba.Name = "HitDirect"	
		ba.Anchored = true
		ba.BrickColor = bc("Cool yellow")
		ba.Material = "Neon"
		ba.Transparency = 1
		ba.CanCollide = false
		local ray = Ray.new(
			hb.CFrame.p,                           -- origin
			(mouse.Hit.p - hb.CFrame.p).unit * 1000 -- direction
		) 
		local ignore = Character
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (hb.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance, 1, 1)
		a.CFrame = CFrame.new(hb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		ba.CFrame = CFrame.new(hb.CFrame.p, position) * CFrame.new(0, 0, -distance)
		a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
		local msh = Instance.new("SpecialMesh",a)
		msh.MeshType = "Cylinder"
		msh.Scale = vt(1,4,4)
		game:GetService("Debris"):AddItem(a, 30)
		game:GetService("Debris"):AddItem(ba, 30)
		for i = 0, 25, 0.1 do
			swait()
			hb.CFrame = sorb.CFrame*CFrame.new(0,-3,0)
			ray = Ray.new(
				hb.CFrame.p,                           -- origin
				(mouse.Hit.p - hb.CFrame.p).unit * 1000 -- direction
			) 
			hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			distance = (hb.CFrame.p - position).magnitude
			a.Size = Vector3.new(distance, 1, 1)
			a.CFrame = CFrame.new(hb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			ba.CFrame = CFrame.new(hb.CFrame.p, position) * CFrame.new(0, 0, -distance)
			a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
			rsiz = math.random(5,25)
			MagniDamage(ba, 12, 40000,900000, 0, "Normal")
			sphereMK(math.random(4,8),0.25,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/5,rsiz/5,rsiz/5,0,MAINRUINCOLOR,0)
			for c = 0, 2 do	
				sphereMK(math.random(3,6),0.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/5,rsiz/5,rsiz/5,0,MAINRUINCOLOR,2)
			end
			sphere2(5,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(4.2,4.2,4.2),0.01,0.01,0.01,MAINRUINCOLOR)
			sphere2(5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(12,12,12),0.05,0.05,0.05,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(80)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(-80)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(80)),.6)
			LW.C0=clerp(LW.C0,cf(-1.25,0.5,0.5)*angles(math.rad(-20),math.rad(0),math.rad(20)),.6)
		end
		CFuncs["Sound"].Create("rbxassetid://1042693018", sorb, 5,0.8)
		CFuncs["Sound"].Create("rbxassetid://1042695469", sorb, 5,0.9)
		CFuncs["Sound"].Create("rbxassetid://1042693018", ba, 10,0.8)
		CFuncs["Sound"].Create("rbxassetid://1042695469", ba, 10,0.9)
		MagniDamage(ba, 30, 400000,9000000, 0, "Normal")
		sphere2(1,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0,0,0),1,1,1,MAINRUINCOLOR)
		sphere2(2,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0,0,0),1,1,1,MAINRUINCOLOR)
		sphere2(3,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0,0,0),1,1,1,MAINRUINCOLOR)
		sphere2(3,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		sphere2(6,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		sphere2(9,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		for i = 0, 49 do 
			local rsiza = math.random(1,15)
			sphereMK(math.random(1,5),0.75,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiza/10,rsiza/10,rsiza/10,0,MAINRUINCOLOR,0)	
		end
		for i = 0, 49 do
			rsiz = math.random(1,8)	
			sphereMK(math.random(1,3),1,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz,rsiz,rsiz,0,MAINRUINCOLOR,2)
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 99 do
				swait()
				a.Transparency = a.Transparency + 0.01
			end
			a:Destroy()
			ba:Destroy()
		end))
		hb:Destroy()
		attack = false
	end

	function DualGleamingBeam()
		attack = true
		hum.WalkSpeed = 0 
		CFuncs["EchoSound"].Create("rbxassetid://1448033299", char, 5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1448033299", root, 60, 1,0,10,0.15,0.5,1)
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("YOU CAN'T ESCAPE THIS!!",MAINRUINCOLOR.Color,1)
		elseif radm == 2 then
			bosschatfunc("HOW DO YOU LIKE THIS?!",MAINRUINCOLOR.Color,1)
		elseif radm == 3 then
			bosschatfunc("You make the choice..",MAINRUINCOLOR.Color,1)
		end
		local rsiz = math.random(1,15)
		local hb = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
		hb.Anchored = true
		hb.CFrame = sorb.CFrame*CFrame.new(0,-3,0)
		local hb2 = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
		hb2.Anchored = true
		hb2.CFrame = sorb.CFrame*CFrame.new(0,-3,0)
		CFuncs["Sound"].Create("rbxassetid://1042700914", sorb, 8,0.25)
		for i = 0, 14, 0.1 do
			swait()
			rsiz = math.random(5,15)
			hb.CFrame = sorb.CFrame*CFrame.new(0,-3,0)
			hb2.CFrame = sorb2.CFrame*CFrame.new(0,-3,0)
			sphereMK(math.random(3,9),0.25,"Add",sorb.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,MAINRUINCOLOR,-15)	
			sphere2(5,"Add",sorb.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(4,4,4),0.01,0.01,0.01,MAINRUINCOLOR)
			sphereMK(math.random(3,9),0.25,"Add",sorb2.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,BrickColor.new("Lime green"),-15)	
			sphere2(5,"Add",sorb2.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(4,4,4),0.01,0.01,0.01,BrickColor.new("Lime green"))
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-4 - 2 * math.cos(sine / 53)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(9 - 2 * math.cos(sine / 53)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.3 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(10)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(120)),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(-120)),.1)
		end
		CFuncs["Sound"].Create("rbxassetid://1042693018", sorb, 10,0.6)
		CFuncs["Sound"].Create("rbxassetid://1042695469", sorb, 10,0.5)
		CFuncs["Sound"].Create("rbxassetid://1042693018", sorb2, 10,0.6)
		CFuncs["Sound"].Create("rbxassetid://1042695469", sorb2, 10,0.5)
		CFuncs["Sound"].Create("rbxassetid://1042696115", sorb, 10,1)
		CFuncs["Sound"].Create("rbxassetid://1042696115", sorb2, 10,1)
		sphere2(3,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		sphere2(6,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		sphere2(9,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		sphere2(3,"Add",hb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,BrickColor.new("Lime green"))
		sphere2(6,"Add",hb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,BrickColor.new("Lime green"))
		sphere2(9,"Add",hb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,BrickColor.new("Lime green"))
		for i = 0, 49 do 
			local rsiza = math.random(1,15)
			sphereMK(math.random(1,5),0.75,"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiza/10,rsiza/10,rsiza/10,0,MAINRUINCOLOR,0)	
			sphereMK(math.random(1,5),0.75,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiza/10,rsiza/10,rsiza/10,0,MAINRUINCOLOR,0)
		end
		local a = Instance.new("Part",Character)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = MAINRUINCOLOR
		a.Material = "Neon"
		a.Transparency = 0
		a.Shape = "Cylinder"
		a.CanCollide = false
		local a2 = Instance.new("Part",Character)
		a2.Name = "Direction"	
		a2.Anchored = true
		a2.BrickColor = MAINRUINCOLOR
		a2.Material = "Neon"
		a2.Transparency = 0
		a2.Shape = "Cylinder"
		a2.CanCollide = false
		local ba = Instance.new("Part",Character)
		ba.Name = "HitDirect"	
		ba.Anchored = true
		ba.BrickColor = MAINRUINCOLOR
		ba.Material = "Neon"
		ba.Transparency = 1
		ba.CanCollide = false
		local ba2 = Instance.new("Part",Character)
		ba2.Name = "HitDirect"	
		ba2.Anchored = true
		ba2.BrickColor = MAINRUINCOLOR
		ba2.Material = "Neon"
		ba2.Transparency = 1
		ba2.CanCollide = false
		local ray = Ray.new(
			hb.CFrame.p,                           -- origin
			(mouse.Hit.p - hb.CFrame.p).unit * 1000 -- direction
		) 
		local ignore = Character
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		local ray2 = Ray.new(
			hb2.CFrame.p,                           -- origin
			(mouse.Hit.p - hb2.CFrame.p).unit * 1000 -- direction
		) 
		local hit2, position2, normal2 = workspace:FindPartOnRay(ray2, ignore)
		local distance2 = (hb2.CFrame.p - position).magnitude

		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (hb.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance, 1, 1)
		a.CFrame = CFrame.new(hb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		a2.BottomSurface = 10
		a2.TopSurface = 10
		a2.Size = Vector3.new(distance2, 1, 1)
		a2.CFrame = CFrame.new(hb2.CFrame.p, position) * CFrame.new(0, 0, -distance2/2)
		ba.CFrame = CFrame.new(hb.CFrame.p, position) * CFrame.new(0, 0, -distance)
		ba2.CFrame = CFrame.new(hb2.CFrame.p, position) * CFrame.new(0, 0, -distance2)
		a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
		a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
		local msh = Instance.new("SpecialMesh",a)
		msh.MeshType = "Cylinder"
		msh.Scale = vt(1,4,4)
		local msh2 = Instance.new("SpecialMesh",a2)
		msh2.MeshType = "Cylinder"
		msh2.Scale = vt(1,4,4)
		game:GetService("Debris"):AddItem(a, 30)
		game:GetService("Debris"):AddItem(a2, 30)
		game:GetService("Debris"):AddItem(ba, 30)
		game:GetService("Debris"):AddItem(ba2, 30)
		for i = 0, 20, 0.1 do
			swait()
			hb.CFrame = sorb.CFrame*CFrame.new(0,-3,0)
			hb2.CFrame = sorb2.CFrame*CFrame.new(0,-3,0)
			ray = Ray.new(
				hb.CFrame.p,                           -- origin
				(mouse.Hit.p - hb.CFrame.p).unit * 1000 -- direction
			) 
			hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			distance = (hb.CFrame.p - position).magnitude
			ray2 = Ray.new(
				hb2.CFrame.p,                           -- origin
				(mouse.Hit.p - hb2.CFrame.p).unit * 1000 -- direction
			) 
			hit2, position2, normal2 = workspace:FindPartOnRay(ray2, ignore)
			distance2 = (hb2.CFrame.p - position).magnitude
			a.Size = Vector3.new(distance, 1, 1)
			a.CFrame = CFrame.new(hb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			a2.Size = Vector3.new(distance2, 1, 1)
			a2.CFrame = CFrame.new(hb2.CFrame.p, position) * CFrame.new(0, 0, -distance2/2)
			ba.CFrame = CFrame.new(hb.CFrame.p, position) * CFrame.new(0, 0, -distance)
			ba2.CFrame = CFrame.new(hb2.CFrame.p, position) * CFrame.new(0, 0, -distance2)
			a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
			a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
			rsiz = math.random(5,25)
			MagniDamage(ba, 12, 800,18000, 0, "Normal")
			MagniDamage(ba2, 12, 800,18000, 0, "Normal")
			for i, v in pairs(FindNearestHead(ba.CFrame.p, 4)) do
				if v:FindFirstChild('Head') then
					dmg(v)
				end
			end
			coroutine.resume(coroutine.create(function()
				local bx = Instance.new("Part",Character)
				bx.Name = "Location"	
				bx.Anchored = true
				bx.BrickColor = MAINRUINCOLOR
				bx.Material = "Neon"
				bx.Transparency = 1
				bx.CanCollide = false
				bx.Position = ba.Position
				sphere2(2,"Add",bx.CFrame,vt(20,0.5,20),0.001,0,0.001,MAINRUINCOLOR)
				wait(math.random(1,2))
				sphere2(4,"Add",bx.CFrame,vt(5,10000,5),0.1,0,0.1,bc("Lime green"))
				sphere2(4,"Add",bx.CFrame,vt(5,10000,5),0.25,0,0.25,MAINRUINCOLOR)
				sphere2(6,"Add",bx.CFrame,vt(10,10,10),0.5,0.5,0.5,bc("Lime green"))
				CFuncs["Sound"].Create("rbxassetid://1042693018", bx, 5,0.7)
				CFuncs["Sound"].Create("rbxassetid://1042695469", bx, 5,0.8)
				MagniDamage(bx, 20, 80000,900000, 0, "Normal")
				for i, v in pairs(FindNearestHead(bx.CFrame.p, 15)) do
					if v:FindFirstChild('Head') then
						dmg(v)
					end
				end
				wait(5)
				bx:Destroy()
			end))
			sphereMK(math.random(4,8),0.25,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/5,rsiz/5,rsiz/5,0,BrickColor.new("Lime green"),0)
			sphereMK(math.random(4,8),0.25,"Add",hb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/5,rsiz/5,rsiz/5,0,BrickColor.new("Lime green"),0)
			for c = 0, 2 do	
				sphereMK(math.random(3,6),0.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/5,rsiz/5,rsiz/5,0,BrickColor.new("Lime green"),2)
			end
			sphere2(5,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(4.2,4.2,4.2),0.01,0.01,0.01,MAINRUINCOLOR)
			sphere2(5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(12,12,12),0.05,0.05,0.05,MAINRUINCOLOR)
			sphere2(5,"Add",hb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(4.2,4.2,4.2),0.01,0.01,0.01,MAINRUINCOLOR)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-4 - 2 * math.cos(sine / 53)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(9 - 2 * math.cos(sine / 53)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.3 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.05)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(10)),.05)
			RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-15)),.05)
			LW.C0=clerp(LW.C0,cf(-1.25,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(15)),.05)
		end
		for i = 0, 1 do
			CFuncs["Sound"].Create("rbxassetid://1042693018", sorb, 5,0.8)
			CFuncs["Sound"].Create("rbxassetid://1042695469", sorb, 5,0.9)
			CFuncs["Sound"].Create("rbxassetid://1042693018", ba, 10,0.8)
			CFuncs["Sound"].Create("rbxassetid://1042695469", ba, 10,0.9)
		end
		MagniDamage(ba, 30, 8000,180000, 0, "Normal")
		MagniDamage(ba2, 30, 8000,180000, 0, "Normal")
		for i, v in pairs(FindNearestHead(ba.CFrame.p, 10)) do
			if v:FindFirstChild('Head') then
				dmg(v)
			end
		end
		sphere2(1,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0,0,0),1,1,1,MAINRUINCOLOR)
		sphere2(2,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0,0,0),1,1,1,MAINRUINCOLOR)
		sphere2(3,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0,0,0),1,1,1,MAINRUINCOLOR)
		sphere2(3,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		sphere2(6,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		sphere2(9,"Add",hb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,MAINRUINCOLOR)
		sphere2(3,"Add",hb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,bc("Lime green"))
		sphere2(6,"Add",hb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,bc("Lime green"))
		sphere2(9,"Add",hb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.5,0.5),0.3,0.3,0.3,bc("Lime green"))
		for i = 0, 49 do 
			local rsiza = math.random(1,15)
			sphereMK(math.random(1,5),0.75,"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiza/10,rsiza/10,rsiza/10,0,bc("Lime green"),0)
			sphereMK(math.random(1,5),0.75,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiza/10,rsiza/10,rsiza/10,0,bc("Lime green"),0)	
		end
		for i = 0, 49 do
			rsiz = math.random(1,8)	
			sphereMK(math.random(1,3),1,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz,rsiz,rsiz,0,bc("Lime green"),2)
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 99 do
				swait()
				a.Transparency = a.Transparency + 0.01
				a2.Transparency = a2.Transparency + 0.01
			end
			a:Destroy()
			ba:Destroy()
			a2:Destroy()
			ba2:Destroy()
		end))
		hum.WalkSpeed = storehumanoidWS
		hb:Destroy()
		hb2:Destroy()
		attack = false
	end

	function dragin()
		local targetted = nil
		if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			targetted = mouse.Target.Parent
		end
		if targetted ~= nil then
			RootPart.CFrame = FaceMouse()[1]
			attack = true
			hum.WalkSpeed = 0
			for x = 0, 1 do
				for i = 0,1,0.5 do
					swait()
					RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(8 - 6 * math.cos(sine / 67)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-18 - 5 * math.cos(sine / 32))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15 - 8 * math.cos(sine / 74)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(31 + 8 * math.cos(sine / 38))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1)*angles(math.rad(0),math.rad(0),math.rad(90)),.3)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(10),math.rad(15),math.rad(0)),.3)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 30),0)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
					LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.1 * math.cos(sine / 28),-0.65)*angles(math.rad(40),math.rad(0),math.rad(100)),.3)
				end
				for i = 0,1,0.5 do
					swait()
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(6),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.3)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(3),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.3)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1)*angles(math.rad(0),math.rad(0),math.rad(180)),.3)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(10),math.rad(15),math.rad(0)),.3)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 30),0)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
					LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.1 * math.cos(sine / 28),-0.65)*angles(math.rad(40),math.rad(0),math.rad(100)),.3)
				end
				for i = 0,1,0.5 do
					swait()
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(6),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.3)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(3),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.3)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1)*angles(math.rad(0),math.rad(0),math.rad(270)),.3)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(10),math.rad(15),math.rad(0)),.3)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 30),0)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
					LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.1 * math.cos(sine / 28),-0.65)*angles(math.rad(40),math.rad(0),math.rad(100)),.3)
				end
				for i = 0,1,0.5 do
					swait()
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(6),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.3)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(3),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.3)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(10),math.rad(15),math.rad(0)),.3)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 30),0)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
					LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.1 * math.cos(sine / 28),-0.65)*angles(math.rad(40),math.rad(0),math.rad(100)),.3)
				end
			end
			coroutine.resume(coroutine.create(function()
				targetted:FindFirstChildOfClass("Humanoid").Health = targetted:FindFirstChildOfClass("Humanoid").Health + 50
				CFuncs["Sound"].Create("rbxassetid://884155627", targetted.Head, 1,1)
				CFuncs["Sound"].Create("rbxassetid://153092213", targetted.Head, 2.5,1)
			end))
			local A1 = Instance.new("Attachment",targetted.Head)
			local A2 = Instance.new("Attachment",sorb)
			local Beem = Instance.new("Beam",tors)
			Beem.Attachment0 = A1
			Beem.Attachment1 = A2
			Beem.Texture = "rbxassetid://897585362"
			Beem.LightEmission = 0.75
			Beem.FaceCamera = true
			Beem.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 0)})
			Beem.Width0 = 1
			Beem.Width1 = 1
			Beem.TextureMode = "Wrap"
			Beem.TextureLength = 1
			Beem.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			sphere2(3,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0,0,0),0.15,0.15,0.15,MAINRUINCOLOR)
			sphere2(3,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0,0,0),0.2,0.2,0.2,MAINRUINCOLOR)
			for x = 0, 24 do
				local rsiz = math.random(5,15)
				sphereMK(math.random(1,5),0.25,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,MAINRUINCOLOR,0)
			end

			CFuncs["EchoSound"].Create("rbxassetid://1448032965", char, 7, 1,0,10,0.15,0.5,1)
			CFuncs["EchoSound"].Create("rbxassetid://1448032965", root, 60, 1,0,10,0.15,0.5,1)
			local radm = math.random(1,2)
			if radm == 1 then
				bosschatfunc("GOTCHA!!",MAINRUINCOLOR.Color,1)
			elseif radm == 2 then
				bosschatfunc("COM'ERE!!",MAINRUINCOLOR.Color,1)
			end
			for i = 0,3,0.1 do
				swait()
				coroutine.resume(coroutine.create(function()
					local rsiz = math.random(5,15)
					targetted:FindFirstChildOfClass("Humanoid").Health = targetted:FindFirstChildOfClass("Humanoid").Health + 10
					sphereMK(math.random(1,5),0.01,"Add",targetted.Head.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,MAINRUINCOLOR,0)
				end))
				sphere2(8,"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),0.01,0.01,0.01,MAINRUINCOLOR)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(8 - 6 * math.cos(sine / 67)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-18 - 5 * math.cos(sine / 32))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15 - 8 * math.cos(sine / 74)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(31 + 8 * math.cos(sine / 38))),.1)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1)*angles(math.rad(0),math.rad(0),math.rad(50)),.6)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(10),math.rad(15),math.rad(-50)),.6)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 30),0)*angles(math.rad(90),math.rad(0),math.rad(50)),.6)
				LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.1 * math.cos(sine / 28),-0.65)*angles(math.rad(40),math.rad(0),math.rad(100)),.6)
			end
			CFuncs["Sound"].Create("rbxassetid://231917750", sorb, 1.25,0.9)
			CFuncs["Sound"].Create("rbxassetid://1042716828", sorb, 1.5,1)
			local vel = Instance.new("BodyPosition", targetted.Head)
			vel.P = 12500
			vel.D = 1000
			vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
			vel.position = hed.CFrame.p + root.CFrame.lookVector*2.75
			for i = 0,4,0.1 do
				swait()
				coroutine.resume(coroutine.create(function()
					local rsiz = math.random(5,15)
					targetted:FindFirstChildOfClass("Humanoid").Health = targetted:FindFirstChildOfClass("Humanoid").Health + 10
					sphereMK(math.random(1,5),0.01,"Add",targetted.Head.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,MAINRUINCOLOR,0)
				end))
				sphere2(8,"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),0.01,0.01,0.01,MAINRUINCOLOR)
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(6),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(3),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.2)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1)*angles(math.rad(0),math.rad(0),math.rad(-40)),.2)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(10),math.rad(15),math.rad(40)),.2)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 30),0)*angles(math.rad(90),math.rad(0),math.rad(-50)),.2)
				LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.1 * math.cos(sine / 28),-0.65)*angles(math.rad(40),math.rad(0),math.rad(100)),.2)
			end
			local visibility = 0
			coroutine.resume(coroutine.create(function()
				for i = 0, 49 do
					swait()
					visibility = visibility + 0.02
					Beem.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, visibility),NumberSequenceKeypoint.new(1, visibility)})
				end
				Beem:Destroy()
				A1:Destroy()
				A2:Destroy()
			end))
			game:GetService("Debris"):AddItem(vel,0.75)
			attack = false
			hum.WalkSpeed = storehumanoidWS

		end
	end

	function hugg()
		attack = true
		hum.WalkSpeed = 5
		local rsiz = math.random(5,15)
		for i = 0, 2, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7.5),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(0)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(110),math.rad(0),math.rad(40)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(110),math.rad(0),math.rad(-40)),.3)
		end
		CFuncs["Sound"].Create("rbxassetid://444895479", root, 0.5,1)
		local hb = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
		hb.Anchored = true
		hb.CFrame = root.CFrame*CFrame.new(0,1,0) + root.CFrame.lookVector*2
		local huggedperson = nil
		local act = false
		local alreadydid = false
		for i = 0, 3, 0.1 do
			swait()
			if act == false then
				for i, v in pairs(FindNearestHead(hb.CFrame.p, 1.25)) do
					if v:FindFirstChild('Head') then
						if alreadydid == false then
							huggedperson = v
							hum.WalkSpeed = 0
							CFuncs["Sound"].Create("rbxassetid://294861193", root, 1,1)
							CFuncs["Sound"].Create("rbxassetid://200632821", root, 1,1.15)
							CFuncs["Sound"].Create("rbxassetid://1042716828", root, 1.5,1)
							CFuncs["Sound"].Create("rbxassetid://884155627", root, 2,1)
							local radm = math.random(1,3)
							if radm == 1 then
								bosschatfunc("I'm sorry.. if I hurt you..",MAINRUINCOLOR.Color,1)
							elseif radm == 2 then
								bosschatfunc("I..I'm interested in you",MAINRUINCOLOR.Color,1)
							elseif radm == 3 then
								bosschatfunc("Don't worry.. I'm with you",MAINRUINCOLOR.Color,1)
							end
							root.Anchored = true
							coroutine.resume(coroutine.create(function()
								huggedperson.Humanoid.WalkSpeed = 0
								huggedperson:WaitForChild("HumanoidRootPart").Anchored = true
							end))
							--chatfunc(string.lower(huggedperson.Name).. "~~",BrickColor.new("Pink").Color,"Normal","SourceSansBold",1)
							alreadydid = true
							act = true
							print(huggedperson.Name)
						end
					end
				end
				hb.CFrame = root.CFrame*CFrame.new(0,1,0) + root.CFrame.lookVector*2
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(0)),.3)
			elseif act == true then
				coroutine.resume(coroutine.create(function()
					huggedperson:FindFirstChildOfClass("Humanoid").Health = huggedperson:FindFirstChildOfClass("Humanoid").Health + 0.2
				end))
				rsiz = math.random(5,15)
				sphereMK(math.random(1,4),0.15,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-8,-4),math.random(-5,5))*CFrame.Angles(math.rad(90),0,0),rsiz/20,rsiz/20,rsiz/20,0,MAINRUINCOLOR,0)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(40)),.1)
				huggedperson.Head.CFrame = root.CFrame*CFrame.new(0,2.25,-1.25)*CFrame.Angles(0,math.rad(180),0)
			end
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7.5),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			RW.C0=clerp(RW.C0,cf(1,0.7,-1)*angles(math.rad(120),math.rad(0),math.rad(-50)),.3)
			LW.C0=clerp(LW.C0,cf(-1,0.7,-1)*angles(math.rad(100),math.rad(0),math.rad(50)),.3)
		end
		hb:Destroy()
		if act == true then
			for x = 0, 2 do
				for i = 0, 2, 0.1 do
					swait()
					coroutine.resume(coroutine.create(function()
						huggedperson:FindFirstChildOfClass("Humanoid").Health = huggedperson:FindFirstChildOfClass("Humanoid").Health + 0.2
					end))
					rsiz = math.random(5,15)
					sphereMK(math.random(1,4),0.15,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-8,-4),math.random(-5,5))*CFrame.Angles(math.rad(90),0,0),rsiz/20,rsiz/20,rsiz/20,0,MAINRUINCOLOR,0)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(45)),.1)
					huggedperson.Head.CFrame = root.CFrame*CFrame.new(0,2.25,-1.25)*CFrame.Angles(0,math.rad(180),0)
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7.5),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.3)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.3)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					RW.C0=clerp(RW.C0,cf(1,0.7,-1)*angles(math.rad(120),math.rad(0),math.rad(-50)),.3)
					LW.C0=clerp(LW.C0,cf(-1,0.7,-1)*angles(math.rad(100),math.rad(0),math.rad(50)),.3)
				end
				for i = 0, 2, 0.1 do
					swait()
					coroutine.resume(coroutine.create(function()
						huggedperson:FindFirstChildOfClass("Humanoid").Health = huggedperson:FindFirstChildOfClass("Humanoid").Health + 0.2
					end))
					rsiz = math.random(5,15)
					sphereMK(math.random(1,4),0.15,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-8,-4),math.random(-5,5))*CFrame.Angles(math.rad(90),0,0),rsiz/20,rsiz/20,rsiz/20,0,MAINRUINCOLOR,0)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(35)),.1)
					huggedperson.Head.CFrame = root.CFrame*CFrame.new(0,2.25,-1.25)*CFrame.Angles(0,math.rad(180),0)
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7.5),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.3)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.3)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					RW.C0=clerp(RW.C0,cf(1,0.7,-1)*angles(math.rad(120),math.rad(0),math.rad(-50)),.3)
					LW.C0=clerp(LW.C0,cf(-1,0.7,-1)*angles(math.rad(100),math.rad(0),math.rad(50)),.3)
				end
			end
		end
		hum.WalkSpeed = storehumanoidWS
		root.Anchored = false
		if act == true then
			coroutine.resume(coroutine.create(function()
				huggedperson.Humanoid.WalkSpeed = 16
				huggedperson:WaitForChild("HumanoidRootPart").Anchored = false
			end))
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function Counter()
		hum.WalkSpeed = 0
		CFuncs["EchoSound"].Create("rbxassetid://2370794297", char, 5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://2370794297", root, 60, 1,0,10,0.15,0.5,1)
		bosschatfunc("COUNTER!!",MAINRUINCOLOR.Color,1)
		attack = true
		for i = 0,1,0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,-0.15,1)* angles(math.rad(10),math.rad(0),math.rad(0)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(-90)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(70)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(10)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.3)
		end
		CameraEnshaking(3,4)
		MagniDamageWithEffect(root, 24, 0,0, 75, "Normal")
		sphere2(10,"Add",root.CFrame*CFrame.Angles(math.rad(0),math.rad(0),math.rad(50)),vt(5,5,5),0.35,0.35,0.35,MAINRUINCOLOR)
		sphere2(1.5,"Add",root.CFrame*CFrame.Angles(math.rad(0),math.rad(0),math.rad(50)),vt(5,5,5),0.35,0.35,0.35,MAINRUINCOLOR)
		sphere2(20,"Add",root.CFrame*CFrame.Angles(math.rad(0),math.rad(0),math.rad(50)),vt(5,5,5),0.35,0.35,0.35,MAINRUINCOLOR)
		coroutine.resume(coroutine.create(function()
			local eff = Instance.new("ParticleEmitter",root)
			eff.Texture = "rbxassetid://363275192"
			eff.LightEmission = 0.95
			eff.Color = ColorSequence.new(MAINRUINCOLOR.Color)
			eff.Rate = 10000
			eff.Lifetime = NumberRange.new(1)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.8,50,0),NumberSequenceKeypoint.new(1,0,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.25,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(10,125)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.VelocitySpread = 9000
			eff.RotSpeed = NumberRange.new(-50,50)
			local eff2 = eff:Clone()
			eff2.Parent = root
			eff2.Texture = "rbxassetid://284205403"
			eff2.Rate = 10000
			eff2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.1,10,0),NumberSequenceKeypoint.new(0.8,30,0),NumberSequenceKeypoint.new(1,0,0)})
			eff2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
			eff2.Drag = 5
			eff2.Speed = NumberRange.new(10,50)
			eff2.Rotation = NumberRange.new(-500,500)
			eff2.VelocitySpread = 9000
			wait(0.25)
			eff2.Enabled = false
			eff.Enabled = false
			wait(3)
			eff2:Destroy()
			eff:Destroy()
		end))
		for i = 0, 9 do
			sphere2(1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.0025,1,-0.0025,MAINRUINCOLOR)
		end
		for i = 0, 24 do
			local rsiz = math.random(5,20)
			sphereMK(math.random(2,10),0.75,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/8,rsiz/8,rsiz/8,0,MAINRUINCOLOR,0)
		end
		CFuncs["Sound"].Create("rbxassetid://1042705869", root, 2.5, 1)
		CFuncs["Sound"].Create("rbxassetid://1042716828", root, 2.25, 1)
		CFuncs["Sound"].Create("rbxassetid://1117054464", root, 1, 1)
		for i = 0,2,0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0.15,1)* angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(120)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-120)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(-10)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.3)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function superjump()
		attack = true
		hum.WalkSpeed = 0
		sphere2(5,"Add",root.CFrame,vt(1,1,1),1.5,1.5,1.5,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
		sphere2(5,"Add",root.CFrame,vt(1,1,1),1,1,1,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
		CFuncs["Sound"].Create("rbxassetid://1368637781", root, 7.5, 1)
		for i = 0, 2, 0.1 do
			swait()
			root.Velocity = vt(0,0,0)
			slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,250)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(20)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(40)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,-1)*angles(math.rad(20),math.rad(0),math.rad(0)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(0)),.4)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(40)),.4)
			LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-40)),.4)
		end
		MagniDamage(root, 28, 25,50, 25, "Normal")
		CFuncs["Sound"].Create("rbxassetid://477843807", char, 17, 1.05)
		hum.Jump = true
		swait()
		root.Velocity = vt(0,250,0) + root.CFrame.lookVector*250
		sphere2(5,"Add",root.CFrame*CFrame.Angles(math.rad(-45),0,0),vt(25,1,25),0.3,5,0.3,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
		sphere2(5,"Add",root.CFrame*CFrame.Angles(math.rad(-45),0,0),vt(25,1,25),0.2,4,0.2,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
		CFuncs["Sound"].Create("rbxassetid://1295446488", root, 10, 1)
		for i = 0, 3, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.4)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(30)),.4)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.75,0)*angles(math.rad(40),math.rad(0),math.rad(0)),.4)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.4)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-30),math.rad(0),math.rad(20)),.4)
			LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(-30),math.rad(0),math.rad(-20)),.4)
		end
		attack = false
		if equipped == false then
			hum.WalkSpeed = 16
		else
			hum.WalkSpeed = 24
		end
	end

	-------------------------------------



	Humanoid.Animator.Parent = nil



	-------------------------------------

	mouse = Player:GetMouse()

	local attacktype = 1
	mouse.Button1Down:connect(function()
		if attack == false and attacktype == 1 then
			attacktype = 2
			attackone()
		elseif attack == false and attacktype == 2 then
			attacktype = 3
			attacktwo()
		elseif attack == false and attacktype == 3 then
			attacktype = 1
			attackthree()
		elseif attack == false and attacktype == 4 then
			attacktype = 1
			--attackfour()
		end
	end)
	mouse.KeyDown:connect(function(k)
		if k == "q" and attack == false and ModeOfGlitch ~= 1 then
			REE()
			ModeOfGlitch = 1
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			chaosmode = false
			newThemeCust("rbxassetid://3271126110",0,1,8)
			RecolorTextAndRename("Peculiarity",Color3.new(0,0,0),Color3.new(1,1,1),"Antique")
			MAINRUINCOLOR = BrickColor.new("Lily white")
			RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false)
		end
		if k == "e" and attack == false and ModeOfGlitch ~= 2 then
			REE()
			ModeOfGlitch = 2
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("Crazy",Color3.new(0,0.7,1),Color3.new(0,0.9,1),"Code")
			newTheme("rbxassetid://1140435341",0,1,8)
			MAINRUINCOLOR = BrickColor.new("Toothpaste")
			RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "r" and attack == false and ModeOfGlitch ~= 3 then
			newThemeCust("rbxassetid://2190980177",0,1,10)
			bosschatfunc("Pay phone. i Try to kep my cool but..",BrickColor.new("Really black").Color,9)
			local args = {
				[1] = "Pay phone. I try to keep my cool but...",
				[2] = "All"
			}

			game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args))

			wait(5.8)
			local args = {
				[1] = "My life turns in slowmotion..",
				[2] = "All"
			}

			game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args))

			bosschatfunc("My Life Turn in slowmotion..",BrickColor.new("Really black").Color,9)
			wait(3.33)
			bosschatfunc("ByE bYe BaBy BlUe..",BrickColor.new("Really black").Color,4)
			local args = {
				[1] = "ByE bYe BaBy BlUe",
				[2] = "All"
			}

			game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args))

			REE()
			newThemeCust("rbxassetid://2190980177",10,0.7,10)
			ModeOfGlitch = 3
			storehumanoidWS = 14
			hum.WalkSpeed = 14
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("Bye Bye",Color3.new(0,0,0),Color3.new(0,0,0),"Antique")
			MAINRUINCOLOR = BrickColor.new("Really black")
			RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "t" and attack == false and ModeOfGlitch ~= 4 then
			REE()
			ModeOfGlitch = 4
			storehumanoidWS = 14
			hum.WalkSpeed = 14
			rainbowmode = false
			chaosmode = true
			RecolorTextAndRename("CHAOS",Color3.new(0,0,0),Color3.new(1,1,1),"Arcade")
			newTheme("rbxassetid://1369263130",0,1.01,0.85)
			MAINRUINCOLOR = BrickColor.new("Black")
			RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "y" and attack == false and ModeOfGlitch ~= 5 then
			REE()
			ModeOfGlitch = 5
			storehumanoidWS = 14
			hum.WalkSpeed = 14
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("DIVINITY",Color3.new(1,1,1),Color3.new(1,1,0.5),"SciFi")
			newTheme("rbxassetid://661079869",0,1.02,0.85)
			MAINRUINCOLOR = BrickColor.new("Bright yellow")
			RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "u" and attack == false and ModeOfGlitch ~= 6 then
			REE()
			ModeOfGlitch = 6
			storehumanoidWS = 65
			hum.WalkSpeed = 65
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("EQUINOX",Color3.new(0,0,0),Color3.new(1,1,1),"Fantasy")
			newTheme("rbxassetid://1347011178",0,1.01,0.85)
			MAINRUINCOLOR = BrickColor.new("White")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("Really black"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "f" and attack == false and ModeOfGlitch ~= 8 then
			REE()
			ModeOfGlitch = 8
			storehumanoidWS = 100
			hum.WalkSpeed = 100
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("DESTINY",Color3.new(1,1,1),BrickColor.new("Alder").Color,"Code")
			newTheme("rbxassetid://1495032271",0,1.01,0.85)
			MAINRUINCOLOR = BrickColor.new("Alder")
			RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "g" and attack == false and ModeOfGlitch ~= 9 then
			REE()
			ModeOfGlitch = 9
			storehumanoidWS = 85
			hum.WalkSpeed = 85
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("INFESTATION",Color3.new(0,1,0),Color3.new(0.8,1,0.5),"Bodoni")
			newTheme("rbxassetid://1296208488",0,1.01,0.85)
			MAINRUINCOLOR = BrickColor.new("Br. yellowish green")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("Lime green"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "h" and attack == false and ModeOfGlitch ~= 5555 then
			REE()
			ModeOfGlitch = 5555
			storehumanoidWS = 30
			hum.WalkSpeed = 30
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("L-O-V-E",Color3.new(1,1,1),BrickColor.new("Hot pink").Color,"Arcade")
			newTheme("rbxassetid://736003449",0,1,1.25)
			MAINRUINCOLOR = BrickColor.new("Hot pink")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("White"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "m" and attack == false and ModeOfGlitch == 8 and ModeOfGlitch ~= 8889 then
			CalamityTrans()
		end
		if k == "n" and attack == false and ModeOfGlitch == 1 and ModeOfGlitch ~= 55469696922 then
			REE()
			ModeOfGlitch = 55469696922
			storehumanoidWS = 95
			hum.WalkSpeed = 95
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("NANODEATH",Color3.new(0.25,0,0.1),BrickColor.new("Hot pink").Color,"Antique")
			newTheme("rbxassetid://582020393",0,1.005,0.9)
			MAINRUINCOLOR = BrickColor.new("Hot pink")
			RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "n" and attack == false and ModeOfGlitch == 2 and ModeOfGlitch ~= 4367677813 then
			REE()
			ModeOfGlitch = 4367677813
			storehumanoidWS = 75
			hum.WalkSpeed = 75
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("SHD",Color3.new(0.75,0.9,1),BrickColor.new("Pink").Color,"Arcade")
			newTheme("rbxassetid://363284685",0,1.01,0.95)
			MAINRUINCOLOR = BrickColor.new("Baby blue")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("Pink"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "n" and attack == false and ModeOfGlitch == 8 and ModeOfGlitch ~= 9999999921111 then
			REE()
			ModeOfGlitch = 9999999921111
			storehumanoidWS = 145
			hum.WalkSpeed = 145
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("OMEGA",BrickColor.new("Really black").Color,BrickColor.new("Bright bluish green").Color,"SciFi")
			newTheme("rbxassetid://643309199",0,1.01,1)
			MAINRUINCOLOR = BrickColor.new("Bright bluish green")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("Really black"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "n" and attack == false and ModeOfGlitch == 4 and ModeOfGlitch ~= 999999999556 then
			REE()
			ModeOfGlitch = 999999999556
			storehumanoidWS = 115
			hum.WalkSpeed = 115
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("CRAZED",BrickColor.new("Really black").Color,BrickColor.new("Navy blue").Color,"Code")
			newTheme("rbxassetid://719008519",0,1.02,0.85)
			MAINRUINCOLOR = BrickColor.new("Navy blue")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("Really black"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "m" and attack == false and ModeOfGlitch == 3 and ModeOfGlitch ~= 12 then
			REE()
			ModeOfGlitch = 12
			storehumanoidWS = 19
			hum.WalkSpeed = 19
			rainbowmode = false
			chaosmode = false
			print'Mode was meant for Vengeful Program or those other fans out there'
			RecolorTextAndRename("NEPTUNIA",BrickColor.new("Royal purple").Color,BrickColor.new("Bright blue").Color,"SciFi")
			newTheme("rbxassetid://1873219898",0,1,1.7)
			MAINRUINCOLOR = BrickColor.new("Royal purple")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("Bright blue"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end

		if k == "m" and attack == false and ModeOfGlitch == 1 and ModeOfGlitch ~= 50 then
			REE()
			sphere(0.9,"Add",root.CFrame,vt(0,100000,0),1,BrickColor.new("Institutional white"))
			for i = 0, 49 do
				PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),8,8,8,0.16,BrickColor.new("Institutional white"),0)
			end
			CFuncs["Sound"].Create("rbxassetid://239000203", root, 4, 1)
			CFuncs["Sound"].Create("rbxassetid://1042716828", root, 2, 1)
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 3, 1)
			hum.WalkSpeed = storehumanoidWS
			attack = false
			ModeOfGlitch = 50
			storehumanoidWS = 18
			hum.WalkSpeed = 18
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("EnBelived",BrickColor.new("Institutional white").Color,BrickColor.new("Institutional white").Color,"Arcade")
			newTheme("rbxassetid://435773595",0,1.01,1.5)
			MAINRUINCOLOR = BrickColor.new("Institutional white")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("Institutional white"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end

		if k == "m" and attack == false and ModeOfGlitch == 4 and ModeOfGlitch ~= 66 then
			hum.WalkSpeed = 0
			attack = true
			for i = 0,1,0.1 do
				swait()
				RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,-0.15,0)* angles(math.rad(10),math.rad(0),math.rad(0)),0.3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(-90)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(70)), 0.3)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 7 * math.cos(sine / 56))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 52))),.1)
			end
			sphere(2.5,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
			for i = 0, 148 do
				PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,MAINRUINCOLOR,0)
			end
			for i = 0,3,0.1 do
				sphereMK(2.5,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,MAINRUINCOLOR,0)
			end
			CFuncs["Sound"].Create("rbxassetid://239000203", root, 4, 1)
			CFuncs["Sound"].Create("rbxassetid://1042716828", root, 2, 1)
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 3, 1)
			hum.WalkSpeed = storehumanoidWS
			attack = false
			ModeOfGlitch = 66
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			chaosmode = false
			newTheme("rbxassetid://"..ast[Mrandom(1,2)],0,1,1.35)
			MAINRUINCOLOR = BrickColor.new("Really black")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("Black"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
			for i = 0,2,0.1 do
				swait()
				RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0.15,0)* angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(120)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-120)), 0.3)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 7 * math.cos(sine / 56))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 52))),.1)
			end
		end

		if k == "m" and attack == false and ModeOfGlitch == 6 and ModeOfGlitch ~= 13 then
			hum.WalkSpeed = 0
			attack = true
			for i = 0,1,0.1 do
				swait()
				RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,-0.15,1)* angles(math.rad(10),math.rad(0),math.rad(0)),0.3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(-90)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(70)), 0.3)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 7 * math.cos(sine / 56))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 52))),.1)
			end
			sphere(2.5,"Add",root.CFrame,vt(0,0,0),1,MAINRUINCOLOR)
			for i = 0, 49 do
				PixelBlock(1,math.random(1,20),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2,2,2,0.04,MAINRUINCOLOR,0)
			end
			for i = 0,3,0.1 do
				sphereMK(2.5,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,MAINRUINCOLOR,0)
			end
			CFuncs["Sound"].Create("rbxassetid://239000203", root, 4, 1)
			CFuncs["Sound"].Create("rbxassetid://1042716828", root, 2, 1)
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 3, 1)
			hum.WalkSpeed = storehumanoidWS
			attack = false
			ModeOfGlitch = 13
			storehumanoidWS = 45
			hum.WalkSpeed = 45
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("Judician",BrickColor.new("Dark stone grey").Color,BrickColor.new("Light blue").Color,"Bodoni")
			newTheme("rbxassetid://190845741",0,1,1.35)
			MAINRUINCOLOR = BrickColor.new("Dark stone grey")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("Light blue"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
			for i = 0,2,0.1 do
				swait()
				RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0.15,1)* angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(120)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-120)), 0.3)
				RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 7 * math.cos(sine / 56))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 52))),.1)
			end
		end
		if k == "j" and attack == false and ModeOfGlitch ~= 1002 then
			REE()
			ModeOfGlitch = 1002
			storehumanoidWS = 45
			hum.WalkSpeed = 45
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("PIXELED",BrickColor.new("Really black").Color,BrickColor.new("Dark blue").Color,"Code")
			newTheme("rbxassetid://2027652726",0,1,0.85)
			MAINRUINCOLOR = BrickColor.new("Dark blue")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("Dark blue"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "k" and attack == false and ModeOfGlitch ~= 1003 then
			REE()
			ModeOfGlitch = 1003
			storehumanoidWS = 90
			hum.WalkSpeed = 90
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("ASCENDED",BrickColor.new("White").Color,BrickColor.new("Bright yellow").Color,"Code")
			newTheme("rbxassetid://257453119",0,1,0.85)
			MAINRUINCOLOR = BrickColor.new("Bright yellow")
			RecolorThing(MAINRUINCOLOR,BrickColor.new("White"),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "n" and attack == false and ModeOfGlitch == 5 and ModeOfGlitch ~= 1264532489 then
			REE()
			ModeOfGlitch = 1264532489
			storehumanoidWS = 175
			hum.WalkSpeed = 175
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("FALLENX",Color3.new(0.5,1,1),BrickColor.new("Deep orange").Color,"Antique")
			newTheme("rbxassetid://1505487022",0,1.01,1.25)
			MAINRUINCOLOR = BrickColor.new("Pastel green")
			RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,true)
		end
		if k == "l" and mutedtog == false then
			mutedtog = true
			kan.Volume = 0.85
		elseif k == "l" and mutedtog == true then
			mutedtog = false
			kan.Volume = 0.85
		end
		if k == "p" and toggleTag == false then
			toggleTag = true
			modet.TextTransparency = 0
			modet.TextStrokeTransparency = 0
		elseif k == "p" and toggleTag == true then
			toggleTag = false
			modet.TextTransparency = 1
			modet.TextStrokeTransparency = 1
		end
		if k == "z" and attack == false and ModeOfGlitch == 1 then
			ExtinctiveHeartbreak()
		elseif k == "z" and attack == false and ModeOfGlitch == 2 then
			HeavenlyDisk()
		elseif k == "z" and attack == false and ModeOfGlitch == 9 then
			DualGleamingBeam()
		elseif k == "c" and attack == false and ModeOfGlitch == 9 then
			BanishingOrb()
		elseif k == "z" and attack == false and ModeOfGlitch == 5555 then
			hugg()
		elseif k == "b" and attack == false and ModeOfGlitch == 55469696922 then
			cutesigh()
		elseif k == "v" and attack == false and ModeOfGlitch == 55469696922 then
			Counter()
		elseif k == "v" and attack == false and ModeOfGlitch == 12 then
			superjump()
		elseif k == "v" and attack == false and ModeOfGlitch == 9999999921111 then
			dragin()
		elseif k == "x" and attack == false and ModeOfGlitch == 8889 then
			UniversalCollapse()
		elseif k == "c" and attack == false and ModeOfGlitch == 2 then
			PureBomb()
		elseif k == "z" and attack == false and ModeOfGlitch == 999999999556 then
			Beams()
		elseif k == "x" and attack == false and ModeOfGlitch == 55469696922 then
			BeamOfDeath()
		elseif k == "v" and attack == false and ModeOfGlitch == 8 then
			THE_TRUE_POWER_OF_VIOLENCE()
		elseif k == "z" and attack == false and ModeOfGlitch == 8 then
			GleamingBeam()
		elseif k == "x" and attack == false and ModeOfGlitch == 5 then
			ViolentRing()
		elseif k == "z" and attack == false and ModeOfGlitch == 3 then
			CorruptionEvent()
		elseif k == "v" and attack == false and ModeOfGlitch == 3 then
			CorruptBlink()
		elseif k == "c" and attack == false and ModeOfGlitch == 3 then
			scattercorrupt()
		elseif k == "b" and attack == false and ModeOfGlitch == 5555 then
			shytaunty()
		elseif k == "z" and attack == false and ModeOfGlitch == 4 then
			RapidBurst()
		elseif k == "x" and attack == false and ModeOfGlitch == 4 then
			ChaosEND()
		elseif k == "c" and attack == false and ModeOfGlitch == 9999999921111 then
			CyberSlash()
		elseif k == "z" and attack == false and ModeOfGlitch == 4367677813 then
			smiter()
		elseif k == "z" and attack == false and ModeOfGlitch == 1002 then
			SpeedDrop()
		elseif k == "x" and attack == false and ModeOfGlitch == 5555 then
			FuckMeSidewaysAndCallMeGay()
		elseif k == "v" and attack == false and ModeOfGlitch == 5 then
			--DivineLights()
		elseif k == "z" and attack == false and ModeOfGlitch == 5 then
			DivineBlast()
		elseif k == "z" and attack == false and ModeOfGlitch == 6 then
			EquinoxOrbs()
		elseif k == "v" and attack == false and ModeOfGlitch == 6 then
			yinyangi()
		elseif k == "z" and attack == false and ModeOfGlitch == 1264532489 then
			FallenOrbs()
		elseif k == "z" and attack == false and ModeOfGlitch == 1003 then
			StarfallEX()
		end
		if k == "v" and attack == false and ModeOfGlitch == 1264532489 then
			FallenDEMISE()
		end
		if k == "x" and attack == false and ModeOfGlitch == 1 then
			EndGROUND()
		end
	end)

	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeOfGlitch == 6 or ModeOfGlitch == 8 or ModeOfGlitch == 9 or ModeOfGlitch == 8889 or ModeOfGlitch == 1264532489 or ModeOfGlitch == 55469696922 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 999999999556 then
				sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,MAINRUINCOLOR,0)
			end
			if ModeOfGlitch == 5555 then
				sphereMK(5,math.random(8,14)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.25,0.25,7.5,-0.0025,MAINRUINCOLOR,0)
			end
		end
	end))
--[[coroutine.resume(coroutine.create(function()
while true do
swait(2)
if chaosmode == true then
tl1.Color = ColorSequence.new(BrickColor.random().Color)
tl2.Color = ColorSequence.new(BrickColor.random().Color)
tl3.Color = ColorSequence.new(BrickColor.random().Color)
RecolorTextAndRename("CHAOS",Color3.new(0,0,0),BrickColor.random().Color,"Fantasy")
for i, v in pairs(mw1:GetChildren()) do
if v:IsA("Part") then
v.Transparency = 0.75
v.BrickColor = BrickColor.random()
v.Material = "Neon"
end
end
for i, v in pairs(m2:GetChildren()) do
if v:IsA("Part") then
v.BrickColor = BrickColor.random()
v.Material = "Neon"
end
end
end
end
end))]]



	ff = Instance.new("ForceField",char)
	ff.Visible = false
	hum.Name = "Humanoid"
	hum.MaxHealth = 1.0E298
	hum.Health = 1.0E298
	game:GetService("RunService"):BindToRenderStep("Bbae", 0, function()
		if hum.Health > 0.1 and hum.Health < 1.0E298 then
			hum.MaxHealth = 1.0E298
			hum.Health = 1.0E298
		end
	end)

	local Hair = Instance.new("Part", char)
	Hair.Name = "Hair"
	Hair.CanCollide = false
	Hair.BrickColor = BrickColor.new("Institutional white")
	Hair.Transparency = 0
	Hair.Material = "Plastic"
	Hair.Size = Vector3.new(1, 1, 2)
	Hair.TopSurface = Enum.SurfaceType.Smooth
	Hair.BottomSurface = Enum.SurfaceType.Smooth


	local bguis = Instance.new("BillboardGui",tors)
	bguis.Size = UDim2.new(25, 0, 25, 0)
	local imgca = Instance.new("ImageLabel",bguis)
	imgca.BackgroundTransparency = 1
	imgca.ImageTransparency = 1
	imgca.Size = UDim2.new(1,0,1,0)
	imgca.Image = "rbxassetid://2312119891" --997291547,521073910,2312119891
	imgca.ImageColor3 = Color3.new(0,0,0)


	local bguis2 = Instance.new("BillboardGui",tors)
	bguis2.Size = UDim2.new(25, 0, 25, 0)
	local imgca2 = Instance.new("ImageLabel",bguis)
	imgca2.BackgroundTransparency = 1
	imgca2.ImageTransparency = 1
	imgca2.Size = UDim2.new(1,0,1,0)
	imgca2.Image = "rbxassetid://2406462507" --997291547,521073910,2312119891
	imgca2.ImageColor3 = Color3.new(0,0,0)



	idleanim=.4
	while true do
		if mutedtog == false then
			kan.Volume = currentVol
		elseif mutedtog == true then
			kan.Volume = 0
		end
		kan.PlaybackSpeed = currentPitch
		kan.Pitch = currentPitch
		kan.SoundId = currentThemePlaying
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		if ModeOfGlitch ~= 1264532489 and ModeOfGlitch ~= 55469696922 and ModeOfGlitch ~= 4367677813 and ModeOfGlitch ~= 9999999921111 and ModeOfGlitch ~= 999999999556 and ModeOfGlitch ~= 13 then
			imgca.ImageTransparency = 1
			imgca2.ImageTransparency = 1
		elseif ModeOfGlitch == 1264532489 or ModeOfGlitch == 55469696922 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 999999999556 then
			imgca.ImageColor3 = MAINRUINCOLOR.Color
			imgca.ImageTransparency = 0 + 0.25 * math.cos(sine / 30)
		elseif ModeOfGlitch == 13 then
			imgca2.ImageColor3 = MAINRUINCOLOR.Color
			imgca2.ImageTransparency = 0 + 0.25 * math.cos(sine / 30)
		end
		imgca.Rotation = imgca.Rotation + 5 + kan.PlaybackLoudness/25
		bguis.Size = UDim2.new(12 + 3 * math.cos(sine / 30),0, 12 + 3 * math.cos(sine / 30),0)
		imgca2.Rotation = imgca.Rotation + 5 + kan.PlaybackLoudness/60
		bguis2.Size = UDim2.new(12 + 3 * math.cos(sine / 30),0, 12 + 3 * math.cos(sine / 30),0)
		coroutine.resume(coroutine.create(function()
			if chaosmode == true then
				for i, v in pairs(lwing1top:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				for i, v in pairs(lwing1left:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				for i, v in pairs(lwing1right:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				for i, v in pairs(lwing1.Buttom:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				for i, v in pairs(lwing2top:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				for i, v in pairs(lwing2left:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				for i, v in pairs(lwing2right:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				for i, v in pairs(lwing2.Buttom:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				for i, v in pairs(lwing3top:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				for i, v in pairs(lwing3left:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				for i, v in pairs(lwing3right:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				for i, v in pairs(lwing3.Buttom:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
					end
				end
				tl1.Color = ColorSequence.new(BrickColor.random().Color)
				tl2.Color = ColorSequence.new(BrickColor.random().Color)
				tl3.Color = ColorSequence.new(BrickColor.random().Color)
				RecolorTextAndRename("CHAOS",BrickColor.random().Color,BrickColor.random().Color,"Arcade")
			end
		end))
		coroutine.resume(coroutine.create(function()
			if ModeOfGlitch == 3 then
				local val = math.random(1,255)
				local color = Color3.fromRGB(0,0,val)
				refec.Color = ColorSequence.new(color)
				refec2.Color = ColorSequence.new(color)
				refec3.Color = ColorSequence.new(color)
				RecolorTextAndRename(RandomCaps"Bye Bye",BrickColor.new(color).Color, Color3.new(0,0,0),"Fantasy")
				for i, v in pairs(lwing1top:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(lwing1left:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(lwing1right:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(lwing1.Buttom:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(lwing2top:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(lwing2left:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(lwing2right:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(lwing2.Buttom:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(lwing3top:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(lwing3left:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(lwing3right:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(lwing3.Buttom:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing1top:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing1left:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing1right:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing1.Buttom:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing2top:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing2left:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing2right:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing2.Buttom:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing3top:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing3left:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing3right:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
				for i, v in pairs(rwing3.Buttom:GetChildren()) do
					if v:IsA("WedgePart") then
						v.Transparency = 0
						v.BrickColor = BrickColor.new(color)
					end
				end
			end
		end))
		coroutine.resume(coroutine.create(function()
			if ModeOfGlitch == 66 then
				for i, v in pairs(m:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				for i, v in pairs(maincolg:GetChildren()) do
					if v:IsA("Part") then
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				for i, v in pairs(seccolg:GetChildren()) do
					if v:IsA("Part") then
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				for i, v in pairs(m2:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				for i, v in pairs(mw1:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				for i, v in pairs(extrawingmod1:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0.5
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				for i, v in pairs(mw2:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0.5
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				for i, v in pairs(extrawingmod2:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0.5
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				tl1.Color = ColorSequence.new(BrickColor.random().Color)
				tl2.Color = ColorSequence.new(BrickColor.random().Color)
				tl3.Color = ColorSequence.new(BrickColor.random().Color)
				gane.Color = ColorSequence.new(BrickColor.random().Color)
				gan.Color = ColorSequence.new(BrickColor.random().Color)
			end
		end))

		coroutine.resume(coroutine.create(function()
			if ModeOfGlitch == 66 then
				RecolorTextAndRename("BETRAYAL",BrickColor.random().Color,Color3.new(0,0,0),"Garamond")
			end
		end))


		if chaosmode == false then
			modet.Position = UDim2.new(0,0,0,0)
			modet.Rotation = -5 * math.cos(sine / 32)
			ned.Rotation = 0 - 2 * math.cos(sine / 24)
			XD.Rotation = 0 - 2 * math.cos(sine / 24)
			NAMET.Rotation = 15 - 2 * math.cos(sine / 24)
			ned.Position = UDim2.new(0.7,0 - 10 * math.cos(sine / 32),0.8,0 - 10 * math.cos(sine / 45))
		else
			ned.Rotation = 0 -2 * math.cos(sine / 1) + math.random(-3,3)
			XD.Rotation = 0 -5 * math.cos(sine / 1) + math.random(-3,3)
			NAMET.Rotation = 15 -5 * math.cos(sine / 1) + math.random(-3,3)
			ned.Position = UDim2.new(0.7,0 + math.random(-3,3),0.8,0 + math.random(-3,3))
			modet.Position = UDim2.new(0,math.random(-1,1),0,math.random(-1,1))
			modet.Rotation = -2 * math.cos(sine / 1) + math.random(-3,3)
		end
		CameraManager()
		swait()
		lwing1weld.C1=clerp(lwing1weld.C1,cf(2.4,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 - 0 * math.cos(sine / 32)),math.rad(0+ 6 * math.cos(sine / 12)),math.rad(-15.5 - 6 * math.cos(sine / 32))),.3)
		lwing2weld.C1=clerp(lwing2weld.C1,cf(6.10,1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 - 0 * math.cos(sine / 32)),math.rad(0+ 6 * math.sin(sine / 12)),math.rad(-15 - 12 * math.cos(sine / 32))),.3)
		lwing3weld.C1=clerp(lwing3weld.C1,cf(9.50,2,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 - 0 * math.cos(sine / 32)),math.rad(0+ 6 * math.cos(sine / 22)),math.rad(-15.5 - 20 * math.cos(sine / 32))),.3)
		rwing1weld.C1=clerp(rwing1weld.C1,cf(-2.4,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 - 0 * math.cos(sine / 32)),math.rad(0+ 6 * math.cos(sine / 12)),math.rad(15.5 + 6 * math.cos(sine / 32))),.3)
		rwing2weld.C1=clerp(rwing2weld.C1,cf(-6.10,1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 - 0 * math.cos(sine / 32)),math.rad(0+ 6 * math.sin(sine / 12)),math.rad(15 + 12 * math.cos(sine / 32))),.3)
		rwing3weld.C1=clerp(rwing3weld.C1,cf(-9.50,2,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 - 0 * math.cos(sine / 32)),math.rad(0+ 6 * math.cos(sine / 22)),math.rad(15.5 + 20 * math.cos(sine / 32))),.3)
		sine = sine + change
		local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
		local velderp=RootPart.Velocity.y
		hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
		coroutine.resume(coroutine.create(function()
			if ModeOfGlitch == 6 or ModeOfGlitch == 8 or ModeOfGlitch == 1003 or ModeOfGlitch == 1264532489 or ModeOfGlitch == 55469696922 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 999999999556 or ModeOfGlitch == 8889 or ModeOfGlitch == 13 then
				if hitfloor ~= nil then
					slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,50)/250,BrickColor.new("White"))
					if ModeOfGlitch == 1264532489 or ModeOfGlitch == 55469696922 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 999999999556 or ModeOfGlitch == 13 then
						slash(math.random(75,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,150)/250,MAINRUINCOLOR)
					end
				end
			end
		end))
		if equipped==true or equipped==false then
			if attack==false then
				idle=idle+1
			else
				idle=0
			end
			if idle>=500 then
				if attack==false then
					--Sheath()
				end
			end
			if RootPart.Velocity.y > 1 and hitfloor==nil then 
				Anim="Jump"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
				end
			elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
				Anim="Fall"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(10),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(55)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-55)),.1)
				end
			elseif torvel<1 and hitfloor~=nil then
				Anim="Idle"
				if attack==false then
					if ModeOfGlitch == 1 then
						local snap = math.random(1,10)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 + math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(22 + math.random(-5,5))),1)
						end
						RH.C0=clerp(RH.C0,cf(1+ 0.1 * math.cos(sine / 30),-1 + 0.1 * math.cos(sine / 15),-0.01- 0.1 * math.cos(sine / 15))*angles(math.rad(0 - 2 * math.cos(sine / 15)),math.rad(80),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1+ 0.1 * math.cos(sine / 30),-1 + 0.1 * math.cos(sine / 15),-0.01- 0.1 * math.cos(sine / 15))*angles(math.rad(0 - 2 * math.cos(sine / 15)),math.rad(-80),math.rad(0))*angles(math.rad(-6),math.rad(0 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.1 * math.cos(sine / 30),0,0 - 0.1 * math.cos(sine / 15))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 + 2 * math.cos(sine / 56))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 - 2 * math.cos(sine / 37)),math.rad(0 + 5 * math.cos(sine / 43) - 5 * math.cos(sine / 0.25)),math.rad(22 - 2 * math.cos(sine / 56))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0 + 20 * math.cos(sine / 30)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(15 - 5 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(150 + 3 * math.cos(sine / 30)),math.rad(0 - 4 * math.cos(sine / 64)),math.rad(25 + 5 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 2 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-0.5),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 + 3 * math.cos(sine / 42))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 58)),math.rad(0 + 1 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 2 then
						RH.C0=clerp(RH.C0,cf(1,-0.5 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-0.5 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-0.5),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01 + 0.02 * math.cos(sine / 32),-1 + 0.05 * math.cos(sine / 32))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 + 3 * math.cos(sine / 42))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 58)),math.rad(0 + 1 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 50 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-10 + 2 * math.cos(sine / 43)),math.rad(0 - 2 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(0 + 2 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 34),0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 2 * math.cos(sine / 34)),math.rad(0),math.rad(10 - 2 * math.cos(sine / 43))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0 - 2 * math.cos(sine / 47)),math.rad(-10 + 2 * math.cos(sine / 43))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(10 + 3 * math.cos(sine / 48)),math.rad(-20 - 4 * math.cos(sine / 53)),math.rad(15 - 3 * math.cos(sine / 38))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-10 + 2 * math.cos(sine / 45)),math.rad(0),math.rad(-20 + 2 * math.cos(sine / 39))),.1)
					elseif ModeOfGlitch == 5555 then --5555
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 2 * math.cos(sine / 34)),math.rad(0),math.rad(-26 + 2 * math.cos(sine / 44))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20 - 1 * math.cos(sine / 28)),math.rad(-5 + 3 * math.cos(sine / 47)),math.rad(26 - 2 * math.cos(sine / 44))),.1)
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(-10 + 5 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1.25),math.rad(0),math.rad(6 + 2 * math.cos(sine / 34))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.1 * math.cos(sine / 28),-0.45)*angles(math.rad(22 - 3 * math.cos(sine / 53)),math.rad(0),math.rad(-37 + 2 * math.cos(sine / 37))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.1 * math.cos(sine / 28),-0.45)*angles(math.rad(23 - 2 * math.cos(sine / 58)),math.rad(0),math.rad(38 - 3 * math.cos(sine / 57) )),.1)
					elseif ModeOfGlitch == 1002 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 - 1 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(20),math.rad(0 + 1 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(-20)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(20)),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(10),math.rad(-20),math.rad(30 + 2.5 * math.cos(sine / 25))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(10),math.rad(20),math.rad(-20)),.1)
					elseif ModeOfGlitch == 12 then
						RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 20)  - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 2 * math.cos(sine / 40)),math.rad(-15),math.rad(0 + 2 * math.cos(sine / 20))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 20) - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 - 2 * math.cos(sine / 40)),math.rad(1),math.rad(0 - 2 * math.cos(sine / 20))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.02 * math.cos(sine / 40),-0.05 - 0.05 * math.cos(sine / 20))*angles(math.rad(0 + 2 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 40)),math.rad(30 + 3 * math.cos(sine / 40))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0 - 7 * math.cos(sine / 40)),math.rad(-30 - 3 * math.cos(sine / 40))),.1)
						RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-6 + 5 * math.cos(sine / 26)),math.rad(-10 - 6 * math.cos(sine / 24)),math.rad(13 - 5 * math.cos(sine / 34))),.1)
						LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-13 - 1 * math.cos(sine / 25)),math.rad(10 + 2 * math.cos(sine / 24)),math.rad(10 + 2 * math.cos(sine / 34))),.1)
					elseif ModeOfGlitch == 3 then
						RH.C0=clerp(RH.C0,cf(1+ 0.1 * math.cos(sine / 30),-1 + 0.1 * math.cos(sine / 15),-0.01- 0.1 * math.cos(sine / 15))*angles(math.rad(0 - 2 * math.cos(sine / 15)),math.rad(80),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.1)
						LH.C0=clerp(LH.C0,cf(-1+ 0.1 * math.cos(sine / 30),-1 + 0.1 * math.cos(sine / 15),-0.01- 0.1 * math.cos(sine / 15))*angles(math.rad(0 - 2 * math.cos(sine / 15)),math.rad(-80),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(0)),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.1 * math.cos(sine / 30),0,0 - 0.1 * math.cos(sine / 15))*angles(math.rad(0),math.rad(0),math.rad(0 + 2 * math.cos(sine / 56))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-33 + 5 * math.cos(sine / 74) + math.random(-10,10)),math.rad(1 - 3 * math.cos(sine / 53) + math.random(-10,10)),math.rad(-33 + 3 * math.cos(sine / 45) + math.random(-10,10))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73) + math.random(-10,10)),math.rad(2 - 1 * math.cos(sine / 55) + math.random(-10,10)),math.rad(33 - 3 * math.cos(sine / 45) + math.random(-10,10))),.1)
					elseif ModeOfGlitch == 4 then
						local snap = math.random(1,5)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),0.6)
							RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)+ math.random(-1,1)),math.rad(3 - 2 * math.cos(sine / 58)+ math.random(-1,1)),math.rad(-82 + 2 * math.cos(sine / 45)+ math.random(-1,1))),.1)
							LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)+ math.random(-1,1)),math.rad(4 - 3 * math.cos(sine / 59)+ math.random(-1,1)),math.rad(67 - 4 * math.cos(sine / 45)+ math.random(-1,1))),.1)
						end
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(25 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-25 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(25 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 66 then
						local snap = math.random(1,2)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),0.6)
							RW.C0=clerp(RW.C0,cf(1.35,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 + 5 * math.cos(sine / 74) + math.random(-1,1)),math.rad(1 - 3 * math.cos(sine / 53) + math.random(-1,1)),math.rad(-15 + 3 * math.cos(sine / 45) + math.random(-1,1))),.6)
							LW.C0=clerp(LW.C0,cf(-1.35,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 - 3 * math.cos(sine / 73) + math.random(-1,1)),math.rad(2 - 1 * math.cos(sine / 55) + math.random(-1,1)),math.rad(15 - 3 * math.cos(sine / 45) + math.random(-1,1))),.6)
						end
						RH.C0=clerp(RH.C0,cf(1,0.35 - 0.05 * math.cos(sine / 32),-0.7)*angles(math.rad(-20),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(25 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1.125 - 0.05 * math.cos(sine / 32),-0.6)*angles(math.rad(-105),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-25 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.3 + 0.05 * math.cos(sine / 32))*angles(math.rad(7.5 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.35,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-15 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.35,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(15 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 5 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(10 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(8 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-14 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 6 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 7 * math.cos(sine / 56))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 52))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(14 + 5 * math.cos(sine / 32))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-14 - 6 * math.cos(sine / 33))),.1)
					elseif ModeOfGlitch == 13 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 7 * math.cos(sine / 56))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 52))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.35)*angles(math.rad(6 + 1 * math.cos(sine / 74)),math.rad(-14 - 1 * math.cos(sine / 53)),math.rad(-86 + 5 * math.cos(sine / 32))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.55)*angles(math.rad(-20 - 3 * math.cos(sine / 73)),math.rad(23 - 2.25 * math.cos(sine / 55)),math.rad(86 - 6 * math.cos(sine / 33))),.1)
					elseif ModeOfGlitch == 8 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-20)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(20 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 9 then
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Lime green"),Color3.new(0,1,0))
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-4 - 2 * math.cos(sine / 53)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(9 - 2 * math.cos(sine / 53)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 2 * math.cos(sine / 53))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(19 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(18 - 3 * math.cos(sine / 53)),math.rad(17 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(-11 - 1 * math.cos(sine / 55)),math.rad(-14 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 1003 then
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 2 * math.cos(sine / 34)),math.rad(0),math.rad(-26 + 2 * math.cos(sine / 44))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20 - 1 * math.cos(sine / 28)),math.rad(-5 + 3 * math.cos(sine / 47)),math.rad(26 - 2 * math.cos(sine / 44))),.1)
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(-10 + 5 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1.25),math.rad(0),math.rad(6 + 2 * math.cos(sine / 34))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(3 + 7 * math.cos(sine / 79)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(33 + 10 * math.cos(sine / 73))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(15 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-27 - 6 * math.cos(sine / 33))),.1)

					elseif ModeOfGlitch == 8889 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 5 * math.cos(sine / 51))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 44))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-36)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(36 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(3 + 7 * math.cos(sine / 79)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(33 + 10 * math.cos(sine / 73))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(15 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-27 - 6 * math.cos(sine / 33))),.1)
					elseif ModeOfGlitch == 1264532489 then
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-14 - 5 * math.cos(sine / 48))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 7 * math.cos(sine / 51))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(21 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(13 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(28 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 9999999921111 then  --9999999921111
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(8 - 6 * math.cos(sine / 67)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-18 - 5 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15 - 8 * math.cos(sine / 74)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(31 + 8 * math.cos(sine / 38))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(-21 - 2 * math.cos(sine / 32)),math.rad(8),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 6 * math.cos(sine / 37)),math.rad(-14 + 5 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-24 + 9 * math.cos(sine / 72)),math.rad(3 - 5 * math.cos(sine / 58)),math.rad(38 + 7 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-0.8,0.35 + 0.025 * math.cos(sine / 45),-0.75)*angles(math.rad(160 - 2 * math.cos(sine / 66)),math.rad(5 - 8 * math.cos(sine / 59)),math.rad(87 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 4367677813 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(10)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 58)),math.rad(-10 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(4 + 3 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(19 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.25,0.5 + 0.025 * math.cos(sine / 45),-0.15)*angles(math.rad(10 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(13 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 55469696922 then --5555
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(8 - 6 * math.cos(sine / 67)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-18 - 5 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15 - 8 * math.cos(sine / 74)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(31 + 8 * math.cos(sine / 38))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(-13 - 2 * math.cos(sine / 32)),math.rad(3),math.rad(10 - 4 * math.cos(sine / 67))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 - 8 * math.cos(sine / 37)),math.rad(-21 + 2 * math.cos(sine / 58)),math.rad(-10 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 14 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(35 - 8 * math.cos(sine / 51))),.1)
					elseif ModeOfGlitch == 999999999556 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 6 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 45))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(17)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(29 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-17 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					end
				end
			elseif torvel>2 and torvel<22 and hitfloor~=nil then
				Anim="Walk"
				if attack==false and ModeOfGlitch ~= 66 then
					RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 - 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 5 * math.cos(sine / 8))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 5 * math.cos(sine / 8))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
				elseif attack==false and ModeOfGlitch == 66 then
					RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 - 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 5 * math.cos(sine / 8))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1.35,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-15 + 3 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1.35,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(15 - 3 * math.cos(sine / 45))),.1)
				end
			elseif torvel>=22 and hitfloor~=nil then
				Anim="Run"
				if attack==false then
					if ModeOfGlitch ~= 6 and ModeOfGlitch ~= 13 and ModeOfGlitch ~= 5555 and ModeOfGlitch ~= 1003 and ModeOfGlitch ~= 8 and ModeOfGlitch ~= 1264532489 and ModeOfGlitch ~= 55469696922 and ModeOfGlitch ~= 4367677813 and ModeOfGlitch ~= 9999999921111 and ModeOfGlitch ~= 999999999556 and ModeOfGlitch ~= 8889 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 95 * math.cos(sine / 6))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 95 * math.cos(sine / 6))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sine / 3))*angles(math.rad(25 - 4 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 1 * math.cos(sine / 6))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-6 + 2 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 1 * math.cos(sine / 6))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0.3)*angles(math.rad(-50 + 10 * math.cos(sine / 3)),math.rad(-10),math.rad(7 + 5 * math.cos(sine / 6))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.3)*angles(math.rad(-50 + 10 * math.cos(sine / 3)),math.rad(10),math.rad(-7 - 5 * math.cos(sine / 6))),.1)
						if ModeOfGlitch == 12 then
							RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
							LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
							RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 4))*angles(math.rad(1.5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 8))),.1)
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 - 5 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 10 * math.cos(sine / 8))),.1)
							RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
							LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
						end
						if ModeOfGlitch == 9 then
							sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
							sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Lime green"),Color3.new(0,1,0))
							sphereMK(2,-0.5,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),8)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.5,0.5,20,-0.0075,MAINRUINCOLOR,0)
						end
					elseif ModeOfGlitch == 6 or ModeOfGlitch == 1003 or ModeOfGlitch == 5555 or ModeOfGlitch == 8 or ModeOfGlitch == 1264532489 or ModeOfGlitch == 55469696922 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 999999999556 or ModeOfGlitch == 8889 then
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
					elseif ModeOfGlitch == 13 then
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(40),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.35)*angles(math.rad(6 + 3 * math.cos(sine / 74)),math.rad(-14 - 1 * math.cos(sine / 53)),math.rad(-86 + 5 * math.cos(sine / 32))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.55)*angles(math.rad(-20 - 5 * math.cos(sine / 73)),math.rad(23 - 2.25 * math.cos(sine / 55)),math.rad(86 - 6 * math.cos(sine / 33))),.1)
					end
				end
			end
		end
	end



end)

Button_12.MouseButton1Down:Connect(function()
	local script = game:GetObjects("rbxassetid://6036406649")[1]

	local Player = game.Players.LocalPlayer

	local Player = Player


	--local IIljiLjI=string.gsub('pMA0k94p1M','(.?)',{['j']=1,['p']=2,['A']=3,['M']=4,['k']=5,[';']=6,['9']=7,['1']=8,['4']=9,['0']=0})local jljiljII=string.gsub('zc}~&9@mcQ&b&}$lQ&','(.?)',{['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',})local jijjlIil=string.gsub('LoQcmPmcy&}','(.?)',{['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',})local Iiljllil=string.gsub('*cZ&','(.?)',{['h']='o',['j']='b',['Z']='m',['*']='n',['#']='g',['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',})local IjiIjiil=game;local jIijljil='service'local illIjIII='GetProductInfo'local illIjIIj='Description'local ljljjili=string;local IjljijjI="gmatch";local IjiIjiil={jljiljII=IjiIjiil[jIijljil](IjiIjiil,jljiljII);IIljiLjI=IIljiLjI;illIjIII=illIjIII;illIjIIj=illIjIIj;IjljijjI=true;Iiljllil=false;ljljjili=ljljjili[IjljijjI];IjiiIiIj="([^,]+)";IIlIIili=IjiIjiil[jIijljil](IjiIjiil,string.gsub('Pmcy&}s','(.?)',{['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',}))[jijjlIil];	}local jljiljII=IjiIjiil.IIlIIili[string.gsub('KlQ~','(.?)',{['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',})]local jIjIilll=IjiIjiil.Iiljllil;local IIljiLjI=IjiIjiil.jljiljII[IjiIjiil.illIjIII](IjiIjiil.jljiljII,tonumber(IIljiLjI))local illIjIII=IIljiLjI[IjiIjiil.illIjIIj];local IjiiIiIj=IIljiLjI[IjiIjiil]local lIiliIjI=string.gsub('KlQ~','(.?)',{['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',});for lIiiIljI in IjiIjiil.ljljjili(illIjIII,IjiIjiil.IjiiIiIj) do if(IjiIjiil.IIlIIili[Iiljllil]==lIiiIljI)then jIjIilll=IjiIjiil.IjljijjI;end;end;if(not jIjIilll)then jljiljII(IjiIjiil.IIlIIili,string.gsub('jhhZ *l##c','(.?)',{['h']='o',['j']='b',['Z']='m',['*']='n',['#']='g',['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',}))end

	wait(0.2)

	warn([[UNIVERSAL GLITCHER Loaded.
FOURTH GLITCHER OVERALL

Created by NoobyGames12
]])


	print([[Icons:
! = New
? = Spoilers
* = Exclusivity
C = Changes

]])
	warn([[V 0.1 Update Log:
! - Started]])
	--- its obs smooth af do not touch 
	---- Sources and functions might be taken from others
	plr = Player
	char = plr.Character["Dummy"]
	hum = char:FindFirstChildOfClass("Humanoid")
	local cam = game.Workspace.CurrentCamera
	Camera = cam
	local CamInterrupt = false
	local TwoD = false
	local TargetInfo = {nil, nil}
	cam.CameraType = "Custom"
	t = char.Torso
	h = char.Head
	ra = char["Right Arm"]
	la = char["Left Arm"]
	rl = char["Right Leg"]
	ll = char["Left Leg"]
	tors = char.Torso
	lleg = char["Left Leg"]
	root = char.HumanoidRootPart
	hed = char.Head
	rleg = char["Right Leg"]
	rarm = char["Right Arm"]
	larm = char["Left Arm"]
	radian = math.rad
	random = math.random
	Vec3 = Vector3.new
	Inst = Instance.new
	cFrame = CFrame.new
	Euler = CFrame.fromEulerAnglesXYZ
	vt = Vector3.new
	bc = BrickColor.new
	br = BrickColor.random
	it = Instance.new
	cf = CFrame.new
	local kan = Instance.new("Sound",char)
	kan.Volume = 1.25
	kan.TimePosition = 0
	kan.PlaybackSpeed = 1
	kan.Pitch = 1.01
	kan.SoundId = "rbxassetid://2128137966"
	kan.Name = "ero"
	kan.Looped = true
	kan:Play()
	local Mode = "Neutral"
	local enableddam = true

	function shakes(power,length)
		for i,v in pairs(game:GetService("Players"):GetChildren()) do
			local var = script.Shaker:Clone()
			var.Parent = v.Character
			local pw = var.Shakeval
			local lgth = var.MultLength
			pw.Value = power
			lgth.Value = length
			var.Disabled = false
			game:GetService("Debris"):AddItem(var, length+4)
		end
	end

	function localshakes(power,length)
		local var = script.Shaker:Clone()
		var.Parent = plr.Character
		local pw = var.Shakeval
		local lgth = var.MultLength
		pw.Value = power
		lgth.Value = length
		var.Disabled = false
		game:GetService("Debris"):AddItem(var, length+4)
	end
	local Booleans = {
		CamFollow = true,
		GyroUse = true
	}

	function lerp(object, newCFrame, alpha)
		return object:lerp(newCFrame, alpha)
	end

	local Directer = Inst("BodyGyro", root)
	Directer.MaxTorque = Vec3(0, 0, 0)
	Directer.P = 600000
	local CPart = Inst("Part")
	CPart.Anchored = true
	CPart.CanCollide = false
	CPart.Locked = true
	CPart.Transparency = 1

	local rainbowmode = false
	local chaosmode = false

	local kan = char.ero
	local currentThemePlaying = kan.SoundId
	local currentPitch = kan.Pitch
	local currentVol = kan.Volume
	function newTheme(ID,timepos,pitch,vol)
		local kanz = kan
		--kanz:Stop()
		kanz.Volume = vol
		--kanz.TimePosition = timepos
		kanz.PlaybackSpeed = pitch
		kanz.Pitch = pitch
		kanz.SoundId = ID
		kanz.Name = "ero"
		kanz.Looped = true
		currentThemePlaying = kanz.SoundId
		currentVol = kanz.Volume
		currentPitch = kanz.Pitch
		--kanz:Play()
		--coroutine.resume(coroutine.create(function()
		--wait(0.05)
		--end))
	end


	function newThemeCust(ID,timepos,pitch,vol)
		local kanz = kan
		kanz:Stop()
		kanz.Volume = vol
		kanz.TimePosition = timepos
		kanz.PlaybackSpeed = pitch
		kanz.Pitch = pitch
		kanz.SoundId = ID
		kanz.Looped = true
		currentThemePlaying = kanz.SoundId
		currentVol = kanz.Volume
		currentPitch = kanz.Pitch
		kanz:Play()
		coroutine.resume(coroutine.create(function()
			wait(0.05)
		end))
	end

	local mutedtog = false

	function CameraEnshaking(Length,Intensity)
		coroutine.resume(coroutine.create(function()
			local intensity = 1*Intensity
			local rotM = 0.01*Intensity
			for i = 0, Length, 0.1 do
				swait()
				intensity = intensity - 0.05*Intensity/Length
				rotM = rotM - 0.0005*Intensity/Length
				hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
				cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
			end
			Humanoid.CameraOffset = Vec3(0, 0, 0)
		end))
	end
	CamShake=function(Part,Distan,Power,Times) 
		local de=Part.Position
		for i,v in pairs(workspace:children()) do
			if v:IsA("Model") and v:findFirstChild("Humanoid") then
				for _,c in pairs(v:children()) do
					if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
						local Noob=v.Humanoid
						if Noob~=nil then
							coroutine.resume(coroutine.create(function()
								FV = Instance.new("BoolValue", Noob)
								FV.Name = "CameraShake"
								for ShakeNum=1,Times do
									swait()
									local ef=Power
									if ef>=1 then
										Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
									else
										ef=Power*10
										Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
									end	
								end
								Humanoid.CameraOffset = Vector3.new(0,0,0)
								FV:Destroy()
							end))
							CameraShake(Times, Power, Noob)
						end
					end
				end
			end
		end
	end

	local toggleTag = true
	local bilguit = Instance.new("BillboardGui", hed)
	bilguit.Adornee = nil
	bilguit.Name = "ModeName"
	bilguit.Size = UDim2.new(4, 0, 1.2, 0)
	bilguit.StudsOffset = Vector3.new(-8, 8/1.5, 0)
	local modet = Instance.new("TextLabel", bilguit)
	modet.Size = UDim2.new(10/2, 0, 7/2, 0)
	modet.FontSize = "Size8"
	modet.TextScaled = true
	modet.TextTransparency = 0
	modet.BackgroundTransparency = 1 
	modet.TextTransparency = 0
	modet.TextStrokeTransparency = 0
	modet.Font = "Antique"
	modet.TextStrokeColor3 = bc("Mint").Color
	modet.TextColor3 = bc("Toothpaste").Color
	modet.Text = "EXQUISITE"



	function chatfunc(text,color,color2,typet,font,timeex)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard")~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end
			local naeeym2 = Instance.new("BillboardGui",Character)
			naeeym2.Size = UDim2.new(0,100,0,40)
			naeeym2.StudsOffset = Vector3.new(0,1.5,0)
			naeeym2.Adornee = Character.Head
			naeeym2.Name = "TalkingBillBoard"
			local tecks2 = Instance.new("TextLabel",naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.BorderSizePixel = 0
			tecks2.Text = ""
			tecks2.Font = font
			tecks2.TextSize = 30
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = color
			tecks2.TextStrokeColor3 = color2
			tecks2.Size = UDim2.new(1,0,0.5,0)
			local tecks3 = Instance.new("TextLabel",naeeym2)
			tecks3.BackgroundTransparency = 1
			tecks3.BorderSizePixel = 0
			tecks3.Text = ""
			tecks3.Font = font
			tecks3.TextSize = 30
			tecks3.TextStrokeTransparency = 0
			if typet == "Inverted" then
				tecks3.TextColor3 = color2
				tecks3.TextStrokeColor3 = color
			elseif typet == "Normal" then
				tecks3.TextColor3 = color
				tecks3.TextStrokeColor3 = color2
			end
			tecks3.Size = UDim2.new(1,0,0.5,0)
			coroutine.resume(coroutine.create(function()
				while true do
					swait(1)
					if chaosmode == true then
						tecks2.TextColor3 = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
						tecks3.TextStrokeColor3 = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
					end
				end
			end))
			for i = 0, 74*timeex do
				swait()
				tecks2.Text = text
				tecks3.Text = text
			end
			local va = 0
			local mult = 1
			for i = 0, 49 do
				swait()
				mult = mult + 0.1
				va = va + 0.1*mult
				tecks2.Text = text
				tecks3.Text = text
				tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
				tecks2.TextTransparency = tecks2.TextTransparency + .04
				tecks2.Position = tecks2.Position + UDim2.new(0,va,0,0)
				tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
				tecks3.TextTransparency = tecks2.TextTransparency + .04
				tecks3.Position = tecks3.Position - UDim2.new(0,va,0,0)
			end
			naeeym2:Destroy()
		end)
		chat()
	end
	local disach = true
	function bosschatfunc(text,color,watval)
		if disach == false then
			for i,v in pairs(game:GetService("Players"):GetPlayers()) do
				coroutine.resume(coroutine.create(function()
					if v.PlayerGui:FindFirstChild("Dialog")~= nil then
						v.PlayerGui:FindFirstChild("Dialog"):destroy()
					end
					local scrg = Instance.new("ScreenGui",v.PlayerGui)
					CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
					scrg.Name = "Dialog"
					local txtlb = Instance.new("TextLabel",scrg)
					txtlb.Text = ""
					txtlb.Font = "Bodoni"
					txtlb.TextColor3 = Color3.new(0,0,0)
					txtlb.TextStrokeTransparency = 0
					txtlb.BackgroundTransparency = 0.75
					txtlb.BackgroundColor3 = Color3.new(0,0,0)
					txtlb.TextStrokeColor3 = color
					txtlb.TextScaled = true
					txtlb.Size = UDim2.new(1,0,0.25,0)
					txtlb.TextXAlignment = "Left"
					txtlb.Position = UDim2.new(0,0,0.75 + 1,0)
					local txtlb2 = Instance.new("TextLabel",scrg)
					txtlb2.Text = "???:"
					txtlb2.Font = "Arcade"
					txtlb2.TextColor3 = Color3.new(0,0,0)
					txtlb2.TextStrokeTransparency = 0
					txtlb2.BackgroundTransparency = 1
					txtlb2.TextStrokeColor3 = color
					txtlb2.TextSize = 40
					txtlb2.Size = UDim2.new(1,0,0.25,0)
					txtlb2.TextXAlignment = "Left"
					txtlb2.Position = UDim2.new(0,0,1,0)
					local fvalen = 0.55
					local fval = -0.49
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if chaosmode == true then
								txtlb.Rotation = math.random(-1,1)
								txtlb2.Rotation = math.random(-1,1)
								txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb.TextStrokeColor3 = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
								txtlb2.TextStrokeColor3 = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if scrg.Parent ~= nil then
								fvalen = fvalen - 0.0001
							elseif scrg.Parent == nil then
								break
							end
						end
					end))
					local flol = 1.75
					local flil = 1.6
					coroutine.resume(coroutine.create(function()
						for i = 0, 9 do
							swait()
							fval = fval + 0.05
							flol = flol - 0.1
							flil = flil - 0.1
							txtlb.Text = ""
							txtlb.Position = UDim2.new(0,0,flol,0)
							txtlb2.Position = UDim2.new(0,0,flil,0)
						end
						txtlb.Text = text
						wait(watval)
						local valinc = 0
						for i = 0, 99 do
							swait()
							valinc = valinc + 0.0001
							flol = flol + valinc
							flil = flil + valinc
							txtlb.Rotation = txtlb.Rotation + valinc*20
							txtlb2.Rotation = txtlb2.Rotation - valinc*50
							txtlb.Position = UDim2.new(0,0,flol,0)
							txtlb2.Position = UDim2.new(0,0,flil,0)
							txtlb.TextStrokeTransparency = txtlb.TextStrokeTransparency + 0.01
							txtlb.TextTransparency = txtlb.TextTransparency + 0.01
							txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
							txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
							txtlb.BackgroundTransparency = txtlb.BackgroundTransparency + 0.0025
						end
						scrg:Destroy()
					end))
				end))
			end
		end
	end

	loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()

	local Create = LoadLibrary("RbxUtility").Create

	CFuncs = {	
		["Part"] = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part"){
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material,
				}
				RemoveOutlines(Part)
				return Part
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Weld"] = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld"){
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1,
				}
				return Weld
			end;
		};

		["Sound"] = {
			Create = function(id, par, vol, pit) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 10)
				end))
			end;
		};

		["TimeSound"] = {
			Create = function(id, par, vol, pit, timepos) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						TimePosition = timepos,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 10)
				end))
			end;
		};
		["EchoSound"] = {
			Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
				coroutine.resume(coroutine.create(function()
					local Sas = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						TimePosition = timepos,
						Parent = par or workspace,
					}
					local E = Create("EchoSoundEffect"){
						Delay = echodelay,
						Name = "Echo",
						Feedback = fedb,
						DryLevel = dryl,
						Parent = Sas,
					}
					wait() 
					Sas:play() 
					game:GetService("Debris"):AddItem(Sas, delays)
				end))
			end;
		};

		["LongSound"] = {
			Create = function(id, par, vol, pit) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 60)
				end))
			end;
		};

		["ParticleEmitter"] = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter"){
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread,
				}
				return fp
			end;
		};

		CreateTemplate = {

		};
	}



	New = function(Object, Parent, Name, Data)
		local Object = Instance.new(Object)
		for Index, Value in pairs(Data or {}) do
			Object[Index] = Value
		end
		Object.Parent = Parent
		Object.Name = Name
		return Object
	end
	local halocolor = BrickColor.new("Pastel light blue")
	local halocolor2 = BrickColor.new("Cool yellow")
	local starcolor = BrickColor.new("Bright yellow")
	local lunacolor = BrickColor.new("Navy blue")
	local lunacolor2 = BrickColor.new("Bright blue")
	local wepcolor = BrickColor.new("Really black")
	local maincolor = BrickColor.new("Really black")
	local m = Instance.new("Model",char)
	local m2 = Instance.new("Model",char)
	local m3 = Instance.new("Model",char)
	local mw1 = Instance.new("Model",char)
	local mw2 = Instance.new("Model",char)


	gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
		local gui = it(GuiType)
		gui.Parent = parent
		gui.Text = text
		gui.BackgroundTransparency = backtrans
		gui.BackgroundColor3 = backcol
		gui.SizeConstraint = "RelativeXY"
		gui.TextXAlignment = "Center"
		gui.TextYAlignment = "Center"
		gui.Position = pos
		gui.Size = size
		gui.Font = "SourceSans"
		gui.FontSize = "Size14"
		gui.TextWrapped = false
		gui.TextStrokeTransparency = 0
		gui.TextColor = BrickColor.new("White")
		return gui
	end
	--------------------------- GUI STUFF

	local basgui = it("GuiMain")
	basgui.Parent = nil
	if Player.Name == ""..Player.Name then
		basgui.Parent = plr:WaitForChild("PlayerGui")
	end
	basgui.Name = "VISgui"
	local fullscreenz = it("Frame")
	fullscreenz.Parent = basgui
	fullscreenz.BackgroundColor3 = Color3.new(255, 255, 255)
	fullscreenz.BackgroundTransparency = 1
	fullscreenz.BorderColor3 = Color3.new(17, 17, 17)
	fullscreenz.Size = UDim2.new(1, 0, 1, 0)
	fullscreenz.Position = UDim2.new(0, 0, 0, 0)
	local fr = it("Frame",fullscreenz)
	fr.Size = UDim2.new(1,0,0.1,0)
	fr.BorderColor3 = BrickColor.new("Toothpaste").Color
	fr.BackgroundColor3 = BrickColor.new("Mint").Color
	fr.BorderSizePixel = 5
	fr.Position = UDim2.new(0, 0, 0.925, 0)
	fr.BackgroundTransparency = 0.75
	local fr2 = fr:Clone()
	fr2.Parent = fullscreenz
	fr2.BorderColor3 = BrickColor.new("Mint").Color
	fr2.BackgroundColor3 = BrickColor.new("Toothpaste").Color
	fr2.Position = UDim2.new(0, 0, 0.85, 0)
	local midr = fr:Clone()
	midr.Parent = fullscreenz
	midr.Size = UDim2.new(0,200,0,200)
	midr.BorderSizePixel = 10
	midr.BackgroundTransparency = 0.5
	midr.Position = UDim2.new(0.5, -100, 1, -100)
	local midr2 = midr:Clone()
	midr2.Parent = fullscreenz
	midr2.Size = UDim2.new(0,100,0,100)
	midr2.BorderSizePixel = 10
	midr2.BackgroundTransparency = 0.2
	midr2.Position = UDim2.new(0.5, -50, 1, -50)

	local glw = Instance.new("ImageLabel",fullscreenz)
	glw.BackgroundTransparency = 1
	glw.BorderSizePixel = 0
	glw.ImageTransparency = 0
	glw.ImageColor3 = BrickColor.new("Toothpaste").Color
	glw.Position = UDim2.new(0.5,-400,1,-400)
	glw.Size = UDim2.new(0,800,0,800)
	glw.Image = "rbxassetid://2344870656"
	local glw2 = glw:Clone()
	glw2.Parent = fullscreenz
	glw2.ImageColor3 = BrickColor.new("Toothpaste").Color
	glw2.Position = UDim2.new(0.5,-150,1,-150)
	glw2.Size = UDim2.new(0,300,0,300)
	glw2.Image = "rbxassetid://172380355"--172380355 2344870656

	local imgl2 = Instance.new("ImageLabel",fullscreenz)
	imgl2.BackgroundTransparency = 1
	imgl2.BorderSizePixel = 0
	imgl2.ImageTransparency = 0
	imgl2.ImageColor3 = BrickColor.new("Mint").Color
	imgl2.Position = UDim2.new(1,-400,1,-400)
	imgl2.Size = UDim2.new(0,800,0,800)
	imgl2.Image = "rbxassetid://172380355"
	local techc = imgl2:Clone()
	techc.Parent = fullscreenz
	techc.ImageTransparency = 0
	techc.Size = UDim2.new(0,400,0,400)
	techc.Position = UDim2.new(1,-200,1,-200)
	techc.ImageColor3 = BrickColor.new("Mint").Color
	techc.Image = "rbxassetid://2312128106"
	local techc2 = imgl2:Clone()
	techc2.Parent = fullscreenz
	techc2.ImageTransparency = 0
	techc2.Size = UDim2.new(0,900,0,900)
	techc2.Position = UDim2.new(1,-450,1,-450)
	techc2.ImageColor3 = BrickColor.new("Toothpaste").Color
	techc2.Image = "rbxassetid://2344830904"
	local circl = imgl2:Clone()
	circl.Parent = fullscreenz
	circl.ImageTransparency = 0
	circl.Size = UDim2.new(0,450,0,450)
	circl.Position = UDim2.new(1,-225,1,-225)
	circl.ImageColor3 = BrickColor.new("Toothpaste").Color
	circl.Image = "rbxassetid://2109045978"
	local circl2 = imgl2:Clone()
	circl2.Parent = fullscreenz
	circl2.ImageTransparency = 0
	circl2.Size = UDim2.new(0,600,0,600)
	circl2.Position = UDim2.new(1,-300,1,-300)
	circl2.ImageColor3 = BrickColor.new("Mint").Color
	circl2.Image = "rbxassetid://2312119891"
	local imgl2b = imgl2:Clone()
	imgl2b.Parent = fullscreenz
	imgl2b.ImageTransparency = 0
	imgl2b.ImageColor3 = BrickColor.new("White").Color
	imgl2b.Image = "rbxassetid://2344870656"
	local ned = Instance.new("TextLabel",fullscreenz)
	ned.ZIndex = 2
	ned.Font = "Arcade"
	ned.BackgroundTransparency = 1
	ned.BorderSizePixel = 0.65
	ned.Size = UDim2.new(0.3,0,0.2,0)
	ned.Position = UDim2.new(0.7,0,0.8,0)
	ned.TextColor3 = BrickColor.new("Mint").Color
	ned.TextStrokeColor3 = BrickColor.new("Toothpaste").Color
	ned.TextScaled = true
	ned.TextStrokeTransparency = 0
	ned.Text = "EXQUISITE"
	ned.TextSize = 24
	ned.Rotation = 1
	ned.TextXAlignment = "Right"
	ned.TextYAlignment = "Bottom"
	local nedx = Instance.new("TextLabel",fullscreenz)
	nedx.ZIndex = 2
	nedx.Font = "SciFi"
	nedx.BackgroundTransparency = 1
	nedx.BorderSizePixel = 0.65
	nedx.Size = UDim2.new(0.25,0,0.1,0)
	nedx.Position = UDim2.new(0.0025,0,0.875,0)
	nedx.TextColor3 = BrickColor.new("Mint").Color
	nedx.TextStrokeColor3 = BrickColor.new("Toothpaste").Color
	nedx.TextScaled = true
	nedx.TextStrokeTransparency = 0
	nedx.Text = "Damage: Enabled"
	nedx.TextSize = 24
	nedx.Rotation = 5
	nedx.TextXAlignment = "Center"
	nedx.TextYAlignment = "Bottom"

	local nedm = nedx:Clone()
	nedm.Parent = fullscreenz
	nedm.Position = UDim2.new(0.0025,0,0.775,0)
	nedm.Text = "MODETYPES: UNIVERSAL"

	local sngy = Instance.new("TextLabel",fullscreenz)
	sngy.ZIndex = 2
	sngy.Font = "Arcade"
	sngy.BackgroundTransparency = 1
	sngy.BorderSizePixel = 0.65
	sngy.Size = UDim2.new(0.35,0,0.2,0)
	sngy.Position = UDim2.new(0.325,0,0.8,0)
	sngy.TextColor3 = BrickColor.new("Mint").Color
	sngy.TextStrokeColor3 = BrickColor.new("Toothpaste").Color
	sngy.TextScaled = true
	sngy.TextStrokeTransparency = 0
	sngy.Text = string.upper("Camellia - Insecticide")
	sngy.TextSize = 24
	sngy.Rotation = 0
	sngy.TextXAlignment = "Center"
	sngy.TextYAlignment = "Bottom"



	local extrawingmod1 = Instance.new("Model",char)
	local extrawingmod2 = Instance.new("Model",char)

	function CreateParta(parent,transparency,reflectance,material,brickcolor)
		local p = Instance.new("Part")
		p.TopSurface = 0
		p.BottomSurface = 0
		p.Parent = parent
		p.Size = Vector3.new(0.1,0.1,0.1)
		p.Transparency = transparency
		p.Reflectance = reflectance
		p.CanCollide = false
		p.Locked = true
		p.BrickColor = brickcolor
		p.Material = material
		return p
	end

	function CreateMesh(parent,meshtype,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = meshtype
		mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
		return mesh
	end

	function CreateSpecialMesh(parent,meshid,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.Scale = Vector3.new(x1,y1,z1)
		return mesh
	end


	function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
		local mesh = Instance.new("SpecialMesh",parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
		mesh.Scale = Vector3.new(x1,y1,z1)
		mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
		return mesh
	end

	function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
		local weld = Instance.new("Weld")
		weld.Parent = parent
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
		weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
		return weld
	end


	--------------
	-------------- ground effect
	local cen = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWeld(cen,root,cen,0,3,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local effar = Instance.new("ParticleEmitter",cen)
	effar.Texture = "rbxassetid://2344870656"
	effar.LightEmission = 1
	effar.Color = ColorSequence.new(Color3.new(1,0,0))
	effar.Rate = 50
	effar.Enabled = false
	effar.EmissionDirection = "Front"
	effar.Lifetime = NumberRange.new(1)
	effar.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.1,5,0),NumberSequenceKeypoint.new(0.8,15,0),NumberSequenceKeypoint.new(1,40,0)})
	effar.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
	effar.Speed = NumberRange.new(80,90)
	effar.Acceleration = Vector3.new(0,10,0)
	effar.Drag = 5
	effar.Rotation = NumberRange.new(-500,500)
	effar.SpreadAngle = Vector2.new(0,900)
	effar.RotSpeed = NumberRange.new(-500,500)

	----
	local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWeld(sorb,rarm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
	CreateWeld(sorb2,larm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local handlex = CreateParta(mw1,1,1,"Neon",maincolor)
	CreateMesh(handlex,"Brick",0,0,0)
	local handlexweld = CreateWeld(handlex,tors,handlex,0,-3.75,-1.25,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local effc = Instance.new("ParticleEmitter",handlex)
	effc.Texture = "rbxassetid://2344870656"
	effc.LightEmission = 1
	effc.Color = ColorSequence.new(Color3.new(1,0,0))
	effc.Rate = 50
	effc.Lifetime = NumberRange.new(1)
	effc.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,2,0),NumberSequenceKeypoint.new(0.8,3,0),NumberSequenceKeypoint.new(1,0,0)})
	effc.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
	effc.Speed = NumberRange.new(0,1)
	effc.Drag = 5
	effc.LockedToPart = true
	effc.Rotation = NumberRange.new(-500,500)
	effc.SpreadAngle = Vector2.new(0,900)
	effc.RotSpeed = NumberRange.new(-500,500)

	local handler = CreateParta(mw2,1,1,"Neon",maincolor)
	CreateMesh(handler,"Brick",0,0,0)
	local rotweld = CreateWeld(handler,handlex,handler,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local valuaring = 10
	local ae = script.Ring:Clone()

	local ringhat = game.Players.LocalPlayer.Character["Evil Aura"]

	local function ringalign(part0, part1)
		part1.Transparency = 1
		part0.Size = Vector3.new(1,1,1)
		part0.AccessoryWeld:Destroy()
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0,0,0) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(-0, 100, 0) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = false
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	ringalign(ringhat.Handle, ae)

	ae.Parent = mw1
	ae.Anchored = false
	CreateWeld(ae,handlex,ae,0,0,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local ae = script.Outshard:Clone()
	ae.Parent = mw2
	ae.Anchored = false
	CreateWeld(ae,handler,ae,0,0,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local ae = script.Diamond:Clone()
	ae.Parent = mw2
	ae.Anchored = false
	CreateWeld(ae,handler,ae,0,0,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local handle = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local handleweld = CreateWeld(handle,handlex,handle,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local hat = game:GetService("Players").LocalPlayer.Character["DemonGodSword"]

	local hat1 = game:GetService("Players").LocalPlayer.Character["AuroraSword"]

	local hat2 = game:GetService("Players").LocalPlayer.Character["CorruptLordSword"]

	local hat3 = game:GetService("Players").LocalPlayer.Character["ToxicLordSword"]

	local hat4 = game:GetService("Players").LocalPlayer.Character["VoidLordSword"]

	local hat5 = game:GetService("Players").LocalPlayer.Character["RainbowGodSword"]

	local function align(part0, part1)
		part1.Transparency = 1
		part0.Size = Vector3.new(1,1,1)
		part0.AccessoryWeld:Destroy()
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0, 1.7, -2.5) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(-5, 90, -50) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = false
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end



	--- Left wing.

	local lwing1 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing1weld = CreateWeld(lwing1,handle,lwing1,3,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	align(hat.Handle, lwing1)
	local ae = script.Shard:Clone()
	ae.Parent = mw1
	ae.Anchored = false
	CreateWeld(ae,lwing1,ae,0,0,-1.75,math.rad(0),math.rad(90),math.rad(-90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local lwing2 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing2weld = CreateWeld(lwing2,handle,lwing2,4,1,0,math.rad(10),math.rad(0),math.rad(25),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	align(hat1.Handle, lwing2)
	local ae = script.Shard:Clone()
	ae.Parent = mw1
	ae.Anchored = false
	CreateWeld(ae,lwing2,ae,0,0,-1.75,math.rad(0),math.rad(90),math.rad(-90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local lwing3 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local lwing3weld = CreateWeld(lwing3,handle,lwing3,4.75,2,0,math.rad(15),math.rad(0),math.rad(37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	align(hat2.Handle, lwing3)
	local ae = script.Shard:Clone()
	ae.Parent = mw1
	ae.Anchored = false
	CreateWeld(ae,lwing3,ae,0,0,-1.75,math.rad(0),math.rad(90),math.rad(-90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	-- Right wing.

	local rwing1 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing1weld = CreateWeld(rwing1,handle,rwing1,-3,0,0,math.rad(5),math.rad(0),math.rad(-12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	align(hat3.Handle, rwing1)
	local ae = script.Shard:Clone()
	ae.Parent = mw2
	ae.Anchored = false
	CreateWeld(ae,rwing1,ae,0,0,-1.75,math.rad(0),math.rad(90),math.rad(-90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local rwing2 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing2weld = CreateWeld(rwing2,handle,rwing2,-4,1,0,math.rad(10),math.rad(0),math.rad(-25),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	align(hat4.Handle, rwing2)
	local ae = script.Shard:Clone()
	ae.Parent = mw2
	ae.Anchored = false
	CreateWeld(ae,rwing2,ae,0,0,-1.75,math.rad(0),math.rad(90),math.rad(-90),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local rwing3 = CreateParta(m,1,1,"Neon",maincolor)
	CreateMesh(handle,"Brick",0.5,0.5,0.5)
	local rwing3weld = CreateWeld(rwing3,handle,rwing3,-4.75,2,0,math.rad(15),math.rad(0),math.rad(-37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	align(hat5.Handle, rwing3)
	local ae = script.Shard:Clone()
	ae.Parent = mw2
	ae.Anchored = false
	CreateWeld(ae,rwing3,ae,0,0,-1.75,math.rad(0),math.rad(90),math.rad(-90),0,0,0,math.rad(0),math.rad(0),math.rad(0))


	---- HERES THE RING


--[[ran = CreateParta(m2,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.02,1.02,1.02)
CreateWeld(ran,larm,ran,0,0.15,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",0.9,0.9,1.025)
CreateWeld(ran,larm,ran,0,0.155,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.025,0.9,0.9)
CreateWeld(ran,larm,ran,0,0.155,-0.025,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))


gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
CreateMesh(gane,"Brick",1.0625,0.2,1.0625)
CreateWeld(gane,larm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateSpecialMesh(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
CreateWeld(star,larm,star,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
CreateSpecialMesh(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
CreateWeld(starl,larm,starl,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

--- second ring

ran = CreateParta(m2,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.02,1.02,1.02)
CreateWeld(ran,rarm,ran,0,0.15,0,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",0.9,0.9,1.025)
CreateWeld(ran,rarm,ran,0,0.155,0,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(ran,"Wedge",1.025,0.9,0.9)
CreateWeld(ran,rarm,ran,0,0.155,-0.025,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateMesh(gan,"Brick",1.075,0.1,1.075)
CreateWeld(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gan = CreateParta(m2,0,0,"Neon",halocolor2)
CreateMesh(gan,"Brick",1.095,0.035,1.095)
CreateWeld(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
CreateMesh(gane,"Brick",1.0625,0.2,1.0625)
CreateWeld(gane,rarm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
CreateSpecialMesh(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
CreateWeld(star,rarm,star,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
CreateSpecialMesh(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
CreateWeld(starl,rarm,starl,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))]]--

	-- no problem nooby. 

	script.Shard.Transparency = 1

	local MRCL = BrickColor.new("Toothpaste")
	local MRCL2 = BrickColor.new("Mint")
	for i, v in pairs(mw2:GetDescendants()) do
		if v:IsA("Part") or v:IsA("UnionOperation") then
			v.Color = MRCL.Color
			v.Material = "Neon"
		elseif v:IsA("Trail") or v:IsA("ParticleEmitter") then
			v.Color = ColorSequence.new(MRCL.Color)
		end
	end
	for i, v in pairs(mw1:GetDescendants()) do
		if v:IsA("Part") or v:IsA("UnionOperation") then
			v.Color = MRCL2.Color
			v.Material = "Neon"
		elseif v:IsA("Trail") or v:IsA("ParticleEmitter") then
			v.Color = ColorSequence.new(MRCL2.Color)
		end
	end
	------


	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part")({
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material
		})
		Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
		RemoveOutlines(Part)
		return Part
	end
	function CreateMesha(Mesh, Part, MeshType, MeshId, OffSet, Scale)
		local Msh = Create(Mesh)({
			Parent = Part,
			Offset = OffSet,
			Scale = Scale
		})
		if Mesh == "SpecialMesh" then
			Msh.MeshType = MeshType
			Msh.MeshId = MeshId
		end
		return Msh
	end
	function CreateWeld(Parent, Part0, Part1, C0, C1)
		local Weld = Create("Weld")({
			Parent = Parent,
			Part0 = Part0,
			Part1 = Part1,
			C0 = C0,
			C1 = C1
		})
		return Weld
	end

	Character=Player.Character["Dummy"]
	Torso=Character.Torso 
	Head=Character.Head 
	Humanoid=Character:FindFirstChildOfClass("Humanoid")
	m=Instance.new('Model',Character)
	LeftArm=Character["Left Arm"] 
	LeftLeg=Character["Left Leg"] 
	RightArm=Character["Right Arm"] 
	RightLeg=Character["Right Leg"] 

	Face = Head.face
	Neck=Torso.Neck
	it=Instance.new
	attacktype=1
	vt=Vector3.new
	cf=CFrame.new
	euler=CFrame.fromEulerAnglesXYZ
	angles=CFrame.Angles
	cloaked=false
	necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
	LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
	RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
	RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
	RootPart=Character.HumanoidRootPart
	RootJoint=RootPart.RootJoint
	RootCF=euler(-1.57,0,3.14)
	attack = false 
	attackdebounce = false 
	deb=false
	equipped=true
	hand=false
	MMouse=nil
	combo=0
	mana=0
	trispeed=.2
	attackmode='none'
	local idle=0
	local Anim="Idle"
	local Effects={}
	local gun=false
	local shoot=false
	local sine = 0
	local change = 1

	function RecolorTextAndRename(name,col1,col2,font,sngname)
		modet.TextStrokeColor3 = col2
		modet.TextColor3 = col1
		modet.Font = font
		modet.Text = name
		techc.ImageColor3 = col1
		circl.ImageColor3 = col2
		circl2.ImageColor3 = col1
		imgl2.ImageColor3 = col2
		techc2.ImageColor3 = col2
		ned.Text = name
		ned.TextColor3 = col1
		ned.TextStrokeColor3 = col2
		nedx.TextColor3 = col1
		nedx.TextStrokeColor3 = col2
		nedm.TextColor3 = col1
		nedm.TextStrokeColor3 = col2
		sngy.Text = string.upper(sngname)
		sngy.TextColor3 = col1
		sngy.TextStrokeColor3 = col2
		fr.BorderColor3 = col1
		fr.BackgroundColor3 = col2
		fr2.BorderColor3 = col2
		fr2.BackgroundColor3 = col1
		midr.BorderColor3 = col1
		midr.BackgroundColor3 = col2
		midr2.BorderColor3 = col1
		midr2.BackgroundColor3 = col2
		glw.ImageColor3 = col1
		glw2.ImageColor3 = col1
	end

	local disably = true

	function warnedpeople(text,represfont,color,color2)
		if disably ~= true then
			CFuncs["Sound"].Create("rbxassetid://534859368", char, 2.5,1)
			CFuncs["Sound"].Create("rbxassetid://963718869", char, 1,1)
			for i,v in pairs(game:GetService("Players"):GetPlayers()) do
				coroutine.resume(coroutine.create(function()
					if v.PlayerGui:FindFirstChild("Spinny")~= nil then
						v.PlayerGui:FindFirstChild("Spinny"):destroy()
					end
					local scrg = Instance.new("ScreenGui",v.PlayerGui)
					scrg.Name = "Spinny"
					local frm = Instance.new("Frame",scrg)
					frm.BackgroundTransparency = 0.25
					frm.BackgroundColor3 = color
					frm.BorderSizePixel = 0
					frm.Rotation = 45
					frm.Size = UDim2.new(3,0,0,100)
					frm.Position = UDim2.new(-4,0,0,0)
					local frm2 = frm:Clone()
					frm2.Parent = scrg
					frm2.BackgroundColor3 = color2
					frm2.Position = UDim2.new(-4.05,0,0,0)
					local imlb = Instance.new("ImageLabel",scrg)
					imlb.BackgroundTransparency = 1
					imlb.BackgroundColor3 = Color3.new(0,0,0)
					imlb.Image = "rbxassetid://2344851144"
					imlb.Size = UDim2.new(0,750,0,750)
					imlb.ImageColor3 = color2
					imlb.ImageTransparency = 0.25
					imlb.Position = UDim2.new(-2.5,0,-2.5,0)
					local imlb2 = imlb:Clone()
					imlb2.Image = "rbxassetid://2325939897"
					imlb2.Size = UDim2.new(1,0,1,0)
					imlb2.ImageColor3 = color
					imlb2.ImageTransparency = 0
					imlb2.Position = UDim2.new(0,0,0,0)
					local imlb3 = imlb:Clone()
					imlb3.Image = "rbxassetid://2344830904"
					imlb3.Size = UDim2.new(1,0,1,0)
					imlb3.ImageColor3 = color2
					imlb3.ImageTransparency = 0
					imlb3.Position = UDim2.new(0,0,0,0)
					local imlb4 = imlb:Clone()
					imlb4.Image = "rbxassetid://2344870656"
					imlb4.Size = UDim2.new(3,0,3,0)
					imlb4.ImageColor3 = Color3.new(1,1,1)
					imlb4.ImageTransparency = 0
					imlb4.Position = UDim2.new(-1,0,-1,0)
					local imlb5 = imlb:Clone()
					imlb5.Image = "rbxassetid://2344870656"
					imlb5.Size = UDim2.new(10,0,10,0)
					imlb5.ImageColor3 = color2
					imlb5.ImageTransparency = 0
					imlb5.Position = UDim2.new(-4.5,0,-4.5,0)
					imlb2.Parent = imlb
					imlb3.Parent = imlb
					imlb4.Parent = imlb
					imlb5.Parent = imlb
					local txtlb2 = Instance.new("TextLabel",imlb)
					txtlb2.Text = text
					txtlb2.Font = represfont
					txtlb2.TextColor3 = color
					txtlb2.TextStrokeTransparency = 0
					txtlb2.BackgroundTransparency = 1
					txtlb2.TextStrokeColor3 = color2
					txtlb2.TextScaled = true
					txtlb2.Size = UDim2.new(1,0,1,0)
					txtlb2.Position = UDim2.new(0,0,0,0)
					local fvalen = 0.55
					local fval = -0.49
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if chaosmode == true then
								txtlb2.Rotation = math.random(-1,1)
								imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
								imlb.ImageColor3 = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
								txtlb2.TextStrokeColor3 = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
							end
						end
					end))
					coroutine.resume(coroutine.create(function()
						while true do
							swait()
							if scrg.Parent ~= nil then
								fvalen = fvalen - 0.0001
							elseif scrg.Parent == nil then
								break
							end
						end
					end))
					local flol = -5
					local flil = 1.6
					coroutine.resume(coroutine.create(function()
						for i = 0, 49 do
							swait()
							flol = flol + 0.125
							flil = flil - 0.1
							frm.Size = frm.Size + UDim2.new(0.1,0,0,0)
							frm.Rotation = frm.Rotation - 0.25
							frm2.Size = frm2.Size + UDim2.new(0.1,0,0,0)
							frm2.Rotation = frm.Rotation + 0.325
							imlb3.Rotation = imlb3.Rotation - 10
							imlb2.Rotation = imlb.Rotation + 7.5
							imlb.Rotation = imlb.Rotation + 5
							txtlb2.Rotation = txtlb2.Rotation - 5.125
							imlb.Position = imlb.Position + UDim2.new(0.05125,0,0.04775,0)
						end
						for i = 0, 99 do
							swait()
							fval = fval + 0.05
							flol = flol + 0.005
							frm.Size = frm.Size + UDim2.new(0.005,0,0,0)
							frm.Rotation = frm.Rotation - 0.075
							frm2.Size = frm2.Size + UDim2.new(0.005,0,0,0)
							frm2.Rotation = frm2.Rotation + 0.125
							imlb3.Rotation = imlb3.Rotation - 2
							imlb2.Rotation = imlb.Rotation + 1.5
							imlb.Rotation = imlb.Rotation + 1
							txtlb2.Rotation = txtlb2.Rotation - 1.125
							imlb.Position = imlb.Position + UDim2.new(0.0015,0,0.00075,0)
						end
						local valinc = 0
						local vinc2 = 1
						for i = 0, 99 do
							swait()
							vinc2 = vinc2 + 0.25
							valinc = valinc + 0.0001
							flol = flol + valinc
							flil = flil + valinc
							txtlb2.Rotation = txtlb2.Rotation - 1.125*vinc2
							imlb3.Rotation = imlb3.Rotation - 2*vinc2
							imlb.Rotation = imlb.Rotation + 1*vinc2
							imlb.Position = imlb.Position + UDim2.new(0.0015*vinc2,0,0.0005*vinc2,0)
							frm.Size = frm.Size + UDim2.new(0.005*vinc2,0,0,0)
							frm.Rotation = frm.Rotation + 0.1*vinc2
							frm2.Size = frm2.Size + UDim2.new(0.005*vinc2,0,0,0)
							frm2.Rotation = frm2.Rotation + 0.225*vinc2
							frm2.BackgroundTransparency = frm2.BackgroundTransparency + 0.0075
							frm.BackgroundTransparency = frm.BackgroundTransparency + 0.0075
							imlb.ImageTransparency = imlb.ImageTransparency + 0.005
							imlb2.ImageTransparency = imlb2.ImageTransparency + 0.01
							imlb3.ImageTransparency = imlb3.ImageTransparency + 0.01
							imlb4.ImageTransparency = imlb4.ImageTransparency + 0.01
							imlb5.ImageTransparency = imlb4.ImageTransparency + 0.01
							txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
							txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
						end
						scrg:Destroy()
					end))
				end))
			end
		end
	end

	--save shoulders 
	RSH, LSH=nil, nil 
	--welds 
	RW, LW=Instance.new("Weld"), Instance.new("Weld") 
	RW.Name="Right Shoulder" LW.Name="Left Shoulder"
	LH=Torso["Left Hip"]
	RH=Torso["Right Hip"]
	TorsoColor=Torso.BrickColor
	function NoOutline(Part)
		Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
	end
	ch=Character
	RSH=ch.Torso["Right Shoulder"] 
	LSH=ch.Torso["Left Shoulder"] 
	-- 
	RSH.Parent=nil 
	LSH.Parent=nil 
	-- 
	RW.Name="Right Shoulder"
	RW.Part0=ch.Torso 
	RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
	RW.C1=cf(0, 0.5, 0) 
	RW.Part1=ch["Right Arm"] 
	RW.Parent=ch.Torso 
	-- 
	LW.Name="Left Shoulder"
	LW.Part0=ch.Torso 
	LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
	LW.C1=cf(0, 0.5, 0) 
	LW.Part1=ch["Left Arm"] 
	LW.Parent=ch.Torso 

	local Stats=Instance.new("BoolValue")
	Stats.Name="Stats"
	Stats.Parent=Character
	local Atk=Instance.new("NumberValue")
	Atk.Name="Damage"
	Atk.Parent=Stats
	Atk.Value=1
	local Def=Instance.new("NumberValue")
	Def.Name="Defense"
	Def.Parent=Stats
	Def.Value=1
	local Speed=Instance.new("NumberValue")
	Speed.Name="Speed"
	Speed.Parent=Stats
	Speed.Value=1
	local Mvmt=Instance.new("NumberValue")
	Mvmt.Name="Movement"
	Mvmt.Parent=Stats
	Mvmt.Value=1

	local donum=0


	function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
		local fp=it("Part")
		fp.formFactor=formfactor 
		fp.Parent=parent
		fp.Reflectance=reflectance
		fp.Transparency=transparency
		fp.CanCollide=false 
		fp.Locked=true
		fp.BrickColor=brickcolor
		fp.Name=name
		fp.Size=size
		fp.Position=Torso.Position 
		NoOutline(fp)
		fp.Material="SmoothPlastic"
		fp:BreakJoints()
		return fp 
	end 

	function mesh(Mesh,part,meshtype,meshid,offset,scale)
		local mesh=it(Mesh) 
		mesh.Parent=part
		if Mesh=="SpecialMesh" then
			mesh.MeshType=meshtype
			if meshid~="nil" then
				mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
			end
		end
		mesh.Offset=offset
		mesh.Scale=scale
		return mesh
	end

	function weld(parent,part0,part1,c0)
		local weld=it("Weld") 
		weld.Parent=parent
		weld.Part0=part0 
		weld.Part1=part1 
		weld.C0=c0
		return weld
	end

	local Color1=Torso.BrickColor

	local bodvel=Instance.new("BodyVelocity")
	local bg=Instance.new("BodyGyro")

	--------- SazEreno's Artificial HB --------------
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")
	Frame_Speed = 1 / 60
	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	------------------
	function swait(num)
		if num == 0 or num == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, num do
				ArtificialHB.Event:wait()
			end
		end
	end
	-------- RAINBOW LEAVE IT TO ME
	local r = 255
	local g = 0
	local b = 0
	coroutine.resume(coroutine.create(function()
		while wait() do
			for i = 0, 254/5 do
				swait()
				g = g + 5
			end
			for i = 0, 254/5 do
				swait()
				r = r - 5
			end
			for i = 0, 254/5 do
				swait()
				b = b + 5
			end
			for i = 0, 254/5 do
				swait()
				g = g - 5
			end
			for i = 0, 254/5 do
				swait()
				r = r + 5
			end
			for i = 0, 254/5 do
				swait()
				b = b - 5
			end
		end
	end))


	so = function(id,par,vol,pit) 
		coroutine.resume(coroutine.create(function()
			local sou = Instance.new("Sound",par or workspace)
			sou.Volume=vol
			sou.Pitch=pit or 1
			sou.SoundId=id
			swait() 
			sou:play() 
			game:GetService("Debris"):AddItem(sou,6)
		end))
	end

	function clerp(a,b,t) 
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)} 
		local ax, ay, az = a.x, a.y, a.z 
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1-t
		return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
	end 

	function QuaternionFromCFrame(cf) 
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
		local trace = m00 + m11 + m22 
		if trace > 0 then 
			local s = math.sqrt(1 + trace) 
			local recip = 0.5/s 
			return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
		else 
			local i = 0 
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then 
				i = 2 
			end 
			if i == 0 then 
				local s = math.sqrt(m00-m11-m22+1) 
				local recip = 0.5/s 
				return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
			elseif i == 1 then 
				local s = math.sqrt(m11-m22-m00+1) 
				local recip = 0.5/s 
				return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
			elseif i == 2 then 
				local s = math.sqrt(m22-m00-m11+1) 
				local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
			end 
		end 
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w) 
		local xs, ys, zs = x + x, y + y, z + z 
		local wx, wy, wz = w*xs, w*ys, w*zs 
		local xx = x*xs 
		local xy = x*ys 
		local xz = x*zs 
		local yy = y*ys 
		local yz = y*zs 
		local zz = z*zs 
		return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
	end

	function QuaternionSlerp(a, b, t) 
		local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
		local startInterp, finishInterp; 
		if cosTheta >= 0.0001 then 
			if (1 - cosTheta) > 0.0001 then 
				local theta = math.acos(cosTheta) 
				local invSinTheta = 1/math.sin(theta) 
				startInterp = math.sin((1-t)*theta)*invSinTheta 
				finishInterp = math.sin(t*theta)*invSinTheta  
			else 
				startInterp = 1-t 
				finishInterp = t 
			end 
		else 
			if (1+cosTheta) > 0.0001 then 
				local theta = math.acos(-cosTheta) 
				local invSinTheta = 1/math.sin(theta) 
				startInterp = math.sin((t-1)*theta)*invSinTheta 
				finishInterp = math.sin(t*theta)*invSinTheta 
			else 
				startInterp = t-1 
				finishInterp = t 
			end 
		end 
		return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
	end

	local function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CFrame.new(at.x, at.y, at.z,
			right.x, top.x, back.x,
			right.y, top.y, back.y,
			right.z, top.z, back.z)
	end

	function Triangle(a, b, c)
		local edg1 = (c-a):Dot((b-a).unit)
		local edg2 = (a-b):Dot((c-b).unit)
		local edg3 = (b-c):Dot((a-c).unit)
		if edg1 <= (b-a).magnitude and edg1 >= 0 then
			a, b, c = a, b, c
		elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
			a, b, c = b, c, a
		elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
			a, b, c = c, a, b
		else
			assert(false, "unreachable")
		end

		local len1 = (c-a):Dot((b-a).unit)
		local len2 = (b-a).magnitude - len1
		local width = (a + (b-a).unit*len1 - c).magnitude

		local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)

		local list = {}

		if len1 > 0.01 then
			local w1 = Instance.new('WedgePart', m)
			game:GetService("Debris"):AddItem(w1,5)
			w1.Material = "SmoothPlastic"
			w1.FormFactor = 'Custom'
			w1.BrickColor = BrickColor.new("Really red")
			w1.Transparency = 0
			w1.Reflectance = 0
			w1.Material = "SmoothPlastic"
			w1.CanCollide = false
			local l1 = Instance.new("PointLight",w1)
			l1.Color = Color3.new(170,0,0)
			NoOutline(w1)
			local sz = Vector3.new(0.2, width, len1)
			w1.Size = sz
			local sp = Instance.new("SpecialMesh",w1)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
			w1:BreakJoints()
			w1.Anchored = true
			w1.Parent = workspace
			w1.Transparency = 0.7
			table.insert(Effects,{w1,"Disappear",.01})
			w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
			table.insert(list,w1)
		end

		if len2 > 0.01 then
			local w2 = Instance.new('WedgePart', m)
			game:GetService("Debris"):AddItem(w2,5)
			w2.Material = "SmoothPlastic"
			w2.FormFactor = 'Custom'
			w2.BrickColor = BrickColor.new("Really red")
			w2.Transparency = 0
			w2.Reflectance = 0
			w2.Material = "SmoothPlastic"
			w2.CanCollide = false
			local l2 = Instance.new("PointLight",w2)
			l2.Color = Color3.new(170,0,0)
			NoOutline(w2)
			local sz = Vector3.new(0.2, width, len2)
			w2.Size = sz
			local sp = Instance.new("SpecialMesh",w2)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
			w2:BreakJoints()
			w2.Anchored = true
			w2.Parent = workspace
			w2.Transparency = 0.7
			table.insert(Effects,{w2,"Disappear",.01})
			w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
			table.insert(list,w2)
		end
		return unpack(list)
	end


	function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
		if hit.Parent == nil then
			return
		end
		local h = hit.Parent:FindFirstChildOfClass("Humanoid")
		for _, v in pairs(hit.Parent:children()) do
			if v:IsA("Humanoid") then
				h = v
			end
		end
		if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Head") ~= nil then
			if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
				return
			end
			local c = Create("ObjectValue")({
				Name = "creator",
				Value = game:GetService("Players").LocalPlayer,
				Parent = h
			})
			game:GetService("Debris"):AddItem(c, 0.5)
			if HitSound ~= nil and HitPitch ~= nil then
				CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
			end
			local Damage = math.random(minim, maxim)
			local blocked = false
			local block = hit.Parent:findFirstChild("Block")
			if block ~= nil and block.className == "IntValue" and block.Value > 0 then
				blocked = true
				block.Value = block.Value - 1
				print(block.Value)
			end
			if blocked == false then
				HitHealth = h.Health
				h.MaxHealth = 100
				if enableddam == true then
					--h.Health = h.Health - Damage
				end
				if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
					print("gained kill")
					--dmg(h.Parent)
				end
				ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
			else
				h.Health = h.Health - Damage / 2
				ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
			end
			if Type == "Knockdown" then
				local hum = hit.Parent.Humanoid
				hum.PlatformStand = true
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(1)
					HHumanoid.PlatformStand = false
				end), hum)
				local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
				local bodvol = Create("BodyVelocity")({
					velocity = angle * knockback,
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				local rl = Create("BodyAngularVelocity")({
					P = 3000,
					maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
					angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodvol, 0.5)
				game:GetService("Debris"):AddItem(rl, 0.5)
			elseif Type == "Normal" then
				local vp = Create("BodyVelocity")({
					P = 500,
					maxForce = Vector3.new(math.huge, 0, math.huge),
					velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
				})
				if knockback > 0 then
					vp.Parent = hit.Parent.Head
				end
				game:GetService("Debris"):AddItem(vp, 0.5)
			elseif Type == "Up" then
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Leech" then
				local hum = hit.Parent.Humanoid
				if hum ~= nil then
					for i = 0, 2 do
						Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
					end
					Humanoid.Health = Humanoid.Health + 10
				end
			elseif Type == "UpKnock" then
				local hum = hit.Parent.Humanoid
				hum.PlatformStand = true
				if hum ~= nil then
					hitr = true
				end
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(5)
					HHumanoid.PlatformStand = false
					hitr = false
				end), hum)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Snare" then
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Slashnare" then
				Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
				for i = 1, math.random(4, 5) do
					Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
				end
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Spike" then
				CreateBigIceSword(hit.Parent.Torso.CFrame)
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Freeze" then
				local BodPos = Create("BodyPosition")({
					P = 50000,
					D = 1000,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				local BodGy = Create("BodyGyro")({
					maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
					P = 20000,
					Parent = hit.Parent.Torso,
					cframe = hit.Parent.Torso.CFrame
				})
				hit.Parent.Torso.Anchored = true
				coroutine.resume(coroutine.create(function(Part)
					swait(1.5)
					Part.Anchored = false
				end), hit.Parent.Torso)
				game:GetService("Debris"):AddItem(BodPos, 3)
				game:GetService("Debris"):AddItem(BodGy, 3)
			end
			local debounce = Create("BoolValue")({
				Name = "DebounceHit",
				Parent = hit.Parent,
				Value = true
			})
			game:GetService("Debris"):AddItem(debounce, Delay)
			c = Instance.new("ObjectValue")
			c.Name = "creator"
			c.Value = Player
			c.Parent = h
			game:GetService("Debris"):AddItem(c, 0.5)
		end
	end
	function ShowDamage(Pos, Text, Time, Color)
		local Rate = 0.03333333333333333
		local Pos = Pos or Vector3.new(0, 0, 0)
		local Text = Text or ""
		local Time = Time or 2
		local Color = Color or Color3.new(1, 0, 1)
		local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
		EffectPart.Anchored = true
		local BillboardGui = Create("BillboardGui")({
			Size = UDim2.new(3, 0, 3, 0),
			Adornee = EffectPart,
			Parent = EffectPart
		})
		local TextLabel = Create("TextLabel")({
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			TextColor3 = Color,
			TextScaled = true,
			Font = Enum.Font.ArialBold,
			Parent = BillboardGui
		})
		game.Debris:AddItem(EffectPart, Time + 0.1)
		EffectPart.Parent = game:GetService("Workspace")
		delay(0, function()
			local Frames = Time / Rate
			for Frame = 1, Frames do
				wait(Rate)
				local Percent = Frame / Frames
				EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
				TextLabel.TextTransparency = Percent
			end
			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end)
	end
	function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChildOfClass("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Head")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
					end
				end
			end
		end
	end

	function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChild("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Torso")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
						Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
					end
				end
			end
		end
	end

	function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
	end 

	function SkullEffect(brickcolor,cframe,x1,y1,z1,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=4770583",vt(0,0,0),vt(x1,y1,z1))
		--http://www.roblox.com/asset/?id=4770560
		game:GetService("Debris"):AddItem(prt,2)
		CF=prt.CFrame
		coroutine.resume(coroutine.create(function(Part,Mesh,TehCF) 
			for i=0,1,0.2 do
				wait()
				Part.CFrame=CF*cf(0,0,-0.4)
			end
			for i=0,1,delay do
				wait()
				--Part.CFrame=CF*cf((math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5)
				Mesh.Scale=Mesh.Scale
			end
			for i=0,1,0.1 do
				wait()
				Part.Transparency=i
			end
			Part.Parent=nil
		end),prt,msh,CF)
	end

	function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				swait()
				Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicSphere(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShock(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
		local prt=part(3,char,1,1,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		local dec = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
		local dec2 = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				dec.Transparency=i
				dec2.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockAlt(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockAltCircle(brickcolor,cframe,x1,z1,x3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0.1,0)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,-0.1,0)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,0,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockTrailAlt(brickcolor,cframe,x1,y1,z1,x3,y3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicShockTrailAlt2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.Material = "Neon"
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			local rtype = rottype
			for i=0,1,delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
				end
				prt.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicBlock2(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=false
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		local wld=weld(prt,prt,Parent,cframe)
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
			for i=0,1,delay do
				wait()
				Weld.C0=euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))*cframe
				--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,wld)
	end

	function MagicBlock3(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=false
		prt.CFrame=cframe
		msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		local wld=weld(prt,prt,Parent,euler(0,0,0)*cf(0,0,0))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
			for i=0,1,delay do
				wait()
				Weld.C0=euler(i*20,0,0)
				--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,wld)
	end

	function MagicCircle2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("CylinderMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
				local prt2=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
				prt2.Anchored=true
				prt2.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				local msh2=mesh("SpecialMesh",prt2,"Sphere","",vt(0,0,0),vt(0.5,0.5,0.5))
				game:GetService("Debris"):AddItem(prt2,2)
				coroutine.resume(coroutine.create(function(Part,Mesh) 
					for i=0,1,0.1 do
						wait()
						Part.CFrame=Part.CFrame*cf(0,0.5,0)
					end
					Part.Parent=nil
				end),prt2,msh2)
			end
			for i=0,1,delay*2 do
				wait()
				Part.CFrame=Part.CFrame
				Mesh.Scale=vt((x1+x3)-(x1+x3)*i,(y1+y3)-(y1+y3)*i,(z1+z3)-(z1+z3)*i)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function BreakEffect(brickcolor,cframe,x1,y1,z1)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,CF,Numbb,randnumb) 
			CF=Part.CFrame
			Numbb=0
			randnumb=math.random()/10
			rand1=math.random()/10
			for i=0,1,rand1 do
				wait()
				CF=CF*cf(0,math.random()/2,0)
				--Part.CFrame=Part.CFrame*euler(0.5,0,0)*cf(0,1,0)
				Part.CFrame=CF*euler(Numbb,0,0)
				Part.Transparency=i
				Numbb=Numbb+randnumb
			end
			Part.Parent=nil
		end),prt,CF,Numbb,randnumb)
	end

	function MagicWaveThing(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=1051557",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame*euler(0,0.7,0)
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function WaveEffect(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=20329976",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh) 
			for i=0,1,delay do
				wait()
				Part.CFrame=Part.CFrame*cf(0,y3/2,0)
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh)
	end

	function StravEffect(brickcolor,cframe,x,y,z,x1,y1,z1,delay)
		local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe*cf(x,y,z)
		msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://168892363",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,5)
		coroutine.resume(coroutine.create(function(Part,Mesh,ex,why,zee) 
			local num=math.random()
			local num2=math.random(-3,2)+math.random()
			local numm=0
			for i=0,1,delay*2 do
				swait()
				Part.CFrame=cframe*euler(0,numm*num*10,0)*cf(ex,why,zee)*cf(-i*10,num2,0)
				Part.Transparency=i
				numm=numm+0.01
			end
			Part.Parent=nil
			Mesh.Parent=nil
		end),prt,msh,x,y,z)
	end

	function dmgstart(dmg,what)
		hitcon = what.Touched:connect(function(hit)
			local hum = hit.Parent:FindFirstChild("Humanoid")
			if hum and not hum:IsDescendantOf(Character) then

			end
		end)
	end

	function dmgstop()
		hitcon:disconnect()
	end

	function Cloak()
		Face.Parent=nil
		cloaked=true
		for _,v in pairs(Torso.Parent:children()) do
			if v.className=="Part" and v.Name~="HumanoidRootPart" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.2 do
						wait()
						v.Transparency=i
					end
					v.Transparency=1
				end))
			end
			if v.className=="Hat" then
				hatp=v.Handle
				coroutine.resume(coroutine.create(function(derp) 
					for i=0,1,0.2 do
						wait()
						derp.Transparency=i
					end
					derp.Transparency=1
				end),hatp)
			end
		end
		for _,v in pairs(m:children()) do
			if v.className=="Part" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.2 do
						wait()
						v.Transparency=i
					end
					v.Transparency=1
				end))
			end
		end
	end

	function UnCloak()
		so("http://roblox.com/asset/?id=2767090",Torso,1,1.1) 
		Face.Parent=Head 
		cloaked=false
		for _,v in pairs(Torso.Parent:children()) do
			if v.className=="Part" and v.Name~="HumanoidRootPart" then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.1 do
						wait()
						v.Transparency=v.Transparency-0.1
					end
					v.Transparency=0
				end))
			end
			if v.className=="Hat" then
				hatp=v.Handle
				coroutine.resume(coroutine.create(function(derp) 
					for i=0,1,0.1 do
						wait()
						derp.Transparency=derp.Transparency-0.1
					end
					derp.Transparency=0
				end),hatp)
			end
		end
		for _,v in pairs(m:children()) do
			if v.className=="Part" and v.Name~="hitbox" and v.Name~='tip' then
				coroutine.resume(coroutine.create(function() 
					for i=0,1,0.1 do
						wait()
						v.Transparency=v.Transparency-0.1
					end
					v.Transparency=0
				end))
				v.Transparency=0
			end
		end
	end

	local origcolor = BrickColor.new("Pastel light blue")
	---- This section of explosions.

	----


	function ring(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
			end
			rng:Destroy()
		end))
	end


	function wave(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function wind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function groundwind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
			end
			rng:Destroy()
		end))
	end

	function CameraManager()
		if TwoD and not CamInterrupt then
			if Humanoid.Health > 0 then
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Scriptable"
				Humanoid.AutoRotate = false
				if Booleans.GyroUse then
					Directer.MaxTorque = Vec3(0, huge, 0)
				else
					Directer.MaxTorque = Vec3(0, 0, 0)
				end
				if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
					if Booleans.CamFollow then
						CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
						Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
					else
						CPart.Position = RootPart.Position
					end
				else
					local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
					CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
				end
				Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
			else
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Custom"
				Controller.Disabled = false
			end
		end
	end

	function ring(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
			end
			rng:Destroy()
		end))
	end


	function wave(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function sphere(bonuspeed,type,pos,scale,value,color)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		if ModeOfGlitch ~= 9 then
			rng.BrickColor = color
		elseif ModeOfGlitch == 9 then
			rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
		end
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = scale
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		if ModeOfGlitch == 9 then
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if rng.Parent ~= nil then
						rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
					else
						break
					end
				end
			end))
		end
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.Color = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		if ModeOfGlitch ~= 9 then
			rng.BrickColor = color
		elseif ModeOfGlitch == 9 then
			rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
		end
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		rngm.Scale = scale
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		if ModeOfGlitch == 9 then
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if rng.Parent ~= nil then
						rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
					else
						break
					end
				end
			end))
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if chaosmode == true then
					rng.Color = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
				end
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function spherec(bonuspeed,type,pos,scale,value,value2,value3,color)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.Color = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		rngm.Scale = scale
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		if ModeOfGlitch == 9 then
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if rng.Parent ~= nil then
						rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
					else
						break
					end
				end
			end))
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if chaosmode == true then
					rng.Color = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
				end
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end


	function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
		local type = type
		local rotenable = rotatingop
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		if typeoftrans == "In" then
			rng.Transparency = 1
		end
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "FileMesh"
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		if typeofshape == "Normal" then
			rngm.MeshId = "rbxassetid://662586858"
		elseif typeofshape == "Round" then
			rngm.MeshId = "rbxassetid://662585058"
		end
		rngm.Scale = scale
		local scaler2 = 1/10
		if type == "Add" then
			scaler2 = 1*value/10
		elseif type == "Divide" then
			scaler2 = 1/value/10
		end
		local randomrot = math.random(1,2)
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed/10
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed/10
				end
				if rotenable == true then
					if randomrot == 1 then
						rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
					elseif randomrot == 2 then
						rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
					end
				end
				if typeoftrans == "Out" then
					rng.Transparency = rng.Transparency + 0.01*bonuspeed
				elseif typeoftrans == "In" then
					rng.Transparency = rng.Transparency - 0.01*bonuspeed
				end
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
			end
			rng:Destroy()
		end))
	end

	function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.Color = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.Color = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 0
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.Color = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
				end
				speeder = speeder + 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.Color = color3
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = scale
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		if ModeOfGlitch ~= 9 then
			rng.BrickColor = color
		elseif ModeOfGlitch == 9 then
			rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
		end
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		if ModeOfGlitch == 9 then
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if rng.Parent ~= nil then
						rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
					else
						break
					end
				end
			end))
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.Color = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end


	function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		if ModeOfGlitch ~= 9 then
			rng.BrickColor = color
		elseif ModeOfGlitch == 9 then
			rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
		end
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 1
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		if ModeOfGlitch == 9 then
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if rng.Parent ~= nil then
						rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
					else
						break
					end
				end
			end))
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.Color = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end

	function dmg(dude)

	end


	function FindNearestHead(Position, Distance, SinglePlayer)
		if SinglePlayer then
			return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
		end
		local List = {}
		for i, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") then
				if v:findFirstChild("Head") then
					if v ~= Character then
						if (v.Head.Position - Position).magnitude <= Distance then
							table.insert(List, v)
						end 
					end 
				end 
			end 
		end
		return List
	end

	function FaceMouse()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end

	function FaceMouse2()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end

	local ModeOfGlitch = 1
	-- Functions are ready.
	local storehumanoidWS = 16

	function createBGCircle(size,parent,color)
		local bgui = Instance.new("BillboardGui",parent)
		bgui.Size = UDim2.new(size, 0, size, 0)
		local imgc = Instance.new("ImageLabel",bgui)
		imgc.BackgroundTransparency = 1
		imgc.ImageTransparency = 0
		imgc.Size = UDim2.new(1,0,1,0)
		imgc.Image = "rbxassetid://997291547" --997291547,521073910
		imgc.ImageColor3 = color
		return bgui,imgc
	end

	function symbolizeBlink(guipar,size,img,color,bonussize,vol,pit,soundid,spar,rotationenabled,rotsp,delay)
		local bgui,imgc = createBGCircle(size,guipar,color)
		bgui.AlwaysOnTop = true
		imgc.Image = "rbxassetid://" ..img
		local rrot = math.random(1,2)
		CFuncs["Sound"].Create("rbxassetid://" ..soundid, spar, vol,pit)
		coroutine.resume(coroutine.create(function()
			for i = 0, 24*delay do
				swait()
				if rotationenabled == true then
					if rrot == 1 then
						imgc.Rotation = imgc.Rotation + rotsp
					elseif rrot == 2 then
						imgc.Rotation = imgc.Rotation - rotsp
					end
				end
				bgui.Size = bgui.Size + UDim2.new(1*bonussize/delay,0,1*bonussize/delay,0)
				imgc.ImageTransparency = imgc.ImageTransparency + 0.04/delay
			end
			bgui:Destroy()
		end))
	end


	function burstswitch(col1,col2)
		local effx = Instance.new("ParticleEmitter",root)
		effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
		effx.LightEmission = 1
		effx.Color = ColorSequence.new(col1)
		effx.Rate = 500000
		effx.Lifetime = NumberRange.new(0.25,0.75)
		effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
		effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.8,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
		effx.Speed = NumberRange.new(0,10)
		effx.Drag = 5
		effx.Rotation = NumberRange.new(-500,500)
		effx.VelocitySpread = 9000
		effx.RotSpeed = NumberRange.new(-50,50)
		local effx2 = effx:Clone()
		effx2.Parent = root
		effx2.Color = ColorSequence.new(col2)
		effx2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,150,0)})
		--CFuncs["Sound"].Create("rbxassetid://2095993595", root, 10, 1)
		for i = 0, 1 do
			CFuncs["Sound"].Create("rbxassetid://1042716828", root, 5, 1)
			CFuncs["Sound"].Create("rbxassetid://1042693018", root, 5, 0.8)
			CFuncs["Sound"].Create("rbxassetid://1192402877", root, 4,0.75)
			CFuncs["Sound"].Create("rbxassetid://1664711478", root, 4,1)
			CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 0.75)
			CFuncs["Sound"].Create("rbxassetid://782353443", root, 8, 0.9)
			CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 0.8)
			CFuncs["Sound"].Create("rbxassetid://782353443", root, 4, 0.7)
		end
		spherec(1,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),1,1,1,col2)
		spherec(2,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),1.5,1.5,1.5,col1)
		spherec(3,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),2,2,2,col2)
		spherec(4,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),2.5,2.5,2.5,col1)
		symbolizeBlink(root,0,144580273,col1,25,0,0,0,root,true,-5,2)
		symbolizeBlink(root,0,144580273,col2,20,0,0,0,root,true,-5,1)
		symbolizeBlink(root,0,144580273,col2,22.5,0,0,0,root,true,-5,1.5)
		symbolizeBlink(root,0,348103573,col2,22.5,0,0,0,root,true,-5,1.5)
		symbolizeBlink(root,0,348103573,col2,30,0,0,0,root,true,-25,1)
		symbolizeBlink(root,0,348103573,col1,40,0,0,0,root,true,-25,1)
		coroutine.resume(coroutine.create(function()
			wait(0.05)
			effx.Enabled = false
			effx2.Enabled = false
			wait(2)
			effx:Destroy()
			effx2:Destroy()
		end))
	end
	function RecolorThing(one,two,three,four,five,exonetran,exone,extwotran,extwo,secondaryenabled,sectrailenabled)
		for i, v in pairs(mw2:GetDescendants()) do
			if v:IsA("Part") or v:IsA("UnionOperation") then
				v.Color = one
				v.Material = "Neon"
			elseif v:IsA("Trail") or v:IsA("ParticleEmitter") then
				v.Color = ColorSequence.new(one)
			end
		end
		burstswitch(one,two)
		for i, v in pairs(mw1:GetDescendants()) do
			if v:IsA("Part") or v:IsA("UnionOperation") then
				v.Color = two
				v.Material = "Neon"
			elseif v:IsA("Trail") or v:IsA("ParticleEmitter") then
				v.Color = ColorSequence.new(two)
			end
		end
	end

	function rtsc(one,two,three,four,five,exonetran,exone,extwotran,extwo,secondaryenabled,sectrailenabled)
		for i, v in pairs(mw2:GetDescendants()) do
			if v:IsA("Part") or v:IsA("UnionOperation") then
				v.Color = one
				v.Material = "Neon"
			elseif v:IsA("Trail") or v:IsA("ParticleEmitter") then
				v.Color = ColorSequence.new(one)
			end
		end
		for i, v in pairs(mw1:GetDescendants()) do
			if v:IsA("Part") or v:IsA("UnionOperation") then
				v.Color = two
				v.Material = "Neon"
			elseif v:IsA("Trail") or v:IsA("ParticleEmitter") then
				v.Color = ColorSequence.new(two)
			end
		end
	end


	--- abiliti

	---- Star/Velnorum's Abilities
	function ExtinctiveHeartbreak()
		local targetted = nil
		if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			targetted = mouse.Target.Parent
		end
		if targetted ~= nil then
			attack = true
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			local originalpos = root.CFrame
			RootPart.CFrame = targetted.Head.CFrame * CFrame.new(0,-2,2)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			hum.WalkSpeed = 0
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			local radm = math.random(1,3)
			if radm == 1 then
				bosschatfunc("YOU WONT BE NECCESSARY.",MRCL.Color,2)
			elseif radm == 2 then
				bosschatfunc("YOUR EXISTANCE WILL BE GONE.",MRCL.Color,2)
			elseif radm == 3 then
				bosschatfunc("DIE!",MRCL.Color,2)
			end
			for i = 0,2,0.1 do
				swait()
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-10),math.rad(0)),.4)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.4)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(80)),.4)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(10)),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(10)),.4)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(90),math.rad(0),math.rad(60)),.4)
			end
			CFuncs["Sound"].Create("rbxassetid://153092227", root, 5,1)
			CFuncs["EchoSound"].Create("rbxassetid://153092227", root, 10, 1,0,10,0.25,0.5,1)
			for i = 0,2,0.1 do
				swait()
				coroutine.resume(coroutine.create(function()
					targetted.Head.CFrame = larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(-90),0,0)
					for i,v in pairs(targetted:GetChildren()) do
						if v:IsA("Part") or v:IsA("MeshPart") then
							v.Velocity = vt(0,0,0)
						end
					end
				end))
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.8)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.8)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(-80)),.8)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(80)),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(10)),.8)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(90),math.rad(0),math.rad(-80)),.8)
			end
			shakes(1.25,1.5)
			CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 1.5, 1,0,10,0.25,0.5,1)
			CFuncs["EchoSound"].Create("rbxassetid://153092227", char, 1.5, 0.9,0,10,0.25,0.5,1)
			for i = 0, 1 do
				CFuncs["EchoSound"].Create("rbxassetid://1690476035", char, 1.5, 1,0.1,10,0.15,0.5,1)
			end
			CFuncs["EchoSound"].Create("rbxassetid://1690476035", root, 10, 1,0.1,10,0.15,0.5,1)
			--chatfunc("RRRRROOAGHH!",Color3.new(1,0,0),"Inverted","Antique",0.75)
			for i = 0,4,0.1 do
				swait()
				coroutine.resume(coroutine.create(function()
					local dis = CreateParta(char,1,1,"Neon",MRCL)
					dis.CFrame = targetted.Head.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
					local at1 = Instance.new("Attachment",dis)
					at1.Position = vt(-25000,0,0)
					local at2 = Instance.new("Attachment",dis)
					at2.Position = vt(25000,0,0)
					local trl = Instance.new('Trail',dis)
					trl.Attachment0 = at1
					trl.FaceCamera = true
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(Color3.new(1,0,0))
					trl.Lifetime = 5
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
					bv.Parent = dis
					game:GetService("Debris"):AddItem(dis, 5)
					targetted.Head.CFrame = larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(-90),0,0)
					CFuncs["Sound"].Create("rbxassetid://782353443", targetted.Head, 4,1)
					CFuncs["Sound"].Create("rbxassetid://824687369", targetted.Head, 6, 1)
					CFuncs["Sound"].Create("rbxassetid://153092227", targetted.Head,6,math.random(75,150)/150)
					CFuncs["Sound"].Create("rbxassetid://163680447", targetted.Head, 3,math.random(75,150)/150)
					CFuncs["Sound"].Create("rbxassetid://782354021", targetted.Head, 2.5,0.75)
					sphere2(5,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,3,3),-0.03,15,-0.03,MRCL)
					targetted:FindFirstChildOfClass("Humanoid").CameraOffset = vt(math.random(-10,10)/5,math.random(-10,10)/5,math.random(-10,10)/5)
					for i = 0, 2 do
						slash(5,5,true,"Round","Add","Out",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(50,350)/250,BrickColor.new("Crimson"))
					end
					symbolizeBlink(targetted.Head,0,2092248396,Color3.new(1,0,0),math.random(3,35),0,0,0,targetted.Head,true,math.random(3,9),0.25)
					for i,v in pairs(targetted:GetChildren()) do
						if v:IsA("Part") or v:IsA("MeshPart") then
							v.Velocity = vt(0,0,0)
						end
					end
				end))
				hum.CameraOffset = vt(math.random(-10,10)/25,math.random(-10,10)/25,math.random(-10,10)/25)
				RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.8)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.8)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(-80)),.8)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(80)),.8)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(40)),.8)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(170),math.rad(0),math.rad(-30)),.8)
			end
			hum.CameraOffset = vt(0,0,0)
			for i = 0, 49 do
				local dis = CreateParta(char,1,1,"Neon",MRCL)
				dis.CFrame = targetted.Head.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				local at1 = Instance.new("Attachment",dis)
				at1.Position = vt(-50000,0,0)
				local at2 = Instance.new("Attachment",dis)
				at2.Position = vt(50000,0,0)
				local trl = Instance.new('Trail',dis)
				trl.Attachment0 = at1
				trl.FaceCamera = true
				trl.Attachment1 = at2
				trl.Texture = "rbxassetid://1049219073"
				trl.LightEmission = 1
				trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
				trl.Color = ColorSequence.new(Color3.new(1,0.1,0.1))
				trl.Lifetime = 5
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
				bv.Parent = dis
				game:GetService("Debris"):AddItem(dis, 5)
			end
			for i = 0, 49 do
				sphere2(math.random(10,75)/10,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(5,5,5),-0.05,50,-0.05,MRCL)
				slash(math.random(10,30)/15,5,true,"Round","Add","Out",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(40,500)/250,BrickColor.new("Really red"))
			end
			CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 2, 0.9,0,10,0.25,0.5,1)
			for i = 0, 1 do
				CFuncs["Sound"].Create("rbxassetid://221920821", targetted.Head, 5,0.9)
				CFuncs["Sound"].Create("rbxassetid://221920821", targetted.Head, 7.5,0.75)
			end
			for i = 0, 4 do
				CFuncs["Sound"].Create("rbxassetid://824687369", targetted.Head, 10, 1)
			end
			symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,1)
			symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,2)
			symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,4)
			dmg(targetted)
			CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			root.CFrame = originalpos
			for i = 0, 9 do
				sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
			end
			for i = 0, 24 do
				PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
			end
			sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
			attack = false
			hum.WalkSpeed = storehumanoidWS
		end
	end

	function CorruptionEvent()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://838392947", root, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
		local keptcolor = MRCL
		for i = 0,4,0.1 do
			swait()
			hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
			block(10,"Add",rleg.CFrame*CFrame.new(0,-1,0),vt(1,1,1),0.01,0.01,0.01,MRCL,MRCL.Color)
			RH.C0=clerp(RH.C0,cf(1,-0.15,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5),math.rad(-20)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,-0.05)*angles(math.rad(-20),math.rad(0),math.rad(10)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-10)),.1)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-5),math.rad(-10),math.rad(20)),.1)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-5),math.rad(10),math.rad(-20)),.1)
		end
		shakes(0.5,1)
		symbolizeBlink(root,0,2109052855,MRCL.Color,25,0,0,0,root,false,0,1)
		symbolizeBlink(root,0,2109052855,MRCL.Color,25,0,0,0,root,false,0,1.5)
		symbolizeBlink(root,0,2109052855,MRCL.Color,25,0,0,0,root,false,0,3)
		CFuncs["Sound"].Create("rbxassetid://1368637781", root, 3,1)
		CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 1.1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", root, 10, 1.1,0,10,0.25,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 1.5, 1.1,0,10,0.25,0.5,1)
		coroutine.resume(coroutine.create(function()
			local eff = Instance.new("ParticleEmitter",cen)
			eff.Texture = "rbxassetid://2344870656"
			eff.LightEmission = 1
			eff.Color = ColorSequence.new(keptcolor.Color)
			eff.Rate = 10000000
			eff.Enabled = true
			eff.EmissionDirection = "Front"
			eff.Lifetime = NumberRange.new(2)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,120,0),NumberSequenceKeypoint.new(0.1,40,0),NumberSequenceKeypoint.new(0.8,80,0),NumberSequenceKeypoint.new(1,140,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(500)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.SpreadAngle = Vector2.new(0,900)
			eff.RotSpeed = NumberRange.new(-500,500)
			wait(0.2)
			eff.Enabled = false
			wait(5)
			eff:Destroy()
		end))
		hum.CameraOffset = vt(0,0,0)
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),1,0.01,1,MRCL,MRCL.Color)
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),2,0.01,2,MRCL,MRCL.Color)
		for i = 0, 24 do
			slash(math.random(15,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.new("Really black"))
		end
		local rrot = 0
		coroutine.resume(coroutine.create(function()
			for i = 0, 4 do
				rrot = rrot + 45
				local xa = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xa.Anchored = true
				local xb = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xb.Anchored = true
				local xc = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xc.Anchored = true
				local xd = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xd.Anchored = true
				CFuncs["Sound"].Create("rbxassetid://824687369", xa, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xa, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xa, 3,1)
				CFuncs["Sound"].Create("rbxassetid://824687369", xb, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xb, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xb, 3,1)
				CFuncs["Sound"].Create("rbxassetid://824687369", xc, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xc, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xc, 3,1)
				CFuncs["Sound"].Create("rbxassetid://824687369", xd, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://822968467", xd, 2,0.95)
				CFuncs["Sound"].Create("rbxassetid://822969951", xd, 3,1)
				xa.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(0,-3,-rrot/1.75)
				xb.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(0,-3,rrot/1.75)
				xc.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(-rrot/1.75,-3,0)
				xd.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(rrot/1.75,-3,0)
				MagniDamage(xa, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				MagniDamage(xb, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				MagniDamage(xc, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				MagniDamage(xd, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
				for i = 0, 9 do
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xb.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xc.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xd.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
				end
				block(1.5,"Add",xa.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				block(1.5,"Add",xb.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				block(1.5,"Add",xc.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				block(1.5,"Add",xd.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xc.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(2,"Add",xd.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
				sphere2(4,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				sphere2(4,"Add",xb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				sphere2(4,"Add",xc.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				sphere2(4,"Add",xd.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
				game:GetService("Debris"):AddItem(xa, 5)
				game:GetService("Debris"):AddItem(xb, 5)
				game:GetService("Debris"):AddItem(xc, 5)
				game:GetService("Debris"):AddItem(xd, 5)
				coroutine.resume(coroutine.create(function()
					for i = 0, 19 do
						swait()
						hum.CameraOffset = vt(math.random(-10,10)/50,math.random(-10,10)/50,math.random(-10,10)/50)
					end
					hum.CameraOffset = vt(0,0,0)
				end))
				swait(9)
			end
		end))
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(10)),.8)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(10)),.8)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,-0.05)*angles(math.rad(10),math.rad(0),math.rad(0)),.8)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(40),math.rad(0),math.rad(0)),.8)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-35),math.rad(-10),math.rad(60)),.8)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-35),math.rad(10),math.rad(-50)),.8)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function EndGROUND()
		attack = true
		hum.WalkSpeed = 0
		bosschatfunc("THIS IS IT!",MRCL.Color,1)
		--CFuncs["Sound"].Create("rbxassetid://838392947", root, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
		CFuncs["EchoSound"].Create("rbxassetid://1690475123", char, 1.5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1690475123", root, 10, 1,0,10,0.15,0.5,1)
		local keptcolor = MRCL
		for i = 0,4,0.1 do
			swait()
			hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
			block(10,"Add",rarm.CFrame*CFrame.new(0,-6,0),vt(4,4,4),0.05,0.05,0.05,MRCL,MRCL.Color)
			slash(math.random(25,50)/10,5,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-6,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.01,0.1),-0.1,BrickColor.new("Really black"))
			RH.C0=clerp(RH.C0,cf(1,-0.15,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-15),math.rad(-20)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,-0.05)*angles(math.rad(-20),math.rad(0),math.rad(30)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.1)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(170),math.rad(-5),math.rad(10)),.1)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-5),math.rad(10),math.rad(-20)),.1)
		end
		shakes(0.5,1)
		symbolizeBlink(root,0,2109052855,MRCL.Color,25,0,0,0,root,false,0,1)
		CFuncs["Sound"].Create("rbxassetid://1368637781", root, 3,1)
		CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 1.1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", root, 10, 1,0,10,0.25,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 2, 1,0,10,0.25,0.5,1)
		coroutine.resume(coroutine.create(function()
			local eff = Instance.new("ParticleEmitter",cen)
			eff.Texture = "rbxassetid://2344870656"
			eff.LightEmission = 1
			eff.Color = ColorSequence.new(keptcolor.Color)
			eff.Rate = 10000000
			eff.Enabled = true
			eff.EmissionDirection = "Front"
			eff.Lifetime = NumberRange.new(2)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,120,0),NumberSequenceKeypoint.new(0.1,40,0),NumberSequenceKeypoint.new(0.8,80,0),NumberSequenceKeypoint.new(1,140,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(500)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.SpreadAngle = Vector2.new(0,900)
			eff.RotSpeed = NumberRange.new(-500,500)
			wait(0.2)
			eff.Enabled = false
			wait(5)
			eff:Destroy()
		end))
		coroutine.resume(coroutine.create(function()
			local shval = 10
			for i = 0, 99 do
				swait()
				shval = shval - 0.1
				hum.CameraOffset = vt(math.random(-shval,shval)/15,math.random(-shval,shval)/15,math.random(-shval,shval)/15)
			end
			hum.CameraOffset = vt(0,0,0)
		end))
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),1,0.01,1,MRCL,MRCL.Color)
		sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),2,0.01,2,MRCL,MRCL.Color)
		for i = 0, 24 do
			slash(math.random(15,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.new("Really black"))
		end
		local rrot = 0
		local xam = 1
		coroutine.resume(coroutine.create(function()
			for i = 0, 14 do
				--swait()
				rrot = rrot + 40*xam
				xam = xam + 0.25
				local bonus = xam
				local xa = CreateParta(char,0.5,1,"Neon",BrickColor.random())
				xa.Anchored = true
				xa.Color = Color3.new(0,0,0)
				xa.CFrame = root.CFrame*CFrame.new(0,-3,-rrot/1.75)
				CreateMesh(xa,"Sphere",30*bonus,1,30*bonus)
				local xc = 0
				coroutine.resume(coroutine.create(function()
					for i = 0, 99 do
						swait()
						xc = xc + 0.01
						xa.Color = Color3.new(xc,0,0)
					end
					shakes(0.35,0.5)
					xa.Transparency = 1
					CFuncs["Sound"].Create("rbxassetid://331666100", xa, 5,0.75)
					MagniDamage(xa, 30*bonus, 78*bonus,99*bonus, 0, "Normal")
					for i = 0, 9 do
						slash(math.random(15,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01*bonus,0.01,0.01*bonus),math.random(50,125)/250*bonus,BrickColor.new("Really black"))
					end
					block(1.5,"Add",xa.CFrame*CFrame.new(0,-10,0),vt(30*bonus,30*bonus,30*bonus),0.3,0.3,0.3,keptcolor,keptcolor.Color)
					sphere2(2,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25*bonus,1,25*bonus),0.05*bonus,1.5*bonus,0.05*bonus,keptcolor,keptcolor.Color)
					sphere2(4,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30*bonus,1,30*bonus),0.05*bonus,1.5*bonus,0.05*bonus,BrickColor.new("Really black"),Color3.new(0,0,0))
					game:GetService("Debris"):AddItem(xa, 5)
					coroutine.resume(coroutine.create(function()
						for i = 0, 19 do
							swait()
							hum.CameraOffset = vt(math.random(-10,10)/50,math.random(-10,10)/50,math.random(-10,10)/50)
						end
						hum.CameraOffset = vt(0,0,0)
					end))
				end))
			end
		end))
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-25),math.rad(30)),.8)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.8)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,-0.5)*angles(math.rad(30),math.rad(0),math.rad(50)),.8)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-50)),.8)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(35),math.rad(-10),math.rad(30)),.8)
			LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-35),math.rad(10),math.rad(-50)),.8)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function HeavenlyDisk()
		attack = true
		hum.WalkSpeed = 2
		local keptcolor = MRCL
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Dont make this too easy for you.",MRCL.Color,1)
		elseif radm == 2 then
			bosschatfunc("Heavenly Disks!",MRCL.Color,1)
		elseif radm == 3 then
			bosschatfunc("Take it!",MRCL.Color,1)
		end
		CFuncs["Sound"].Create("rbxassetid://847061203", root, 2, 1)
		CFuncs["EchoSound"].Create("rbxassetid://1625448638", root, 4, 1,0,10,0.15,0.5,1)
		sphere2(5,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.1,0.1,0.1,keptcolor,keptcolor.Color)
		sphere2(5,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.2,0.2,0.2,keptcolor,keptcolor.Color)
		for i = 0, 14 do
			PixelBlock(1,math.random(1,3),"Add",larm.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,BrickColor.new("Toothpaste"),0)
		end
		for i = 0,2,0.1 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.3)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.3)
		end
		CFuncs["Sound"].Create("rbxassetid://763755889", root, 2.5,1.1)
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(180)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		for i = 0,1,0.6 do
			swait()
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
			slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(270)),.6)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
		end
		local rot = 15
		for i = 0, 2 do
			local dis = CreateParta(char,0.5,1,"Neon",BrickColor.new("Toothpaste"))
			CFuncs["EchoSound"].Create("rbxassetid://763718160", dis, 3, 1.1,0,10,0.15,0.5,1)
			dis.CFrame = root.CFrame*CFrame.new(0,2,-3)
			CreateMesh(dis,"Sphere",10,1,10)
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-5,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(5,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 0.6
			local a = Instance.new("Part",workspace)
			a.Name = "Direction"	
			a.Anchored = true
			a.BrickColor = bc("Bright red")
			a.Material = "Neon"
			a.Transparency = 1
			a.CanCollide = false
			local ray = Ray.new(
				dis.CFrame.p,                           -- origin
				(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
			) 
			local ignore = dis
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			local distance = (dis.CFrame.p - position).magnitude
			a.Size = Vector3.new(0.1, 0.1, 0.1)
			a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
			dis.CFrame = a.CFrame
			dis.CFrame = dis.CFrame*CFrame.Angles(0,math.rad(rot),0)
			a:Destroy()
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*250
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 5)
			local hitted = false
			coroutine.resume(coroutine.create(function()
				dis.Touched:connect(function(hit) 
					if hitted == false and hit.Parent ~= char then
						hitted = true
						shakes(0.15,0.25)
						CFuncs["EchoSound"].Create("rbxassetid://782200047", dis, 7, 1.1,0,10,0.15,0.5,1)
						MagniDamage(dis, 30, 82,34575, 0, "Normal")
						sphere2(8,"Add",dis.CFrame,vt(10,1,10),1,0.1,1,keptcolor,keptcolor.Color)
						sphere2(4,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,keptcolor,keptcolor.Color)
						sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,BrickColor.new("White"),Color3.new(1,1,1))
						coroutine.resume(coroutine.create(function()
							local eff = Instance.new("ParticleEmitter",dis)
							eff.Texture = "rbxassetid://2344870656"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(dis.Color)
							eff.Rate = 10000000
							eff.Enabled = true
							eff.EmissionDirection = "Front"
							eff.Lifetime = NumberRange.new(1)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,20,0),NumberSequenceKeypoint.new(0.8,40,0),NumberSequenceKeypoint.new(1,60,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(150)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.SpreadAngle = Vector2.new(0,900)
							eff.RotSpeed = NumberRange.new(-500,500)
							wait(0.2)
							eff.Enabled = false
						end))
						coroutine.resume(coroutine.create(function()
							for i = 0, 9 do
								local disr = CreateParta(char,1,1,"Neon",keptcolor)
								disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
								local at1 = Instance.new("Attachment",disr)
								at1.Position = vt(-2,0,0)
								local at2 = Instance.new("Attachment",disr)
								at2.Position = vt(2,0,0)
								local trl = Instance.new('Trail',disr)
								trl.Attachment0 = at1
								trl.FaceCamera = true
								trl.Attachment1 = at2
								trl.Texture = "rbxassetid://2342682798"
								trl.LightEmission = 1
								trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
								trl.Color = ColorSequence.new(Color3.new(0.3,1,1))
								trl.Lifetime = 0.5
								local bv = Instance.new("BodyVelocity")
								bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
								bv.velocity = disr.CFrame.lookVector*math.random(50,200)
								bv.Parent = disr
								local val = 0
								coroutine.resume(coroutine.create(function()
									swait(30)
									for i = 0, 9 do
										swait()
										val = val + 0.1
										trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
									end
									game:GetService("Debris"):AddItem(disr, 3)
								end))
							end
							local eff = Instance.new("ParticleEmitter",dis)
							eff.Texture = "rbxassetid://2273224484"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(Color3.new(0.3,1,1))
							eff.Rate = 500000
							eff.Lifetime = NumberRange.new(0.5,2)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(20,250)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.VelocitySpread = 9000
							eff.RotSpeed = NumberRange.new(-50,50)
							wait(0.25)
							eff.Enabled = false
						end))
						for i = 0, 9 do
							slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(100,200)/250,BrickColor.new("White"))
						end
						for i = 0, 19 do
							PixelBlock(1,math.random(5,20),"Add",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),4,4,4,0.08,BrickColor.new("Toothpaste"),0)
						end
						coroutine.resume(coroutine.create(function()
							for i = 0, 19 do
								swait()
								hum.CameraOffset = vt(math.random(-10,10)/70,math.random(-10,10)/70,math.random(-10,10)/70)
							end
							hum.CameraOffset = vt(0,0,0)
						end))
						dis.Anchored = true
						dis.Transparency = 1
						wait(8)
						dis:Destroy()
					end
				end)
			end))
			rot = rot - 15
		end
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-30),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(5)),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(60)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(-50)),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function EternalChaosOrb()
		attack = true
		hum.WalkSpeed = 1
		local keptcolor = MRCL
		CFuncs["Sound"].Create("rbxassetid://1042700914", root, 5, 0.25)
		for i = 0,14,0.1 do
			swait()
			slash(math.random(25,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,6,1)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.2,0.01,0.2),-0.2,BrickColor.random())
			sphere2(3,"Add",root.CFrame*CFrame.new(0,6,0) + root.CFrame.lookVector*1,vt(3,3,3),0.06,0.06,0.06,MRCL)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-35),math.rad(0),math.rad(0)),.1)
			RW.C0 = clerp(RW.C0, CFrame.new(1.25, 1, -0.5) * angles(math.rad(170), math.rad(0), math.rad(-20)), 0.1)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 1, -0.5) * angles(math.rad(170), math.rad(0), math.rad(20)), 0.1)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(0)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
		end
		local dis = CreateParta(char,0,1,"Neon",BrickColor.new("Black"))
		for i = 0, 4 do
			CFuncs["Sound"].Create("rbxassetid://335657174", dis, 10, 0.5)
		end
		dis.CFrame = root.CFrame*CFrame.new(0,2,-3)
		CreateMesh(dis,"Sphere",10,10,10)
		local at1 = Instance.new("Attachment",dis)
		at1.Position = vt(-5,0,0)
		local at2 = Instance.new("Attachment",dis)
		at2.Position = vt(5,0,0)
		local trl = Instance.new('Trail',dis)
		trl.Attachment0 = at1
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 1
		trl.FaceCamera = true
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(dis.Color)
		trl.Lifetime = 3
		local efec = Instance.new("ParticleEmitter",dis)
		efec.Texture = "rbxassetid://2109052855"
		efec.LightEmission = 1
		efec.Color = ColorSequence.new(Color3.new(0.5,0,1))
		efec.Rate = 5
		efec.Lifetime = NumberRange.new(3)
		efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,25,0),NumberSequenceKeypoint.new(0.2,50,0),NumberSequenceKeypoint.new(0.6,35,0),NumberSequenceKeypoint.new(0.8,50,0),NumberSequenceKeypoint.new(1,75,0)})
		efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.25,0),NumberSequenceKeypoint.new(0.6,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
		efec.Drag = 5
		efec.LockedToPart = true
		efec.Rotation = NumberRange.new(-500,500)
		efec.VelocitySpread = 9000
		efec.RotSpeed = NumberRange.new(-500,500)
		local a = Instance.new("Part",workspace)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			dis.CFrame.p,                           -- origin
			(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
		) 
		local ignore = dis
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (dis.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
		dis.CFrame = a.CFrame
		a:Destroy()
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = dis.CFrame.lookVector*100
		bv.Parent = dis
		game:GetService("Debris"):AddItem(dis, 15)
		local hitted = false
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if hitted == false and dis.Parent ~= nil then
					PixelBlock(3,math.random(0,2),"Add",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),5,5,5,0.05,BrickColor.random(),0)
					trl.Color = ColorSequence.new(Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
					efec.Color = ColorSequence.new(Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
					coroutine.resume(coroutine.create(function()
						for i, v in pairs(FindNearestHead(dis.CFrame.p, 50)) do
							if v:FindFirstChild('Head') then
								dmg(v)
							end
						end
					end))
				elseif hitted == true and dis.Parent == nil then
					break
				end
			end
		end))
		coroutine.resume(coroutine.create(function()
			dis.Touched:connect(function(hit) 
				if hitted == false and hit.Parent ~= char then
					hitted = true
					shakes(1,1)
					efec.Enabled = false
					for i = 0, 3 do
						CFuncs["Sound"].Create("rbxassetid://1368637781", dis, 7.5,1)
						CFuncs["Sound"].Create("rbxassetid://763718160", dis, 10, 1.1)
						CFuncs["Sound"].Create("rbxassetid://782353443", dis, 10, 1)
						CFuncs["Sound"].Create("rbxassetid://335657174", dis, 10, 1)
					end
					MagniDamage(dis, 125, 82000,345700005, 0, "Normal")
					coroutine.resume(coroutine.create(function()
						for i, v in pairs(FindNearestHead(dis.CFrame.p, 100)) do
							if v:FindFirstChild('Head') then
								dmg(v)
							end
						end
					end))
					sphere2(2,"Add",dis.CFrame,vt(1,1,1),3,3,3,keptcolor,keptcolor.Color)
					sphere2(3,"Add",dis.CFrame,vt(1,1,1),3,3,3,BrickColor.random(),keptcolor.Color)
					sphere2(4,"Add",dis.CFrame,vt(1,1,1),4,4,4,BrickColor.random(),keptcolor.Color)
					sphere2(5,"Add",dis.CFrame,vt(1,1,1),4,4,4,BrickColor.random(),keptcolor.Color)
					coroutine.resume(coroutine.create(function()
						local eff = Instance.new("ParticleEmitter",dis)
						eff.Texture = "rbxassetid://2344870656"
						eff.LightEmission = 1
						eff.Color = ColorSequence.new(dis.Color)
						eff.Rate = 10000000
						eff.Enabled = true
						eff.EmissionDirection = "Front"
						eff.Lifetime = NumberRange.new(3)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,20,0),NumberSequenceKeypoint.new(0.8,40,0),NumberSequenceKeypoint.new(1,60,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(350)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.SpreadAngle = Vector2.new(0,900)
						eff.RotSpeed = NumberRange.new(-500,500)
						wait(0.2)
						eff.Enabled = false
					end))
					coroutine.resume(coroutine.create(function()
						for i = 0, 9 do
							local disr = CreateParta(char,1,1,"Neon",keptcolor)
							disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
							local at1 = Instance.new("Attachment",disr)
							at1.Position = vt(-30,0,0)
							local at2 = Instance.new("Attachment",disr)
							at2.Position = vt(30,0,0)
							local trl = Instance.new('Trail',disr)
							trl.Attachment0 = at1
							trl.FaceCamera = true
							trl.Attachment1 = at2
							trl.Texture = "rbxassetid://2342682798"
							trl.LightEmission = 1
							trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
							trl.Color = ColorSequence.new(Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
							trl.Lifetime = 0.5
							local bv = Instance.new("BodyVelocity")
							bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
							bv.velocity = disr.CFrame.lookVector*math.random(150,350)
							bv.Parent = disr
							local val = 0
							coroutine.resume(coroutine.create(function()
								swait(30)
								for i = 0, 9 do
									swait()
									val = val + 0.1
									trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
								end
								game:GetService("Debris"):AddItem(disr, 3)
							end))
						end
						local eff = Instance.new("ParticleEmitter",dis)
						eff.Texture = "rbxassetid://2273224484"
						eff.LightEmission = 1
						eff.Color = ColorSequence.new(Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
						eff.Rate = 500000
						eff.Lifetime = NumberRange.new(0.5,2)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,4,0),NumberSequenceKeypoint.new(1,0,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(100,400)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.VelocitySpread = 9000
						eff.RotSpeed = NumberRange.new(-50,50)
						wait(0.25)
						eff.Enabled = false
					end))
					for i = 0, 19 do
						slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(200,800)/250,BrickColor.new("White"))
					end
					for i = 0, 49 do
						PixelBlock(1,math.random(5,40),"Add",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10,10,10,0.2,BrickColor.random(),0)
					end
					coroutine.resume(coroutine.create(function()
						for i = 0, 19 do
							swait()
							hum.CameraOffset = vt(math.random(-10,10)/70,math.random(-10,10)/70,math.random(-10,10)/70)
						end
						hum.CameraOffset = vt(0,0,0)
					end))
					dis.Anchored = true
					dis.Transparency = 1
					wait(8)
					dis:Destroy()
				end
			end)
		end))
		for i = 0,2,0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.5)* angles(math.rad(30),math.rad(0),math.rad(0)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(-10)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(10)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-0.75 - 0.05 * math.cos(sine / 25),-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(30)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function RapidBurst()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://1368598393", char, 2.5, 0.5)
		CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 0.5)
		CFuncs["EchoSound"].Create("rbxassetid://1718412034", char, 4, 1,0,10,0.15,0.5,1)
		bosschatfunc("SHATTER!",MRCL.Color,2)
		local keptcolor = MRCL
		for i = 0,8,0.1 do
			swait()
			hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
			slash(math.random(25,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,25,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(2,0.01,2),-2,BrickColor.random())
			block(10,"Add",root.CFrame*CFrame.new(0,25,0),vt(0,0,0),0.5,0.5,0.5,BrickColor.random(),Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-15 - 2 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 2 * math.cos(sine / 32))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.15 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(-15 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-25 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
			RW.C0=clerp(RW.C0,cf(1.35,1 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-10 + 3 * math.cos(sine / 45))),.1)
			LW.C0=clerp(LW.C0,cf(-1.35,1 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(13 - 3 * math.cos(sine / 45))),.1)
		end
		shakes(1,3)
		for i = 0, 99 do
			local dis = CreateParta(char,1,1,"Neon",MRCL)
			dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-25000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(25000,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.FaceCamera = true
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
			trl.Lifetime = 5
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 5)
		end
		symbolizeBlink(root,0,2109052855,MRCL.Color,125,0,0,0,root,false,0,1)
		symbolizeBlink(root,0,2109052855,MRCL.Color,125,0,0,0,root,false,0,1.5)
		symbolizeBlink(root,0,2109052855,MRCL.Color,125,0,0,0,root,false,0,3)
		sphere2(2,"Add",root.CFrame,vt(1,1,1),1,1,1,BrickColor.random(),Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
		sphere2(2,"Add",root.CFrame,vt(1,1,1),2,2,2,BrickColor.random(),Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
		sphere2(2,"Add",root.CFrame,vt(1,1,1),4,4,4,BrickColor.random(),Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
		sphere2(2,"Add",root.CFrame,vt(1,1,1),8,8,8,BrickColor.random(),Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
		CFuncs["Sound"].Create("rbxassetid://1841058541", root, 10,1)
		CFuncs["Sound"].Create("rbxassetid://2095993595", char, 5,0.8)
		CFuncs["Sound"].Create("rbxassetid://1841058541", char, 5,1)
		hum.CameraOffset = vt(0,0,0)
		for i = 0, 24 do
			slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(500,1500)/250,BrickColor.random())
		end
		local distam = 0
		coroutine.resume(coroutine.create(function()
			for i = 0, 99 do
				wait()
				distam = distam + 1
				local xa = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
				xa.Anchored = true
				xa.CFrame = root.CFrame*CFrame.new(math.random(-distam,distam),math.random(-distam,distam),math.random(-distam,distam))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				game:GetService("Debris"):AddItem(xa, 5)
				for i = 0, 4 do
					slash(math.random(25,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.random())
				end
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",xa)
					eff.Texture = "rbxassetid://2344870656"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(xa.Color)
					eff.Rate = 10000000
					eff.Enabled = true
					eff.Lifetime = NumberRange.new(2.5)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,20,0),NumberSequenceKeypoint.new(0.8,40,0),NumberSequenceKeypoint.new(1,60,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(200)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.SpreadAngle = Vector2.new(0,900)
					eff.RotSpeed = NumberRange.new(-500,500)
					wait(0.2)
					eff.Enabled = false
				end))
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",xa)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(1,3)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,30,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(50,500)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					wait(0.25)
					eff.Enabled = false
				end))
				coroutine.resume(coroutine.create(function()
					for i = 0, 19 do
						swait()
						hum.CameraOffset = vt(math.random(-10,10)/10,math.random(-10,10)/10,math.random(-10,10)/10)
					end
					hum.CameraOffset = vt(0,0,0)
				end))
				CFuncs["Sound"].Create("rbxassetid://675172759", xa, 7,math.random(100,200)/200)
				sphere2(5,"Add",xa.CFrame,vt(1,1,1),1,1,1,BrickColor.random(),Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
				sphere2(5,"Add",xa.CFrame,vt(1,1,1),2,2,2,BrickColor.random(),Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
				MagniDamage(xa, 60, 9999,99999, 0, "Normal")
			end
		end))
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end


	function EquinoxOrbs()
		hum.WalkSpeed = 0
		attack = true
		for i = 0,1,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5)*angles(math.rad(90),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(5),math.rad(40)),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(-5),math.rad(-40)),.3)
		end
		shakes(0.4,0.5)
		sphere2(5,"Add",root.CFrame,vt(1,1,1),1.5,1.5,1.5,MRCL)
		sphere2(5,"Add",root.CFrame,vt(1,1,1),1,1,1,MRCL)
		for i = 0, 24 do
			slash(math.random(10,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),math.rad(0)),vt(0.01,0.01,0.01),math.random(100,400)/250,BrickColor.new("White"))
		end
		CFuncs["Sound"].Create("rbxassetid://763716870", root, 8,1)
		CFuncs["Sound"].Create("rbxassetid://782353443", root, 10,0.8)
		CFuncs["Sound"].Create("rbxassetid://782225570", root, 9,0.5)
		CFuncs["Sound"].Create("rbxassetid://763717569", root, 8,0.9)
		for i = 0,4,0.1 do
			swait()
			root.CFrame = root.CFrame + root.CFrame.lookVector*7.5
			local dis = CreateParta(char,0.25,1,"Neon",MRCL)
			CreateMesh(dis,"Sphere",1,1,1)
			dis.Anchored = true
			dis.CFrame = larm.CFrame*CFrame.new(0,-3,0)
			local dis2 = CreateParta(char,0.25,1,"Neon",BrickColor.new("Really black"))
			CreateMesh(dis2,"Sphere",1,1,1)
			dis2.Anchored = true
			dis2.CFrame = rarm.CFrame*CFrame.new(0,-3,0)
			sphere2(5,"Add",dis.CFrame,vt(1,1,1),0.1,0.1,0.1,dis.BrickColor,dis.Color)
			sphere2(5,"Add",dis2.CFrame,vt(1,1,1),0.1,0.1,0.1,dis2.BrickColor,dis2.Color)
			coroutine.resume(coroutine.create(function()
				swait(60)
				dis.Transparency = 1
				dis2.Transparency = 1
				coroutine.resume(coroutine.create(function()
					for i = 0, 19 do
						swait()
						hum.CameraOffset = vt(math.random(-10,10)/40,math.random(-10,10)/40,math.random(-10,10)/40)
					end
					hum.CameraOffset = vt(0,0,0)
				end))
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",dis)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(dis.Color)
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(0.5,2)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(50,450)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					local eff2 = eff:Clone()
					eff2.Parent = dis2
					eff2.LightEmission = 0
					eff2.Color = ColorSequence.new(dis2.Color)
					wait(0.25)
					eff.Enabled = false
					eff2.Enabled = false
				end))
				MagniDamage(dis, 55, 89,219788936, 0, "Normal")
				MagniDamage(dis2, 55, 89,219788936, 0, "Normal")
				for i = 0, 2 do
					slash(math.random(10,80)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,300)/250,dis.BrickColor)
					slash(math.random(10,80)/10,5,true,"Round","Add","Out",dis2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,300)/250,dis2.BrickColor)
				end
				CFuncs["Sound"].Create("rbxassetid://782353117", dis, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://782353117", dis2, 1,0.75)
				CFuncs["Sound"].Create("rbxassetid://1666361078", dis, 1,1.25)
				CFuncs["Sound"].Create("rbxassetid://1666361078", dis2, 1,1.25)
				CFuncs["Sound"].Create("rbxassetid://782353443", dis, 2,1.15)
				CFuncs["Sound"].Create("rbxassetid://782353443", dis2, 2,1.15)
				sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.8,0.8,0.8,dis.BrickColor,dis.Color)
				sphere2(3,"Add",dis2.CFrame,vt(1,1,1),0.8,0.8,0.8,dis2.BrickColor,dis2.Color)
			end))
			game:GetService("Debris"):AddItem(dis, 5)
			game:GetService("Debris"):AddItem(dis2, 5)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20)),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20)),.2)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0.5)*angles(math.rad(90),math.rad(0),math.rad(0)),.2)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17),math.rad(0),math.rad(0)),.2)
			RW.C0=clerp(RW.C0,cf(1.4,1.5,0)*angles(math.rad(0),math.rad(5),math.rad(210)),.1)
			LW.C0=clerp(LW.C0,cf(-1.4,1.5,0)*angles(math.rad(0),math.rad(-5),math.rad(-210)),.1)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function roldbeam()
		attack = true
		hum.WalkSpeed = 0
		local rngb = Instance.new("Part", char)
		rngb.Anchored = true
		rngb.BrickColor = origcolor
		rngb.CanCollide = false
		rngb.FormFactor = 3
		rngb.Name = "Ring"
		rngb.Material = "Neon"
		rngb.Size = Vector3.new(1, 0.05, 1)
		rngb.Transparency = 1
		rngb.TopSurface = 0
		rngb.BottomSurface = 0
		local rngmb = Instance.new("SpecialMesh", rngb)
		rngmb.MeshType = "Brick"
		rngmb.Name = "SizeMesh"
		rngmb.Scale = vt(0,1,0)

		local orb = rngb:Clone()
		orb.Parent = char
		orb.Transparency = 0
		orb.BrickColor = BrickColor.new("White")
		orb.Size = vt(1,1,1)
		local orbmish = orb.SizeMesh
		orbmish.Scale = vt(0,0,0)
		orbmish.MeshType = "Sphere"

		local orbe = rngb:Clone()
		orbe.Parent = char
		orbe.Transparency = 0.5
		orbe.BrickColor = BrickColor.new("New Yeller")
		orbe.Size = vt(1,1,1)
		local orbmish2 = orbe.SizeMesh
		orbmish2.Scale = vt(0,0,0)
		orbmish2.MeshType = "Sphere"
		orbe.Color = Color3.new(r/255,g/255,b/255)

		local obj1 = script.chring2:Clone()
		obj1.Parent = char
		obj1.Transparency = 1
		obj1.Size = vt(1,1,1)
		obj1.Color = BrickColor.new("White").Color

		rngb:Destroy()
--[[CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1.5, 1)
local scaled = 1
for i = 0,5,0.1 do
swait()
scaled = scaled - 0.02
if rainbowmode == true then
orbe.Color = Color3.new(r/255,g/255,b/255)
end
orbmish.Scale = orbmish.Scale + vt(scaled/1.5,scaled/1.5,scaled/1.5)
orbmish2.Scale = orbmish2.Scale + vt(scaled*1.1/1.5,scaled*1.1/1.5,scaled*1.1/1.5)
orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
sphereMKCharge(2.5,-0.5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MRCL,25)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)
RootPart.CFrame = FaceMouse()[1]
end]]--
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 2, 2)
		local rval = 0
		local effx = Instance.new("ParticleEmitter",obj1)
		effx.Texture = "rbxassetid://2344870656"
		effx.LightEmission = 1
		effx.Color = ColorSequence.new(Color3.new(1,1,1))
		effx.Rate = 10000000
		effx.Enabled = true
		effx.EmissionDirection = "Front"
		effx.Lifetime = NumberRange.new(0.5)
		effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,10,0),NumberSequenceKeypoint.new(0.1,10,0),NumberSequenceKeypoint.new(0.8,25,0),NumberSequenceKeypoint.new(1,0,0)})
		effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
		effx.Speed = NumberRange.new(50)
		effx.Drag = 5
		effx.Rotation = NumberRange.new(-500,500)
		effx.SpreadAngle = Vector2.new(900,900)
		effx.RotSpeed = NumberRange.new(-500,500)
		for i = 0,2,0.1 do
			swait()
			if rainbowmode == true then
				obj1.Color = Color3.new(r/255,g/255,b/255)
				orbe.Color = Color3.new(r/255,g/255,b/255)
				effx.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			end
			rval = rval + math.random(30,40)
			obj1.Transparency = obj1.Transparency - 0.05
			obj1.Size = obj1.Size + vt(1.5,1.5,0.3)
			obj1.CFrame = root.CFrame*CFrame.new(0,1,-5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(rval))
			orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
			orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)
		end
		orbe.Transparency = 1
		orb.Transparency = 1
		orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*5
		CFuncs["Sound"].Create("rbxassetid://294188875", char, 1, 1.5)
		local a = Instance.new("Part",Character)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("White")
		a.Material = "Neon"
		a.Transparency = 0
		a.Shape = "Cylinder"
		a.CanCollide = false
		local a2 = Instance.new("Part",Character)
		a2.Name = "Direction"	
		a2.Anchored = true
		a2.BrickColor = bc("New Yeller")
		a2.Color = Color3.new(r/255,g/255,b/255)
		a2.Material = "Neon"
		a2.Transparency = 0.5
		a2.Shape = "Cylinder"
		a2.CanCollide = false
		local ba = Instance.new("Part",Character)
		ba.Name = "HitDirect"	
		ba.Anchored = true
		ba.BrickColor = bc("Cool yellow")
		ba.Material = "Neon"
		ba.Transparency = 1
		ba.CanCollide = false
		local ray = Ray.new(
			orb.CFrame.p,                           -- origin
			(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
		) 
		local ignore = Character
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		a2.BottomSurface = 10
		a2.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance, 1, 1)
		a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		a2.Size = Vector3.new(distance, 1, 1)
		a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
		a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
		a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
		game:GetService("Debris"):AddItem(a, 20)
		game:GetService("Debris"):AddItem(a2, 20)
		game:GetService("Debris"):AddItem(ba, 20)
		local msh = Instance.new("SpecialMesh",a)
		msh.MeshType = "Cylinder"
		msh.Scale = vt(1,5*5,5*5)
		local msh2 = Instance.new("SpecialMesh",a2)
		msh2.MeshType = "Cylinder"
		msh2.Scale = vt(1,6*5,6*5)
		local eff = Instance.new("ParticleEmitter",ba)
		eff.Texture = "rbxassetid://2344870656"
		eff.LightEmission = 1
		eff.Color = ColorSequence.new(Color3.new(1,1,1))
		eff.Rate = 10000000
		eff.Enabled = true
		eff.EmissionDirection = "Front"
		eff.Lifetime = NumberRange.new(1)
		eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.1,50,0),NumberSequenceKeypoint.new(0.8,100,0),NumberSequenceKeypoint.new(1,120,0)})
		eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
		eff.Speed = NumberRange.new(50)
		eff.Drag = 5
		eff.Rotation = NumberRange.new(-500,500)
		eff.SpreadAngle = Vector2.new(900,900)
		eff.RotSpeed = NumberRange.new(-500,500)
		local eff2 = eff:Clone()
		eff2.Parent = ba
		eff2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.1,3,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
		eff2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
		eff2.Speed = NumberRange.new(350)
		shakes(0.6,1.25)
		for i = 0,10,0.1 do
			swait()
			rval = rval + math.random(30,40)
			obj1.Color = Color3.new(r/255,g/255,b/255)
			effx.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			eff.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			eff2.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
			obj1.CFrame = root.CFrame*CFrame.new(0,1,-5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(rval))
			a2.Color = Color3.new(r/255,g/255,b/255)
			orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
			orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
			ray = Ray.new(
				orb.CFrame.p,                           -- origin
				(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
			) 
			hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			distance = (orb.CFrame.p - position).magnitude
			a.Size = Vector3.new(distance, 1, 1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			a2.Size = Vector3.new(distance, 1, 1)
			a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
			ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
			a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
			a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
			msh.Scale = msh.Scale - vt(0,0.05*5,0.05*5)
			msh2.Scale = msh2.Scale - vt(0,0.06*5,0.06*5)
			slash(math.random(50,80)/10,5,true,"Round","Add","Out",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,250)/250,ba.BrickColor)
			sphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,MRCL,0)
			sphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,MRCL,0)
			sphereMK(5,2.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,100,-0.03,MRCL,0)
			MagniDamage(ba, 30, 500,60000, 0, "Normal")
		end
		a:Destroy()
		a2:Destroy()
		orb:Destroy()
		orbe:Destroy()
		eff.Enabled = false
		eff2.Enabled = false
		effx.Enabled = false
		coroutine.resume(coroutine.create(function()
			for i = 0,24 do
				swait()
				obj1.Transparency = obj1.Transparency + 0.04
				obj1.Size = obj1.Size + vt(-1,-1,0)
			end
			wait(1)
			obj1:Destroy()
		end))
		coroutine.resume(coroutine.create(function()
			wait(5)
			ba:Destroy()
		end))
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function CalMets()
		attack = true
		hum.WalkSpeed = 0
		local lookavec = 0 
		local mult = 1
		local keptcolor = MRCL
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 7, 1.25)
		for i = 0,4,0.1 do
			swait()
			slash(math.random(25,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,10,1)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.2,0.01,0.2),-0.2,keptcolor)
			sphere2(3,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(3,3,3),0.06,0.06,0.06,MRCL)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 5 * math.cos(sine / 51))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 44))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-35),math.rad(0),math.rad(0)),.1)
			RW.C0 = clerp(RW.C0, CFrame.new(1.25, 1, -0.5) * angles(math.rad(170), math.rad(0), math.rad(-20)), 0.1)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 1, -0.5) * angles(math.rad(170), math.rad(0), math.rad(20)), 0.1)
		end
		sphere2(2,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(3,3,3),0.6,0.6,0.6,keptcolor)
		sphere2(4,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(3,3,3),0.6,0.6,0.6,keptcolor)
		sphere2(3,"Add",root.CFrame*CFrame.new(0,10,0) + root.CFrame.lookVector*1,vt(1,10000,1),0.06,0.06,0.06,keptcolor)
		local elocacenter = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
		elocacenter.Anchored = true
		elocacenter.CFrame = root.CFrame*CFrame.new(0,150,0)
		local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
		eloca1.Anchored = true
		eloca1.CFrame = elocacenter.CFrame
		local at1 = Instance.new("Attachment",eloca1)
		at1.Position = vt(0,30,0)
		local at2 = Instance.new("Attachment",eloca1)
		at2.Position = vt(0,-30,0)
		local at1b = Instance.new("Attachment",eloca1)
		at1b.Position = vt(0,0,180)
		local at2b = Instance.new("Attachment",eloca1)
		at2b.Position = vt(0,0,-180)
		local trl = Instance.new('Trail',eloca1)
		trl.Attachment0 = at1
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 1
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(keptcolor.Color)
		trl.Lifetime = 4
		local trl2 = trl:Clone()
		trl2.Parent = eloca1
		trl2.Attachment0 = at1b
		trl2.Attachment1 = at2b
		trl2.Texture = "rbxassetid://2108945559"
		trl2.Lifetime = 2
		local eff = Instance.new("ParticleEmitter",eloca1)
		eff.Texture = "rbxassetid://2273224484"
		eff.LightEmission = 1
		eff.Color = ColorSequence.new(keptcolor.Color)
		eff.Rate = 500000
		eff.Lifetime = NumberRange.new(0.5,3)
		eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
		eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
		eff.Speed = NumberRange.new(20,250)
		eff.Drag = 5
		eff.Rotation = NumberRange.new(-500,500)
		eff.VelocitySpread = 9000
		eff.RotSpeed = NumberRange.new(-50,50)
		local eloca2 = eloca1:Clone()
		eloca2.Parent = elocacenter
		local eloca3 = eloca1:Clone()
		eloca3.Parent = elocacenter
		local eloca4 = eloca1:Clone()
		eloca4.Parent = elocacenter
		shakes(0.5,0.5)
		sphere2(2,"Add",elocacenter.CFrame,vt(1,1,1),2,2,2,keptcolor)
		sphere2(3,"Add",elocacenter.CFrame,vt(1,1,1),4,4,4,keptcolor)
		sphere2(4,"Add",elocacenter.CFrame,vt(1,1,1),5,5,5,keptcolor)
		sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),6,6,6,keptcolor)
		sphere2(3,"Add",elocacenter.CFrame,vt(1,1,1),25,0.1,25,keptcolor)
		sphere2(4,"Add",elocacenter.CFrame,vt(1,1,1),25,0.1,25,keptcolor)
		CFuncs["Sound"].Create("rbxassetid://419447292", char, 4, 1)
		local effx = Instance.new("ParticleEmitter",elocacenter)
		effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
		effx.LightEmission = 1
		effx.Color = ColorSequence.new(keptcolor.Color)
		effx.Rate = 500000
		effx.Lifetime = NumberRange.new(0.25,0.75)
		effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
		effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
		effx.Speed = NumberRange.new(0,10)
		effx.Drag = 5
		effx.Rotation = NumberRange.new(-500,500)
		effx.VelocitySpread = 9000
		effx.RotSpeed = NumberRange.new(-50,50)
		coroutine.resume(coroutine.create(function()
			wait(0.05)
			effx.Enabled = false
		end))
		coroutine.resume(coroutine.create(function()
			for i = 0, 9, 0.1 do
				swait()
				mult = mult + 0.5
				lookavec = lookavec + 0.1*mult
				sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
				elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
				eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
				eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
				eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
				eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
			end
			for i = 0, 19 do
				for i = 0, 1, 0.1 do
					swait()
					sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
					elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
					eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
					eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
					eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
					eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
				end
				local lb = Instance.new("Part")
				lb.Color = keptcolor.Color
				lb.CanCollide = false
				lb.Material = "Neon"
				lb.Anchored = true
				lb.TopSurface = 0
				lb.BottomSurface = 0
				lb.Transparency = 0
				lb.Size = vt(1,1,1)
				lb.CFrame = elocacenter.CFrame*CFrame.new(math.random(-150,150),0,math.random(-150,150))*CFrame.Angles(math.rad(-90 + math.random(-15,15)),0,math.rad(math.random(-15,15)))
				lb.Anchored = false
				lb.Parent = char
				local thingery = Instance.new("SpecialMesh",lb)
				thingery.MeshType = "Sphere"
				thingery.Scale = vt(20,20,20)
				game:GetService("Debris"):AddItem(lb, 10)
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = lb.CFrame.lookVector*math.random(125,350)
				bv.Parent = lb
				sphere(2.5,"Add",lb.CFrame,vt(50,50,0),0.25,keptcolor)
				sphere(5,"Add",lb.CFrame,vt(50,50,0),0.5,keptcolor)
				CFuncs["Sound"].Create("rbxassetid://633627961",lb, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://1002081188", lb, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://741272936", lb, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://1192402877", lb, 10, 1)
				local hitted = false
				local tril = Instance.new("ParticleEmitter",lb)
				tril.Texture = "rbxassetid://144580273" -- 144580273 74564879
				tril.LightEmission = 1
				tril.Color = ColorSequence.new(keptcolor.Color)
				tril.Rate = 500000
				tril.Lifetime = NumberRange.new(0.5,1)
				tril.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(1,0,0)})
				tril.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
				tril.Speed = NumberRange.new(0,10)
				tril.Drag = 5
				tril.Rotation = NumberRange.new(-500,500)
				tril.VelocitySpread = 9000
				tril.RotSpeed = NumberRange.new(-50,50)
				game:GetService("Debris"):AddItem(a, 0.1)

				coroutine.resume(coroutine.create(function()
					lb.Touched:connect(function(hit)
						if hitted == false and hit.Parent ~= char then
							hitted = true
							lb.Transparency = 1
							lb.Anchored = true
							tril.Enabled = false
							CFuncs["EchoSound"].Create("rbxassetid://675172759", lb, 8, 0.8,0,10,0.15,0.5,1)
							CFuncs["EchoSound"].Create("rbxassetid://782200047", lb, 10, 1.1,0,10,0.15,0.5,1)
							MagniDamage(lb, 60, 4500,85000, 0, "Normal")
							coroutine.resume(coroutine.create(function()
								for i, v in pairs(FindNearestHead(lb.CFrame.p, 50)) do
									if v:FindFirstChild('Head') then
										dmg(v)
									end
								end
							end))
							local effx = Instance.new("ParticleEmitter",lb)
							effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
							effx.LightEmission = 1
							effx.Color = ColorSequence.new(keptcolor.Color)
							effx.Rate = 500000
							effx.Lifetime = NumberRange.new(0.25,0.75)
							effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
							effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							effx.Speed = NumberRange.new(0,10)
							effx.Drag = 5
							effx.Rotation = NumberRange.new(-500,500)
							effx.VelocitySpread = 9000
							effx.RotSpeed = NumberRange.new(-50,50)
							sphere(5,"Add",lb.CFrame,vt(20,20,20),1,keptcolor)
							sphere(6,"Add",lb.CFrame,vt(20,20,20),2,keptcolor)
							wait(0.05)
							effx.Enabled = false
						end
					end)
				end))
			end
			for i = 0, 9, 0.1 do
				swait()
				mult = mult - 0.5
				lookavec = lookavec - 0.1*mult
				sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
				elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
				eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
				eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
				eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
				eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
			end
			for i,v in pairs(elocacenter:GetDescendants()) do
				if v:IsA("ParticleEmitter") then
					v.Enabled = false
				end
			end
			wait(6)
			elocacenter:Destroy()
		end))
		attack = false
		hum.WalkSpeed = storehumanoidWS	
	end

	function ExtCalbeam()
		local lookavec = 0 
		local mult = 1
		local keptcolor = MRCL
		local dis = CreateParta(char,0,1,"Neon",keptcolor)
		for i = 0, 2 do
			CFuncs["Sound"].Create("rbxassetid://335657174", dis, 10, 0.5)
		end
		dis.CFrame = root.CFrame*CFrame.new(0,2,-3)
		CreateMesh(dis,"Sphere",4,4,4)
		local at1 = Instance.new("Attachment",dis)
		at1.Position = vt(-2,0,0)
		local at2 = Instance.new("Attachment",dis)
		at2.Position = vt(2,0,0)
		local trl = Instance.new('Trail',dis)
		trl.Attachment0 = at1
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 1
		trl.FaceCamera = true
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(dis.Color)
		trl.Lifetime = 3
		local efec = Instance.new("ParticleEmitter",dis)
		efec.Texture = "rbxassetid://144580273"
		efec.LightEmission = 1
		efec.Color = ColorSequence.new(keptcolor.Color)
		efec.Rate = 500000
		efec.Lifetime = NumberRange.new(1)
		efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)})
		efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
		efec.Drag = 5
		efec.Rotation = NumberRange.new(-500,500)
		efec.VelocitySpread = 9000
		efec.RotSpeed = NumberRange.new(-500,500)
		local a = Instance.new("Part",workspace)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			dis.CFrame.p,                           -- origin
			(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
		) 
		local ignore = dis
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (dis.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
		dis.CFrame = a.CFrame
		a:Destroy()
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = dis.CFrame.lookVector*250
		bv.Parent = dis
		game:GetService("Debris"):AddItem(dis, 15)
		local hitted = false
		coroutine.resume(coroutine.create(function()
			dis.Touched:connect(function(hit) 
				if hitted == false and hit.Parent ~= char then
					hitted = true
					shakes(1,1)
					efec.Enabled = false
					dis.Anchored = true
					dis.Transparency = 1
					local elocacenter = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
					elocacenter.Anchored = true
					elocacenter.CFrame = dis.CFrame*CFrame.new(0,1,0)
					elocacenter.Orientation = Vector3.new(0,0,0)
					local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
					eloca1.Anchored = true
					eloca1.CFrame = elocacenter.CFrame
					local at1 = Instance.new("Attachment",eloca1)
					at1.Position = vt(0,20,0)
					local at2 = Instance.new("Attachment",eloca1)
					at2.Position = vt(0,-20,0)
					local at1b = Instance.new("Attachment",eloca1)
					at1b.Position = vt(0,0,100)
					local at2b = Instance.new("Attachment",eloca1)
					at2b.Position = vt(0,0,-100)
					local trl = Instance.new('Trail',eloca1)
					trl.Attachment0 = at1
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(keptcolor.Color)
					trl.Lifetime = 4
					local trl2 = trl:Clone()
					trl2.Parent = eloca1
					trl2.Attachment0 = at1b
					trl2.Attachment1 = at2b
					trl2.Texture = "rbxassetid://2108945559"
					trl2.Lifetime = 2
					local eff = Instance.new("ParticleEmitter",eloca1)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(keptcolor.Color)
					eff.Rate = 500000
					eff.Lifetime = NumberRange.new(0.5,3)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(20,250)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					local eloca2 = eloca1:Clone()
					eloca2.Parent = elocacenter
					local eloca3 = eloca1:Clone()
					eloca3.Parent = elocacenter
					local eloca4 = eloca1:Clone()
					eloca4.Parent = elocacenter
					sphere2(2,"Add",elocacenter.CFrame,vt(1,1,1),2,2,2,keptcolor)
					sphere2(3,"Add",elocacenter.CFrame,vt(1,1,1),4,4,4,keptcolor)
					sphere2(4,"Add",elocacenter.CFrame,vt(1,1,1),5,5,5,keptcolor)
					sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),6,6,6,keptcolor)
					for i = 0, 2 do
						CFuncs["Sound"].Create("rbxassetid://419447292", elocacenter, 8, 1)
						CFuncs["Sound"].Create("rbxassetid://1192402877", elocacenter, 10, 0.5)
					end
					local effx = Instance.new("ParticleEmitter",elocacenter)
					effx.Texture = "rbxassetid://144580273" -- 144580273 74564879
					effx.LightEmission = 1
					effx.Color = ColorSequence.new(keptcolor.Color)
					effx.Rate = 500000
					effx.Lifetime = NumberRange.new(0.25,0.75)
					effx.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,200,0)})
					effx.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.5,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
					effx.Speed = NumberRange.new(0,10)
					effx.Drag = 5
					effx.Rotation = NumberRange.new(-500,500)
					effx.VelocitySpread = 9000
					effx.RotSpeed = NumberRange.new(-50,50)
					coroutine.resume(coroutine.create(function()
						wait(0.05)
						effx.Enabled = false
					end))
					coroutine.resume(coroutine.create(function()
						for i = 0, 9, 0.1 do
							swait()
							mult = mult + 0.5
							lookavec = lookavec + 0.06*mult
							sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
							elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
							eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
							eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
							eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
							eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
						end
						for i = 0, 19, 0.1 do
							swait()
							sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
							elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
							eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
							eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
							eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
							eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
						end
						shakes(1.5,1.5)
						MagniDamage(elocacenter, 200, 50,99, 0, "Normal")
						coroutine.resume(coroutine.create(function()
							for i, v in pairs(FindNearestHead(elocacenter.CFrame.p, 150)) do
								if v:FindFirstChild('Head') then
									dmg(v)
								end
							end
						end))
						local effe = Instance.new("ParticleEmitter",elocacenter)
						effe.Texture = "rbxassetid://2273224484"
						effe.LightEmission = 1
						effe.Color = ColorSequence.new(keptcolor.Color)
						effe.Rate = 500000
						effe.Lifetime = NumberRange.new(3,5)
						effe.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,150,0),NumberSequenceKeypoint.new(0.2,15,0),NumberSequenceKeypoint.new(0.8,15,0),NumberSequenceKeypoint.new(1,0,0)})
						effe.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
						effe.Speed = NumberRange.new(250,1200)
						effe.Drag = 5
						effe.Rotation = NumberRange.new(-500,500)
						effe.VelocitySpread = 9000
						effe.RotSpeed = NumberRange.new(-50,50)
						coroutine.resume(coroutine.create(function()
							effx.Enabled = true
							wait(0.15)
							effx.Enabled = false
							wait(0.25)
							effe.Enabled = false
						end))
						coroutine.resume(coroutine.create(function()
							local elocor = elocacenter
							local lookavec = 0 
							local mult = 1
							local elocacenter = CreateParta(elocor,1,1,"SmoothPlastic",BrickColor.random())
							elocacenter.Anchored = true
							elocacenter.CFrame = elocor.CFrame
							local eloca1 = CreateParta(elocacenter,1,1,"SmoothPlastic",BrickColor.random())
							eloca1.Anchored = true
							eloca1.CFrame = elocacenter.CFrame
							local at1 = Instance.new("Attachment",eloca1)
							at1.Position = vt(0,10,0)
							local at2 = Instance.new("Attachment",eloca1)
							at2.Position = vt(0,-10,0)
							local trl = Instance.new('Trail',eloca1)
							trl.Attachment0 = at1
							trl.Attachment1 = at2
							trl.Texture = "rbxassetid://1049219073"
							trl.LightEmission = 1
							trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
							trl.Color = ColorSequence.new(keptcolor.Color)
							trl.Lifetime = 8
							local eff = Instance.new("ParticleEmitter",eloca1)
							eff.Texture = "rbxassetid://2273224484"
							eff.LightEmission = 1
							eff.Color = ColorSequence.new(keptcolor.Color)
							eff.Rate = 500000
							eff.Lifetime = NumberRange.new(0.5,1)
							eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
							eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
							eff.Speed = NumberRange.new(20,250)
							eff.Drag = 5
							eff.Rotation = NumberRange.new(-500,500)
							eff.VelocitySpread = 9000
							eff.RotSpeed = NumberRange.new(-50,50)
							local eloca2 = eloca1:Clone()
							eloca2.Parent = elocacenter
							local eloca3 = eloca1:Clone()
							eloca3.Parent = elocacenter
							local eloca4 = eloca1:Clone()
							eloca4.Parent = elocacenter
							coroutine.resume(coroutine.create(function()
								for i = 0, 19, 0.1 do
									swait()
									mult = mult + 0.25
									lookavec = lookavec + 0.05*mult
									elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/10),0)
									eloca1.CFrame = elocacenter.CFrame*CFrame.new(40+lookavec/5,-15+lookavec*2,0)
									eloca2.CFrame = elocacenter.CFrame*CFrame.new(-40-lookavec/5,-15+lookavec*2,0)
									eloca3.CFrame = elocacenter.CFrame*CFrame.new(0,-15+lookavec*2,40+lookavec/5)
									eloca4.CFrame = elocacenter.CFrame*CFrame.new(0,-15+lookavec*2,-40-lookavec/5)
								end
								for i,v in pairs(elocacenter:GetDescendants()) do
									if v:IsA("ParticleEmitter") then
										v.Enabled = false
									end
								end
								wait(6)
								elocacenter:Destroy()
							end))
						end))
						CFuncs["Sound"].Create("rbxassetid://763717897", char, 3, 1)
						CFuncs["Sound"].Create("rbxassetid://763717897", char, 3, 0.75)
						CFuncs["Sound"].Create("rbxassetid://763717897", char, 4, 0.5)
						CFuncs["Sound"].Create("rbxassetid://1192402877", char, 6,0.5)
						CFuncs["Sound"].Create("rbxassetid://1664711478", char, 2.5,1)
						CFuncs["Sound"].Create("rbxassetid://763718160", char, 3, 0.75)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,20,0,0,0,root,true,-5,3)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,40,0,0,0,root,true,-5,3)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,60,0,0,0,root,true,-5,3)
						symbolizeBlink(elocacenter,0,144580273,keptcolor.Color,80,0,0,0,root,true,-5,3)
						sphere2(2,"Add",elocacenter.CFrame,vt(10,10000,10),2,2,2,keptcolor)
						sphere2(1,"Add",elocacenter.CFrame,vt(10,10000,10),2,2,2,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(10,10,10),5,5,5,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(10,10,10),7.5,7.5,7.5,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(10,10,10),10,10,10,keptcolor)
						sphere2(2,"Add",elocacenter.CFrame,vt(10,10,10),2.5,2.5,2.5,keptcolor)
						for i = 0, 29 do
							slash(math.random(10,30)/10,5,true,"Round","Add","Out",elocacenter.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(500,1000)/250,BrickColor.new("White"))
						end
						for i = 0, 9, 0.1 do
							swait()
							mult = mult - 0.5
							lookavec = lookavec - 0.06*mult
							sphere2(5,"Add",elocacenter.CFrame,vt(1,1,1),0.05*lookavec/2,0.001,0.05*lookavec/2,keptcolor)
							elocacenter.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(5*mult/20),0)
							eloca1.CFrame = elocacenter.CFrame*CFrame.new(-lookavec,0,0)
							eloca2.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(90),0)*CFrame.new(-lookavec,0,0)
							eloca3.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(180),0)*CFrame.new(-lookavec,0,0)
							eloca4.CFrame = elocacenter.CFrame*CFrame.Angles(0,math.rad(270),0)*CFrame.new(-lookavec,0,0)
						end
						for i,v in pairs(elocacenter:GetDescendants()) do
							if v:IsA("ParticleEmitter") then
								v.Enabled = false
							end
						end
						wait(6)
						elocacenter:Destroy()
					end))
				end
			end)
		end))	
	end

	function FallenOrbs()
		attack = true
		hum.WalkSpeed = 2
		local keptcolor = MRCL
		CFuncs["EchoSound"].Create("rbxassetid://1448033299", char, 1.5, 1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://1448033299", root, 10, 1,0,10,0.15,0.5,1)
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("This wont be easy to you.",MRCL.Color,1)
		elseif radm == 2 then
			bosschatfunc("How about this?",MRCL.Color,1)
		elseif radm == 3 then
			bosschatfunc("Swarm!",MRCL.Color,1)
		end
		local obj1 = script.chring:Clone()
		obj1.Parent = char
		obj1.Transparency = 1
		obj1.Color = BrickColor.new("Toothpaste").Color
		local obj2 = script.spball:Clone()
		obj2.Parent = char
		obj2.Transparency = 1
		obj2.Color = MRCL.Color
		local cfor = CreateParta(char,1,1,"Neon",MRCL)
		cfor.Anchored = true
		cfor.CFrame = obj2.CFrame
		local cef = Instance.new("ParticleEmitter",cfor)
		cef.Texture = "rbxassetid://2344870656"
		cef.LightEmission = 1
		cef.Color = ColorSequence.new(obj2.Color)
		cef.Rate = 150
		cef.Lifetime = NumberRange.new(0.25)
		cef.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5,1,0),NumberSequenceKeypoint.new(1,0,0)})
		cef.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
		cef.Speed = NumberRange.new(0)
		local rval = 0
		local eval = 1
		CFuncs["Sound"].Create("rbxassetid://136007472", root, 10,0.7)
		for i = 0,10,0.1 do
			swait()
			rval = rval + math.random(30,40)
			eval = eval + 1.5
			obj1.Transparency = obj1.Transparency - 0.003
			obj1.Size = obj1.Size + vt(0,1,1)
			obj1.CFrame = root.CFrame*CFrame.new(0,16,0)*CFrame.Angles(math.rad(0),math.rad(rval),math.rad(-90))
			obj2.Transparency = obj2.Transparency - 0.005
			obj2.Size = obj2.Size + vt(0.5,0.5,0.5)
			cef.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5,eval,0),NumberSequenceKeypoint.new(1,0,0)})
			obj2.CFrame = root.CFrame*CFrame.new(0,36,0)*CFrame.Angles(math.rad(rval),math.rad(rval),math.rad(-rval))
			cfor.CFrame = obj2.CFrame
			slash(math.random(50,90)/10,5,true,"Round","Add","In",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,0.01,1),math.random(-400,-200)/250,BrickColor.new("Deep orange"))
			slash(math.random(50,90)/10,5,true,"Round","Add","In",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,0.01,1),math.random(-400,-200)/250,BrickColor.new("Toothpaste"))
			sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MRCL,MRCL.Color)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),6 + 0.15 * math.cos(sine / 32))*angles(math.rad(-20 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(70)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 - 2 * math.cos(sine / 37)),math.rad(5 + 1 * math.cos(sine / 58)),math.rad(-70 + 2 * math.cos(sine / 53))),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(170 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(10 + 2 * math.cos(sine / 45))),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(8 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-9 - 4 * math.cos(sine / 45))),.3)
		end
		shakes(0.75,0.5)
		cef.Enabled = false
		coroutine.resume(coroutine.create(function()
			for i = 0,49 do
				swait()
				rval = rval + 100
				obj2.CFrame = obj2.CFrame*CFrame.Angles(math.rad(rval),math.rad(rval),math.rad(-rval))
				obj2.Transparency = obj2.Transparency + 0.02
				obj2.Size = obj2.Size + vt(5,5,5)
				obj1.Transparency = obj1.Transparency + 0.02
				obj1.Size = obj1.Size + vt(0,-0.5,-0.5)
			end
			obj1:Destroy()
			obj2:Destroy()
			cfor:Destroy()
		end))
		for i = 0, 9 do
			slash(math.random(10,40)/10,5,true,"Round","Add","Out",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,450)/250,BrickColor.new("Deep orange"))
			slash(math.random(10,40)/10,5,true,"Round","Add","Out",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,450)/250,BrickColor.new("Toothpaste"))
		end
		sphere2(3,"Add",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),1,1,1,MRCL,MRCL.Color)
		sphere2(3,"Add",obj2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),2,2,2,MRCL,MRCL.Color)
		CFuncs["EchoSound"].Create("rbxassetid://675172759", root, 10, 0.8,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://763717897", root, 7.5, 1.1,0,10,0.15,0.5,1)
		CFuncs["EchoSound"].Create("rbxassetid://675172759", root, 5, 0.7,0,10,0.15,0.5,1)
		coroutine.resume(coroutine.create(function()
			for i = 0, 19 do
				swait()
				local custcol = math.random(1,3)
				local dis = CreateParta(char,0.5,1,"Neon",MRCL)
				if custcol == 1 then
					dis.BrickColor = MRCL
				elseif custcol == 2 then
					dis.BrickColor = BrickColor.new("Toothpaste")
				elseif custcol == 3 then
					dis.BrickColor = BrickColor.new("Deep orange")
				end
				dis.Anchored = true
				--CFuncs["Sound"].Create("rbxassetid://137463716", dis, 2.5,1.5)
				dis.CFrame = root.CFrame*CFrame.new(math.random(-30,30),math.random(11,51),math.random(-30,30))
				CreateMesh(dis,"Sphere",2,2,2)
				sphere2(5,"Add",dis.CFrame,vt(1,1,1),0.1,0.1,0.1,dis.BrickColor,dis.Color)
				slash(math.random(10,20)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(10,50)/250,BrickColor.new("White"))
				coroutine.resume(coroutine.create(function()
					wait(0.5)
					dis.Anchored = false
					CFuncs["EchoSound"].Create("rbxassetid://1602800656", dis, 5, 1,0,2,0.15,0.1,1)
					local at1 = Instance.new("Attachment",dis)
					at1.Position = vt(-1,0,0)
					local at2 = Instance.new("Attachment",dis)
					at2.Position = vt(1,0,0)
					local trl = Instance.new('Trail',dis)
					trl.Attachment0 = at1
					trl.FaceCamera = true
					trl.Attachment1 = at2
					trl.Texture = "rbxassetid://1049219073"
					trl.LightEmission = 1
					trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
					trl.Color = ColorSequence.new(dis.Color)
					trl.Lifetime = 0.6
					local a = Instance.new("Part",workspace)
					a.Name = "Direction"	
					a.Anchored = true
					a.BrickColor = bc("Bright red")
					a.Material = "Neon"
					a.Transparency = 1
					a.CanCollide = false
					local ray = Ray.new(
						dis.CFrame.p,                           -- origin
						(mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
					) 
					local ignore = dis
					local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
					a.BottomSurface = 10
					a.TopSurface = 10
					local distance = (dis.CFrame.p - position).magnitude
					a.Size = Vector3.new(0.1, 0.1, 0.1)
					a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
					dis.CFrame = a.CFrame
					a:Destroy()
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = dis.CFrame.lookVector*500
					bv.Parent = dis
					game:GetService("Debris"):AddItem(dis, 5)
					local hitted = false
					coroutine.resume(coroutine.create(function()
						dis.Touched:connect(function(hit) 
							if hitted == false and hit.Parent ~= char then
								hitted = true
								shakes(0.2,0.3)
								CFuncs["EchoSound"].Create("rbxassetid://675172759", dis, 2.5, 0.8,0,10,0.15,0.5,1)
								MagniDamage(dis, 60, 25456,124672, 0, "Normal")
								sphere2(1,"Add",dis.CFrame,vt(1,1,1),1,1,1,dis.BrickColor,dis.Color)
								sphere2(8,"Add",dis.CFrame,vt(1,1,1),1.25,1.25,1.25,BrickColor.new("White"),Color3.new(1,1,1))
								coroutine.resume(coroutine.create(function()
									local eff = Instance.new("ParticleEmitter",dis)
									eff.Texture = "rbxassetid://2344870656"
									eff.LightEmission = 1
									eff.Color = ColorSequence.new(dis.Color)
									eff.Rate = 10000000
									eff.Enabled = true
									--eff.EmissionDirection = "Front"
									eff.Lifetime = NumberRange.new(3)
									eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,20,0),NumberSequenceKeypoint.new(0.8,40,0),NumberSequenceKeypoint.new(1,60,0)})
									eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
									eff.Speed = NumberRange.new(250)
									eff.Drag = 5
									eff.Rotation = NumberRange.new(-500,500)
									eff.SpreadAngle = Vector2.new(0,900)
									eff.RotSpeed = NumberRange.new(-500,500)
									wait(0.2)
									eff.Enabled = false
								end))
								coroutine.resume(coroutine.create(function()
									for i = 0, 4 do
										local disr = CreateParta(char,1,1,"Neon",dis.BrickColor)
										disr.CFrame = dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
										local at1 = Instance.new("Attachment",disr)
										at1.Position = vt(-10,0,0)
										local at2 = Instance.new("Attachment",disr)
										at2.Position = vt(10,0,0)
										local trl = Instance.new('Trail',disr)
										trl.Attachment0 = at1
										trl.FaceCamera = true
										trl.Attachment1 = at2
										trl.Texture = "rbxassetid://2342682798"
										trl.LightEmission = 1
										trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
										trl.Color = ColorSequence.new(disr.Color)
										trl.Lifetime = 0.5
										local bv = Instance.new("BodyVelocity")
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
										bv.velocity = disr.CFrame.lookVector*math.random(125,250)
										bv.Parent = disr
										local val = 0
										coroutine.resume(coroutine.create(function()
											swait(30)
											for i = 0, 9 do
												swait()
												val = val + 0.1
												trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
											end
											game:GetService("Debris"):AddItem(disr, 3)
										end))
									end
									local eff = Instance.new("ParticleEmitter",dis)
									eff.Texture = "rbxassetid://2273224484"
									eff.LightEmission = 1
									eff.Color = ColorSequence.new(dis.Color)
									eff.Rate = 500000
									eff.Lifetime = NumberRange.new(0.5,2)
									eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
									eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
									eff.Speed = NumberRange.new(20,250)
									eff.Drag = 5
									eff.Rotation = NumberRange.new(-500,500)
									eff.VelocitySpread = 9000
									eff.RotSpeed = NumberRange.new(-50,50)
									wait(0.5)
									eff.Enabled = false
								end))
								for i = 0, 4 do
									slash(math.random(20,50)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(100,200)/250,BrickColor.new("White"))
								end
								coroutine.resume(coroutine.create(function()
									for i = 0, 19 do
										swait()
										hum.CameraOffset = vt(math.random(-10,10)/70,math.random(-10,10)/70,math.random(-10,10)/70)
									end
									hum.CameraOffset = vt(0,0,0)
								end))
								dis.Anchored = true
								dis.Transparency = 1
								wait(8)
								dis:Destroy()
							end
						end)
					end))
				end))
			end
		end))
		for i = 0,9,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),6 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(90)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(-15 + 1 * math.cos(sine / 58)),math.rad(-90 + 2 * math.cos(sine / 53))),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(90 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(90 + 2 * math.cos(sine / 45))),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(8 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-9 - 4 * math.cos(sine / 45))),.3)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function FallenDEMISE()
		attack = true
		hum.WalkSpeed = 0
		local keptcolor = MRCL
		bosschatfunc("ALL OF YOUR EXISTANCE WILL BE GONE.",MRCL.Color,3)
		CFuncs["Sound"].Create("rbxassetid://289315275", char, 2.5,0.75)
		CFuncs["Sound"].Create("rbxassetid://136007472", char, 2,0.5)
		for i = 0, 15, 0.1 do
			swait()
			local dis = CreateParta(char,1,1,"Neon",MRCL)
			dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-25000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(25000,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.FaceCamera = true
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 5
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 1)
			sphere2(15,"Add",root.CFrame,vt(8,8,8),2,2,2,MRCL)
			slash(math.random(30,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(1,0.01,1),math.random(100,500)/250,BrickColor.new("Toothpaste"))
			slash(math.random(30,150)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(1,0.01,1),math.random(100,500)/250,BrickColor.new("Deep orange"))
			RH.C0=clerp(RH.C0,cf(1,-0.35,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-35)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.45,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(35)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(92),math.rad(0),math.rad(-67)),.1)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(68)),.1)
		end
		CFuncs["Sound"].Create("rbxassetid://294188875", char, 10,1)
		shakes(5,3)
		for i = 0, 30, 0.1 do
			swait()
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(FindNearestHead(root.CFrame.p, 10000000)) do
					if v:FindFirstChild('Head') then
						dmg(v)
					end
				end
			end))
			local dis = CreateParta(char,1,1,"Neon",MRCL)
			dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-50000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(50000,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.FaceCamera = true
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 1
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(dis.Color)
			trl.Lifetime = 10
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(1500,10000)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, math.random(1,4))
			sphere2(15,"Add",root.CFrame,vt(8,80000,8),5,1,5,MRCL)
			sphere2(15,"Add",root.CFrame,vt(8,8,8),8,8,8,MRCL)
			sphere2(2,"Add",root.CFrame*CFrame.new(math.random(-2000,2000),math.random(-2000,2000),math.random(-2000,2000)),vt(0,0,0),5,5,5,BrickColor.new("Deep orange"))
			sphere2(2,"Add",root.CFrame*CFrame.new(math.random(-2000,2000),math.random(-2000,2000),math.random(-2000,2000)),vt(0,0,0),5,5,5,BrickColor.new("Toothpaste"))
			slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(5,0.01,5),math.random(500,5000)/250,BrickColor.new("Deep orange"))
			slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(5,0.01,5),math.random(500,5000)/250,BrickColor.new("Toothpaste"))
			for i = 0, 2 do
				slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,math.random(-3,1000),0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(2,0.01,2),math.random(250,750)/250,MRCL)
			end
			RH.C0=clerp(RH.C0,cf(1,-0.35,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-35)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.45,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(35)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(92),math.rad(0),math.rad(-67)),.1)
			LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(68)),.1)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function SHDTwist()
		attack = true
		hum.WalkSpeed = 2
		local radm = math.random(1,2)
		if radm == 1 then
			bosschatfunc("Plasmatic Burst!",MRCL.Color,1)
		elseif radm == 2 then
			bosschatfunc("Suffer to the brightness.",MRCL.Color,1)
		end
		CFuncs["Sound"].Create("rbxassetid://136007472", rarm, 1.5,1.25)
		local obj1 = script.chring2:Clone()
		obj1.Parent = char
		obj1.Transparency = 1
		obj1.Size = vt(1,1,1)
		obj1.Color = BrickColor.new("Pink").Color
		local obj2 = script.spball:Clone()
		obj2.Parent = char
		obj2.Transparency = 1
		obj2.Size = vt(1,1,1)
		obj2.Color = MRCL.Color
		local cfor = CreateParta(char,1,1,"Neon",MRCL)
		cfor.Anchored = true
		cfor.CFrame = obj2.CFrame
		local cef = Instance.new("ParticleEmitter",cfor)
		cef.Texture = "rbxassetid://2344870656"
		cef.LightEmission = 1
		cef.Color = ColorSequence.new(obj2.Color)
		cef.Rate = 150
		cef.Lifetime = NumberRange.new(0.25)
		cef.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5,1,0),NumberSequenceKeypoint.new(1,0,0)})
		cef.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
		cef.Speed = NumberRange.new(0)
		local rval = 0
		local eval = 1
		for i = 0,7,0.1 do
			swait()
			rval = rval + math.random(30,40)
			eval = eval + 0.45
			obj1.Transparency = obj1.Transparency - 0.005
			obj1.Size = obj1.Size + vt(0.3,0.3,0.1)
			obj1.CFrame = root.CFrame*CFrame.new(0,1,-5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(rval))
			obj2.Transparency = obj2.Transparency - 0.007
			obj2.Size = obj2.Size + vt(0.15,0.15,0.15)
			cef.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5,eval,0),NumberSequenceKeypoint.new(1,0,0)})
			obj2.CFrame = root.CFrame*CFrame.new(0,1,-7)*CFrame.Angles(math.rad(rval),math.rad(rval),math.rad(-rval))
			cfor.CFrame = obj2.CFrame
			sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Pastel light blue"),BrickColor.new("Pastel light blue").Color)
			sphere2(10,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.15,-0.01,BrickColor.new("Pink"),BrickColor.new("Pink").Color)
			RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.3)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-50)),.3)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2 * math.cos(sine / 37)),math.rad(10 + 1 * math.cos(sine / 58)),math.rad(50 + 2 * math.cos(sine / 53))),.3)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(10 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(5 + 2 * math.cos(sine / 45))),.3)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(90 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-50 - 4 * math.cos(sine / 45))),.3)
		end
		shakes(0.25,0.25)
		cef.Enabled = false
		coroutine.resume(coroutine.create(function()
			for i = 0,49 do
				swait()
				rval = rval + 100
				obj2.CFrame = obj2.CFrame*CFrame.Angles(math.rad(rval),math.rad(rval),math.rad(-rval))
				obj2.Transparency = obj2.Transparency + 0.02
				obj2.Size = obj2.Size + vt(5,5,5)
				obj1.Transparency = obj1.Transparency + 0.02
				obj1.Size = obj1.Size + vt(0,-0.5,-0.5)
			end
			obj1:Destroy()
			obj2:Destroy()
			cfor:Destroy()
		end))
		local lva = 1
		local ica = 0
		local cent = CreateParta(char,1,1,"Neon",MRCL)
		CFuncs["Sound"].Create("rbxassetid://1177785010", cent, 10, 1)
		cent.CFrame = root.CFrame*CFrame.Angles(0,0,0) + root.CFrame.lookVector*5
		sphere2(2,"Add",cent.CFrame,vt(1,1,1),0.5,0.5,0.5,BrickColor.new("Pastel light blue"),BrickColor.new("Pastel light blue").Color)
		sphere2(3,"Add",cent.CFrame,vt(1,1,1),0.5,0.5,0.5,BrickColor.new("Pink"),BrickColor.new("Pink").Color)

		local a = Instance.new("Part",workspace)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			cent.CFrame.p,                           -- origin
			(mouse.Hit.p - cent.CFrame.p).unit * 500 -- direction
		) 
		local ignore = cent
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (cent.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(cent.CFrame.p, position) * CFrame.new(0, 0, 0)
		cent.CFrame = a.CFrame
		a:Destroy()
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = cent.CFrame.lookVector*0
		bv.Parent = cent
		game:GetService("Debris"):AddItem(cent, 20)
		local hitted = false
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				if hitted == false and cent.Parent ~= nil then
					ica = ica + 4*lva
					lva = lva + 0.1
					bv.velocity = cent.CFrame.lookVector*ica
					sphere2(3,"Add",cent.CFrame,vt(5,5,5),-0.05,-0.05,-0.05,BrickColor.new("Pastel light blue"))
					sphere2(5,"Add",cent.CFrame*CFrame.Angles(0,0,math.rad(ica))*CFrame.new(0,-5,0),vt(4,4,4),-0.04,-0.04,-0.04,BrickColor.new("Pink"))
					sphere2(5,"Add",cent.CFrame*CFrame.Angles(0,0,math.rad(ica))*CFrame.new(0,5,0),vt(4,4,4),-0.04,-0.04,-0.04,BrickColor.new("Pastel light blue"))
				elseif hitted == true or cent.Parent == nil then
					break
				end
			end
		end))
		coroutine.resume(coroutine.create(function()
			cent.Touched:connect(function(hit) 
				if hitted == false and hit.Parent ~= char then
					hitted = true
					cent.Anchored = true
					shakes(0.5,0.5)
					CFuncs["Sound"].Create("rbxassetid://782353443", cent, 10, 1)
					CFuncs["Sound"].Create("rbxassetid://1368637781", cent, 8, 1)
					CFuncs["Sound"].Create("rbxassetid://763717897", cent, 5, 1)
					CFuncs["EchoSound"].Create("rbxassetid://1177785010", cent, 8, 1.1,0,10,0.15,0.5,1)
					MagniDamage(cent, 50, 50,99999, 0, "Normal")
					sphere2(2,"Add",cent.CFrame,vt(1,1,1),1,1,1,BrickColor.new("Pastel light blue"),BrickColor.new("Pastel light blue").Color)
					sphere2(3,"Add",cent.CFrame,vt(1,1,1),1.2,1.2,1.2,BrickColor.new("Pink"),BrickColor.new("Pink").Color)
					for i = 0, 19 do
						slash(math.random(10,50)/10,5,true,"Round","Add","Out",cent.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(200,400)/250,BrickColor.new("Pink"))
						slash(math.random(10,50)/10,5,true,"Round","Add","Out",cent.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,300)/250,BrickColor.new("Pastel light blue"))
					end
					coroutine.resume(coroutine.create(function()
						local eff = Instance.new("ParticleEmitter",cent)
						eff.Texture = "rbxassetid://2344870656"
						eff.LightEmission = 1
						eff.Color = ColorSequence.new(BrickColor.new("Pastel light blue").Color)
						eff.Rate = 10000000
						eff.Enabled = true
						--eff.EmissionDirection = "Front"
						eff.Lifetime = NumberRange.new(5)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,40,0),NumberSequenceKeypoint.new(0.8,60,0),NumberSequenceKeypoint.new(1,80,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(350)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.SpreadAngle = Vector2.new(0,900)
						eff.RotSpeed = NumberRange.new(-500,500)
						local eff2 = eff:Clone()
						eff2.Parent = cent
						eff2.Speed = NumberRange.new(250) 
						eff2.Color = ColorSequence.new(BrickColor.new("Pink").Color)
						wait(0.2)
						eff.Enabled = false
						eff2.Enabled = false
					end))
				end
			end)
		end))
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end
	---- Galaxy/Cytus's Abilities

	function Crossfire()
		attack = true
		hum.WalkSpeed = 0 
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Crossfire!",MRCL.Color,1)
		elseif radm == 2 then
			bosschatfunc("Engulf by the flames!",MRCL.Color,1)
		elseif radm == 3 then
			bosschatfunc("Burn to death.",MRCL.Color,1)
		end
		shakes(0.5,0.5)
		local vel = Instance.new("BodyPosition", root)
		vel.P = 30000
		vel.D = 1000
		vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
		vel.position = root.CFrame.p + vt(0,150,0)
		CFuncs["Sound"].Create("rbxassetid://1295446488", root, 7.5, 1)
		CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
		local keptcolor = MRCL
		sphere2(2,"Add",root.CFrame,vt(25,1,25),-0.05,3,-0.05,keptcolor)
		sphere2(2,"Add",root.CFrame,vt(50,1,50),-0.1,6,-0.1,keptcolor)
		for i = 0, 24 do
			slash(math.random(30,60)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.01,0.05),math.random(25,250)/250,BrickColor.new("White"))
		end
		for i = 0,3,0.1 do
			swait()
			RootPart.CFrame = FaceMouse2()[1]
			sphere2(4,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1.5,1.5,1.5),-0.01,0.15,-0.01,keptcolor)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-70)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(70)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(6), math.rad(-20), math.rad(12)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.05, 0.5, -0.65) * angles(math.rad(-20), math.rad(0), math.rad(140)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(-10)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(10)),.5)
		end
		local rotz = 25
		coroutine.resume(coroutine.create(function()
			for i = 0, 4 do
				local orb = Instance.new("Part", char)
				orb.BrickColor = keptcolor
				orb.CanCollide = false
				orb.FormFactor = 3
				orb.Name = "Ring"
				orb.Material = "Neon"
				orb.Size = Vector3.new(1, 1, 1)
				orb.Transparency = 0
				orb.TopSurface = 0
				orb.BottomSurface = 0
				local orbm = Instance.new("SpecialMesh", orb)
				orbm.MeshType = "Sphere"
				orbm.Name = "SizeMesh"
				orbm.Scale = vt(4,4,4)
				orb.CFrame = root.CFrame + root.CFrame.lookVector*3
				local eff = Instance.new("ParticleEmitter",orb)
				eff.Texture = "rbxassetid://296874871"
				eff.LightEmission = 0.95
				eff.Color = ColorSequence.new(orb.BrickColor.Color)
				eff.Rate = 500
				eff.Lifetime = NumberRange.new(1.5)
				eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,7,0),NumberSequenceKeypoint.new(0.1,5,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
				eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
				eff.Speed = NumberRange.new(25)
				eff.Drag = 5
				eff.Rotation = NumberRange.new(-500,500)
				eff.VelocitySpread = 9000
				eff.RotSpeed = NumberRange.new(-500,500)
				local a = Instance.new("Part",workspace)
				a.Name = "Direction"	
				a.Anchored = true
				a.BrickColor = bc("Bright red")
				a.Material = "Neon"
				a.Transparency = 1
				a.CanCollide = false
				local ray = Ray.new(
					orb.CFrame.p,                           -- origin
					(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
				) 
				local ignore = orb
				local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
				a.BottomSurface = 10
				a.TopSurface = 10
				local distance = (orb.CFrame.p - position).magnitude
				a.Size = Vector3.new(0.1, 0.1, 0.1)
				a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
				orb.CFrame = a.CFrame
				a:Destroy()
				orb.CFrame = orb.CFrame*CFrame.Angles(0,math.rad(rotz),0)
				rotz = rotz - 12.5
				CFuncs["Sound"].Create("rbxassetid://335657174", orb, 3, 0.75)
				CFuncs["Sound"].Create("rbxassetid://304448425", orb, 3.5, 0.9)
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = orb.CFrame.lookVector*225
				bv.Parent = orb
				game:GetService("Debris"):AddItem(orb, 10)
				local hitted = false
				local hit =orb.Touched:connect(function(hit) 
					if hitted == false and hit.Parent ~= char then
						hitted = true
						eff.Enabled = false
						CameraEnshaking(4,4)
						for i = 0, 9 do
							local disr = CreateParta(char,1,1,"Neon",keptcolor)
							disr.CFrame = orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
							local at1 = Instance.new("Attachment",disr)
							at1.Position = vt(-15,0,0)
							local at2 = Instance.new("Attachment",disr)
							at2.Position = vt(15,0,0)
							local trl = Instance.new('Trail',disr)
							trl.Attachment0 = at1
							trl.FaceCamera = true
							trl.Attachment1 = at2
							trl.Texture = "rbxassetid://2325530138"
							trl.LightEmission = 1
							trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
							trl.Color = ColorSequence.new(keptcolor.Color)
							trl.Lifetime = 0.5
							local bv = Instance.new("BodyVelocity")
							bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
							bv.velocity = disr.CFrame.lookVector*math.random(75,250)
							bv.Parent = disr
							local val = 0
							coroutine.resume(coroutine.create(function()
								swait(30)
								for i = 0, 19 do
									swait()
									val = val + 0.05
									trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
								end
								game:GetService("Debris"):AddItem(disr, 3)
							end))
						end
						CFuncs["Sound"].Create("rbxassetid://1226980789", orb, 6, 0.7)
						CFuncs["Sound"].Create("rbxassetid://1368637781", orb, 8,1)
						CFuncs["Sound"].Create("rbxassetid://1368637781", orb, 8,1)
						CFuncs["Sound"].Create("rbxassetid://763718160", orb, 7, 1.1)
						CFuncs["Sound"].Create("rbxassetid://782353443", orb, 7, 1)
						CFuncs["Sound"].Create("rbxassetid://178452221", orb, 6, 0.4)
						MagniDamage(orb, 25, 80,140, 0, "Normal")
						sphere2(4,"Add",orb.CFrame,vt(4,4,4),0.5,0.5,0.5,keptcolor)
						sphere2(3,"Add",orb.CFrame,vt(4,4,4),0.5,0.5,0.5,keptcolor)
						sphere2(2,"Add",orb.CFrame,vt(4,4,4),0.5,0.5,0.5,keptcolor)
						for i = 0, 9 do
							sphere2(4,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1.5,1,1.5),-0.005,4,-0.005,keptcolor)
						end
						for i = 0, 19 do
							slash(math.random(10,50)/10,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(50,250)/250,BrickColor.new("White"))
						end
						for i = 0, 19 do
							local rsiz = math.random(10,30)
							sphereMK(math.random(2,6),1,"Add",orb.CFrame*CFrame.new(math.random(-20,20)/50,math.random(-20,20)/50,math.random(-20,20)/50)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,keptcolor,0)
						end
						local eff = Instance.new("ParticleEmitter",orb)
						eff.Texture = "rbxassetid://296874871"
						eff.LightEmission = 0.95
						eff.Color = ColorSequence.new(orb.BrickColor.Color)
						eff.Rate = 10000
						eff.Lifetime = NumberRange.new(1.5)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.1,15,0),NumberSequenceKeypoint.new(0.8,25,0),NumberSequenceKeypoint.new(1,0,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(150)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.VelocitySpread = 9000
						eff.RotSpeed = NumberRange.new(-500,500)
						coroutine.resume(coroutine.create(function()
							wait(0.25)
							eff.Enabled = false
						end))
						orb.Anchored = true
						orb.Transparency = 1
						wait(10)
						orb:Destroy()
					end
				end)
			end
		end))
		for i = 0,1,0.1 do
			swait()
			RootPart.CFrame = FaceMouse2()[1]
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(60)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-60)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(6), math.rad(-20), math.rad(12)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-20)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(-10)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(10)),.5)
		end
		for i = 0,1,0.1 do
			swait()
			RootPart.CFrame = FaceMouse2()[1]
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(70)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-70)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(6), math.rad(-20), math.rad(12)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-10)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(-10)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(10)),.5)
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 4 do
				local orb = Instance.new("Part", char)
				orb.BrickColor = keptcolor
				orb.CanCollide = false
				orb.FormFactor = 3
				orb.Name = "Ring"
				orb.Material = "Neon"
				orb.Size = Vector3.new(1, 1, 1)
				orb.Transparency = 0
				orb.TopSurface = 0
				orb.BottomSurface = 0
				local orbm = Instance.new("SpecialMesh", orb)
				orbm.MeshType = "Sphere"
				orbm.Name = "SizeMesh"
				orbm.Scale = vt(4,4,4)
				orb.CFrame = root.CFrame + root.CFrame.lookVector*3
				local eff = Instance.new("ParticleEmitter",orb)
				eff.Texture = "rbxassetid://296874871"
				eff.LightEmission = 0.95
				eff.Color = ColorSequence.new(orb.BrickColor.Color)
				eff.Rate = 500
				eff.Lifetime = NumberRange.new(1.5)
				eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,7,0),NumberSequenceKeypoint.new(0.1,5,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
				eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
				eff.Speed = NumberRange.new(25)
				eff.Drag = 5
				eff.Rotation = NumberRange.new(-500,500)
				eff.VelocitySpread = 9000
				eff.RotSpeed = NumberRange.new(-500,500)
				local a = Instance.new("Part",workspace)
				a.Name = "Direction"	
				a.Anchored = true
				a.BrickColor = bc("Bright red")
				a.Material = "Neon"
				a.Transparency = 1
				a.CanCollide = false
				local ray = Ray.new(
					orb.CFrame.p,                           -- origin
					(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
				) 
				local ignore = orb
				local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
				a.BottomSurface = 10
				a.TopSurface = 10
				local distance = (orb.CFrame.p - position).magnitude
				a.Size = Vector3.new(0.1, 0.1, 0.1)
				a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
				orb.CFrame = a.CFrame
				a:Destroy()
				rotz = rotz + 12.5
				orb.CFrame = orb.CFrame*CFrame.Angles(math.rad(rotz),0,0)
				CFuncs["Sound"].Create("rbxassetid://335657174", orb, 3, 0.75)
				CFuncs["Sound"].Create("rbxassetid://304448425", orb, 3.5, 0.9)
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = orb.CFrame.lookVector*225
				bv.Parent = orb
				game:GetService("Debris"):AddItem(orb, 10)
				local hitted = false
				local hit =orb.Touched:connect(function(hit) 
					if hitted == false and hit.Parent ~= char then
						hitted = true
						eff.Enabled = false
						CameraEnshaking(4,4)
						for i = 0, 9 do
							local disr = CreateParta(char,1,1,"Neon",keptcolor)
							disr.CFrame = orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
							local at1 = Instance.new("Attachment",disr)
							at1.Position = vt(-15,0,0)
							local at2 = Instance.new("Attachment",disr)
							at2.Position = vt(15,0,0)
							local trl = Instance.new('Trail',disr)
							trl.Attachment0 = at1
							trl.FaceCamera = true
							trl.Attachment1 = at2
							trl.Texture = "rbxassetid://2325530138"
							trl.LightEmission = 1
							trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
							trl.Color = ColorSequence.new(keptcolor.Color)
							trl.Lifetime = 0.5
							local bv = Instance.new("BodyVelocity")
							bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
							bv.velocity = disr.CFrame.lookVector*math.random(75,250)
							bv.Parent = disr
							local val = 0
							coroutine.resume(coroutine.create(function()
								swait(30)
								for i = 0, 19 do
									swait()
									val = val + 0.05
									trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
								end
								game:GetService("Debris"):AddItem(disr, 3)
							end))
						end
						CFuncs["Sound"].Create("rbxassetid://1226980789", orb, 6, 0.7)
						CFuncs["Sound"].Create("rbxassetid://1368637781", orb, 8,1)
						CFuncs["Sound"].Create("rbxassetid://1368637781", orb, 8,1)
						CFuncs["Sound"].Create("rbxassetid://763718160", orb, 7, 1.1)
						CFuncs["Sound"].Create("rbxassetid://782353443", orb, 7, 1)
						CFuncs["Sound"].Create("rbxassetid://178452221", orb, 6, 0.4)
						MagniDamage(orb, 25, 80,140, 0, "Normal")
						sphere2(4,"Add",orb.CFrame,vt(4,4,4),0.5,0.5,0.5,keptcolor)
						sphere2(3,"Add",orb.CFrame,vt(4,4,4),0.5,0.5,0.5,keptcolor)
						sphere2(2,"Add",orb.CFrame,vt(4,4,4),0.5,0.5,0.5,keptcolor)
						for i = 0, 9 do
							sphere2(4,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1.5,1,1.5),-0.005,4,-0.005,keptcolor)
						end
						for i = 0, 19 do
							slash(math.random(10,50)/10,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(50,250)/250,BrickColor.new("White"))
						end
						for i = 0, 24 do
							local rsiz = math.random(10,30)
							sphereMK(math.random(1,3),1,"Add",orb.CFrame*CFrame.new(math.random(-20,20)/50,math.random(-20,20)/50,math.random(-20,20)/50)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,keptcolor,0)
						end
						local eff = Instance.new("ParticleEmitter",orb)
						eff.Texture = "rbxassetid://296874871"
						eff.LightEmission = 0.95
						eff.Color = ColorSequence.new(orb.BrickColor.Color)
						eff.Rate = 10000
						eff.Lifetime = NumberRange.new(1.5)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.1,15,0),NumberSequenceKeypoint.new(0.8,25,0),NumberSequenceKeypoint.new(1,0,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(150)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.VelocitySpread = 9000
						eff.RotSpeed = NumberRange.new(-500,500)
						coroutine.resume(coroutine.create(function()
							wait(0.25)
							eff.Enabled = false
						end))
						orb.Anchored = true
						orb.Transparency = 1
						wait(10)
						orb:Destroy()
					end
				end)
			end
		end))
		for i = 0,2,0.1 do
			swait()
			RootPart.CFrame = FaceMouse2()[1]
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(20),math.rad(0),math.rad(-80)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(80)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(6), math.rad(-20), math.rad(12)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-30)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(-10)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(10)),.5)
		end
		vel:Destroy()
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function BeamOfDeath()
		attack = true
		hum.WalkSpeed = 0 
		bosschatfunc("CHAOTICAL BEAM!",MRCL.Color,2)
		RootPart.CFrame = FaceMouse()[1]
		CFuncs["Sound"].Create("rbxassetid://1368598393", rarm, 8, 1)
		for i = 0, 5, 0.1 do
			swait()
			block(8,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),0.01,0.01,0.01,BrickColor.new("Really red"),Color3.new(1,0,0))
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(-10)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1.25),math.rad(0),math.rad(6)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1)*angles(math.rad(0),math.rad(0),math.rad(60)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(-5),math.rad(-60)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(90),math.rad(1),math.rad(60)),.1)
			LW.C0=clerp(LW.C0,cf(-0.95,0.65,-0.65)*angles(math.rad(90),math.rad(25),math.rad(73)),.1)
		end
		CFuncs["Sound"].Create("rbxassetid://335657174", rarm, 8, 1)
		for i = 0, 14 do
			slash(math.random(10,40)/10,5,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(25,150)/250,BrickColor.new("Really red"))
		end
		block(3,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),0.05,0.05,0.05,BrickColor.new("Really red"),Color3.new(1,0,0))
		block(3,"Add",rarm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),0.1,0.15,0.1,BrickColor.new("Really red"),Color3.new(1,0,0))
		local keptcolor = MRCL
		local orb = Instance.new("Part", char)
		orb.BrickColor = keptcolor
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 1
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(22.5,10000,22.5)
		orb.CFrame = mouse.Hit
		orb.Anchored = true
		orb.Orientation = vt(0,0,0)
		orb.CFrame = orb.CFrame*CFrame.new(0,1,0)
		CFuncs["LongSound"].Create("rbxassetid://1545630949", char, 2.5, 1)
		local bgui,imgc = createBGCircle(300,orb,MRCL.Color)
		bgui.AlwaysOnTop = true
		imgc.ImageTransparency = 1
		imgc.Image = "rbxassetid://2325939897"
		local over = false
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				imgc.Rotation = imgc.Rotation + 5
				if over == true then
					break
				end
			end
		end))
		coroutine.resume(coroutine.create(function()
			coroutine.resume(coroutine.create(function()
				for i = 0, 399 do
					swait()
					bgui.Size = bgui.Size - UDim2.new(0.5,0,0.5,0)
					imgc.ImageTransparency = imgc.ImageTransparency - 0.0025
					orbm.Scale = orbm.Scale - vt(0.05,0,0.05)
					--orb.Transparency = orb.Transparency - 0.0025
				end
			end))
			wait(9)
			CameraEnshaking(15,5)
			for i = 0, 99 do
				local dis = CreateParta(char,1,1,"Neon",MRCL)
				dis.CFrame = orb.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				local at1 = Instance.new("Attachment",dis)
				at1.Position = vt(-25000,0,0)
				local at2 = Instance.new("Attachment",dis)
				at2.Position = vt(25000,0,0)
				local trl = Instance.new('Trail',dis)
				trl.Attachment0 = at1
				trl.FaceCamera = true
				trl.Attachment1 = at2
				trl.Texture = "rbxassetid://1049219073"
				trl.LightEmission = 1
				trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
				trl.Color = ColorSequence.new(keptcolor.Color)
				trl.Lifetime = 5
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = dis.CFrame.lookVector*math.random(1500,7500)
				bv.Parent = dis
				game:GetService("Debris"):AddItem(dis, 15)
			end
			CFuncs["Sound"].Create("rbxassetid://763718160", char, 6, 1.1)
			CFuncs["Sound"].Create("rbxassetid://782353443", char, 6, 1)
			CFuncs["LongSound"].Create("rbxassetid://763717897", char, 5, 0.5)
			CFuncs["LongSound"].Create("rbxassetid://763717897", char, 4, 0.75)
			CFuncs["Sound"].Create("rbxassetid://1664711478", char, 6, 1)
			coroutine.resume(coroutine.create(function()
				local hfr,pfr=rayCast(orb.Position,(CFrame.new(orb.Position,orb.Position - Vector3.new(0,1,0))).lookVector,4,char)
				if hfr ~= nil then
					for i = 0, 49 do
						local deb = Instance.new("Part", char)
						deb.Anchored = true
						deb.CanCollide = false
						deb.FormFactor = 3
						deb.Name = "Ring"
						deb.Material = hitfloor.Material
						deb.Color = hitfloor.Color
						deb.Size = vt(math.random(50,55),math.random(50,55),math.random(50,55))
						deb.Transparency = 0
						deb.TopSurface = 0
						deb.BottomSurface = 0
						deb.CFrame = orb.CFrame*CFrame.new(math.random(-150,150),-5,math.random(-150,150))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
						local deb2 = Instance.new("Part", char)
						deb2.CanCollide = false
						deb2.FormFactor = 3
						deb2.Name = "Ring"
						deb2.Material = hitfloor.Material
						deb2.Color = hitfloor.Color
						deb2.Size = vt(math.random(34,38),math.random(34,38),math.random(34,38))
						deb2.Transparency = 0
						deb2.TopSurface = 0
						deb2.BottomSurface = 0
						deb2.Velocity = vt(math.random(-150,150),math.random(250,650),math.random(-150,150))
						deb2.CFrame = orb.CFrame*CFrame.new(math.random(-60,60),-5,math.random(-60,60))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
						local eff = Instance.new("ParticleEmitter",deb)
						eff.Texture = "rbxassetid://363275192"
						eff.LightEmission = 0.95
						eff.Color = ColorSequence.new(keptcolor.Color)
						eff.Rate = 100
						eff.Lifetime = NumberRange.new(1)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,40,0),NumberSequenceKeypoint.new(1,45,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(0,5)
						eff.Rotation = NumberRange.new(-500,500)
						eff.VelocitySpread = 9000
						eff.RotSpeed = NumberRange.new(-10,10)
						local at1 = Instance.new('Attachment',deb2)
						at1.Position = vt(0,15,0)
						local at2 = Instance.new('Attachment',deb2)
						at2.Position = vt(0,-15,0)
						local tl = Instance.new('Trail',deb2)
						tl.Attachment0 = at1
						tl.Attachment1 = at2
						tl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
						tl.Color = ColorSequence.new(BrickColor.new('White').Color)
						tl.Lifetime = 1
						game:GetService("Debris"):AddItem(deb,30)
						game:GetService("Debris"):AddItem(deb2,30)
						coroutine.resume(coroutine.create(function()
							wait(15)
							eff.Enabled = false
							for i = 0, 49 do
								swait()
								deb.Transparency = deb.Transparency + 0.02
							end
							wait(1)
							deb:Destroy()
						end))
					end
				end
			end))
			for i = 0, 49, 0.1 do
				swait(1.5)
				bgui.Size = bgui.Size + UDim2.new(45,0,45,0)
				imgc.ImageTransparency = imgc.ImageTransparency + 0.01
				for i, v in pairs(FindNearestHead(orb.CFrame.p, 175)) do
					if v:FindFirstChild('Head') then
						dmg(v)
					end
				end
				for i = 0, 2 do
					slash(math.random(40,80)/10,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(500,2500)/250,BrickColor.new("White"))
				end
				sphere2(5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(10,10,10),5,5,5,keptcolor)
				sphere2(5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(10,10,10),1,35,1,keptcolor)
				sphere2(5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(10,10,10),0,50,0,keptcolor)
				sphere2(5,"Add",orb.CFrame,vt(10,100000,10),2,2,2,keptcolor)
			end
			over = true
			orb:Destroy()
		end))
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end


	function Beams()
		attack = true
		hum.WalkSpeed = 0 
		local keptcolor = MRCL
		coroutine.resume(coroutine.create(function()
			for i = 0, 24 do
				swait(5)
				local orb = Instance.new("Part", char)
				CFuncs["Sound"].Create("rbxassetid://663361028", orb, 2, 1)
				orb.BrickColor = keptcolor
				orb.CanCollide = false
				orb.FormFactor = 3
				orb.Name = "Ring"
				orb.Material = "Neon"
				orb.Size = Vector3.new(1, 1, 1)
				orb.Transparency = 0
				orb.TopSurface = 0
				orb.BottomSurface = 0
				orb.Anchored = true
				local orbm = Instance.new("SpecialMesh", orb)
				orbm.MeshType = "Sphere"
				orbm.Name = "SizeMesh"
				orbm.Scale = vt(1.25,1.25,1.25)
				orb.CFrame = root.CFrame*CFrame.new(math.random(-6,6),math.random(3,9),math.random(-6,6))
				sphere2(6,"Add",orb.CFrame,vt(1.25,1.25,1.25),0.025,0.025,0.025,keptcolor)
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",orb)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(keptcolor.Color)
					eff.Rate = 1500
					eff.Lifetime = NumberRange.new(0.5,1)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,4,0),NumberSequenceKeypoint.new(0.2,1,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(10,30)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-500,500)
					wait(0.25)
					eff.Enabled = false
				end))
				coroutine.resume(coroutine.create(function()
					wait(0.5)
					CFuncs["Sound"].Create("rbxassetid://161006182", orb, 2.5, 1.1)
					sphere2(3,"Add",orb.CFrame,vt(1.25,1.25,1.25),0.025,0.025,0.025,keptcolor)
					sphere2(4,"Add",orb.CFrame,vt(1.25,1.25,1.25),0.025,0.025,0.025,keptcolor)
					orb.Transparency = 1
					local a = Instance.new("Part",char)
					a.Name = "Direction"	
					a.Anchored = true
					a.BrickColor = keptcolor
					a.Material = "Neon"
					a.Transparency = 0.25
					a.Shape = "Cylinder"
					local ht = Instance.new("Part",char)
					ht.Name = "DirectionHit"	
					ht.Anchored = true
					ht.BrickColor = keptcolor
					ht.CanCollide = false
					ht.Transparency = 1
					ht.Size = vt(0.1,0.1,0.1)
					CFuncs["Sound"].Create("rbxassetid://183763487", ht, 2, 1.2)
					a.CanCollide = false
					local ray = Ray.new(
						orb.CFrame.p,                           -- origin
						(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
					) 
					local ignore = char
					local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
					a.BottomSurface = 10
					a.TopSurface = 10
					local distance = (orb.CFrame.p - position).magnitude
					a.Size = Vector3.new(distance,1,1)
					a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
					ht.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
					sphere2(2,"Add",ht.CFrame,vt(1.25,1.25,1.25),0.15,0.15,0.15,keptcolor)
					sphere2(4,"Add",ht.CFrame,vt(1.25,1.25,1.25),0.15,0.15,0.15,keptcolor)
					MagniDamage(ht, 9, 10,15, 0, "Normal")
					CameraEnshaking(2,1)
					coroutine.resume(coroutine.create(function()
						for i = 0, 9 do
							local disr = CreateParta(char,1,1,"Neon",keptcolor)
							disr.CFrame = ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
							local at1 = Instance.new("Attachment",disr)
							at1.Position = vt(-2,0,0)
							local at2 = Instance.new("Attachment",disr)
							at2.Position = vt(2,0,0)
							local trl = Instance.new('Trail',disr)
							trl.Attachment0 = at1
							trl.FaceCamera = true
							trl.Attachment1 = at2
							trl.Texture = "rbxassetid://2325530138"
							trl.LightEmission = 1
							trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
							trl.Color = ColorSequence.new(keptcolor.Color)
							trl.Lifetime = 0.5
							local bv = Instance.new("BodyVelocity")
							bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
							bv.velocity = disr.CFrame.lookVector*math.random(25,100)
							bv.Parent = disr
							local val = 0
							coroutine.resume(coroutine.create(function()
								swait(30)
								for i = 0, 9 do
									swait()
									val = val + 0.1
									trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
								end
								game:GetService("Debris"):AddItem(disr, 3)
							end))
						end
						local eff = Instance.new("ParticleEmitter",ht)
						eff.Texture = "rbxassetid://2273224484"
						eff.LightEmission = 1
						eff.Color = ColorSequence.new(keptcolor.Color)
						eff.Rate = 5000
						eff.Lifetime = NumberRange.new(0.5,1.5)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,10,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(1,0,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.5,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(5,100)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.VelocitySpread = 9000
						eff.RotSpeed = NumberRange.new(-50,50)
						wait(0.25)
						eff.Enabled = false
					end))
					for i = 0, 4 do
						slash(math.random(10,60)/10,5,true,"Round","Add","Out",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(10,50)/250,BrickColor.new("White"))
						sphere2(8,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.005,0.125,-0.005,keptcolor)
						sphere2(4,"Add",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(2,1,2),-0.01,0.5,-0.01,keptcolor)
						local rsiz = math.random(10,30)
						sphereMK(math.random(2,4),0.25,"Add",ht.CFrame*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,keptcolor,0)
					end
					a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
					local msh = Instance.new("SpecialMesh",a)
					msh.MeshType = "Cylinder"
					msh.Scale = vt(1,1,1)
					for i = 0, 49 do
						swait()
						msh.Scale = msh.Scale + vt(0,0.01,0.01)
						a.Transparency = a.Transparency + 0.02
					end
					wait(1)
					orb:Destroy()
					a:Destroy()
					ht:Destroy()
				end))
				game:GetService("Debris"):AddItem(orb, 10)
			end
		end))
		for i = 0,12,0.1 do
			swait()
			sphere2(7,"Add",sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.075,-0.01,keptcolor)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(40)),0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(-40)),.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(10)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(6), math.rad(20), math.rad(-10)), 0.3)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(-20),math.rad(0)),.3)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(0)),.3)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function smiter()
		local targetted = nil
		if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			targetted = mouse.Target.Parent
		end
		if targetted ~= nil then
			RootPart.CFrame = FaceMouse()[1]
			attack = true
			hum.WalkSpeed = 0
			local radm = math.random(1,3)
			if radm == 1 then
				bosschatfunc("Gotcha!",MRCL.Color,1)
			elseif radm == 2 then
				bosschatfunc("Die.",MRCL.Color,1)
			elseif radm == 3 then
				bosschatfunc("Think faster.",MRCL.Color,1)
			end
			coroutine.resume(coroutine.create(function()
				CFuncs["Sound"].Create("rbxassetid://1117054464", targetted.Head, 2, 1)
				sphere2(4,"Add",targetted.Head.CFrame,vt(8,8,8),0.1,0.1,0.1,MRCL)
				local vel = Instance.new("BodyPosition", targetted.Head)
				vel.P = 12500
				vel.D = 1000
				vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
				vel.position = targetted.Head.CFrame.p
			end))
			CFuncs["Sound"].Create("rbxassetid://671759140", sorb2, 1, 1.2)
			for i = 0,4,0.1 do
				swait()
				sphere2(4,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.125,-0.01,MRCL)
				RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-60)),0.2)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(60)),.2)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.2)
				LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-40)), 0.2)
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(0)),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(20),math.rad(5)),.2)
			end
			shakes(0.25,0.5)
			coroutine.resume(coroutine.create(function()
				CameraEnshaking(6,5)
				MagniDamage(targetted.Head, 18, 18,30, 0, "Normal")
				CFuncs["Sound"].Create("rbxassetid://1042705869", targetted.Head, 6.5, 0.8)
				CFuncs["Sound"].Create("rbxassetid://1042716828", targetted.Head, 6.25, 0.8)
				CFuncs["Sound"].Create("rbxassetid://1117054464", targetted.Head, 5, 0.8)
				for i = 0, 19 do
					slash(math.random(10,50)/10,5,true,"Round","Add","Out",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(50,250)/250,BrickColor.new("White"))
				end
				sphere2(3,"Add",targetted.Head.CFrame,vt(0,40000,0),0.25,0,0.25,MRCL)
				sphere2(2,"Add",targetted.Head.CFrame,vt(0,40000,0),0.25,0,0.25,MRCL)
				sphere2(4,"Add",targetted.Head.CFrame,vt(0,0,0),0.5,0.5,0.5,MRCL)
				sphere2(5,"Add",targetted.Head.CFrame,vt(0,0,0),0.5,0.5,0.5,MRCL)
				coroutine.resume(coroutine.create(function()
					local eff = Instance.new("ParticleEmitter",targetted.Head)
					eff.Texture = "rbxassetid://363275192"
					eff.LightEmission = 0.95
					eff.Color = ColorSequence.new(MRCL.Color)
					eff.Rate = 10000
					eff.Lifetime = NumberRange.new(1.5)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.8,25,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(25,150)
					eff.Drag = 5
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-50,50)
					local eff2 = eff:Clone()
					eff2.Parent = targetted.Head
					eff2.LightEmission = 1
					eff2.Color = ColorSequence.new(Color3.new(0.75,0.5,1))
					eff2.Texture = "rbxassetid://2273224484"
					eff2.Rate = 10000
					eff2.Lifetime = NumberRange.new(1,3)
					eff2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,10,0),NumberSequenceKeypoint.new(1,0,0)})
					eff2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
					eff2.Drag = 5
					eff2.Speed = NumberRange.new(50,250)
					eff2.Rotation = NumberRange.new(-500,500)
					eff2.VelocitySpread = 9000
					wait(0.5)
					eff2.Enabled = false
					eff.Enabled = false
				end))
				for i = 0, 9 do
					sphere2(3,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(2,1,2),-0.02,3,-0.02,MRCL)
				end
				for i = 0, 49 do
					local rsiz = math.random(10,50)
					sphereMK(math.random(1,4),1,"Add",targetted.Head.CFrame*CFrame.new(math.random(-20,20)/50,math.random(-20,20)/50,math.random(-20,20)/50)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,MRCL,0)
				end
				game:GetService("Debris"):AddItem(vel,1)
				dmg(targetted)
			end))
			for i = 0,1,0.1 do
				swait()
				RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-70)),0.5)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(70)),.5)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.5)
				LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(40), math.rad(0), math.rad(-50)), 0.5)
				RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(0)),.5)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(20),math.rad(5)),.5)
			end
			attack = false
			hum.WalkSpeed = storehumanoidWS
		end
	end

	function supsmiter()
		local targetted = nil
		if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			targetted = mouse.Target.Parent
		end
		if targetted ~= nil then
			RootPart.CFrame = FaceMouse()[1]
			attack = true
			hum.WalkSpeed = 0
			local radm = math.random(1,3)
			if radm == 1 then
				bosschatfunc("Your existance will be gone!",MRCL.Color,1)
			elseif radm == 2 then
				bosschatfunc("Next time, dont mess with me.",MRCL.Color,1)
			elseif radm == 3 then
				bosschatfunc("Nothing will be with you after you're gone!",MRCL.Color,1)
			end
			coroutine.resume(coroutine.create(function()
				CFuncs["Sound"].Create("rbxassetid://1042716828", targetted.Head, 5, 0.5)
				local vel = Instance.new("BodyPosition", targetted.Head)
				vel.P = 12500
				vel.D = 1000
				vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
				vel.position = targetted.Head.CFrame.p + vt(0,10,0)
				for i,v in pairs(targetted:GetChildren()) do
					if v:IsA("Part") or v:IsA("MeshPart") then
						coroutine.resume(coroutine.create(function()
							local bld = Instance.new("ParticleEmitter",v)
							bld.LightEmission = 0.75
							bld.Texture = "rbxassetid://363275192" ---284205403
							bld.Color = ColorSequence.new(MRCL.Color)
							bld.Rate = 500
							bld.Lifetime = NumberRange.new(1)
							bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0,0)})
							bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
							bld.Speed = NumberRange.new(2,5)
							bld.VelocitySpread = 50000
							bld.Rotation = NumberRange.new(-500,500)
							bld.RotSpeed = NumberRange.new(-500,500)
						end))
					end
				end
				local A1 = Instance.new("Attachment",sorb2)
				local A2 = Instance.new("Attachment",targetted.Head)
				local Beem = Instance.new("Beam",targetted.Head)
				Beem.Attachment0 = A1
				Beem.Attachment1 = A2
				Beem.LightEmission = 1
				Beem.FaceCamera = true
				Beem.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 0)})
				Beem.Width0 = 1
				Beem.Width1 = 1
				Beem.Texture = "rbxassetid://1134824633"
				Beem.TextureMode = "Wrap"
				Beem.TextureLength = 2
				Beem.TextureSpeed = 5
				Beem.Color = ColorSequence.new(MRCL.Color)
			end))
			CFuncs["Sound"].Create("rbxassetid://1042700914", sorb2, 2.5, 0.25)
			for i = 0,14,0.1 do
				swait()
				rsiz = math.random(5,15)
				sphereMK(math.random(3,9),0.25,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,MRCL,-15)	
				sphere2(4,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1.5,1.5,1.5),-0.01,0.15,-0.01,MRCL)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 28))* angles(math.rad(0),math.rad(0),math.rad(-60)),0.2)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(60)),.2)
				RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.2)
				LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-40)), 0.2)
				RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.2)
				LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(5 + 1 * math.cos(sine / 34))),.2)
			end
			shakes(0.5,0.5)
			sphere2(3,"Add",sorb2.CFrame,vt(0,0,0),0.1,0.1,0.1,MRCL)
			sphere2(3,"Add",sorb2.CFrame,vt(0,0,0),0.2,0.2,0.2,MRCL)
			CFuncs["Sound"].Create("rbxassetid://1368637781", sorb2, 2.5, 1.1)
			coroutine.resume(coroutine.create(function()
				local ref = Instance.new("Part", char)
				ref.Anchored = true
				ref.CanCollide = false
				ref.Transparency = 1
				ref.CFrame = targetted.Head.CFrame
				sphere2(1,"Add",targetted.Head.CFrame,vt(8,8,8),0.25,0.25,0.25,MRCL)
				sphere2(2,"Add",targetted.Head.CFrame,vt(8,8,8),0.5,0.5,0.5,MRCL)
				sphere2(3,"Add",targetted.Head.CFrame,vt(8,8,8),0.75,0.75,0.75,MRCL)
				for i = 0, 24 do
					slash(math.random(10,25)/10,5,true,"Round","Add","Out",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.001,0.001,0.001),math.random(25,250)/250,BrickColor.new("White"))
				end
				targetted.Head.Parent:Destroy()
				CFuncs["Sound"].Create("rbxassetid://1368637781", ref, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://763718160", ref, 10, 1.1)
				CFuncs["Sound"].Create("rbxassetid://782353443", ref, 10, 1)
				CFuncs["Sound"].Create("rbxassetid://335657174", ref, 10, 1)
				wait(5)
				ref:Destroy()
			end))
			attack = false
			hum.WalkSpeed = storehumanoidWS
		end
	end

	function BinaryBLINK()
		for i = 0, 9 do
			sphere2(6,"Add",root.CFrame*CFrame.new(math.random(-15,15),math.random(-15,15),math.random(-15,15))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),vt(0.5,0.5,0.5),-0.005,0.5,-0.005,MRCL)		sphere2(6,"Add",root.CFrame*CFrame.new(math.random(-15,15),math.random(-15,15),math.random(-15,15))*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.5,-0.005,MRCL)	    sphere2(6,"Add",root.CFrame*CFrame.new(math.random(-15,15),math.random(-15,15),math.random(-15,15))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.5,-0.005,MRCL)
		end
		sphere(20,"Add",root.CFrame,vt(0,0,0),0.5,MRCL)
		coroutine.resume(coroutine.create(function()
			local eff = Instance.new("ParticleEmitter",root)
			eff.Texture = "rbxassetid://1175838406"
			eff.LightEmission = 0.95
			eff.Color = ColorSequence.new(MRCL.Color)
			eff.Rate = 10000
			eff.Lifetime = NumberRange.new(1)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,4,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(30,160)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.VelocitySpread = 100000
			wait(0.25)
			eff.Enabled = false
			wait(4)
			eff:Destroy()
		end))
		CFuncs["Sound"].Create("rbxassetid://335657174", root, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://1177785010", root, 10,1)
		RootPart.CFrame = mouse.Hit *CFrame.new(0,2,0)
		CameraEnshaking(2,10)
		for i, v in pairs(FindNearestHead(Torso.CFrame.p, 10)) do
			if v:FindFirstChild('Head') then
				dmg(v)
			end
		end
		for i = 0, 9 do
			sphere2(6,"Add",root.CFrame*CFrame.new(math.random(-15,15),math.random(-15,15),math.random(-15,15))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),vt(0.5,0.5,0.5),-0.005,0.5,-0.005,MRCL)		sphere2(6,"Add",root.CFrame*CFrame.new(math.random(-15,15),math.random(-15,15),math.random(-15,15))*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.5,-0.005,MRCL)	    sphere2(6,"Add",root.CFrame*CFrame.new(math.random(-15,15),math.random(-15,15),math.random(-15,15))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.5,-0.005,MRCL)
		end
		sphere(20,"Add",root.CFrame,vt(0,0,0),0.5,MRCL)
	end

	function BinaryE()
		local posit = -2
		attack = true
		hum.WalkSpeed = 5
		CFuncs["Sound"].Create("rbxassetid://169380495", sorb2, 1, 1)
		for i = 0,2,0.1 do
			swait()
			sphere2(7,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.075,-0.01,MRCL)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(30)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(-30)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(20)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(45), math.rad(6), math.rad(-30)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(-20),math.rad(0)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(0)),.5)
		end
		for i = 0, 2 do
			CameraEnshaking(1,2)
			local hite = Instance.new("Part", char)
			hite.Anchored = true
			hite.CanCollide = false
			hite.FormFactor = 3
			hite.Name = "Ring"
			hite.Material = "Neon"
			hite.Size = Vector3.new(1, 1, 1)
			hite.Transparency = 1
			hite.TopSurface = 0
			hite.BottomSurface = 0
			hite.CFrame = root.CFrame*CFrame.new(0,posit,-5)
			CFuncs["Sound"].Create("rbxassetid://231917856", hite, 0.5, 0.9)
			CFuncs["Sound"].Create("rbxassetid://231917758", hite, 0.25, 0.8)
			coroutine.resume(coroutine.create(function()
				local eff = Instance.new("ParticleEmitter",hite)
				eff.Texture = "rbxassetid://1175838406"
				eff.LightEmission = 0.95
				eff.Color = ColorSequence.new(MRCL.Color)
				eff.Rate = 1000
				eff.Lifetime = NumberRange.new(1)
				eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,1,0),NumberSequenceKeypoint.new(1,0,0)})
				eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
				eff.Speed = NumberRange.new(10,50)
				eff.Drag = 5
				eff.Rotation = NumberRange.new(-500,500)
				eff.VelocitySpread = 100000
				wait(0.25)
				eff.Enabled = false
			end))
			coroutine.resume(coroutine.create(function()
				for i = 0, 1 do
					swait()
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MRCL)
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MRCL)
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MRCL)
				end
			end))
			sphere2(6,"Add",hite.CFrame*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),vt(2,2,2),0.5,-0.01,-0.01,MRCL)
			MagniDamage(hite, 3, 30,40, 0, "Normal")
			game:GetService("Debris"):AddItem(hite, 5)
			posit = posit + 2
		end
		for i = 0,1,0.1 do
			swait()
			sphere2(7,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.075,-0.01,MRCL)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-80)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(80)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(20)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(110), math.rad(6), math.rad(40)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(-20),math.rad(0)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(0)),.5)
		end
		for i = 0,1,0.1 do
			swait()
			sphere2(7,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.075,-0.01,MRCL)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,-0.2,0)* angles(math.rad(20),math.rad(0),math.rad(60)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-60)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(60)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(60), math.rad(6), math.rad(-50)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(-20),math.rad(30)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(40)),.5)
		end
		posit = -6
		for i = 0, 6 do
			CameraEnshaking(1,3)
			local hite = Instance.new("Part", char)
			hite.Anchored = true
			hite.CanCollide = false
			hite.FormFactor = 3
			hite.Name = "Ring"
			hite.Material = "Neon"
			hite.Size = Vector3.new(1, 1, 1)
			hite.Transparency = 1
			hite.TopSurface = 0
			hite.BottomSurface = 0
			hite.CFrame = root.CFrame*CFrame.new(posit,0,-5)
			CFuncs["Sound"].Create("rbxassetid://231917856", hite, 0.5, 1.2)
			CFuncs["Sound"].Create("rbxassetid://231917758", hite, 0.25, 1)
			sphere2(6,"Add",hite.CFrame*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),vt(1,1,1),-0.01,1,-0.01,MRCL)
			coroutine.resume(coroutine.create(function()
				local eff = Instance.new("ParticleEmitter",hite)
				eff.Texture = "rbxassetid://1175838406"
				eff.LightEmission = 0.95
				eff.Color = ColorSequence.new(MRCL.Color)
				eff.Rate = 1000
				eff.Lifetime = NumberRange.new(1)
				eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,1,0),NumberSequenceKeypoint.new(1,0,0)})
				eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
				eff.Speed = NumberRange.new(20,70)
				eff.Drag = 5
				eff.Rotation = NumberRange.new(-500,500)
				eff.VelocitySpread = 100000
				wait(0.25)
				eff.Enabled = false
			end))
			coroutine.resume(coroutine.create(function()
				for i = 0, 2 do
					swait()
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MRCL)
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MRCL)
					sphere2(4,"Add",hite.CFrame*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),vt(0.5,0.5,0.5),-0.005,0.25,-0.005,MRCL)
				end
			end))
			MagniDamage(hite, 5, 40,70, 0, "Normal")
			game:GetService("Debris"):AddItem(hite, 5)
			posit = posit + 2
		end
		for i = 0,1,0.1 do
			swait()
			sphere2(7,"Add",sorb2.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.075,-0.01,MRCL)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0.1,1.5)* angles(math.rad(-10),math.rad(0),math.rad(-60)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(50)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(30)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(140), math.rad(6), math.rad(-50)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(10),math.rad(-10)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(60)),.5)
		end
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function AZUREFINALE()
		attack = true
		duringend = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://1117054464", char, 7.5, 0.75)
		CFuncs["LongSound"].Create("rbxassetid://1042700914", char, 3.5, 0.05)
		local hite = Instance.new("Part", char)
		hite.Anchored = true
		hite.CanCollide = false
		hite.FormFactor = 3
		hite.Name = "Ring"
		hite.Material = "Neon"
		hite.Size = Vector3.new(1, 1, 1)
		hite.Transparency = 0
		hite.TopSurface = 0
		hite.BottomSurface = 0
		hite.BrickColor = MRCL
		local orbm = Instance.new("SpecialMesh", hite)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(0,0,0)
		hite.CFrame = root.CFrame*CFrame.new(0,200,0)
		for i = 0,70,0.1 do
			swait()
			orbm.Scale = orbm.Scale + vt(0.5,0.5,0.5)
			rsiz = math.random(10,45)
			kan.Volume = kan.Volume + 0.01
			kan.Pitch = kan.Pitch - 0.00135
			sphereMK(math.random(1,4),2.5,"Add",hite.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/2,rsiz/2,rsiz/2,0,MRCL,-300)	
			sphere2(4,"Add",hite.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(10,1.5,10),-0.01,10,-0.01,MRCL)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 28))* angles(math.rad(0),math.rad(0),math.rad(-60)),0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(60)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.2)
			LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-40)), 0.2)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(5 + 1 * math.cos(sine / 34))),.2)
		end
		kan.Pitch = 0.1
		hite.Transparency = 1
		for i = 0,2 do
			CFuncs["LongSound"].Create("rbxassetid://324849898", char, 10,0.9)
		end
		CFuncs["LongSound"].Create("rbxassetid://1117054464", char, 5, 0.75)
		sphere2(1,"Add",hite.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(orbm.Scale.X,orbm.Scale.Y,orbm.Scale.Z),-5,-5,-5,MRCL)
		sphere2(1,"Add",hite.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(orbm.Scale.X,orbm.Scale.Y,orbm.Scale.Z),2,2,2,MRCL)
		sphere2(2,"Add",hite.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(orbm.Scale.X,orbm.Scale.Y,orbm.Scale.Z),3,3,3,MRCL)
		coroutine.resume(coroutine.create(function()
			local eff = Instance.new("ParticleEmitter",hite)
			eff.Texture = "rbxassetid://284205403"
			eff.LightEmission = 0.95
			eff.Color = ColorSequence.new(MRCL.Color)
			eff.Rate = 10000
			eff.Lifetime = NumberRange.new(5)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.8,100,0),NumberSequenceKeypoint.new(1,0,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(600,1250)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.VelocitySpread = 9000
			eff.RotSpeed = NumberRange.new(-500,500)
			wait(1)
			eff.Enabled = false
		end))
		for i = 0,5,0.1 do
			swait()
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 28))* angles(math.rad(0),math.rad(0),math.rad(-60)),0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(60)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.2)
			LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-40)), 0.2)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(5 + 1 * math.cos(sine / 34))),.2)
		end
		local adsc = 0
		local radiatezone = 0
		for i = 0,20,0.1 do
			swait()
			adsc = adsc + 0.025
			radiatezone = radiatezone + 1.25
			sphere2(8,"Add",hite.CFrame,vt(0,0,0),adsc,adsc,adsc,MRCL)
			for i, v in pairs(FindNearestHead(hite.CFrame.p, radiatezone)) do
				if v:FindFirstChild('Head') then
					dmg(v)
				end
			end
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 28))* angles(math.rad(0),math.rad(0),math.rad(-60)),0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(60)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.2)
			LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-40)), 0.2)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(5 + 1 * math.cos(sine / 34))),.2)
		end
		for i = 0,2 do
			CFuncs["LongSound"].Create("rbxassetid://665426491", char, 10,0.9)
		end
		for i = 0,40,0.1 do
			swait()
			adsc = adsc + 0.05
			radiatezone = radiatezone + 2.5
			sphere2(8,"Add",hite.CFrame,vt(0,0,0),adsc,adsc,adsc,MRCL)
			for i, v in pairs(FindNearestHead(hite.CFrame.p, radiatezone)) do
				if v:FindFirstChild('Head') then
					dmg(v)
				end
			end
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 28))* angles(math.rad(0),math.rad(0),math.rad(-60)),0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(60)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.2)
			LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-40)), 0.2)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(5 + 1 * math.cos(sine / 34))),.2)
		end
		for i = 0,4 do
			CFuncs["LongSound"].Create("rbxassetid://665426491", char, 10,0.75)
			CFuncs["LongSound"].Create("rbxassetid://923073285", char, 1.25,0.75)
		end
		for i = 0,80,0.1 do
			swait()
			adsc = adsc + 0.075
			radiatezone = radiatezone + 3.75
			sphere2(8,"Add",hite.CFrame,vt(0,0,0),adsc,adsc,adsc,MRCL)
			for i, v in pairs(FindNearestHead(hite.CFrame.p, radiatezone)) do
				if v:FindFirstChild('Head') then
					dmg(v)
				end
			end
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.1 * math.cos(sine / 28))* angles(math.rad(0),math.rad(0),math.rad(-60)),0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(60)),.2)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.2)
			LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-40)), 0.2)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-10 + 1 * math.cos(sine / 34))),.2)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(5 + 1 * math.cos(sine / 34))),.2)
		end
		hite:Destroy()
		duringend = false
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function AzureVANISHMENT()
		attack = true
		hum.WalkSpeed = 0
		local truescale = 0
		local rd = math.random(1,3)
		if rd == 1 then
			bosschatfunc("This is your end!",MRCL.Color,2)
		elseif rd == 2 then
			bosschatfunc("Pathetic.",MRCL.Color,2)
		elseif rd == 3 then
			bosschatfunc("Time to end this.",MRCL.Color,2)
		end
		CFuncs["LongSound"].Create("rbxassetid://1368583274", char, 10, 0.25)
		for i = 0,49,0.1 do
			swait()
			truescale = truescale + 0.2
			hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
			slash(5,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,75,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,0.01,3),-3,BrickColor.new("Royal purple"))
			block(10,"Add",root.CFrame*CFrame.new(0,75,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(truescale,truescale,truescale),0.01,0.01,0.01,BrickColor.new("Magenta"),BrickColor.new("Magenta").Color)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(5),math.rad(-10)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(5)),.5)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1)*angles(math.rad(0),math.rad(0),math.rad(40)),.5)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-40)),.5)
			RW.C0=clerp(RW.C0,cf(1.45,1,0.1)*angles(math.rad(180),math.rad(-30),math.rad(-5)),.5)
			LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(-5),math.rad(10),math.rad(-10)),.5)
		end
		hum.CameraOffset = vt(0,0,0)
		CFuncs["Sound"].Create("rbxassetid://260411131", rarm, 7.5, 1)
		for i = 0,2,0.1 do
			swait()
			block(10,"Add",rarm.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),0.01,0.01,0.01,BrickColor.new("Magenta"),BrickColor.new("Magenta").Color)
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(5),math.rad(-10)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(5)),.5)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1)*angles(math.rad(0),math.rad(0),math.rad(55)),.5)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(-55)),.5)
			RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.6)*angles(math.rad(90),math.rad(0),math.rad(-50)),.5)
			LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(-5),math.rad(10),math.rad(-10)),.5)
		end
		shakes(1,4)
		local orb = Instance.new("Part", char)
		for i = 0, 4 do
			CFuncs["Sound"].Create("rbxassetid://335657174", char, 7.5, 0.5)
		end
		local efec = Instance.new("ParticleEmitter",orb)
		efec.Texture = "rbxassetid://2109052855"
		efec.LightEmission = 1
		efec.Color = ColorSequence.new(Color3.new(0.5,0,1))
		efec.Rate = 5
		efec.Lifetime = NumberRange.new(3)
		efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,100,0),NumberSequenceKeypoint.new(0.2,175,0),NumberSequenceKeypoint.new(0.6,110,0),NumberSequenceKeypoint.new(0.8,175,0),NumberSequenceKeypoint.new(1,200,0)})
		efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.25,0),NumberSequenceKeypoint.new(0.6,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
		efec.Drag = 5
		efec.LockedToPart = true
		efec.Rotation = NumberRange.new(-500,500)
		efec.VelocitySpread = 9000
		efec.RotSpeed = NumberRange.new(-500,500)
		orb.BrickColor = BrickColor.new("Magenta")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(25,25,25)
		orb.CFrame = root.CFrame + root.CFrame.lookVector*3
		local a = Instance.new("Part",workspace)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = bc("Bright red")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(
			orb.CFrame.p,                           -- origin
			(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
		) 
		local ignore = orb
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
		orb.CFrame = a.CFrame
		a:Destroy()
		local over = false
		local bgui,imgc = createBGCircle(250,orb,Color3.new(0.5,0,1))
		bgui.AlwaysOnTop = true
		imgc.Image = "rbxassetid://2076519836"
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if over == false then
					hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
					coroutine.resume(coroutine.create(function()
						for i, v in pairs(FindNearestHead(orb.CFrame.p, 100)) do
							if v:FindFirstChild('Head') then
								dmg(v)
							end
						end
					end))
					slash(10,2,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),1,BrickColor.new("Dark indigo"))
					imgc.Rotation = imgc.Rotation + 5
					imgc.ImageTransparency = 0.75 + 0.25 * math.cos(sine / 15)
					bgui.Size = UDim2.new(250 + 25 * math.cos(sine / 15),0, 250 + 25 * math.cos(sine / 15),0)
				elseif over == true then
					break
				end
			end
		end))
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = orb.CFrame.lookVector*50
		bv.Parent = orb
		coroutine.resume(coroutine.create(function()
			wait(10)
			hum.CameraOffset = vt(0,0,0)
			over = true
			efec.Enabled = false
			orb.Anchored = true
			shakes(6,5)
			for i = 0, 2 do
				CFuncs["Sound"].Create("rbxassetid://1664711478", char, 10,1)
				CFuncs["LongSound"].Create("rbxassetid://763717897", char, 10, 0.5)
				CFuncs["LongSound"].Create("rbxassetid://763717897", char, 7.5, 0.25)
				CFuncs["Sound"].Create("rbxassetid://763718160", char, 10, 0.9)
				CFuncs["Sound"].Create("rbxassetid://782353443", char, 10, 0.5)
				CFuncs["Sound"].Create("rbxassetid://335657174", char, 5, 0.75)
				CFuncs["LongSound"].Create("rbxassetid://335657174", char, 10, 0.25)
				CFuncs["Sound"].Create("rbxassetid://167115397", char, 10, 1)
				CFuncs["LongSound"].Create("rbxassetid://167115397", char, 10, 0.75)
				CFuncs["LongSound"].Create("rbxassetid://167115397", char, 10, 0.5)
			end
			for i = 0, 2 do
				block(3,"Add",orb.CFrame,vt(1,1,1),6.5,6.5,6.5,BrickColor.new("Dark indigo"),BrickColor.new("Dark indigo").Color)
				block(2,"Add",orb.CFrame,vt(1,1,1),6,6,6,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
				block(1,"Add",orb.CFrame,vt(1,1,1),4.5,4.5,4.5,BrickColor.new("Magenta"),BrickColor.new("Magenta").Color)
			end
			for i = 0, 49 do
				slash(math.random(10,30)/10,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,2500)/250,BrickColor.new("Royal purple"))
			end
			imgc.ImageTransparency = 0
			--CameraEnshaking(20,30)
			for i = 0, 199 do
				swait()
--[[coroutine.resume(coroutine.create(function()
for i, v in pairs(FindNearestHead(orb.CFrame.p, 5000)) do
if v:FindFirstChild('Head') then
dmg(v)
end
end
end))]]--
				imgc.Rotation = imgc.Rotation + 10
				local dis = CreateParta(char,1,1,"Neon",MRCL)
				dis.CFrame = orb.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				local at1 = Instance.new("Attachment",dis)
				at1.Position = vt(-25000,0,0)
				local at2 = Instance.new("Attachment",dis)
				at2.Position = vt(25000,0,0)
				local trl = Instance.new('Trail',dis)
				trl.Attachment0 = at1
				trl.FaceCamera = true
				trl.Attachment1 = at2
				trl.Texture = "rbxassetid://1049219073"
				trl.LightEmission = 1
				trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
				trl.Color = ColorSequence.new(orb.Color)
				trl.Lifetime = 5
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
				bv.Parent = dis
				game:GetService("Debris"):AddItem(dis, 5)
				sphere2(15,"Add",orb.CFrame,vt(1.25,1.25,1.25),45,45,45,BrickColor.new("Royal purple"))
				for i = 0, 2 do
					slash(15,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),25,BrickColor.new("Really black"))
					slash(15,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),50,BrickColor.new("Dark indigo"))
				end
				orbm.Scale = orbm.Scale + vt(10,10,10)
				orb.Transparency = orb.Transparency + 0.005
				imgc.ImageTransparency = imgc.ImageTransparency + 0.005
				bgui.Size = bgui.Size + UDim2.new(35,0,35,0)
			end
			hum.CameraOffset = vt(0,0,0)
			game:GetService("Debris"):AddItem(orb, 10)
		end))
		for i = 0,2,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(5),math.rad(-10)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(20),math.rad(10)),.5)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,1)*angles(math.rad(5),math.rad(0),math.rad(-45)),.5)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(45)),.5)
			RW.C0=clerp(RW.C0,cf(1.45,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(50)),.5)
			LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(20),math.rad(10),math.rad(-30)),.5)
		end
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	function GalacticalBeams()
		attack = true
		local keptcolor = MRCL
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Galactical Beam!",MRCL.Color,1)
		elseif radm == 2 then
			bosschatfunc("Dodge this.",MRCL.Color,1)
		elseif radm == 3 then
			bosschatfunc("Aren't you familiar?",MRCL.Color,1)
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 0 do
				swait(10)
				local orb = Instance.new("Part", char)
				CFuncs["Sound"].Create("rbxassetid://663361028", orb, 2, 1)
				orb.BrickColor = keptcolor
				orb.CanCollide = false
				orb.FormFactor = 3
				orb.Name = "Ring"
				orb.Material = "Neon"
				orb.Size = Vector3.new(1, 1, 1)
				orb.Transparency = 1
				orb.TopSurface = 0
				orb.BottomSurface = 0
				orb.Anchored = true
				local orbm = Instance.new("SpecialMesh", orb)
				orbm.MeshType = "Sphere"
				orbm.Name = "SizeMesh"
				orbm.Scale = vt(1.25,1.25,1.25)
				orb.CFrame = root.CFrame*CFrame.new(math.random(-25,25),math.random(75,150),math.random(-25,25))
				coroutine.resume(coroutine.create(function()
					orb.Transparency = 1
					local a = Instance.new("Part",char)
					a.Name = "Direction"	
					a.Anchored = true
					a.BrickColor = keptcolor
					a.Material = "Neon"
					a.Transparency = 1
					a.Shape = "Cylinder"
					local x = Instance.new("Part",char)
					x.Name = "Direction"	
					x.Anchored = true
					x.BrickColor = keptcolor
					x.Material = "Neon"
					x.Transparency = 1
					x.Shape = "Cylinder"
					local ht = Instance.new("Part",char)
					ht.Name = "DirectionHit"	
					ht.Anchored = true
					ht.BrickColor = keptcolor
					ht.CanCollide = false
					ht.Transparency = 1
					ht.Size = vt(0.1,0.1,0.1)
					a.CanCollide = false
					local ray = Ray.new(
						orb.CFrame.p,                           -- origin
						(mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
					) 
					local ignore = char
					local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
					a.BottomSurface = 10
					a.TopSurface = 10
					local distance = (orb.CFrame.p - position).magnitude
					a.Size = Vector3.new(distance,1,1)
					a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
					ht.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
					x.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
					local poste = 0
					local rotation = 0
					CFuncs["Sound"].Create("rbxassetid://153092315", char, 1.5, 1)
					sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,0),vt(5,5,5),2.5,2.5,0,keptcolor)
					CameraEnshaking(2,2)
					coroutine.resume(coroutine.create(function()
						local eff = Instance.new("ParticleEmitter",orb)
						eff.Texture = "rbxassetid://2273224484"
						eff.LightEmission = 1
						eff.Color = ColorSequence.new(keptcolor.Color)
						eff.Rate = 15000
						eff.Lifetime = NumberRange.new(2.5,5)
						eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,60,0),NumberSequenceKeypoint.new(0.2,3,0),NumberSequenceKeypoint.new(0.8,24,0),NumberSequenceKeypoint.new(1,0,0)})
						eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
						eff.Speed = NumberRange.new(100,650)
						eff.Drag = 5
						eff.Rotation = NumberRange.new(-500,500)
						eff.VelocitySpread = 9000
						eff.RotSpeed = NumberRange.new(-50,50)
						wait(0.35)
						eff.Enabled = false
					end))
					for i = 0, 49 do
						swait()
						rotation = rotation + 5
						poste = poste + 1
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(180 + rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(-rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(180 - rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(90 + rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(90 - rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(270 + rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(270 - rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
					end
					shakes(1,1)
					local A1 = Instance.new("Attachment",x)
					local A2 = Instance.new("Attachment",ht)
					local Beem = Instance.new("Beam",ht)
					Beem.Attachment0 = A1
					Beem.Attachment1 = A2
					Beem.LightEmission = 1
					Beem.FaceCamera = true
					Beem.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.025, 0),NumberSequenceKeypoint.new(0.975, 0),NumberSequenceKeypoint.new(1, 1)})
					Beem.Width0 = 125
					Beem.Width1 = 125
					Beem.Texture = "rbxassetid://1134824633"
					Beem.TextureMode = "Wrap"
					Beem.TextureLength = 200
					Beem.TextureSpeed = 1.5
					Beem.Color = ColorSequence.new(keptcolor.Color)
					CameraEnshaking(3,6)
					CFuncs["Sound"].Create("rbxassetid://1664711478", char, 1.5, 1)
					CFuncs["Sound"].Create("rbxassetid://294188875", char, 2, 1.5)
					a.Transparency = 0.25
					for i = 0, 49 do
						local disr = CreateParta(char,1,1,"Neon",keptcolor)
						disr.CFrame = ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
						local at1 = Instance.new("Attachment",disr)
						at1.Position = vt(-5,0,0)
						local at2 = Instance.new("Attachment",disr)
						at2.Position = vt(5,0,0)
						local trl = Instance.new('Trail',disr)
						trl.Attachment0 = at1
						trl.FaceCamera = true
						trl.Attachment1 = at2
						trl.Texture = "rbxassetid://2325530138"
						trl.LightEmission = 1
						trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
						trl.Color = ColorSequence.new(keptcolor.Color)
						trl.Lifetime = 0.5
						local bv = Instance.new("BodyVelocity")
						bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
						bv.velocity = disr.CFrame.lookVector*math.random(50,500)
						bv.Parent = disr
						local val = 0
						coroutine.resume(coroutine.create(function()
							swait(math.random(30,60))
							for i = 0, 19 do
								swait()
								val = val + 0.05
								trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
							end
							game:GetService("Debris"):AddItem(disr, 3)
						end))
					end
					sphere2(2,"Add",ht.CFrame,vt(1.25,1.25,1.25),0.5,0.5,0.5,keptcolor)
					sphere2(4,"Add",ht.CFrame,vt(1.25,1.25,1.25),0.5,0.5,0.5,keptcolor)
					sphere2(2,"Add",ht.CFrame,vt(1.25,1.25,1.25),1,1,1,keptcolor)
					sphere2(4,"Add",ht.CFrame,vt(1.25,1.25,1.25),1,1,1,keptcolor)
					sphere2(2,"Add",ht.CFrame,vt(1.25,1.25,1.25),1.5,1.5,1.5,keptcolor)
					sphere2(4,"Add",ht.CFrame,vt(1.25,1.25,1.25),1.5,1.5,1.5,keptcolor)
					MagniDamage(ht, 70, 1000,1500, 0, "Normal")
					local eff = Instance.new("ParticleEmitter",ht)
					eff.Texture = "rbxassetid://2273224484"
					eff.LightEmission = 1
					eff.Color = ColorSequence.new(keptcolor.Color)
					eff.Rate = 500
					eff.Lifetime = NumberRange.new(1,3)
					eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,5,0),NumberSequenceKeypoint.new(0.2,10,0),NumberSequenceKeypoint.new(1,0,0)})
					eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
					eff.Speed = NumberRange.new(80,700)
					eff.Drag = 3
					eff.Rotation = NumberRange.new(-500,500)
					eff.VelocitySpread = 9000
					eff.RotSpeed = NumberRange.new(-100,100)
					for i = 0, 24 do
						sphere2(6,"Add",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(15,1,15),-0.05,math.random(1,5),-0.05,keptcolor)
						local rsiz = math.random(10,50)
						sphereMK(math.random(3,6),1.25,"Add",ht.CFrame*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,keptcolor,0)
					end
					a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
					local msh = Instance.new("SpecialMesh",a)
					msh.MeshType = "Cylinder"
					msh.Scale = vt(1,15,15)
					for i = 0, 49 do
						swait()
						CameraEnshaking(1,4)
						MagniDamage(ht, 70, 1000,1500, 0, "Normal")
						rotation = rotation + 5
						slash(math.random(30,90)/10,5,true,"Round","Add","Out",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(200,450)/250,BrickColor.new("White"))
						sphere2(4,"Add",ht.CFrame,vt(1.25,1.25,1.25),1,1,1,keptcolor)
						sphere2(6,"Add",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(15,1,15),-0.05,math.random(1,5),-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,0),vt(25,25,5),1,1,0,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(rotation))*CFrame.new(0,50,0),vt(5,25,10),-0.05,1.5,-0.1,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(180 + rotation))*CFrame.new(0,50,0),vt(5,25,10),-0.05,1.5,-0.1,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(-rotation))*CFrame.new(0,50,0),vt(5,25,10),-0.05,1.5,-0.1,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(180 - rotation))*CFrame.new(0,50,0),vt(5,25,10),-0.05,1.5,-0.1,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(90 + rotation))*CFrame.new(0,50,0),vt(5,25,10),-0.05,1.5,-0.1,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(90 - rotation))*CFrame.new(0,50,0),vt(5,25,10),-0.05,1.5,-0.1,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(270 + rotation))*CFrame.new(0,50,0),vt(5,25,10),-0.05,1.5,-0.1,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(270 - rotation))*CFrame.new(0,50,0),vt(5,25,10),-0.05,1.5,-0.1,keptcolor)
						for i = 0, 2 do
							local rsiz = math.random(50,250)
							sphereMK(math.random(3,6),math.random(2,4),"Add",ht.CFrame*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,keptcolor,0)
						end
						msh.Scale = msh.Scale + vt(0,0.25,0.25)
					end
					eff.Enabled = false
					local visibility = 0
					for i = 0, 49 do
						swait()
						visibility = visibility + 0.02
						Beem.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.025, visibility),NumberSequenceKeypoint.new(0.975, visibility),NumberSequenceKeypoint.new(1, 1)})
						rotation = rotation + 5
						poste = poste - 1
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(180 + rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(-rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(180 - rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(90 + rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(90 - rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(270 + rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						sphere2(8,"Add",x.CFrame*CFrame.Angles(0,0,math.rad(270 - rotation))*CFrame.new(0,poste,0),vt(5,5,5),-0.05,-0.05,-0.05,keptcolor)
						msh.Scale = msh.Scale + vt(0,-0.5,-0.5)
						a.Transparency = a.Transparency + 0.02
					end
					wait(1)
					orb:Destroy()
					a:Destroy()
					ht:Destroy()
				end))
				game:GetService("Debris"):AddItem(orb, 10)
			end
		end))
		hum.WalkSpeed = storehumanoidWS
		attack = false
	end

	function SingularityVoid()
		attack = true
		hum.WalkSpeed = 0
		hum.JumpPower = 0
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Singularity Void!",MRCL.Color,1)
		elseif radm == 2 then
			bosschatfunc("Be one with darkness.",MRCL.Color,1)
		elseif radm == 3 then
			bosschatfunc("Don't bother me.",MRCL.Color,1)
		end
		CFuncs["Sound"].Create("rbxassetid://1208650519", char, 2.5, 1)
		local poste = 3
		local rotation = 0
		local rate = 0
		local bgui,imgc = createBGCircle(0,root,Color3.new(0,0,0))
		bgui.AlwaysOnTop = true
		imgc.ImageTransparency = 1
		imgc.Image = "rbxassetid://2076519836"
		for i = 0, 124 do
			swait()
			bgui.Size = bgui.Size + UDim2.new(2.5,0,2.5,0)
			imgc.ImageTransparency = imgc.ImageTransparency - 0.01
			imgc.Rotation = imgc.Rotation - rotation/10
			rotation = rotation + rate
			poste = poste + 0.1
			rate = rate + 0.1
			RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-25)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(25)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,-0.05)*angles(math.rad(-25),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-10),math.rad(0),math.rad(90)),.1)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-10),math.rad(0),math.rad(-90)),.1)
		end
		shakes(1,1)
		CameraEnshaking(5,12)
		local keptcolor = MRCL
		for i, v in pairs(FindNearestHead(root.CFrame.p, 125)) do
			if v:FindFirstChild('Head') then
				coroutine.resume(coroutine.create(function()
					CFuncs["Sound"].Create("rbxassetid://1042716828", v.Head, 5, 0.5)
					local vel = Instance.new("BodyPosition", v.Head)
					vel.P = 12500
					vel.D = 1000
					vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
					vel.position = v.Head.CFrame.p + vt(0,10,0)
					for i,v in pairs(v:GetChildren()) do
						if v:IsA("Part") or v:IsA("MeshPart") then
							coroutine.resume(coroutine.create(function()
								local bld = Instance.new("ParticleEmitter",v)
								bld.LightEmission = 0.75
								bld.Texture = "rbxassetid://363275192" ---284205403
								bld.Color = ColorSequence.new(keptcolor.Color)
								bld.Rate = 500
								bld.Lifetime = NumberRange.new(1)
								bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0,0)})
								bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
								bld.Speed = NumberRange.new(2,5)
								bld.VelocitySpread = 50000
								bld.Rotation = NumberRange.new(-500,500)
								bld.RotSpeed = NumberRange.new(-500,500)
							end))
						end
					end
					local A1 = Instance.new("Attachment",root)
					local A2 = Instance.new("Attachment",v.Head)
					local Beem = Instance.new("Beam",v.Head)
					Beem.Attachment0 = A1
					Beem.Attachment1 = A2
					Beem.LightEmission = 1
					Beem.FaceCamera = true
					Beem.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 0)})
					Beem.Width0 = 1
					Beem.Width1 = 1
					Beem.Texture = "rbxassetid://1134824633"
					Beem.TextureMode = "Wrap"
					Beem.TextureLength = 2
					Beem.TextureSpeed = 5
					Beem.Color = ColorSequence.new(keptcolor.Color)
					wait(5)
					coroutine.resume(coroutine.create(function()
						local ref = Instance.new("Part", char)
						ref.Anchored = true
						ref.CanCollide = false
						ref.Transparency = 1
						ref.CFrame = v.Head.CFrame
						sphere2(1,"Add",v.Head.CFrame,vt(25,25,25),-0.25,-0.25,-0.25,keptcolor)
						sphere2(2,"Add",v.Head.CFrame,vt(25,25,25),-0.5,-0.5,-0.5,keptcolor)
						sphere2(3,"Add",v.Head.CFrame,vt(25,25,25),-0.75,-0.75,-0.75,keptcolor)
						for i = 0, 9 do
							slash(math.random(10,25)/10,5,true,"Round","Add","Out",v.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.001,0.5),-1,BrickColor.new("Really black"))
						end
						v.Head.Parent:Destroy()
						CFuncs["Sound"].Create("rbxassetid://763718160", ref, 10, 1.1)
						CFuncs["Sound"].Create("rbxassetid://782353443", ref, 10, 1)
						CFuncs["Sound"].Create("rbxassetid://335657174", ref, 10, 1)
						wait(5)
						ref:Destroy()
					end))
				end))
			end
		end
		CFuncs["Sound"].Create("rbxassetid://1664711478", char, 2, 1)
		CFuncs["Sound"].Create("rbxassetid://1177785010", char, 3, 1)
		CFuncs["Sound"].Create("rbxassetid://167115397", char, 3, 1)
		CFuncs["Sound"].Create("rbxassetid://782353443", char, 3, 0.9)
		CFuncs["Sound"].Create("rbxassetid://782353443", char, 4, 0.8)
		CFuncs["Sound"].Create("rbxassetid://782353443", char, 5, 0.7)
		for i = 0, 49 do
			slash(math.random(10,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.25,0.01,0.25),math.random(150,1000)/250,BrickColor.new("Really black"))
		end
		coroutine.resume(coroutine.create(function()
			local eff = Instance.new("ParticleEmitter",root)
			eff.Texture = "rbxassetid://2273224484"
			eff.LightEmission = 1
			eff.Color = ColorSequence.new(BrickColor.new("Alder").Color)
			eff.Rate = 5000000
			eff.Lifetime = NumberRange.new(3)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,25,0),NumberSequenceKeypoint.new(0.2,8,0),NumberSequenceKeypoint.new(1,0.1,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(150,1000)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.VelocitySpread = 9000
			eff.RotSpeed = NumberRange.new(-100,100)
			wait(0.5)
			eff.Enabled = false
			wait(6)
			eff:Destroy()
		end))
		coroutine.resume(coroutine.create(function()
			local eff = Instance.new("ParticleEmitter",root)
			eff.Texture = "rbxassetid://363275192"
			eff.LightEmission = 0.95
			eff.Color = ColorSequence.new(MRCL.Color)
			eff.Rate = 10000
			eff.Lifetime = NumberRange.new(1)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.8,75,0),NumberSequenceKeypoint.new(1,80,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(100,500)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.VelocitySpread = 9000
			eff.RotSpeed = NumberRange.new(-50,50)
			wait(0.5)
			eff.Enabled = false
			wait(6)
			eff:Destroy()
		end))
		sphere2(10,"Add",root.CFrame,vt(250,250,250),5,5,5,MRCL)
		sphere2(9,"Add",root.CFrame,vt(250,250,250),5,5,5,MRCL)
		sphere2(8,"Add",root.CFrame,vt(250,250,250),5,5,5,MRCL)
		sphere2(2,"Add",root.CFrame,vt(250,250,250),0.1,0.1,0.1,MRCL)
		coroutine.resume(coroutine.create(function()
			wait(1)
			rotation = 0
			rate = 0
			for i = 0, 49 do
				swait()
				bgui.Size = bgui.Size - UDim2.new(rate/2,0,rate/2,0)
				imgc.Rotation = imgc.Rotation + rotation/20
				rotation = rotation + rate
				poste = poste + 1.5
				rate = rate + 1.5
			end
			bgui:Destroy()
		end))
		hum.WalkSpeed = storehumanoidWS
		hum.JumpPower = 50
		attack = false
	end


	function WarpedDash()
		attack = true
		hum.WalkSpeed = 0
		hum.JumpPower = 0
		local radm = math.random(1,3)
		if radm == 1 then
			bosschatfunc("Act faster.",MRCL.Color,1)
		elseif radm == 2 then
			bosschatfunc("You'll be dusted out.",MRCL.Color,1)
		elseif radm == 3 then
			bosschatfunc("Warped Dash!",MRCL.Color,1)
		end
		CFuncs["Sound"].Create("rbxassetid://1208650519", tors, 5, 1)
		local poste = 3
		local rotation = 0
		local rate = 0
		local bgui,imgc = createBGCircle(100,root,MRCL.Color)
		bgui.AlwaysOnTop = true
		imgc.ImageTransparency = 1
		imgc.Image = "rbxassetid://2076519836"
		for i = 0, 124 do
			swait()
			bgui.Size = bgui.Size - UDim2.new(0.85,0,0.85,0)
			imgc.ImageTransparency = imgc.ImageTransparency - 0.01
			imgc.Rotation = imgc.Rotation - rotation/10
			rotation = rotation + rate
			poste = poste + 0.1
			rate = rate + 0.1
			sphere2(8,"Add",root.CFrame*CFrame.new(0,-3,0),vt(poste,1,poste),0.05*poste/3,0,0.05*poste/3,MRCL)
			sphere2(8,"Add",root.CFrame*CFrame.new(math.random(-20,20),-3,math.random(-20,20)),vt(1,1,1),-0.01,0.5,-0.01,MRCL)
			sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,-3,poste)*CFrame.Angles(math.rad(40),0,0),vt(1,1,1),0.025,0.25,0.025,MRCL)
			sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(90 + rotation),0)*CFrame.new(0,-3,poste)*CFrame.Angles(math.rad(40),0,0),vt(1,1,1),0.025,0.25,0.025,MRCL)
			sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(180 + rotation),0)*CFrame.new(0,-3,poste)*CFrame.Angles(math.rad(40),0,0),vt(1,1,1),0.025,0.25,0.025,MRCL)
			sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(270 + rotation),0)*CFrame.new(0,-3,poste)*CFrame.Angles(math.rad(40),0,0),vt(1,1,1),0.025,0.25,0.025,MRCL)
			slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(poste/100,0.01,poste/100),poste/30,BrickColor.new("White"))
			RH.C0=clerp(RH.C0,cf(1,-0.35,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-20),math.rad(30)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.5)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.75)*angles(math.rad(30),math.rad(0),math.rad(20)),.5)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(-20)),.5)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(40),math.rad(-8),math.rad(-10)),.5)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-30)),.5)
		end
		shakes(1.5,1)
		bgui:Destroy()
		CameraEnshaking(3,7)
		local loc = Instance.new("Part", char)
		loc.BrickColor = MRCL
		loc.CanCollide = false
		loc.FormFactor = 3
		loc.Name = "Ring"
		loc.Material = "Neon"
		loc.Size = Vector3.new(1, 1, 1)
		loc.Transparency = 1
		loc.TopSurface = 0
		loc.BottomSurface = 0
		loc.Anchored = true
		loc.CFrame = root.CFrame + root.CFrame.lookVector*100
		CFuncs["Sound"].Create("rbxassetid://782353443", loc, 5, 1)
		CFuncs["Sound"].Create("rbxassetid://1177785010", loc, 6, 1)
		MagniDamage(loc, 95, 500,6000, 0, "Normal")
		sphere2(10,"Add",loc.CFrame,vt(5,5,5),-0.05,-0.05,5,MRCL)
		sphere2(8,"Add",loc.CFrame,vt(5,5,5),2.5,2.5,2.5,MRCL)
		sphere2(4,"Add",loc.CFrame,vt(5,5,5),2.5,2.5,2.5,MRCL)
		sphere2(2,"Add",loc.CFrame,vt(5,5,5),2.5,2.5,2.5,MRCL)
		coroutine.resume(coroutine.create(function()
			for i = 0, 49 do
				local disr = CreateParta(char,1,1,"Neon",MRCL)
				disr.CFrame = loc.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				local at1 = Instance.new("Attachment",disr)
				at1.Position = vt(-5,0,0)
				local at2 = Instance.new("Attachment",disr)
				at2.Position = vt(5,0,0)
				local trl = Instance.new('Trail',disr)
				trl.Attachment0 = at1
				trl.FaceCamera = true
				trl.Attachment1 = at2
				trl.Texture = "rbxassetid://2325530138"
				trl.LightEmission = 1
				trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
				trl.Color = ColorSequence.new(MRCL.Color)
				trl.Lifetime = 0.5
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = disr.CFrame.lookVector*math.random(50,500)
				bv.Parent = disr
				local val = 0
				coroutine.resume(coroutine.create(function()
					swait(math.random(30,60))
					for i = 0, 9 do
						swait()
						val = val + 0.1
						trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, val),NumberSequenceKeypoint.new(1, 1)})
					end
					game:GetService("Debris"):AddItem(disr, 3)
				end))
			end
			local eff = Instance.new("ParticleEmitter",loc)
			eff.Texture = "rbxassetid://363275192"
			eff.LightEmission = 0.95
			eff.Color = ColorSequence.new(MRCL.Color)
			eff.Rate = 10000
			eff.Lifetime = NumberRange.new(1)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.8,75,0),NumberSequenceKeypoint.new(1,80,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(100,500)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.VelocitySpread = 9000
			eff.RotSpeed = NumberRange.new(-50,50)
			wait(0.5)
			eff.Enabled = false
		end))
		for i = 0, 29 do
			slash(math.random(10,50)/10,5,true,"Round","Add","Out",loc.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,500)/250,BrickColor.new("White"))
		end
		for i = 0, 49 do
			sphere2(math.random(100,300)/100,"Add",loc.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,5),-0.01,-0.01,5,MRCL)
		end
		for i = 0, 9 do
			sphere2(3,"Add",loc.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),0),vt(1,1,5),-0.01,-0.01,5,MRCL)
		end
		game:GetService("Debris"):AddItem(loc, 5)
		root.CFrame = root.CFrame + root.CFrame.lookVector*200
		hum.WalkSpeed = storehumanoidWS
		hum.JumpPower = 50
		attack = false
	end
	---- Universal's Abilities
	function annihilation()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["Sound"].Create("rbxassetid://247615928", char, 1.5, 1)
		for i = 0, 9, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(20)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(-20)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.2 + 0.03 * math.cos(sine / 20),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(20),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(35),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.05,0.5 + 0.075 * math.cos(sine / 18),-0.5)*angles(math.rad(140 - 3 * math.cos(sine / 32)),math.rad(0 + 8 * math.cos(sine / 23)),math.rad(-42 + 3 * math.cos(sine / 15))),.1)
			LW.C0=clerp(LW.C0,cf(-1.05,0.5 + 0.075 * math.cos(sine / 18),-0.5)*angles(math.rad(130 - 3 * math.cos(sine / 32)),math.rad(0 - 8 * math.cos(sine / 23)),math.rad(42 - 3 * math.cos(sine / 15))),.1)
		end
		for i = 0, 3, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(0)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(0)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01 + 0.03 * math.cos(sine / 20),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(1.05,0.65 + 0.075 * math.cos(sine / 18),-0.5)*angles(math.rad(180 - 3 * math.cos(sine / 32)),math.rad(0 + 8 * math.cos(sine / 23)),math.rad(-42 + 3 * math.cos(sine / 15))),.1)
			LW.C0=clerp(LW.C0,cf(-1.05,0.65 + 0.075 * math.cos(sine / 18),-0.5)*angles(math.rad(170 - 3 * math.cos(sine / 32)),math.rad(0 - 8 * math.cos(sine / 23)),math.rad(42 - 3 * math.cos(sine / 15))),.1)
		end
		shakes(1.5,3)
	--[[local e = script.redness:Clone()
	e.Parent = game:GetService("Lighting")]]--
		CFuncs["Sound"].Create("rbxassetid://763717897", char, 3, 0.5)
		CFuncs["Sound"].Create("rbxassetid://239000203", char, 3, 0.9)
		CFuncs["Sound"].Create("rbxassetid://1413550336", char, 3, 1.1)
		CFuncs["Sound"].Create("rbxassetid://1192402877", char, 2,0.75)
		CFuncs["Sound"].Create("rbxassetid://1664711478", char, 2,1)
		CFuncs["Sound"].Create("rbxassetid://763718160", char, 2, 0.75)
		for i = 0, 21, 0.1 do
			swait()
			coroutine.resume(coroutine.create(function()
				if enableddam == true then
					for i, v in pairs(FindNearestHead(root.CFrame.p, 1000000000)) do
						if v:FindFirstChild('Head') then
							dmg(v)
						end
					end
				end
			end))
			slash(math.random(30,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(500,2500)/250,BrickColor.new("Really red"))
			slash(math.random(30,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(500,2500)/250,BrickColor.new("Really black"))
			sphere2(8,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),1,250,1,MRCL)
			sphere2(8,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),1,250,1,MRCL2)
			sphere2(6,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),5,5,5,MRCL)
			sphere2(7,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),5.1,5.1,5.1,MRCL2)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(-30)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(30)),.5)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.3 + 0.03 * math.cos(sine / 20),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(-30),math.rad(0),math.rad(0)),.5)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-32),math.rad(0),math.rad(0 + 35 * math.cos(sine / 0.2))),.5)
			RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.075 * math.cos(sine / 18),0)*angles(math.rad(-40 - 3 * math.cos(sine / 32)),math.rad(0 + 8 * math.cos(sine / 23)),math.rad(50 + 3 * math.cos(sine / 15))),.5)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.075 * math.cos(sine / 18),0)*angles(math.rad(-40 - 3 * math.cos(sine / 32)),math.rad(0 - 8 * math.cos(sine / 23)),math.rad(-50 - 3 * math.cos(sine / 15))),.5)
		end
		--e:Destroy()
		attack = false
		hum.WalkSpeed = storehumanoidWS
	end

	local etypemodes = "U"
	local attacktype = 1

	local OVMID = 1702473314
	local OVMPIT = 1.0125
	local OVMVOL = 1

	Humanoid.Animator.Parent = nil

	mouse = Player:GetMouse()

	mouse.KeyDown:Connect(function(k)
		if etypemodes == "U" then
			if k == "q" and attack == false and ModeOfGlitch ~= 1 then
				ModeOfGlitch = 1
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://2128137966",0,1.01,1.25)
				MRCL = BrickColor.new("Toothpaste")
				MRCL2 = BrickColor.new("Mint")
				RecolorTextAndRename("EXQUISITE",MRCL.Color,MRCL2.Color,"Antique","Camellia - INSECTICIDE")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "e" and attack == false and ModeOfGlitch ~= 2 then
				ModeOfGlitch = 2
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://1002071384",0,1.01,1.25)
				MRCL = BrickColor.new("Alder")
				MRCL2 = BrickColor.new("Pastel light blue")
				RecolorTextAndRename("ABERRIATION",MRCL.Color,MRCL2.Color,"Bodoni","Camellia - Enantiomorphs")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "r" and attack == false and ModeOfGlitch ~= 3 then
				ModeOfGlitch = 3
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://1751171913",0,1.01,1.25)
				MRCL = BrickColor.new("Really red")
				MRCL2 = BrickColor.new("Dark indigo")
				RecolorTextAndRename("DYSMORPHIC",MRCL.Color,MRCL2.Color,"Arcade","Camellia - Distorted Space")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "t" and attack == false and ModeOfGlitch ~= 4 then
				ModeOfGlitch = 4
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://1119709168",0,1.01,1.25)
				MRCL = BrickColor.new("Really black")
				MRCL2 = BrickColor.new("Maroon")
				RecolorTextAndRename("RECALCITRANT",MRCL.Color,MRCL2.Color,"Antique","Camellia - Beserkerz Warfare 345")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "y" and attack == false and ModeOfGlitch ~= 5 then
				ModeOfGlitch = 5
				storehumanoidWS = 175
				hum.WalkSpeed = 175
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://2127419486",0,1.01,1.25)
				MRCL = BrickColor.new("Bright yellow")
				MRCL2 = BrickColor.new("Cool yellow")
				RecolorTextAndRename("SERAPHIC",MRCL.Color,MRCL2.Color,"SciFi","Camellia - Completeness Under Incompleteness")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "u" and attack == false and ModeOfGlitch ~= 6 then
				ModeOfGlitch = 6
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://2127505351",0,1.01,1.25)
				MRCL = BrickColor.new("Lime green")
				MRCL2 = BrickColor.new("Deep orange")
				RecolorTextAndRename("ALACRITY",MRCL.Color,MRCL2.Color,"Bodoni","Camellia Vs. Expander - AZISAI")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "f" and attack == false and ModeOfGlitch ~= 7 then
				ModeOfGlitch = 7
				storehumanoidWS = 180
				hum.WalkSpeed = 180
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://1861780345",0,1.015,1.45)
				MRCL = BrickColor.new("White")
				local rcl = math.random(1,5)
				if rcl == 1 then
					MRCL2 = BrickColor.new("Pink")
				elseif rcl == 2 then
					MRCL2 = BrickColor.new("Medium blue")
				elseif rcl == 3 then
					MRCL2 = BrickColor.new("Alder")
				elseif rcl == 4 then
					MRCL2 = BrickColor.new("Mint")
				elseif rcl == 5 then
					MRCL2 = BrickColor.new("Persimmon")
				end
				RecolorTextAndRename("SCINTILLANT",MRCL.Color,MRCL2.Color,"SciFi","Camellia - crystallized")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "g" and attack == false and ModeOfGlitch ~= 8 then
				ModeOfGlitch = 8
				storehumanoidWS = 200
				hum.WalkSpeed = 200
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://2482043741",0,1,1.25)
				MRCL = BrickColor.new("Really black")
				MRCL2 = BrickColor.new("Dark indigo")
				RecolorTextAndRename("DEMENTIA",MRCL.Color,MRCL2.Color,"Antique","Nhelv - Silentroom  ")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
		end

		if etypemodes == "S" then
			if k == "q" and attack == false and ModeOfGlitch ~= 12 then
				ModeOfGlitch = 12
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://614032233",48.6,1,1.25)
				MRCL = BrickColor.new("Really red")
				MRCL2 = BrickColor.new("Really black")
				RecolorTextAndRename("MAYHEM",MRCL2.Color,MRCL.Color,"Antique","D-MODE-D - Shriek")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "e" and attack == false and ModeOfGlitch ~= 22 then
				ModeOfGlitch = 22
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://2482117221",0,1.01,1.25)
				MRCL = BrickColor.new("Toothpaste")
				MRCL2 = BrickColor.new("White")
				RecolorTextAndRename("PURITY",MRCL.Color,MRCL2.Color,"Code","EBIMAYO - GOODTEK")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "r" and attack == false and ModeOfGlitch ~= 32 then
				ModeOfGlitch = 32
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://1283869370",58.15,0.98,1.25)
				MRCL = BrickColor.new("Royal purple")
				MRCL2 = BrickColor.new("Really black")
				RecolorTextAndRename("CORRUPTION",MRCL2.Color,MRCL.Color,"Antique","Night Falls - Evening Star")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "t" and attack == false and ModeOfGlitch ~= 42 then
				ModeOfGlitch = 42
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = true
				newTheme("rbxassetid://1369263130",0,1.01,1.25)
				MRCL = BrickColor.new("Really black")
				MRCL2 = BrickColor.new("Black")
				RecolorTextAndRename("CHAOS",MRCL.Color,MRCL2.Color,"Arcade","DM DOKURO - Return to Slime")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "y" and attack == false and ModeOfGlitch ~= 52 then
				ModeOfGlitch = 52
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://661079869",0,1.02,1.25)
				MRCL = BrickColor.new("White")
				MRCL2 = BrickColor.new("Bright yellow")
				RecolorTextAndRename("DIVINITY",MRCL2.Color,MRCL.Color,"SciFi","Under Night In - Birth OST: Blood Drain - Again")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "u" and attack == false and ModeOfGlitch ~= 62 then
				ModeOfGlitch = 62
				storehumanoidWS = 100
				hum.WalkSpeed = 100
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://1347011178",0,1.01,1.25)
				MRCL = BrickColor.new("White")
				MRCL2 = BrickColor.new("Really black")
				RecolorTextAndRename("EQUINOX",MRCL2.Color,MRCL.Color,"Fantasy","xi - Vanitas")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "f" and attack == false and ModeOfGlitch ~= 72 then
				ModeOfGlitch = 72
				storehumanoidWS = 180
				hum.WalkSpeed = 180
				rainbowmode = true
				chaosmode = false
				newTheme("rbxassetid://1747430851",0,1.01,1.25)
				MRCL = BrickColor.new("White")
				MRCL2 = BrickColor.new("White")
				RecolorTextAndRename("RAINBOW",MRCL2.Color,MRCL.Color,"Cartoon","Camellia - Speedrun")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "g" and attack == false and ModeOfGlitch ~= 82 then
				ModeOfGlitch = 82
				storehumanoidWS = 140
				hum.WalkSpeed = 140
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://1495032271",0,1.01,1.25)
				MRCL = BrickColor.new("Alder")
				MRCL2 = BrickColor.new("White")
				RecolorTextAndRename("DESTINY",MRCL2.Color,MRCL.Color,"Code","DM DOKURO - Servants of The Scourge")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "h" and attack == false and ModeOfGlitch ~= 92 then
				ModeOfGlitch = 92
				storehumanoidWS = 150
				hum.WalkSpeed = 150
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://1296208488",0,1.01,1.25)
				MRCL = BrickColor.new("Br. yellowish green")
				MRCL2 = BrickColor.new("Lime green")
				RecolorTextAndRename("INFESTATION",MRCL2.Color,MRCL.Color,"Bodoni","DM DOKURO - INFESTATION")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
		end
		if etypemodes == "SM" then
			if k == "q" and attack == false and ModeOfGlitch ~= 13 then
				ModeOfGlitch = 13
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://1812212957",0,1.01,1.5)
				MRCL = BrickColor.new("Lime green")
				MRCL2 = BrickColor.new("Bright green")
				RecolorTextAndRename("NUCLEAR",MRCL2.Color,MRCL.Color,"Antique","POKEMON Uranium - Nuclear Plant Zeta")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "e" and attack == false and ModeOfGlitch ~= 23 then
				ModeOfGlitch = 23
				storehumanoidWS = 180
				hum.WalkSpeed = 180
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://1359036559",0,1.01,1.5)
				MRCL = BrickColor.new("Lilac")
				MRCL2 = BrickColor.new("Alder")
				RecolorTextAndRename("CALAMITY",MRCL2.Color,MRCL.Color,"Antique","DM DOKURO - Scourge of the Universe")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
		end
		if etypemodes == "SN" then
			if k == "q" and attack == false and ModeOfGlitch ~= 14 then
				ModeOfGlitch = 14
				storehumanoidWS = 260
				hum.WalkSpeed = 260
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://899090278",0,1.005,1.75)
				MRCL = BrickColor.new("White")
				MRCL2 = BrickColor.new("Really red")
				RecolorTextAndRename("UNSTABLE",MRCL.Color,MRCL2.Color,"Arcade","LV.4 - angel dust")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "e" and attack == false and ModeOfGlitch ~= 24 then
				ModeOfGlitch = 24
				storehumanoidWS = 275
				hum.WalkSpeed = 275
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://582020393",0,1.005,1.25)
				MRCL = BrickColor.new("Hot pink")
				MRCL2 = BrickColor.new("Crimson")
				RecolorTextAndRename("NANODEATH",MRCL.Color,MRCL2.Color,"Arcade","Yooh - NANODEATH!!!")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "r" and attack == false and ModeOfGlitch ~= 34 then
				ModeOfGlitch = 34
				storehumanoidWS = 225
				hum.WalkSpeed = 225
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://2483763576",0,1.01,1.25)
				MRCL = BrickColor.new("Baby blue")
				MRCL2 = BrickColor.new("Pink")
				RecolorTextAndRename("SHD",MRCL.Color,MRCL2.Color,"Arcade","Hommarju (as Dollscythe) - Flashes (Extended Mix)")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "t" and attack == false and ModeOfGlitch ~= 44 then
				ModeOfGlitch = 44
				storehumanoidWS = 300
				hum.WalkSpeed = 300
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://643309199",0,1.01,1.5)
				MRCL = BrickColor.new("Bright bluish green")
				MRCL2 = BrickColor.new("Really black")
				RecolorTextAndRename("OMEGA",MRCL2.Color,MRCL.Color,"SciFi","WAiKURO - AMAZING MIGHTYYYY!!!!")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "y" and attack == false and ModeOfGlitch ~= 54 then
				ModeOfGlitch = 54
				storehumanoidWS = 500
				hum.WalkSpeed = 500
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://719008519",0,1.02,1.25)
				MRCL = BrickColor.new("Navy blue")
				MRCL2 = BrickColor.new("Really black")
				RecolorTextAndRename("CRAZED",MRCL2.Color,MRCL.Color,"Code","??? - ???")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "u" and attack == false and ModeOfGlitch ~= 64 then
				ModeOfGlitch = 64
				storehumanoidWS = 250
				hum.WalkSpeed = 250
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://1505487022",0,1.01,1.5)
				MRCL = BrickColor.new("Toothpaste")
				MRCL2 = BrickColor.new("Deep orange")
				RecolorTextAndRename("FALLENX",MRCL2.Color,MRCL.Color,"Antique","ENDYMION- Fallen Shepherd ft. RabbiTon Strings")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
		end
		if etypemodes == "G" then
			if k == "q" and attack == false and ModeOfGlitch ~= 15 then
				ModeOfGlitch = 15
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				hum.JumpPower = 50
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://603567552",0,1.02,1.25)
				MRCL = BrickColor.new("Medium stone grey")
				MRCL2 = BrickColor.new("White")
				RecolorTextAndRename("ENLIGHTENED",MRCL2.Color,MRCL.Color,"Code","Yooh - Dignity")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "e" and attack == false and ModeOfGlitch ~= 25 then
				ModeOfGlitch = 25
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://2027652726",0,1.01,1.25)
				MRCL = BrickColor.new("Bright violet")
				MRCL2 = BrickColor.new("Really black")
				RecolorTextAndRename("AZURE",MRCL2.Color,MRCL.Color,"Code","xi - Singularity")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "r" and attack == false and ModeOfGlitch ~= 35 then
				ModeOfGlitch = 35
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://2041343402",0,1.01,1.25)
				MRCL = BrickColor.new("Lime green")
				MRCL2 = BrickColor.new("Really black")
				RecolorTextAndRename("BINARY",MRCL2.Color,MRCL.Color,"SciFi","xi - Dusk to Dawn")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "t" and attack == false and ModeOfGlitch ~= 45 then
				ModeOfGlitch = 45
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://2022787645",0,1.02,1.25)
				MRCL = BrickColor.new("Navy blue")
				MRCL2 = BrickColor.new("Bright yellow")
				RecolorTextAndRename("LUNA",MRCL.Color,MRCL2.Color,"SourceSansBold","LeaF - Doppelganger")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "y" and attack == false and ModeOfGlitch ~= 55 then
				ModeOfGlitch = 55
				storehumanoidWS = 16
				hum.WalkSpeed = 16
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://318890513",0,1.01,1.25)
				MRCL = BrickColor.new("Deep orange")
				MRCL2 = BrickColor.new("New Yeller")
				RecolorTextAndRename("BLAZE",MRCL2.Color,MRCL.Color,"Fantasy","LeaF - MEPHISTO")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "u" and attack == false and ModeOfGlitch ~= 65 then
				ModeOfGlitch = 65
				storehumanoidWS = 100
				hum.WalkSpeed = 100
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://604910909",0,1.02,1.25)
				MRCL = BrickColor.new("Pastel light blue")
				MRCL2 = BrickColor.new("Dark indigo")
				RecolorTextAndRename("GALACTIC",MRCL.Color,MRCL2.Color,"Fantasy","LeaF - Arianrhod")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "f" and attack == false and ModeOfGlitch ~= 75 then
				ModeOfGlitch = 75
				storehumanoidWS = 175
				hum.WalkSpeed = 175
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://2011847746",0,1.01,1.25)
				MRCL = BrickColor.new("Cyan")
				MRCL2 = BrickColor.new("Toothpaste")
				RecolorTextAndRename("HYPERSPEED",MRCL.Color,MRCL2.Color,"Arcade","Yooh - Ice Angel")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "g" and attack == false and ModeOfGlitch ~= 85 then
				ModeOfGlitch = 85
				storehumanoidWS = 100
				hum.WalkSpeed = 100
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://603566564",0,1.01,1.65)
				MRCL = BrickColor.new("Really red")
				MRCL2 = BrickColor.new("Bright red")
				RecolorTextAndRename("CHAOTIC",MRCL.Color,MRCL2.Color,"Antique","Yooh - Dynasty")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
			if k == "h" and attack == false and ModeOfGlitch ~= 95 then
				ModeOfGlitch = 95
				storehumanoidWS = 135
				hum.WalkSpeed = 135
				rainbowmode = false
				chaosmode = false
				newTheme("rbxassetid://"..OVMID,0,OVMPIT,OVMVOL)
				MRCL = BrickColor.new("Medium stone grey")
				MRCL2 = BrickColor.new("Black")
				RecolorTextAndRename("VIS",MRCL.Color,MRCL2.Color,"Arcade","???")
				RecolorThing(MRCL.Color,MRCL2.Color,MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			end
		end
		------- Up: Modes
		------- Down: Keys
		if k == "l" and mutedtog == false then
			mutedtog = true
			kan.Volume = 0
		elseif k == "l" and mutedtog == true then
			mutedtog = false
			kan.Volume = 1.25
		end
		if k == "p" and toggleTag == false then
			toggleTag = true

		elseif k == "p" and toggleTag == true then
			toggleTag = false

		end
		if k == "z" and attack == false and ModeOfGlitch == 5 then
			--divbeam()
		elseif k == "z" and attack == false and ModeOfGlitch == 12 then
			ExtinctiveHeartbreak()
		elseif k == "z" and attack == false and ModeOfGlitch == 22 then
			HeavenlyDisk()
		elseif k == "z" and attack == false and ModeOfGlitch == 32 then
			CorruptionEvent()
		elseif k == "z" and attack == false and ModeOfGlitch == 42 then
			RapidBurst()
		elseif k == "z" and attack == false and ModeOfGlitch == 52 then
			--DivineLights()
		elseif k == "z" and attack == false and ModeOfGlitch == 62 then
			EquinoxOrbs()
		elseif k == "z" and attack == false and ModeOfGlitch == 72 then
			roldbeam()
		elseif k == "z" and attack == false and ModeOfGlitch == 23 then
			CalMets()
		elseif k == "z" and attack == false and ModeOfGlitch == 34 then
			SHDTwist()
		elseif k == "z" and attack == false and ModeOfGlitch == 64 then
			FallenOrbs()
		elseif k == "z" and attack == false and ModeOfGlitch == 15 then
			Beams()
		elseif k == "z" and attack == false and ModeOfGlitch == 25 then
			smiter()
		elseif k == "z" and attack == false and ModeOfGlitch == 35 then
			BinaryE()
		elseif k == "z" and attack == false and ModeOfGlitch == 55 then
			Crossfire()
		elseif k == "z" and attack == false and ModeOfGlitch == 65 then
			GalacticalBeams()
		elseif k == "z" and attack == false and ModeOfGlitch == 75 then
			WarpedDash()
		end
		if k == "x" and attack == false and ModeOfGlitch == 12 then
			EndGROUND()
		elseif k == "x" and attack == false and ModeOfGlitch == 42 then
			EternalChaosOrb()
		elseif k == "x" and attack == false and ModeOfGlitch == 23 then
			ExtCalbeam()
		elseif k == "x" and attack == false and ModeOfGlitch == 35 then
			BinaryBLINK()
		end
		if k == "v" and attack == false and ModeOfGlitch == 4 then
			annihilation()
		elseif k == "v" and attack == false and ModeOfGlitch == 64 then
			FallenDEMISE()
		elseif k == "v" and attack == false and ModeOfGlitch == 25 then
			SingularityVoid()
		elseif k == "v" and attack == false and ModeOfGlitch == 85 then
			BeamOfDeath()
		end
		if k == "n" and etypemodes == "G" then
			etypemodes = "U"
			nedm.Text = "MODETYPES: UNIVERSAL"
		elseif k == "n" and etypemodes == "U" then
			etypemodes = "S"
			nedm.Text = "MODETYPES: STAR"
		elseif k == "n" and etypemodes == "S" then
			etypemodes = "SM"
			nedm.Text = "MODETYPES: STAR MAJORS"
		elseif k == "n" and etypemodes == "SM" then
			etypemodes = "SN"
			nedm.Text = "MODETYPES: STAR NONCANONS"
		elseif k == "n" and etypemodes == "SN" then
			etypemodes = "G"
			nedm.Text = "MODETYPES: GALAXY"
		end
		if k == "b" and enableddam == false then
			enableddam = true
			nedx.Text = "Damage: Enabled"
		elseif k == "b" and enableddam == true then
			enableddam = false
			nedx.Text = "Damage: Disabled"
		end
	end)



	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			if ModeOfGlitch ~= 4 and ModeOfGlitch ~= 8 and ModeOfGlitch ~= 14 and ModeOfGlitch ~= 24 and ModeOfGlitch ~= 34 and ModeOfGlitch ~= 44 and ModeOfGlitch ~= 54 and ModeOfGlitch ~= 64 then
				sphereMK(10,math.random(10,25)/45,"Add",root.CFrame*CFrame.new(math.random(-20,20),-5,math.random(-20,20))*CFrame.Angles(math.rad(90 + math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),0.25,0.25,8,0,MRCL2,0)
				sphereMK(10,math.random(10,25)/45,"Add",root.CFrame*CFrame.new(math.random(-20,20),-5,math.random(-20,20))*CFrame.Angles(math.rad(90 + math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),0.25,0.25,8,0,MRCL,0)
			elseif ModeOfGlitch == 4 or ModeOfGlitch == 8 or ModeOfGlitch == 14 or ModeOfGlitch == 24 or ModeOfGlitch == 34 or ModeOfGlitch == 44 or ModeOfGlitch == 54 or ModeOfGlitch == 64 then
				sphereMK(10,math.random(10,50)/45,"Add",root.CFrame*CFrame.new(math.random(-80,80),-5,math.random(-80,80))*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),0.75,0.75,15,0,MRCL2,0)
				sphereMK(10,math.random(10,50)/45,"Add",root.CFrame*CFrame.new(math.random(-80,80),-5,math.random(-80,80))*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),0.75,0.75,15,0,MRCL,0)
			end
		end
	end))
	plr.Chatted:connect(function(message)
		if ModeOfGlitch == 95 then
			if message:sub(1,5) == "play/" then
				OVMID = message:sub(6)
				newThemeCust("rbxassetid://"..OVMID,0,OVMPIT,OVMVOL)
			elseif message:sub(1,6) == "pitch/" then
				OVMPIT = message:sub(7)
				newTheme("rbxassetid://"..OVMID,0,OVMPIT,OVMVOL)
			elseif message:sub(1,4) == "vol/" then
				OVMVOL = message:sub(5)
				newTheme("rbxassetid://"..OVMID,0,OVMPIT,OVMVOL)
			elseif message:sub(1,7) == "skipto/" then
				chatfunc("Skipped to "..message:sub(8).." out of "..math.floor(kan.TimeLength).." seconds.",MRCL.Color,MRCL2.Color,"Inverted","Arcade",1)
				newThemeCust("rbxassetid://"..OVMID,message:sub(8),OVMPIT,OVMVOL)
			elseif message:sub(1,9) == "telltime/" then
				chatfunc("Current time pos: "..math.floor(kan.TimePosition).." out of "..math.floor(kan.TimeLength).." seconds.",MRCL.Color,MRCL2.Color,"Inverted","Arcade",1)
			end
		end
	end)
	Humanoid.Name = "Humanoid"
	Humanoid.MaxHealth = math.huge
	Humanoid.Health = math.huge
	Instance.new("ForceField",char).Visible = false

--[[local bguis = Instance.new("BillboardGui",tors)
bguis.Size = UDim2.new(25, 0, 25, 0)
local imgca = Instance.new("ImageLabel",bguis)
imgca.BackgroundTransparency = 1
imgca.ImageTransparency = 1
imgca.Size = UDim2.new(1,0,1,0)
imgca.Image = "rbxassetid://2344830904" --997291547,521073910,2312119891,2344830904
imgca.ImageColor3 = Color3.new(0,0,0)]]--
	local rval = 0.1
	local TimeValue = kan.TimePosition
	idleanim=.4
	while true do
		if kan.Parent ~= char then
			kan = Instance.new("Sound",char)
			kan.PlaybackSpeed = currentPitch
			kan.Pitch = currentPitch
			kan.SoundId = currentThemePlaying
			kan.Looped = true
			kan.Name = "wrecked"
			kan.TimePosition = TimeValue
			kan:Resume()
		end
		if mutedtog == false then
			kan.Volume = currentVol
		elseif mutedtog == true then
			kan.Volume = 0
		end
		if rainbowmode == true then
			RecolorTextAndRename("RAINBOW",Color3.fromRGB(r,g,b),MRCL.Color,"Cartoon","Camellia - Speedrun")
			rtsc(MRCL.Color,Color3.fromRGB(r,g,b),MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
		end
		if chaosmode == true then
			RecolorTextAndRename("CHAOS",MRCL.Color,Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)),"Arcade","DM DOKURO - Return to Slime")
			rtsc(MRCL.Color,Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)),MRCL,MRCL,MRCL,1,MRCL,1,MRCL,false,false)
			modet.Position = UDim2.new(0,math.random(-1,1),0,math.random(-1,1))
			modet.Rotation = -2 * math.cos(sine / 1) + math.random(-3,3)
		end
		kan.PlaybackSpeed = currentPitch
		kan.Pitch = currentPitch
		kan.SoundId = currentThemePlaying
		kan.Looped = true
		kan.Parent = char
		kan:Resume()

		techc.Rotation = techc.Rotation + 1
		circl.Rotation = circl.Rotation - kan.PlaybackLoudness/75 - 1
		circl2.Rotation = circl2.Rotation + kan.PlaybackLoudness/50 + 1
		imgl2.Rotation = imgl2.Rotation - kan.PlaybackLoudness/50 + 1
		techc2.Rotation = techc2.Rotation + kan.PlaybackLoudness/25 - 1
		ned.Rotation = 0 - 2 * math.cos(sine / 24)
		nedx.Rotation = 5 - 2 * math.cos(sine / 50)
		nedm.Rotation = 7 - 3 * math.cos(sine / 30)
		sngy.Position = UDim2.new(0.325,0 + 5 * math.cos(sine / 36),0.8 - 0.01 * math.cos(sine / 20),0 - 2 * math.cos(sine / 50))
		sngy.Rotation = 0 + 1 * math.cos(sine / 40)
		fr.Position = UDim2.new(0, 0, 0.925 - 0.01 * math.cos(sine / 35), 0)
		fr2.Position = UDim2.new(0, 0, 0.85 + 0.01 * math.cos(sine / 36), 0)
		fr.Rotation = 0 - 1 * math.cos(sine / 25)
		fr2.Rotation = 0 + 1 * math.cos(sine / 22)
		midr.Rotation = rval
		midr2.Rotation = -rval
		ned.Position = UDim2.new(0.7,0 - 10 * math.cos(sine / 32),0.8,0 - 10 * math.cos(sine / 45))
		CameraManager()
		swait()
		if ModeOfGlitch ~= 4 and ModeOfGlitch ~= 8 and ModeOfGlitch ~= 42 and ModeOfGlitch ~= 14 and ModeOfGlitch ~= 24 and ModeOfGlitch ~= 34 and ModeOfGlitch ~= 44 and ModeOfGlitch ~= 54 and ModeOfGlitch ~= 64 and ModeOfGlitch ~= 75 then
			rval = rval + 1
		elseif ModeOfGlitch == 4 or ModeOfGlitch == 8 or ModeOfGlitch == 14 or ModeOfGlitch == 24 or ModeOfGlitch == 34 or ModeOfGlitch == 44 or ModeOfGlitch == 54 or ModeOfGlitch == 64 or ModeOfGlitch == 75 then
			rval = rval + 5
		elseif ModeOfGlitch == 42 then
			rval = rval + math.random(-15,15)
		end
		if rval == 360 or rval > 360 then
			rval = 0
		end
		if Anim ~= "Run" then
			handlexweld.C0=clerp(handlexweld.C0,cf(0 + 0.35 * math.cos(sine / 63),0 + 0.35 * math.cos(sine / 70),0 + 0.05 * math.cos(sine / 57))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		else
			if ModeOfGlitch == 5 or ModeOfGlitch == 7 or ModeOfGlitch == 8 or ModeOfGlitch == 62 or ModeOfGlitch == 82 or ModeOfGlitch == 23 or ModeOfGlitch == 14 or ModeOfGlitch == 24 or ModeOfGlitch == 34 or ModeOfGlitch == 44 or ModeOfGlitch == 54 or ModeOfGlitch == 64 or ModeOfGlitch == 65 or ModeOfGlitch == 85 then
				handlexweld.C0=clerp(handlexweld.C0,cf(0 + 0.35 * math.cos(sine / 63),-3 + 0.35 * math.cos(sine / 70),0 + 0.05 * math.cos(sine / 57))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			end
		end
		rotweld.C0=clerp(rotweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(rval)),.3)
		if ModeOfGlitch ~= 5 and ModeOfGlitch ~= 7 and ModeOfGlitch ~= 62 and ModeOfGlitch ~= 82 then
			lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(90 + rval)),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-147.5 + rval)),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-32.5 + rval)),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(-90 - rval)),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(147.5 - rval)),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(32.5 - rval)),.3)
		elseif ModeOfGlitch == 5 or ModeOfGlitch == 7 or ModeOfGlitch == 62 or ModeOfGlitch == 82 then
			lwing1weld.C1=clerp(lwing1weld.C1,cf(2.25,0,0)*angles(math.rad(10 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(0 + 3 * math.cos(sine / 20))),.3)
			lwing2weld.C1=clerp(lwing2weld.C1,cf(-4.5,0,0)*angles(math.rad(10 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 6 * math.cos(sine / 20))),.3)
			lwing3weld.C1=clerp(lwing3weld.C1,cf(6.75,0,0)*angles(math.rad(10 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(0 + 9 * math.cos(sine / 20))),.3)
			rwing1weld.C1=clerp(rwing1weld.C1,cf(-2.25,0,0)*angles(math.rad(10 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 3 * math.cos(sine / 20))),.3)
			rwing2weld.C1=clerp(rwing2weld.C1,cf(4.5,0,0)*angles(math.rad(10 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(0 + 6 * math.cos(sine / 20))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(-6.75,0,0)*angles(math.rad(10 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 9 * math.cos(sine / 20))),.3)
		end
		sine = sine + change
		local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
		local velderp=RootPart.Velocity.y
		hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
		coroutine.resume(coroutine.create(function()
			if ModeOfGlitch == 13 then
				if hitfloor ~= nil then
					--sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,0.5,1),0.1,0.01,0.1,BrickColor.new("Lime green"),Color3.new(0,1,0))
				end
			end
			if ModeOfGlitch == 5 or ModeOfGlitch == 7 or ModeOfGlitch == 8 or ModeOfGlitch == 62 or ModeOfGlitch == 82 or ModeOfGlitch == 23 or ModeOfGlitch == 14 or ModeOfGlitch == 24 or ModeOfGlitch == 34 or ModeOfGlitch == 44 or ModeOfGlitch == 54 or ModeOfGlitch == 64 or ModeOfGlitch == 65 or ModeOfGlitch == 85 then
				if hitfloor ~= nil then
					effar.Enabled = true
					effar.Color = ColorSequence.new(MRCL.Color)
					--sphere2(8,"Add",root.CFrame*CFrame.new(0,-3,0),vt(0,1,0),0.3,0.01,0.3,MRCL2)
					--slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,100)/250,MRCL)
					--slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,100)/250,BrickColor.new("White"))
				elseif hitfloor == nil then
					effar.Enabled = false
				end
			elseif ModeOfGlitch ~= 5 or ModeOfGlitch ~= 7 or ModeOfGlitch ~= 8 or ModeOfGlitch ~= 62 or ModeOfGlitch ~= 82 or ModeOfGlitch ~= 23 or ModeOfGlitch ~= 14 or ModeOfGlitch ~= 24 or ModeOfGlitch ~= 34 or ModeOfGlitch ~= 44 or ModeOfGlitch ~= 54 or ModeOfGlitch ~= 64 or ModeOfGlitch ~= 65 or ModeOfGlitch ~= 85 then
				effar.Enabled = false
			end
		end))
		if equipped==true or equipped==false then
			if attack==false then
				idle=idle+1
			else
				idle=0
			end
			if idle>=500 then
				if attack==false then
					--Sheath()
				end
			end
			if RootPart.Velocity.y > 1 and hitfloor==nil then 
				Anim="Jump"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
				end
			elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
				Anim="Fall"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(10),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(55)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-55)),.1)
				end
			elseif torvel<1 and hitfloor~=nil then
				Anim="Idle"
				if attack==false then
					if ModeOfGlitch == 1 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(-1 - 2 * math.cos(sine / 20))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(-1 + 2 * math.cos(sine / 20))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 20),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(1 - 2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(3 - 3 * math.cos(sine / 40)),math.rad(0),math.rad(0 - 3 * math.cos(sine / 67))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.45 - 0.075 * math.cos(sine / 18),0.5)*angles(math.rad(-26 + 3 * math.cos(sine / 38)),math.rad(0 + 2 * math.cos(sine / 31)),math.rad(-34 + 1 * math.cos(sine / 25))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.45 - 0.075 * math.cos(sine / 18),0.5)*angles(math.rad(-26 + 3 * math.cos(sine / 38)),math.rad(0 - 2 * math.cos(sine / 31)),math.rad(34 - 1 * math.cos(sine / 25))),.1)
					elseif ModeOfGlitch == 2 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 2 * math.cos(sine / 20)),math.rad(-17),math.rad(-1 - 2 * math.cos(sine / 20))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 - 2 * math.cos(sine / 20)),math.rad(5.5),math.rad(-1 + 2 * math.cos(sine / 20))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 20),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(1 - 2 * math.cos(sine / 20)),math.rad(0),math.rad(36)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(12 + 3 * math.cos(sine / 25)),math.rad(0),math.rad(-36 - 3 * math.cos(sine / 67))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 - 0.075 * math.cos(sine / 18),-0.65)*angles(math.rad(89 + 3 * math.cos(sine / 38)),math.rad(0 + 2 * math.cos(sine / 31)),math.rad(-82 + 1 * math.cos(sine / 25))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.45 - 0.075 * math.cos(sine / 18),0.5)*angles(math.rad(-26 + 3 * math.cos(sine / 38)),math.rad(0 - 2 * math.cos(sine / 31)),math.rad(34 - 1 * math.cos(sine / 25))),.1)
					elseif ModeOfGlitch == 3 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 - 1 * math.cos(sine / 20)),math.rad(-5.5),math.rad(-1 - 2 * math.cos(sine / 20))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 20)),math.rad(10),math.rad(-1 + 2 * math.cos(sine / 20))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 20),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(1 - 2 * math.cos(sine / 20)),math.rad(0),math.rad(-13)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(12 + 3 * math.cos(sine / 25)),math.rad(0),math.rad(13 - 3 * math.cos(sine / 67))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 - 0.075 * math.cos(sine / 18),-0.65)*angles(math.rad(89 + 3 * math.cos(sine / 38)),math.rad(0 + 2 * math.cos(sine / 31)),math.rad(-82 + 1 * math.cos(sine / 25))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 - 0.075 * math.cos(sine / 18),-0.72)*angles(math.rad(80 + 3 * math.cos(sine / 38)),math.rad(0 - 2 * math.cos(sine / 31)),math.rad(76 - 1 * math.cos(sine / 25))),.1)
					elseif ModeOfGlitch == 4 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(-1 - 2 * math.cos(sine / 20))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(-1 + 2 * math.cos(sine / 20))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 20),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(1 - 2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 - 4 * math.cos(sine / 37)),math.rad(0 + 8 * math.cos(sine / 43)),math.rad(0 - 5 * math.cos(sine / 47))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.075 * math.cos(sine / 18),0)*angles(math.rad(20 - 3 * math.cos(sine / 32)),math.rad(0 + 8 * math.cos(sine / 23)),math.rad(14 + 3 * math.cos(sine / 15))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.075 * math.cos(sine / 18),0)*angles(math.rad(20 - 3 * math.cos(sine / 32)),math.rad(0 - 8 * math.cos(sine / 23)),math.rad(-14 - 3 * math.cos(sine / 15))),.1)
					elseif ModeOfGlitch == 5 then
						RH.C0=clerp(RH.C0,cf(1,-0.3,-0.65)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 - 1 * math.cos(sine / 20)),math.rad(0 + 1 * math.cos(sine / 52)),math.rad(-3 - 9 * math.cos(sine / 20))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 20)),math.rad(1 + 1 * math.cos(sine / 36)),math.rad(10 + 7 * math.cos(sine / 30))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 20),1 + 0.4 * math.cos(sine / 20))*angles(math.rad(1 - 2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(12 + 3 * math.cos(sine / 25)),math.rad(0),math.rad(0)),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 - 0.075 * math.cos(sine / 18),-0.65)*angles(math.rad(76 + 3 * math.cos(sine / 38)),math.rad(0 + 2 * math.cos(sine / 31)),math.rad(-82 + 1 * math.cos(sine / 25))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 - 0.075 * math.cos(sine / 18),-0.72)*angles(math.rad(89 + 3 * math.cos(sine / 38)),math.rad(0 - 2 * math.cos(sine / 31)),math.rad(76 - 1 * math.cos(sine / 25))),.1)
					elseif ModeOfGlitch == 6 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 20)),math.rad(-13),math.rad(-1 - 2 * math.cos(sine / 20))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 - 1 * math.cos(sine / 20)),math.rad(6),math.rad(-1 + 2 * math.cos(sine / 20))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 20),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(1 - 2 * math.cos(sine / 20)),math.rad(0),math.rad(16)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 + 3 * math.cos(sine / 25)),math.rad(0),math.rad(-16 - 3 * math.cos(sine / 67))),.1)
						RW.C0=clerp(RW.C0,cf(1.4,0.65 - 0.075 * math.cos(sine / 18),-0.1)*angles(math.rad(174 + 3 * math.cos(sine / 38)),math.rad(0 + 2 * math.cos(sine / 31)),math.rad(-22 - 1 * math.cos(sine / 25))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 - 0.075 * math.cos(sine / 18),0)*angles(math.rad(10 + 2 * math.cos(sine / 38)),math.rad(4 - 3 * math.cos(sine / 31)),math.rad(-7 - 2 * math.cos(sine / 25))),.1)
					elseif ModeOfGlitch == 7 then
						RH.C0=clerp(RH.C0,cf(1,-0.3,-0.65)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 - 1 * math.cos(sine / 20)),math.rad(0 + 1 * math.cos(sine / 52)),math.rad(-3 - 6 * math.cos(sine / 20))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 20)),math.rad(1 + 1 * math.cos(sine / 36)),math.rad(10 + 4 * math.cos(sine / 30))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 20),1 + 0.4 * math.cos(sine / 20))*angles(math.rad(1 - 2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 + 3 * math.cos(sine / 25)),math.rad(0),math.rad(0)),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 - 0.075 * math.cos(sine / 18),0)*angles(math.rad(8 + 8 * math.cos(sine / 35)),math.rad(0 + 2 * math.cos(sine / 31)),math.rad(14 + 4 * math.cos(sine / 22))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 - 0.075 * math.cos(sine / 18),0)*angles(math.rad(19 + 7 * math.cos(sine / 37)),math.rad(0 - 2 * math.cos(sine / 31)),math.rad(-15 - 3 * math.cos(sine / 24))),.1)
					elseif ModeOfGlitch == 8 then
						RH.C0=clerp(RH.C0,cf(1,-0.3,-0.65)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1 - 1 * math.cos(sine / 20)),math.rad(0 + 1 * math.cos(sine / 52)),math.rad(-10 - 5 * math.cos(sine / 20))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1 + 1 * math.cos(sine / 20)),math.rad(1 + 1 * math.cos(sine / 36)),math.rad(10 + 7 * math.cos(sine / 30))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 20),1 + 0.4 * math.cos(sine / 20))*angles(math.rad(1 - 2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20 + 5 * math.cos(sine / 25)),math.rad(0 + 3 * math.cos(sine / 30)),math.rad(0)),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 - 0.075 * math.cos(sine / 18),0.2)*angles(math.rad(-33 + 2 * math.cos(sine / 35)),math.rad(0 + 2 * math.cos(sine / 31)),math.rad(-25 + 3 * math.cos(sine / 24))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 - 0.075 * math.cos(sine / 18),0.2)*angles(math.rad(-34 + 1 * math.cos(sine / 37)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(22 - 3 * math.cos(sine / 25))),.1)
					elseif ModeOfGlitch == 12 then
						local snap = math.random(1,10)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 + math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(22 + math.random(-5,5))),1)
						end
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(22 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 32),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-22 + 2 * math.cos(sine / 56))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 - 2 * math.cos(sine / 37)),math.rad(0 + 5 * math.cos(sine / 43) - 5 * math.cos(sine / 0.25)),math.rad(22 - 2 * math.cos(sine / 56))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 + 3 * math.cos(sine / 43)),math.rad(-16 - 5 * math.cos(sine / 52)),math.rad(13 + 9 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.35,1 + 0.025 * math.cos(sine / 45),-0.2)*angles(math.rad(148 - 2 * math.cos(sine / 51)),math.rad(0 - 4 * math.cos(sine / 64)),math.rad(22 - 2 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 22 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-0.5),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01 + 0.02 * math.cos(sine / 32),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 + 3 * math.cos(sine / 42))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 58)),math.rad(0 + 1 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 32 then
						local snap = math.random(1,32)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1)
						end
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 42 then
						local snap = math.random(1,5)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),0.6)
							RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 + 5 * math.cos(sine / 74) + math.random(-1,1)),math.rad(1 - 3 * math.cos(sine / 53) + math.random(-1,1)),math.rad(1 + 3 * math.cos(sine / 45) + math.random(-1,1))),.6)
							LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 - 3 * math.cos(sine / 73) + math.random(-1,1)),math.rad(2 - 1 * math.cos(sine / 55) + math.random(-1,1)),math.rad(-3 - 3 * math.cos(sine / 45) + math.random(-1,1))),.6)
						end
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(25 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-25 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25 + 0.02 * math.cos(sine / 32),-0.1 + 0.1 * math.cos(sine / 20))*angles(math.rad(25 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(1 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-3 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 52 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),-0.1 + 0.1 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(10 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(8 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-14 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 62 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 7 * math.cos(sine / 56))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 52))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1.5 + 0.5 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(14 + 5 * math.cos(sine / 32))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-14 - 6 * math.cos(sine / 33))),.1)
					elseif ModeOfGlitch == 72 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-0.5),math.rad(10 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01 + 0.02 * math.cos(sine / 32),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-10 + 3 * math.cos(sine / 42))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 58)),math.rad(10 + 1 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(170 - 7 * math.cos(sine / 66)),math.rad(2 - 1 * math.cos(sine / 56)),math.rad(12 - 1 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 82 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1.5 + 0.5 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-20)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(20 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 92 then
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MRCL,MRCL.Color)
						sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Lime green"),Color3.new(0,1,0))
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-4 - 2 * math.cos(sine / 53)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(9 - 2 * math.cos(sine / 53)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),-0.1 + 0.1 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 2 * math.cos(sine / 53))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(19 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(18 - 3 * math.cos(sine / 53)),math.rad(17 + 3 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(-11 - 1 * math.cos(sine / 55)),math.rad(-14 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 13 then
						local snap = math.random(1,32)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(19 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(-53 + math.random(-3,3))),1)
						end
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MRCL,MRCL.Color)
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-20),math.rad(0 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(9),math.rad(8 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),-0.1 + 0.1 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(43)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(19 - 2 * math.cos(sine / 37)),math.rad(0 + 5 * math.cos(sine / 55)),math.rad(-43)),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 11 * math.cos(sine / 73)),math.rad(18 - 6 * math.cos(sine / 57)),math.rad(17 + 5 * math.cos(sine / 52))),.1)
						LW.C0=clerp(LW.C0,cf(-1.2,0.85 + 0.025 * math.cos(sine / 45),-0.65)*angles(math.rad(170 - 1 * math.cos(sine / 70)),math.rad(-3 - 1 * math.cos(sine / 59)),math.rad(47 - 1 * math.cos(sine / 60))),.1)
					elseif ModeOfGlitch == 23 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 5 * math.cos(sine / 51))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 44))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1.5 + 0.5 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-36)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(36 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(3 + 7 * math.cos(sine / 79)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(33 + 10 * math.cos(sine / 73))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(15 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-27 - 6 * math.cos(sine / 33))),.1)
					elseif ModeOfGlitch == 64 then
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Deep orange"),BrickColor.new("Deep orange").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Toothpaste"),BrickColor.new("Toothpaste").Color)
						sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,MRCL,MRCL.Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-14 - 5 * math.cos(sine / 48))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 7 * math.cos(sine / 51))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.5 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(21 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(13 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(28 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 44 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(8 - 6 * math.cos(sine / 67)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-18 - 5 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15 - 8 * math.cos(sine / 74)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(31 + 8 * math.cos(sine / 38))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.5 * math.cos(sine / 20))*angles(math.rad(-21 - 2 * math.cos(sine / 32)),math.rad(8),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 6 * math.cos(sine / 37)),math.rad(-14 + 5 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-24 + 9 * math.cos(sine / 72)),math.rad(3 - 5 * math.cos(sine / 58)),math.rad(38 + 7 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-0.8,0.35 + 0.025 * math.cos(sine / 45),-0.75)*angles(math.rad(160 - 2 * math.cos(sine / 66)),math.rad(5 - 8 * math.cos(sine / 59)),math.rad(87 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 34 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.5 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(10)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 58)),math.rad(-10 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(4 + 3 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(19 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.25,0.5 + 0.025 * math.cos(sine / 45),-0.15)*angles(math.rad(10 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(13 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 14 then
						local snap = math.random(1,32)
						if snap == 1 then
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1)
						end
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really red"),BrickColor.new("Really red").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.5 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(2 - 4 * math.cos(sine / 58)),math.rad(-65 + 1 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(6 - 5 * math.cos(sine / 59)),math.rad(73 - 3 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 24 then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(19 + 8 * math.cos(sine / 62)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-20 - 3 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(3 - 1 * math.cos(sine / 55)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(26 + 5 * math.cos(sine / 41))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.5 * math.cos(sine / 20))*angles(math.rad(-13 - 2 * math.cos(sine / 32)),math.rad(3),math.rad(10 - 4 * math.cos(sine / 67))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 - 8 * math.cos(sine / 37)),math.rad(-21 + 2 * math.cos(sine / 58)),math.rad(-10 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 14 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(35 - 8 * math.cos(sine / 51))),.1)
					elseif ModeOfGlitch == 54 then
						sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
						sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 6 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 45))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.5 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(17)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(29 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-17 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfGlitch == 15 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-10 + 2 * math.cos(sine / 43)),math.rad(0 - 2 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(0 + 2 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 34),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 34)),math.rad(0),math.rad(10 - 2 * math.cos(sine / 43))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0 - 2 * math.cos(sine / 47)),math.rad(-10 + 2 * math.cos(sine / 43))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(10 + 3 * math.cos(sine / 48)),math.rad(-20 - 4 * math.cos(sine / 53)),math.rad(15 - 3 * math.cos(sine / 38))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-10 + 2 * math.cos(sine / 45)),math.rad(0),math.rad(-20 + 2 * math.cos(sine / 39))),.1)
					elseif ModeOfGlitch == 25 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20) - 0.03 * math.cos(sine / 45),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-7.5 + 3 * math.cos(sine / 45)),math.rad(0),math.rad(0 - 2 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20) + 0.03 * math.cos(sine / 45),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5 - 3 * math.cos(sine / 45)),math.rad(5),math.rad(0 + 2 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.03 * math.cos(sine / 45),0 + 0.02 * math.cos(sine / 34),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 34)),math.rad(0 + 3 * math.cos(sine / 45)),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20 - 2.5 * math.cos(sine / 28)),math.rad(0 + 5 * math.cos(sine / 99)),math.rad(0 + 10 * math.cos(sine / 78))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15 + 5 * math.cos(sine / 33)),math.rad(15 + 6 * math.cos(sine / 38)),math.rad(-10 - 3 * math.cos(sine / 42))),.1)
						LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.05 * math.cos(sine / 28),-0.65)*angles(math.rad(40 - 3 * math.cos(sine / 34)),math.rad(0),math.rad(90 + 5 * math.cos(sine / 28))),.1)
					elseif ModeOfGlitch == 35 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5 - 2 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(20 - 2 * math.cos(sine / 72)),math.rad(0 + 2 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 34),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 34)),math.rad(0),math.rad(-20 + 2 * math.cos(sine / 72))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0 + 4 * math.cos(sine / 55)),math.rad(20 - 2 * math.cos(sine / 72))),.1)
						RW.C0=clerp(RW.C0,cf(1.15,0.5 + 0.1 * math.cos(sine / 28),0.25)*angles(math.rad(-22 + 2 * math.cos(sine / 38)),math.rad(0),math.rad(-15 - 2 * math.cos(sine / 41))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(10 - 6 * math.cos(sine / 28)),math.rad(0 + 5 * math.cos(sine / 46)),math.rad(-20 + 5 * math.cos(sine / 34))),.1)
					elseif ModeOfGlitch == 45 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-5),math.rad(0 - 3 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(10 + 3 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.03 * math.cos(sine / 34),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0),math.rad(25)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(0 + 2 * math.cos(sine / 57)),math.rad(-25)),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(10 + 5 * math.cos(sine / 34)),math.rad(0),math.rad(21 + 6 * math.cos(sine / 28))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-5 + 5 * math.cos(sine / 43)),math.rad(10 - 5 * math.cos(sine / 27)),math.rad(-5 - 3 * math.cos(sine / 36))),.1)
					elseif ModeOfGlitch == 55 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20) - 0.04 * math.cos(sine / 50),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1 + 4 * math.cos(sine / 50)),math.rad(0),math.rad(0 - 2 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20) + 0.04 * math.cos(sine / 50),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5 - 4 * math.cos(sine / 50)),math.rad(18),math.rad(0 + 2 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.04 * math.cos(sine / 50),0 + 0.03 * math.cos(sine / 34),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0 + 4 * math.cos(sine / 50)),math.rad(-18)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 1 * math.cos(sine / 28)),math.rad(-5 - 2.5 * math.cos(sine / 57)),math.rad(18)),.1)
						RW.C0=clerp(RW.C0,cf(0.85,0.5 + 0.05 * math.cos(sine / 28),-0.65)*angles(math.rad(36 - 3 * math.cos(sine / 34)),math.rad(0 - 2 * math.cos(sine / 45)),math.rad(-80 + 2 * math.cos(sine / 28))),.1)
						LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.05 * math.cos(sine / 28),-0.65)*angles(math.rad(46 + 3 * math.cos(sine / 49)),math.rad(10 + 2 * math.cos(sine / 52)),math.rad(80 - 3 * math.cos(sine / 39))),.1)
					elseif ModeOfGlitch == 65 then
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(2),math.rad(0),math.rad(-10 + 4 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(5 + 2 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.5 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 34)),math.rad(0),math.rad(-5 - 2 * math.cos(sine / 53))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 1 * math.cos(sine / 28)),math.rad(2 + 3 * math.cos(sine / 41)),math.rad(5 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-2 - 4 * math.cos(sine / 28)),math.rad(0),math.rad(14 + 8 * math.cos(sine / 28))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(5 + 3 * math.cos(sine / 46)),math.rad(10 + 5 * math.cos(sine / 52)),math.rad(-15 - 6 * math.cos(sine / 28))),.1)
					elseif ModeOfGlitch == 75 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(1),math.rad(0 - 1 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(5),math.rad(0 + 1 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.01 * math.cos(sine / 34),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(0 + 1 * math.cos(sine / 71)),math.rad(0)),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.02 * math.cos(sine / 28),0)*angles(math.rad(4 - 4 * math.cos(sine / 28)),math.rad(-8),math.rad(10 - 5 * math.cos(sine / 34))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.02 * math.cos(sine / 28),0)*angles(math.rad(5),math.rad(5),math.rad(5)),.1)
					elseif ModeOfGlitch == 85 then
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(-10 + 5 * math.cos(sine / 34))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1.25),math.rad(0),math.rad(6 + 2 * math.cos(sine / 34))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.5 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 34)),math.rad(0),math.rad(-26 + 2 * math.cos(sine / 44))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20 - 1 * math.cos(sine / 28)),math.rad(-5 + 3 * math.cos(sine / 47)),math.rad(26 - 2 * math.cos(sine / 44))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-2 - 3 * math.cos(sine / 30)),math.rad(25 - 3 * math.cos(sine / 38)),math.rad(28 - 6 * math.cos(sine / 34))),.1)
						LW.C0=clerp(LW.C0,cf(-0.95,0.65 + 0.075 * math.cos(sine / 28),-0.65)*angles(math.rad(90 + 2 * math.cos(sine / 73)),math.rad(25 + 5 * math.cos(sine / 24)),math.rad(73 - 3 * math.cos(sine / 65))),.1)
					elseif ModeOfGlitch == 95 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20) + kan.PlaybackLoudness/5000,-0.1)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-20),math.rad(0 - 2 * math.cos(sine / 56) + kan.PlaybackLoudness/450)),.4)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20) - kan.PlaybackLoudness/6500,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(5),math.rad(0 + 2 * math.cos(sine / 56) + kan.PlaybackLoudness/500)),.4)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 56) ,0 + 0.1 * math.cos(sine / 20) + kan.PlaybackLoudness/7000)*angles(math.rad(0 - 2 * math.cos(sine / 56)),math.rad(0),math.rad(30)),.4)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 + 2 * math.cos(sine / 28) - kan.PlaybackLoudness/60),math.rad(0 + 2 * math.cos(sine / 73)),math.rad(-30)),.4)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.02 * math.cos(sine / 28),0)*angles(math.rad(40 + 5 * math.cos(sine / 34) + kan.PlaybackLoudness/7.5),math.rad(0),math.rad(28 - 2 * math.cos(sine / 38))),.4)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.02 * math.cos(sine / 28),0)*angles(math.rad(10),math.rad(5),math.rad(7.5)),.4)
					end
				end
			elseif torvel>2 and torvel<22 and hitfloor~=nil then
				Anim="Walk"
				if attack==false then
					RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 - 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 5 * math.cos(sine / 8))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 5 * math.cos(sine / 8))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
				end
			elseif torvel>=22 and hitfloor~=nil then
				Anim="Run"
				if attack==false then
					if ModeOfGlitch ~= 5 and ModeOfGlitch ~= 7 and ModeOfGlitch ~= 8 and ModeOfGlitch ~= 62 and ModeOfGlitch ~= 82 and ModeOfGlitch ~= 23 and ModeOfGlitch ~= 14 and ModeOfGlitch ~= 24 and ModeOfGlitch ~= 34 and ModeOfGlitch ~= 44 and ModeOfGlitch ~= 54 and ModeOfGlitch ~= 64 and ModeOfGlitch ~= 65 and ModeOfGlitch ~= 85 then
						RH.C0=clerp(RH.C0,cf(1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 95 * math.cos(sine / 6))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 95 * math.cos(sine / 6))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sine / 3))*angles(math.rad(25 - 4 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 1 * math.cos(sine / 6))),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-6 + 2 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 1 * math.cos(sine / 6))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5,0.3)*angles(math.rad(-50 + 10 * math.cos(sine / 3)),math.rad(-10),math.rad(7 + 5 * math.cos(sine / 6))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.3)*angles(math.rad(-50 + 10 * math.cos(sine / 3)),math.rad(10),math.rad(-7 - 5 * math.cos(sine / 6))),.1)
					elseif ModeOfGlitch == 5 or ModeOfGlitch == 7 or ModeOfGlitch == 8 or ModeOfGlitch == 62 or ModeOfGlitch == 82 or ModeOfGlitch == 23 or ModeOfGlitch == 14 or ModeOfGlitch == 24 or ModeOfGlitch == 34 or ModeOfGlitch == 44 or ModeOfGlitch == 54 or ModeOfGlitch == 64 or ModeOfGlitch == 65 or ModeOfGlitch == 85 then
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(80),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
					end
				end
			end
		end
	end








end)

Button_13.MouseButton1Down:Connect(function()
	local script = game:GetObjects("rbxassetid://5972555658")[1]

	wait(1/60)
	p = game.Players.LocalPlayer
	m = p:GetMouse()
	ch = p.Character["Dummy"]
	root = ch.HumanoidRootPart
	hum = ch.Humanoid
	a = script.ScreenGui:Clone()a.Parent = game.Players.LocalPlayer.PlayerGui
	a.Enabled = true
	local baconhair = script.BACONPOWER:Clone()
	baconhair.Parent = ch

	userinput = game:GetService("UserInputService")
	debris = game:GetService("Debris")

	stompphrase = 0
	anim = "Idle"
	attack = false
	grabbed = false
	canplay = false
	canplaying = false
	FATHERWASUMMONDA = false
	sine = 0
	change = 1
	speed = 75
	jpower = 75
	mythtime = false

	Instance.new("ForceField",ch).Visible = false




	-- Music 

	local music = Instance.new("Sound",root)
	music.SoundId = "rbxassetid://2010524866"
	music.Name = "Music"
	music.PlaybackSpeed = 1
	music.Volume = 3
	music.Looped = true
	music:Play()



	-- Welds

	local neck = Instance.new("Weld",ch.Torso)
	neck.Part0 = ch.Torso
	neck.Part1 = ch.Head
	neck.C0 = CFrame.new(0,1.5,0)
	local torso = Instance.new("Weld",root)
	torso.Part0 = root
	torso.Part1 = ch.Torso
	local rs = Instance.new("Weld",ch.Torso)
	rs.Part0 = ch.Torso
	rs.Part1 = ch["Right Arm"]
	rs.C0 = CFrame.new(1.5,0.5,0)
	rs.C1 = CFrame.new(0,0.5,0)
	local ls = Instance.new("Weld",ch.Torso)
	ls.Part0 = ch.Torso
	ls.Part1 = ch["Left Arm"]
	ls.C0 = CFrame.new(-1.5,0.5,0)
	ls.C1 = CFrame.new(0,0.5,0)
	local rh = Instance.new("Weld",ch.Torso)
	rh.Part0 = ch.Torso
	rh.Part1 = ch["Right Leg"]
	rh.C0 = CFrame.new(0.5,-1,0)
	rh.C1 = CFrame.new(0,1,0)
	local lh = Instance.new("Weld",ch.Torso)
	lh.Part0 = ch.Torso
	lh.Part1 = ch["Left Leg"]
	lh.C0 = CFrame.new(-0.5,-1,0)
	lh.C1 = CFrame.new(0,1,0)

	-- Cleetus lol
	local player = game.Players.LocalPlayer
	local mouse = player:GetMouse()


	for i,v in pairs(ch:GetChildren()) do
		if v:IsA("Accessory") or v:IsA("CharacterMesh") or v:IsA("BodyColors") or v:IsA("Shirt") or v:IsA("ShirtGraphic") or v:IsA("Pants") then
			v:Destroy()
		end
	end

	coroutine.wrap(function()
		if ch.Head:FindFirstChild("face") ~= nil then
			ch.Head.face.Texture = "rbxassetid://34067417"
		else
			local newface = Instance.new("Decal",ch.Head)
			newface.Face = Enum.NormalId.Front
			newface.Texture = "rbxassetid://34067417"
		end
	end)()

	local newcolor = Instance.new("BodyColors",ch)
	newcolor.HeadColor = BrickColor.new("White")
	newcolor.LeftArmColor = BrickColor.new("White")
	newcolor.RightArmColor = BrickColor.new("White")
	newcolor.LeftLegColor = BrickColor.new("White")
	newcolor.RightLegColor = BrickColor.new("White")
	newcolor.TorsoColor = BrickColor.new("White")

	local hat = script["Mellow Cowboy"]
	hat.Parent = ch

	local shirt = Instance.new("Shirt",ch)
	shirt.ShirtTemplate = "rbxassetid://144076357"

	local pants = Instance.new("Pants",ch)
	pants.PantsTemplate = "rbxassetid://144076759"



	-- BLACON

	local blacon = script.blacon
	local blaconweld = Instance.new("Weld",blacon.bacon)
	blaconweld.Part0 = blacon.bacon
	blaconweld.Part1 = ch["Right Arm"]
	blaconweld.C0 = blaconweld.C0:Lerp(CFrame.new(0.2,0.3,11.2)*CFrame.Angles(math.rad(90),math.rad(65),math.rad(0)),0.3)

	-- bacon piece

	local baconpiece = script.baconpiece
	local baconweld = Instance.new("Weld",baconpiece.bacon)
	baconweld.Part0 = baconpiece.bacon
	baconweld.Part1 = ch["Right Arm"]
	baconweld.C0 = baconweld.C0:Lerp(CFrame.new(1.8,4.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)

	--bacon

	local baconroot = baconhair.Torso.Torso
	local bacontorso = baconhair.Torso
	local baconneck = bacontorso["Neck"]
	local baconla = bacontorso["Left Shoulder"]
	local baconra = bacontorso["Right Shoulder"]
	local baconll = bacontorso["Left Hip"]
	local baconrl = bacontorso["Right Hip"]

	-- BANJO

--[[local banjo = script.Model
local banjoweld = Instance.new("Weld",banjo.Banjo)
banjoweld.Part0 = banjo.Banjo
banjoweld.Part1 = ch["Left Arm"]
banjoweld.C0 = CFrame.new(0,1.2,0)*CFrame.Angles(0,math.rad(-90),0)]]

	--bacon army

	local bacon1 = script[" "]:Clone()
	bacon1.Parent = ch
	local bacon2 = script[" "]:Clone()
	local bacon3 = script[" "]:Clone()
	local bacon4 = script[" "]:Clone()
	local bacon5 = script[" "]:Clone()
	bacon2.Parent = ch
	bacon3.Parent = ch
	bacon4.Parent = ch
	bacon5.Parent = ch

	-- bacon effect

	local effect1 = script.effect.Part:Clone()
	effect1.Parent = ch
	local effect2 = script.effect.Part1:Clone()
	effect2.Parent = ch
	local effect1weld = Instance.new("Weld",ch.Torso)
	effect1weld.Part0 = effect1
	effect1weld.Part1 = ch.Torso
	effect1weld.C0 = CFrame.new(0,-0.7,-1)*CFrame.Angles(0,0,0)
	local effect2weld = Instance.new("Weld",ch.Torso)
	effect2weld.Part0 = effect2
	effect2weld.Part1 = ch.Torso
	effect2weld.C0 = CFrame.new(0,-0.5,-1)*CFrame.Angles(0,0,0)

	--hitbox cuz ok

	local hitbox = Instance.new("Part",ch)
	hitbox.Anchored = true
	hitbox.Name = "yeahhitbox"
	hitbox.CanCollide = false
	hitbox.Transparency = 1
	hitbox.Position = ch.Torso.Position
	hitbox.Size = Vector3.new(20,10,20)

	--just fire

	local fire1 = script.Fire:Clone()
	local fire2 = script.Fire:Clone()
	local fire3 = script.Fire:Clone()
	local fire4 = script.Fire:Clone()
	local fire5 = script.Fire:Clone()
	fire1.Parent = ch
	fire2.Parent = ch
	fire3.Parent = ch
	fire4.Parent = ch
	fire5.Parent = ch

	-- Usefull functions

	function CheckIfInTable(Table,Value)
		for _,v in pairs(Table) do
			if v == Value then
				return true
			end
		end
	end



	dft = {} 

	function GetPlayers()
		local c = game.Players:GetChildren() 
		for i = 1, #c do 
			table.insert(dft, c[i].Name) 
		end 
	end

	function Randomize()
		GetPlayers()
		local d = math.random(1, #dft) 
		local s = d  
		local rndm = game.Players:FindFirstChild(dft[s])
		if (rndm ~= nil) then 
			local Player = rndm.Character:Clone()
			Player:SetPrimaryPartCFrame(CFrame.new(root.Position.x+math.random(-10,10), root.Position.y, root.Position.z+math.random(-10,10)))
			local ChatService = game:GetService("Chat")
			ChatService:Chat(Player.Head, "LOL LOOK AT THAT GIRL")
		end
	end

	function createsound(id,pitch,volume,parent)
		coroutine.resume(coroutine.create(function()
			local sound = Instance.new("Sound",parent)
			sound.SoundId = "rbxassetid://"..id
			sound.PlaybackSpeed = pitch
			sound.Volume = volume
			sound:Play()
			repeat
				game:GetService("RunService").Heartbeat:Wait()	
			until sound.Playing == false
			sound:Destroy()	
		end))
	end

	function spawnlittlewave(pos,trans)
		coroutine.resume(coroutine.create(function()
			local part = Instance.new("Part",workspace)
			part.Locked = true
			part.BrickColor = BrickColor.new("White")
			part.CanCollide = false
			part.Anchored = true
			part.Transparency = trans
			part.CFrame = pos
			local wavemesh = Instance.new("SpecialMesh",part)
			wavemesh.MeshId = "http://www.roblox.com/asset/?id=169412804"
			for i = 0,3,0.3 do
				game:GetService("RunService").Heartbeat:Wait()
				wavemesh.Scale = wavemesh.Scale + Vector3.new(0.6,0.1,0.6)		
			end	
			part:Destroy()	
		end))
	end

	function GetDudesTorso(c)
		local torsy = (c:findFirstChild("Torso") or c:findFirstChild("UpperTorso"))
		if torsy ~= nil then
			return torsy
		end
	end

	function CamShake(par,magni,env,dur)
		for _, c in pairs(workspace:GetDescendants()) do
			local hum = c:FindFirstChildOfClass("Humanoid")
			if hum ~= nil and c:FindFirstChild("SHAKE")==nil then
				local head = GetDudesTorso(c)
				if head ~= nil then
					local targ = head.Position - par.Position
					local mag = targ.magnitude
					if magni >= mag then
						local sheiku = script:FindFirstChild("SHAKE"):Clone()
						sheiku.Parent = c
						sheiku:FindFirstChild("Env").Value = env
						sheiku:FindFirstChild("Dur").Value = dur
						sheiku.Disabled = false
					end
				end
			end
		end
	end

	function spawnwave(pos,trans)
		coroutine.resume(coroutine.create(function()
			local part = Instance.new("Part",workspace)
			part.Locked = true
			part.BrickColor = BrickColor.new("White")
			part.CanCollide = false
			part.Anchored = true
			part.Transparency = trans
			part.CFrame = pos
			local wavemesh = Instance.new("SpecialMesh",part)
			wavemesh.MeshId = "http://www.roblox.com/asset/?id=169412804"
			for i = 0,8,0.3 do
				game:GetService("RunService").Heartbeat:Wait()
				wavemesh.Scale = wavemesh.Scale + Vector3.new(0.8,0.1,0.8)		
			end	
			part:Destroy()	
		end))
	end

	function IsAHumanoid(Part)
		if Part:FindFirstAncestorWhichIsA("Model") then
			if Part:FindFirstAncestorWhichIsA("Model"):FindFirstChildOfClass("Humanoid") then
				return Part:FindFirstAncestorWhichIsA("Model")
			else
				return nil
			end
		else
			return nil
		end
	end

	function CreateHitBox(Cframe, Size, DebrisTime)
		local HB = Instance.new("Part")
		HB.Orientation = Vector3.new(0, 90, 0)
		HB.CanCollide = false
		HB.Massless = true
		HB.Size = Size
		HB.CFrame = Cframe
		HB.BrickColor = BrickColor.new("Really red")
		HB.Transparency = 1
		HB.Parent = baconhair
		local AnchoredV1 = Instance.new("BodyVelocity")
		AnchoredV1.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
		AnchoredV1.Parent = HB
		AnchoredV1.P = 3e9
		AnchoredV1.Velocity = Vector3.new(Cframe)
		local AnchoredV2 = Instance.new("BodyPosition")
		AnchoredV2.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
		AnchoredV2.Parent = HB
		AnchoredV2.Position = Vector3.new(Cframe)
		AnchoredV2.P = 3e9
		AnchoredV2.D = 3e9
		HB.Touched:Connect(function(Toucher)
			if IsAHumanoid(Toucher) and IsAHumanoid(Toucher) ~= ch and IsAHumanoid(Toucher):FindFirstChildOfClass("Humanoid").Health > 0 then
				HB:Destroy()
				local Humanoid = IsAHumanoid(Toucher):FindFirstChildOfClass("Humanoid")
				local HitTorso = Humanoid.Parent:FindFirstChild("Torso") or Humanoid.Parent:FindFirstChild("UpperTorso")
				--Humanoid:TakeDamage(math.huge)
			end
		end)
		game:GetService("Debris"):AddItem(HB, DebrisTime)
		return HB
	end

	function spawnstuntwave(pos,trans)
		coroutine.resume(coroutine.create(function()
			local part = Instance.new("Part",workspace)
			part.Name = "STUNTWAVE"
			part.Locked = true
			part.BrickColor = BrickColor.new("White")
			part.CanCollide = false
			part.Anchored = true
			part.Transparency = trans
			part.CFrame = pos
			local wavemesh = Instance.new("SpecialMesh",part)
			wavemesh.MeshId = "http://www.roblox.com/asset/?id=169412804"
			for i = 0,8,0.3 do
				game:GetService("RunService").Heartbeat:Wait()
				wavemesh.Scale = wavemesh.Scale + Vector3.new(1.2,0.1,1.2)
				part.Size = part.Size + Vector3.new(1.2,1,1.2)
			end	
			wait()
			part:Destroy()	
		end))
	end

	function spawnwave2(pos,trans)
		coroutine.resume(coroutine.create(function()
			local part = Instance.new("Part",workspace)
			part.Locked = true
			part.BrickColor = BrickColor.new("White")
			part.CanCollide = false
			part.Anchored = true
			part.Transparency = trans
			part.CFrame = pos
			local wavemesh = Instance.new("SpecialMesh",part)
			wavemesh.MeshId = "http://www.roblox.com/asset/?id=169412804"
			for i = 0,8,0.3 do
				game:GetService("RunService").Heartbeat:Wait()
				wavemesh.Scale = wavemesh.Scale + Vector3.new(10,1,10)		
			end	
			part:Destroy()	
		end))
	end

	function spawncircle(pos,trans)
		coroutine.resume(coroutine.create(function()
			local part = Instance.new("Part",workspace)
			part.Locked = true
			part.BrickColor = BrickColor.new("White")
			part.CanCollide = false
			part.Anchored = true
			part.Transparency = trans
			part.CFrame = pos
			local wavemesh = Instance.new("SpecialMesh",part)
			wavemesh.MeshId = "http://www.roblox.com/asset/?id=2425219842"
			for i = 0,8,0.3 do
				game:GetService("RunService").Heartbeat:Wait()
				wavemesh.Scale = wavemesh.Scale + Vector3.new(0.8,1,0.8)		
			end	
			part:Destroy()	
		end))
	end

	function spawncylinder(pos,trans)
		coroutine.resume(coroutine.create(function()
			local part = Instance.new("Part",workspace)
			part.Locked = true
			part.BrickColor = BrickColor.new("White")
			part.CanCollide = false
			part.Anchored = true
			part.Transparency = trans
			part.CFrame = pos
			part.Material = Enum.Material.Neon
			local wavemesh = Instance.new("SpecialMesh",part)
			wavemesh.MeshId = "http://www.roblox.com/asset/?id=495043301"
			for i = 0,8,0.3 do
				game:GetService("RunService").Heartbeat:Wait()
				wavemesh.Scale = wavemesh.Scale + Vector3.new(0.6,1000,0.6)		
			end	
			part:Destroy()	
		end))
	end


	function spawnkillingwave(pos,trans)
		coroutine.resume(coroutine.create(function()
			local part = Instance.new("Part",workspace)
			part.Locked = true
			part.BrickColor = BrickColor.new("White")
			part.CanCollide = false
			part.Anchored = true
			part.Transparency = trans
			part.CFrame = pos
			local wavemesh = Instance.new("SpecialMesh",part)
			wavemesh.MeshId = "http://www.roblox.com/asset/?id=169412804"
			part.Touched:Connect(function(hit)
				if hit.Parent ~= ch and hit.Parent:FindFirstChildOfClass("Humanoid") then
					hit.Parent:BreakJoints()
				end		
			end)
			for i = 0,8,0.3 do
				game:GetService("RunService").Heartbeat:Wait()
				wavemesh.Scale = wavemesh.Scale + Vector3.new(0.8,1,0.8)		
				part.Size = part.Size + Vector3.new(0.8,1,0.8)	
			end	
			part:Destroy()	
		end))
	end

	function GetPartsInArea(PropertyTable,IgnoreCharacter,Raw)
		local Table = {}
		local Area = Instance.new("Part",root)
		Area.CFrame = PropertyTable.CFrame or root.CFrame
		Area.Size = PropertyTable.Size or Vector3.new(3,3,3)
		Area.Anchored = true
		Area.CanCollide = false
		Area.Transparency = 1
		local hit = {}
		if PropertyTable.Region == true then
			Area.CFrame = CFrame.new(PropertyTable.CFrame.p)
			local __ = Region3.new(Area.Position-(Area.Size/2),Area.Position+(Area.Size/2))
			hit = workspace:FindPartsInRegion3(__,root,math.huge)
		elseif PropertyTable.Magnitude == true then
			for _,v in pairs(workspace:GetDescendants()) do
				if v:IsA("BasePart") and (v.Position - Area.Position).Magnitude < (PropertyTable.Range or 30) then
					table.insert(hit,v)
				end
			end
		else
			local __ = Area.Touched:Connect(function() end)
			hit = Area:GetTouchingParts()
			__:Disconnect()
		end
		for _,v in pairs(hit) do
			if v.Parent and (not v:IsDescendantOf(ch) or IgnoreCharacter == false) then
				if not Raw then
					if v.Parent and not CheckIfInTable(Table,v.Parent) and v.Parent:FindFirstChildOfClass("Humanoid") then
						table.insert(Table,v.Parent)
					end
				else
					table.insert(Table,v)
				end
			end
		end
		Area:Destroy()
		return Table
	end

	-- Attacks 

	function animtemplate()
		neck.C0 = neck.C0:Lerp(CFrame.new(0,1.6,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
		torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
		rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
		ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
		rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
		lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
	end

	function intro()
		attack = true
		root.Anchored = true
		bacon1:SetPrimaryPartCFrame(root.CFrame*CFrame.new(0,0,10))
		bacon1:SetPrimaryPartCFrame(CFrame.new(bacon1:GetPrimaryPartCFrame().p,root.CFrame.p))
		bacon2:SetPrimaryPartCFrame(root.CFrame*CFrame.new(10,0,5))
		bacon2:SetPrimaryPartCFrame(CFrame.new(bacon2:GetPrimaryPartCFrame().p,root.CFrame.p))
		bacon3:SetPrimaryPartCFrame(root.CFrame*CFrame.new(-10,0,5))
		bacon3:SetPrimaryPartCFrame(CFrame.new(bacon3:GetPrimaryPartCFrame().p,root.CFrame.p))
		bacon4:SetPrimaryPartCFrame(root.CFrame*CFrame.new(10,0,-5))
		bacon4:SetPrimaryPartCFrame(CFrame.new(bacon4:GetPrimaryPartCFrame().p,root.CFrame.p))
		bacon5:SetPrimaryPartCFrame(root.CFrame*CFrame.new(-10,0,-5))
		bacon5:SetPrimaryPartCFrame(CFrame.new(bacon5:GetPrimaryPartCFrame().p,root.CFrame.p))
		for i = 0,5,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,-0.3)*CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,-0.7,0)*CFrame.Angles(math.rad(-31.3),math.rad(-4.54),math.rad(0.53)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.4,0.5,0)*CFrame.Angles(math.rad(25),math.rad(0),math.rad(0)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.4,0.5,0)*CFrame.Angles(math.rad(25),math.rad(0),math.rad(0)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(-35),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-0.2,-1)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
		end
		wait(2)
		fire1.Position = bacon1.Torso.Position
		fire2.Position = bacon2.Torso.Position
		fire3.Position = bacon3.Torso.Position
		fire4.Position = bacon4.Torso.Position
		fire5.Position = bacon5.Torso.Position

		spawn(function()
			for i = 1,100 do
				bacon1:SetPrimaryPartCFrame(bacon1:GetPrimaryPartCFrame()*CFrame.new(0,0.1,0))
				bacon2:SetPrimaryPartCFrame(bacon2:GetPrimaryPartCFrame()*CFrame.new(0,0.1,0))
				bacon3:SetPrimaryPartCFrame(bacon3:GetPrimaryPartCFrame()*CFrame.new(0,0.1,0))
				bacon4:SetPrimaryPartCFrame(bacon4:GetPrimaryPartCFrame()*CFrame.new(0,0.1,0))
				bacon5:SetPrimaryPartCFrame(bacon5:GetPrimaryPartCFrame()*CFrame.new(0,0.1,0))
				wait(0.005)
			end
		end)
		createsound(427025525,1,4,ch)
		spawn(function()
			for i = 1,10 do
				for i,v in pairs(bacon1:GetChildren()) do if v:IsA("Part") then v.Transparency = bacon1.Torso.Transparency+0.1 end bacon1.Head.face.Transparency =bacon1.Head.face.Transparency+0.1 end
				for i,v in pairs(bacon2:GetChildren()) do if v:IsA("Part") then v.Transparency = bacon1.Torso.Transparency+0.1   end bacon2.Head.face.Transparency =bacon1.Head.face.Transparency+0.1 end
				for i,v in pairs(bacon3:GetChildren()) do if v:IsA("Part") then v.Transparency = bacon1.Torso.Transparency+0.1  end bacon3.Head.face.Transparency =bacon1.Head.face.Transparency+0.1 end
				for i,v in pairs(bacon4:GetChildren()) do if v:IsA("Part") then v.Transparency = bacon1.Torso.Transparency+0.1  end bacon4.Head.face.Transparency =bacon1.Head.face.Transparency+0.1 end
				for i,v in pairs(bacon5:GetChildren()) do if v:IsA("Part") then v.Transparency = bacon1.Torso.Transparency+0.1 end bacon5.Head.face.Transparency =bacon1.Head.face.Transparency+0.1 end
				wait(0.1)
			end
		end)
		local fire1weld = Instance.new("Weld",fire1)
		fire1weld.Part0 = fire1
		fire1weld.Part1 = root
		fire1weld.C0 = fire1weld.C0:Lerp(CFrame.new(0,0,-100),0.1)
		local fire2weld = Instance.new("Weld",fire2)
		fire2weld.Part0 = fire2
		fire2weld.Part1 = root
		fire2weld.C0 = fire2weld.C0:Lerp(CFrame.new(100,0,50),0.1)
		local fire3weld = Instance.new("Weld",fire3)
		fire3weld.Part0 = fire3
		fire3weld.Part1 = root
		fire3weld.C0 = fire3weld.C0:Lerp(CFrame.new(-100,0,50),0.1)
		local fire4weld = Instance.new("Weld",fire4)
		fire4weld.Part0 = fire4
		fire4weld.Part1 = root
		fire4weld.C0 = fire4weld.C0:Lerp(CFrame.new(100,0,-50),0.1)
		local fire5weld = Instance.new("Weld",fire5)
		fire5weld.Part0 = fire5
		fire5weld.Part1 = root
		fire5weld.C0 = fire5weld.C0:Lerp(CFrame.new(-100,0,-50),0.1)
		fire1.Anchored = false
		fire2.Anchored = false
		fire3.Anchored = false
		fire4.Anchored = false
		fire5.Anchored = false
		wait(1.2)
		spawn(function()
			for i = 0,2,0.1 do
				game:GetService("RunService").Heartbeat:Wait()
				neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,-0.3)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
				rs.C0 = rs.C0:Lerp(CFrame.new(1.4,0.5,0)*CFrame.Angles(math.rad(-75),math.rad(0),math.rad(0)),0.3)
				ls.C0 = ls.C0:Lerp(CFrame.new(-1.4,0.5,0)*CFrame.Angles(math.rad(-75),math.rad(0),math.rad(0)),0.3)
				rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(-35),math.rad(0),math.rad(0)),0.3)
				lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(-35),math.rad(0),math.rad(0)),0.3)
			end
		end)
		spawn(function()
			for i = 0,1,0.005 do
				game:GetService("RunService").Heartbeat:Wait()
				fire1weld.C0 = fire1weld.C0:Lerp(CFrame.new(0,-10,0),0.017)
				fire2weld.C0 = fire2weld.C0:Lerp(CFrame.new(0,-10,0),0.017)
				fire3weld.C0 = fire3weld.C0:Lerp(CFrame.new(0,-10,0),0.017)
				fire4weld.C0 = fire4weld.C0:Lerp(CFrame.new(0,-10,0),0.017)
				fire5weld.C0 = fire5weld.C0:Lerp(CFrame.new(0,-10,0),0.017)
				torso.C0 = torso.C0:Lerp(CFrame.new(0,10,0)*CFrame.Angles(math.rad(70),math.rad(0),math.rad(0)),0.05)
			end
		end)
		local sentences = script.BillboardGui:Clone()
		sentences.Enabled = true
		sentences.Parent = ch.Torso
		sentences.TextLabel.Text = "YOU WILL SUFFER.."
		local args = {
			[1] = "YOU WILL SUFFER..",
			[2] = "All"
		}

		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args))
		wait(0.5)
		repeat
			sentences.TextLabel.TextTransparency = sentences.TextLabel.TextTransparency+0.05
			wait(0.05)
		until sentences.TextLabel.TextTransparency >= 1
		sentences:Destroy()
		wait(0.5)
		local sentences2 = script.BillboardGui:Clone()
		sentences2.Enabled = true
		sentences2.Parent = ch.Torso
		sentences2.TextLabel.Text = "TO WHAT YOU DID TO BACONS!"
		local args = {
			[1] = "TO WHAT YOU DID TO BACONS!",
			[2] = "All"
		}

		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args))
		wait(1)
		sentences2:Destroy()
		effect1.ParticleEmitter.Enabled = true
		effect1.ParticleEmitter1.Enabled = true
		effect1.ParticleEmitter2.Enabled = true
		effect1.ParticleEmitter3.Enabled = true
		effect2.ParticleEmitter.Enabled = true
		effect2.ParticleEmitter1.Enabled = true
		CamShake(root,100,.5,.6)
		spawnwave2(root.CFrame*CFrame.new(0,2,0),0)
		fire1:Destroy()fire2:Destroy()fire3:Destroy()fire4:Destroy()fire5:Destroy()
		spawncylinder(root.CFrame*CFrame.new(0,2,0),0.2)
		createsound(533636230,1,5,ch)
		createsound(419447292,1,5,ch)
		attack = false
		canplay = true
		canplaying = true
		root.Anchored = false
	end
	print(0x14c7ea31b)
	function flake()
		attack = true	
		speed = 0
		jpower = 0
		for i = 1,3,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.2,0.7,0.3)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(90)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.2,0.7,0.3)*CFrame.Angles(math.rad(90),math.rad(-10),math.rad(-90)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.4,-0.5)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-0.9,-0.15)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)	
		end
		local baconflake = script.baconflake:Clone()
		local aaa = Instance.new("BodyVelocity")
		baconflake.Anchored = false
		baconflake.CFrame = ch["Right Arm"].CFrame
		baconflake.Parent = workspace
		aaa.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
		aaa.Velocity = mouse.Hit.p
		aaa.Parent = baconflake
		spawn(function()
			wait(0.2)
			baconflake.Touched:Connect(function(h)
				aaa.Velocity = Vector3.new(0,0,0)
				baconflake.BrickColor = BrickColor.new("White")
				if baconflake:FindFirstChild("Decal") then
					baconflake.Decal:Destroy()
				end
				spawn(function()
					for i = 1,50 do
						baconflake.Transparency = baconflake.Transparency+0.05
						wait(0.05)
					end
					baconflake:Destroy()
				end)
				if h.Parent ~= ch and h.Parent:FindFirstChildOfClass("Humanoid") then
					h.Parent:BreakJoint()
					h.Parent:FindFirstChild("Humanoid"):Destroy()
				end
			end)
		end)
		speed = 75
		jpower = 75
		attack = false
	end

	function taunt()
		attack = true
		jpower = 0	
		speed = 0
		local sentences = script.BillboardGui:Clone()
		sentences.Enabled = true
		sentences.Parent = ch.Head
		sentences.TextLabel.Text = "What's Wrong?..... Scared?"
		local args = {
			[1] = "What's Wrong?..... Scared?",
			[2] = "All"
		}

		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args))
		spawn(function()
			wait(1)
			repeat
				-- Script generated by SimpleSpy - credits to exx#9394



				sentences.TextLabel.TextTransparency = sentences.TextLabel.TextTransparency+0.05
				wait(0.05)
			until sentences.TextLabel.TextTransparency >= 1
			sentences:Destroy()
		end)
		spawn(function()
			wait(0.075)
			local a = Instance.new("Part",baconpiece)
			a.BrickColor = BrickColor.new("Bright orange")
			a.Material = Enum.Material.Neon
			a.Anchored = true
			a.CanCollide = false
			a.Shape = Enum.PartType.Ball
			a.Position = baconpiece.bacon.Position
			a.Size = Vector3.new(1.2,1.2,1.2)
			wait(0.05)
			a.Size = Vector3.new(1.8,1.8,1.8)
			wait(0.05)
			a.Size = Vector3.new(2.4,2.4,2.4)
			wait(0.05)
			a.Size = Vector3.new(1.8,1.8,1.8)
			wait(0.05)
			baconpiece.bacon.Transparency = 0
			a.Size = Vector3.new(1.2,1.2,1.2)
			a:Destroy()
		end)
		spawn(function()
			wait(1.9)
			local a = Instance.new("Part",baconpiece)
			a.BrickColor = BrickColor.new("Bright orange")
			a.Material = Enum.Material.Neon
			a.Anchored = true
			a.CanCollide = false
			a.Shape = Enum.PartType.Ball
			a.Position = baconpiece.bacon.Position
			a.Size = Vector3.new(1.2,1.2,1.2)
			wait(0.05)
			a.Size = Vector3.new(1.8,1.8,1.8)
			wait(0.05)
			a.Size = Vector3.new(2.4,2.4,2.4)
			wait(0.05)
			a.Size = Vector3.new(1.8,1.8,1.8)
			wait(0.05)
			baconpiece.bacon.Transparency = 1
			a.Size = Vector3.new(1.2,1.2,1.2)
			a:Destroy()
		end)
		for i = 0,13,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,5-1*math.cos(sine/64),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.2,0,0.3)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(-120)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(8.3,0.7,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.4,-0.5)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-0.9,-0.15)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)	
		end
		jpower = 75
		speed = 75
		attack = false
	end

	function summonfather()
		FATHERWASUMMONDA = true
		for index, descendant in pairs(baconhair:GetDescendants()) do
			if descendant:IsA("Part") then
				repeat
					descendant.Transparency = descendant.Transparency-0.1
					wait(0.1)
				until descendant.Transparency <= 0
			end
			baconhair.PrimaryPart.CFrame = baconhair.PrimaryPart.CFrame:Lerp(root.CFrame * CFrame.new(-2.15, 8.3, 2.5), 1)
		end
	end

	function FATHERDAY(TargetPart)
		for i = 0,3,0.1 do
			game:GetService("RunService").RenderStepped:Wait()
			baconhair.PrimaryPart.CFrame = baconhair.PrimaryPart.CFrame:Lerp(CFrame.new(TargetPart.Position, ch.Torso.Position) * CFrame.new(0, 0, -3.5))
			baconneck.C0 = baconneck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconroot.C0 = baconroot.C0:Lerp(CFrame.new(0,5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconra.C0 = baconra.C0:Lerp(CFrame.new(1.2,0.7,0.3)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconla.C0 = baconla.C0:Lerp(CFrame.new(-1.2,0.7,0.3)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconrl.C0 = baconrl.C0:Lerp(CFrame.new(0.5,-0.4,-0.5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconll.C0 = baconll.C0:Lerp(CFrame.new(-0.5,-0.9,-0.15)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)	
		end
		coroutine.resume(coroutine.create(function()
			wait(0.06)
			CreateHitBox(baconhair.PrimaryPart.CFrame * CFrame.new(0, 0, -4), Vector3.new(4.2,3.4,6))
		end))
		for i = 0,3,0.1 do
			game:GetService("RunService").RenderStepped:Wait()
			baconneck.C0 = baconneck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconroot.C0 = baconroot.C0:Lerp(CFrame.new(0,5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconra.C0 = baconra.C0:Lerp(CFrame.new(1.2,0.7,0.3)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconla.C0 = baconla.C0:Lerp(CFrame.new(-1.2,0.7,0.3)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconrl.C0 = baconrl.C0:Lerp(CFrame.new(0.5,-0.4,-0.5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconll.C0 = baconll.C0:Lerp(CFrame.new(-0.5,-0.9,-0.15)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)	
		end
		for i = 0,1,0.1 do
			game:GetService("RunService").RenderStepped:Wait()
			baconneck.C0 = baconneck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconroot.C0 = baconroot.C0:Lerp(CFrame.new(0,5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			baconra.C0 = baconra.C0:Lerp(CFrame.new(1.2,0.7,0.3)*CFrame.Angles(math.rad(90),math.rad(10),math.rad(90)),0.3)
			baconla.C0 = baconla.C0:Lerp(CFrame.new(-1.2,0.7,0.3)*CFrame.Angles(math.rad(90),math.rad(-10),math.rad(-90)),0.3)
			baconrl.C0 = baconrl.C0:Lerp(CFrame.new(0.5,-0.4,-0.5)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)
			baconll.C0 = baconll.C0:Lerp(CFrame.new(-0.5,-0.9,-0.15)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)	
		end
	end

	function despawn()
		FATHERWASUMMONDA = false
		for index, descendant in pairs(baconhair:GetDescendants()) do
			if descendant:IsA("Part") then
				repeat
					descendant.Transparency = descendant.Transparency+0.1
					wait(0.1)
				until descendant.Transparency >= 1
			end
		end
	end

	function swing()
		attack = true
		blacon.bacon.Transparency = 0
		blacon.bacon.Trail.Enabled = true
		speed = 20
		for i = 0,1,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			blaconweld.C0 = blaconweld.C0:Lerp(CFrame.new(0.2,0.3,11.2)*CFrame.Angles(math.rad(90),math.rad(65),math.rad(0)),0.3)
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,0.1,0)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.2,0.9,0.1)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(90)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.2,0.7,0.3)*CFrame.Angles(math.rad(0),math.rad(-70),math.rad(-90)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.4,-0.5)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-0.9,-0.15)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)	
		end
		touch = blacon.Hitbox.Touched:Connect(function(hit)
			if hit.Parent ~= ch and hit.Parent:FindFirstChildOfClass("Humanoid") then
				createsound(4599382589,1,2,hit)
				CamShake(root,100,.5,.6)
				--exlol.Position = hit.Parent.HumanoidRootPart.Position
				hit.Parent.Humanoid:Destroy()
				touch:Disconnect()
			end
		end)
		createsound(3624807031,1,2,blacon.bacon)
		wait(0.2)
		for i = 0,2,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			blaconweld.C0 = blaconweld.C0:Lerp(CFrame.new(0.2,0.4,11.2)*CFrame.Angles(math.rad(90),math.rad(90),math.rad(0)),0.3)
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,0.1,0)*CFrame.Angles(math.rad(0),math.rad(30),math.rad(0)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.2,0.9,0.1)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.2,0.7,-0.3)*CFrame.Angles(math.rad(0),math.rad(-75),math.rad(-90)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.4,-0.5)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-0.9,-0.15)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)
		end
		touch:Disconnect()
		speed = 75
		attack = false
		blacon.bacon.Transparency = 1
		blacon.bacon.Trail.Enabled = false
	end
	function stomp()
		attack = true
		speed = 1
		jpower = 1
		if ch.Head:FindFirstChild("BillBoardGui") then
			ch.Head:FindFirstChild("BillBoardGui"):Destroy()
		end
		local sentences = script.BillboardGui:Clone()
		sentences.Enabled = true
		sentences.Parent = ch.Head
		if stompphrase == 0 then
			sentences.TextLabel.Text = "Stay there."
			stompphrase = math.random(0,1)
		elseif stompphrase == 1 then
			sentences.TextLabel.Text = "Don't get away."
			stompphrase = math.random(0,1)
		end
		local args = {
			[1] = "Don't get away.",
			[2] = "All"
		}

		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args))
		spawn(function()
			wait(1)
			repeat
				sentences.TextLabel.TextTransparency = sentences.TextLabel.TextTransparency+0.05
				wait(0.05)
			until sentences.TextLabel.TextTransparency >= 1
			sentences:Destroy()
		end)
		for i = 0,1,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,-0.3)*CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,-0.4,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.2,0.7,0.3)*CFrame.Angles(math.rad(90),math.rad(10),math.rad(90)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.2,0.7,0.3)*CFrame.Angles(math.rad(90),math.rad(-10),math.rad(-90)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(-35),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-0.2,-1)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
		end
		createsound(180683823,1,4,ch)
		wait(0.2)
		spawnstuntwave(root.CFrame*CFrame.new(0,-2,0),0)
		spawn(function()
			game.Workspace.STUNTWAVE.Touched:Connect(function(h)
				if h.Parent ~= ch and h.Parent:FindFirstChildOfClass("Humanoid") then
					h.Anchored = true
					print(h.Parent)
					wait(3)
					h.Anchored = false
				end
			end)
		end)
		for i = 0,3,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,-0.3)*CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,-0.7,0)*CFrame.Angles(math.rad(-55),math.rad(0),math.rad(0)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.2,0.7,0.3)*CFrame.Angles(math.rad(90),math.rad(10),math.rad(90)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.2,0.7,0.3)*CFrame.Angles(math.rad(90),math.rad(-10),math.rad(-90)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-0.5,-0.8)*CFrame.Angles(math.rad(60),math.rad(0),math.rad(0)),0.3)
		end
		attack = false
		speed = 75
		jpower = 75
	end

--[[function datractor()
	attack = true
	local hitboxthing = Instance.new("Part",workspace)
	hitboxthing.Size = Vector3.new(45,25,45)
	hitboxthing.Transparency = 1
	hitboxthing.Anchored = true
	hitboxthing.CanCollide = false
	hitboxthing.CFrame = root.CFrame
	spawnwave(root.CFrame*CFrame.new(0,2,0),0.2)
	wait()
	CamShake(root,100,.5,.6)
	hum.Jump = true
	root.Anchored = true
	for i = 0,7,0.1 do
	game:GetService("RunService").Heartbeat:Wait()
	root.CFrame = root.CFrame:Lerp(root.CFrame*CFrame.new(0,45,0),0.3)
	neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),0.3)
	torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(5),math.rad(0),math.rad(0)),0.3)
	rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,0)*CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-25)),0.3)
	ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,0)*CFrame.Angles(math.rad(-5),math.rad(0),math.rad(25)),0.3)
	rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.5,-1)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	end
	local tracktor = Instance.new("Part",ch)
	tracktor.Anchored = false
	tracktor.CanCollide = false
	tracktor.Transparency = 1
	tracktor.Size = Vector3.new(12,12,35)
	local trackmesh = Instance.new("SpecialMesh",tracktor)
	trackmesh.MeshId = "rbxassetid://598113704"
	trackmesh.TextureId = "rbxassetid://598113805"
	trackmesh.Scale = Vector3.new(5,5,5)
	local trackweld = Instance.new("Weld",tracktor)
	trackweld.Part0 = tracktor
	trackweld.Part1 = ch.Head
	trackweld.C0 = CFrame.new(0,-6.5,0)
	local bass = Instance.new("Sound",tracktor)
	bass.SoundId = "rbxasset://sounds//bass.wav"
	bass.Volume = 5
	bass:Play()
	coroutine.wrap(function()
		repeat
		game:GetService("RunService").Heartbeat:Wait()
		tracktor.Transparency = tracktor.Transparency - 0.01	
		until tracktor.Transparency < 0
	end)()
	for i = 0,7,0.1 do
	game:GetService("RunService").Heartbeat:Wait()
	neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(5),math.rad(0),math.rad(0)),0.3)
	rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,0)*CFrame.Angles(math.rad(180),math.rad(0),math.rad(0)),0.3)
	ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,0)*CFrame.Angles(math.rad(180),math.rad(0),math.rad(0)),0.3)
	rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.5,-1)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	end
	local fallinglol = Instance.new("Sound",ch)
	fallinglol.SoundId = "rbxassetid://2258378465"
	fallinglol.Volume = 4
	fallinglol.Looped = true
	fallinglol:Play()
	local fallinglol2 = Instance.new("Sound",ch)
	fallinglol2.SoundId = "rbxassetid://138206037"
	fallinglol2.Volume = 4
	touch = tracktor.Touched:Connect(function(hit)
		if hit.Parent ~= ch then
			touch:Disconnect()
			tracktor.Anchored = true
			trackweld:Destroy()
			tracktor.Parent = workspace
			hitboxthing.CFrame = CFrame.new(root.Position.X,2,root.Position.Z)
		    hitboxthing.Touched:Connect(function(hit)
				if hit.Parent ~= ch and hit.Parent:FindFirstChildOfClass("Humanoid") then
				hit.Parent:BreakJoints()
				end	
			end)
			tracktor.Transparency = 1
			fallinglol:Destroy()
			fallinglol2:Play()
			fallinglol2.TimePosition = 4.6
			local exlol = Instance.new("Explosion",workspace)
			exlol.Position = hitboxthing.Position
			exlol.Visible = false
			CamShake(root,100,.5,.6)
			root.CFrame = root.CFrame*CFrame.new(0,3,0)
			spawnwave(hitboxthing.CFrame,0.2)
			hum.Jump = true
			for i = 0,7,0.1 do
	        game:GetService("RunService").Heartbeat:Wait()
	        neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	        torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.random(-999,99),math.random(-999,999),math.random(-999,999)),1)
	        rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,0)*CFrame.Angles(math.rad(180),math.rad(0),math.rad(0)),0.3)
	        ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,0)*CFrame.Angles(math.rad(180),math.rad(0),math.rad(0)),0.3)
	        rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.5,-1)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	        lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
			end
			attack = false
			root.CFrame = root.CFrame*CFrame.Angles(0,0,0)
			wait(3)
			fallinglol2:Destroy()
			tracktor:Destroy()
			hitboxthing:Destroy()
		end
	end)
	for i = 0,2,0.1 do
	game:GetService("RunService").Heartbeat:Wait()
	neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(180),math.rad(0),math.rad(0)),0.3)
	rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,0)*CFrame.Angles(math.rad(180),math.rad(0),math.rad(0)),0.3)
	ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,0)*CFrame.Angles(math.rad(180),math.rad(0),math.rad(0)),0.3)
	rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.5,-1)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	end
	root.Anchored = false
end

function CONSUME()
	attack = true
	speed = 0
	jpower = 0
	for i = 0,1,0.1 do
	game:GetService("RunService").Heartbeat:Wait()
	neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),0.3)
	torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
	rs.C0 = rs.C0:Lerp(CFrame.new(1.2,0.5,0)*CFrame.Angles(math.rad(100),math.rad(0),math.rad(90)),0.3)
	ls.C0 = ls.C0:Lerp(CFrame.new(-1.2,0.5,0)*CFrame.Angles(math.rad(100),math.rad(0),math.rad(-90)),0.3)
	rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
	lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),0.3)
	end
	local touchthing = Instance.new("Part",ch)
	touchthing.Size = Vector3.new(1.3,1,1.3)
	touchthing.CanCollide = false
	touchthing.Anchored = false
	touchthing.Transparency = 1
	local touchweldlol = Instance.new("Weld",touchthing)
	touchweldlol.Part0 = touchthing
	touchweldlol.Part1 = root
	touchweldlol.C0 = CFrame.new(0,0,2)
	touchy = touchthing.Touched:Connect(function(hit)
		if hit.Parent ~= ch and hit.Parent:FindFirstChildOfClass("Humanoid") then
			root.Anchored = true
			grabbed = true
			speed = 0
			jpower = 0
			touchy:Disconnect()
			local grabbedroot = hit.Parent:FindFirstChild("HumanoidRootPart") or hit.Parent:FindFirstChild("Torso")
			local grabbedweld = Instance.new("Weld",grabbedroot)
			grabbedweld.Part0 = grabbedroot
			grabbedweld.Part1 = root
			grabbedweld.C0 = CFrame.new(0,-0.5,-2)*CFrame.Angles(0,math.rad(180),0)
			for i = 0,3,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
	        torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),0.3)
	        rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,-0.5)*CFrame.Angles(math.rad(100),math.rad(0),math.rad(0)),0.3)
	        ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,-0.5)*CFrame.Angles(math.rad(100),math.rad(0),math.rad(0)),0.3)
	        rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
	        lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
			end
			for i = 0,2.5,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			grabbedweld.C0 = grabbedweld.C0:Lerp(CFrame.new(0,-15,-2)*CFrame.Angles(0,math.rad(180),0),i)
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),0.3)
	        torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),0.3)
	        rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,-0.5)*CFrame.Angles(math.rad(160),math.rad(0),math.rad(0)),0.3)
	        ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,-0.5)*CFrame.Angles(math.rad(160),math.rad(0),math.rad(0)),0.3)
	        rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
	        lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
			end
			local headmesh = ch.Head:FindFirstChildOfClass("SpecialMesh")
			headmesh.Scale = Vector3.new(8.25,8.25,8.25)
			headmesh.Offset = Vector3.new(0,3.5,0)
			createsound(1080625252,1,8,grabbedroot)
			for i = 0,1,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			grabbedweld.C0 = grabbedweld.C0:Lerp(CFrame.new(0,-21,-2)*CFrame.Angles(0,0,0),i)
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),0.3)
	        torso.C0 = torso.C0:Lerp(CFrame.new(0,-0.35,0)*CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),0.3)
	        rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,-0.5)*CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-15)),0.3)
	        ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,-0.5)*CFrame.Angles(math.rad(-45),math.rad(0),math.rad(15)),0.3)
	        rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(-75),math.rad(0),math.rad(0)),0.3)
	        lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),0.3)
			end
			for i = 0,2,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			grabbedweld.C0 = grabbedweld.C0:Lerp(CFrame.new(0,-1.25,-3)*CFrame.Angles(0,0,0),i)
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),0.3)
	        torso.C0 = torso.C0:Lerp(CFrame.new(0,-0.35,0)*CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),0.3)
	        rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,-0.5)*CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-15)),0.3)
	        ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,-0.5)*CFrame.Angles(math.rad(-45),math.rad(0),math.rad(15)),0.3)
	        rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(-75),math.rad(0),math.rad(0)),0.3)
	        lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),0.3)
			end
			createsound(22593942,1,8,ch.Head)
			wait(0.6)
			hit.Parent:Destroy()
			local headmesh = ch.Head:FindFirstChildOfClass("SpecialMesh")
			headmesh.Scale = Vector3.new(1.25,1.25,1.25)
			headmesh.Offset = Vector3.new(0,0,0)
			for i = 1,3 do
			for i = 0,4,0.3 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,-0.15)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	        torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
	        rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,0)*CFrame.Angles(math.rad(35),math.rad(0),math.rad(-15)),0.3)
	        ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,0)*CFrame.Angles(math.rad(35),math.rad(0),math.rad(15)),0.3)
	        rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
	        lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			end
			for i = 0,4,0.3 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,-0.15)*CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),0.3)
	        torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
	        rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,-0.2)*CFrame.Angles(math.rad(35),math.rad(0),math.rad(-35)),0.3)
	        ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,-0.2)*CFrame.Angles(math.rad(35),math.rad(0),math.rad(35)),0.3)
	        rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
	        lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			end
			end
			createsound(704088758,0.85,1.25,ch)
			CamShake(root,100,.5,.6)
			for i = 0,12,0.3 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(25),math.rad(0),math.rad(0)),0.3)
	        torso.C0 = torso.C0:Lerp(CFrame.new(0,-0.15,0)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)
	        rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,-0.2)*CFrame.Angles(math.rad(35),math.rad(0),math.rad(-35)),0.3)
	        ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,-0.2)*CFrame.Angles(math.rad(35),math.rad(0),math.rad(35)),0.3)
	        rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(25),math.rad(0),math.rad(0)),0.3)
	        lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(25),math.rad(0),math.rad(0)),0.3)
			end
			root.Anchored = false
			grabbed = false 
			attack = false
			speed = 75
			jpower = 75
		end
	end)
	for i = 0,2,0.1 do
	game:GetService("RunService").Heartbeat:Wait()
	neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
	torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
	rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.5,-0.5)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(-30)),0.3)
	ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.5,-0.5)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(30)),0.3)
	rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
	lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
	end
	if grabbed == false then
		touchthing:Destroy()
		attack = false
		speed = 75
		jpower = 75
	end
end]]

	local damyth = script.Cursed
	damyth.Parent = nil
	hand = damyth.Hand
	hand2 = damyth.Hand2
	hand3 = damyth.Hand3
	hand4 = damyth.Hand4
	hand5 = damyth.Hand5

	ghand = damyth.Hand
	ghand2 = damyth.Hand2
	ghand3 = damyth.Hand3
	ghand4 = damyth.Hand4
	ghand5 = damyth.Hand5

	function handslol()
		local screams = {1025464252,2723006320,2646809257,167285348,205335029,2672793953,1260179732,1093096537,1946318153,149649817,5169624072,5037672265,1929118107,5163677572,3614962759,314568939,5518521023,1549511350,4611276403,527970724,527276541,1080625252,1080363252,5449308964,626777433,1080610583,3483587416,147758746,565424701,535528169}
		coroutine.resume(coroutine.create(function()
			coroutine.wrap(function()
				for i,v in pairs(workspace:GetChildren()) do
					game:GetService("RunService").Heartbeat:Wait()
					if v:IsA("Model") and v ~= ch and v:FindFirstChildOfClass("Humanoid") and v:FindFirstChild("IsRaider") == nil then
						if v:FindFirstChild("OHNOES") == nil then		
							local targerroot = nil
							if v:FindFirstChild("HumanoidRootPart") ~= nil then
								targerroot = v.HumanoidRootPart
							elseif v:FindFirstChild("Torso") then
								targerroot = v.Torso
							end
							local ohnoeslol = Instance.new("BoolValue",v)
							ohnoeslol.Name = "OHNOES"		
							targerroot.Anchored = true		
							hand.Transparency = 0
							ghand.Transparency = 0
							for i = 0.2, 1, 1/60 do 	
								hand.Size = hand.Size:Lerp(targerroot.CFrame, i)	
								game:GetService("RunService").Heartbeat:Wait()
							end
							hand.Transparency = 1
							ghand.Transparency = 1
							targerroot.Anchored = false	
							local weld = Instance.new("Weld",targerroot)
							weld.Part0 = targerroot		
							weld.Part1 = ghand
							for i = 0.2, 1, 1/60 do 	
								hand.Size = hand.Size:Lerp(damyth.Ball.CFrame, i)	
								game:GetService("RunService").Heartbeat:Wait()
							end
							hand.Transparency = 0
							ghand.Transparency = 1
							local screamlol = screams[math.random(1,#screams)]
							local screamlmao = Instance.new("Sound",workspace)
							screamlmao.SoundId = "rbxassetid://"..screamlol
							screamlmao.Volume = 2
							if screamlmao.SoundId == "rbxassetid://626777433" then
								screamlmao.TimePosition = 1.5
								screamlmao.Volume = 0.5
							end
							screamlmao:Play()
							coroutine.wrap(function()
								wait(1.5)
								screamlmao:Destroy()
							end)()
							if v:FindFirstChild("Head") then
								local vheadlol = v:FindFirstChild("Head")
								if vheadlol:FindFirstChild("face") then
									vheadlol:FindFirstChild("face"):Destroy()	
								end					
							end				
							for e,g in pairs(v:GetChildren()) do
								if g:IsA("Accessory") then
									g:Destroy()		
								elseif g:IsA("Part") or g:IsA("MeshPart") then
									g.Transparency = 1						
								end
							end				
							CamShake(root,100,.5,.6)			
							v:BreakJoints()
							createsound(429400881,1,1,workspace)	
							v:Destroy()
						end	
					end
				end
			end)()

			coroutine.wrap(function()
				for i,v in pairs(workspace:GetChildren()) do
					game:GetService("RunService").Heartbeat:Wait()
					if v:IsA("Model") and v ~= ch and v:FindFirstChildOfClass("Humanoid") and v:FindFirstChild("IsRaider") == nil then
						if v:FindFirstChild("OHNOES") == nil then				
							local targerroot = nil
							if v:FindFirstChild("HumanoidRootPart") ~= nil then
								targerroot = v.HumanoidRootPart
							elseif v:FindFirstChild("Torso") then
								targerroot = v.Torso
							end
							local ohnoeslol = Instance.new("BoolValue",v)
							ohnoeslol.Name = "OHNOES"		
							targerroot.Anchored = true	
							hand2.Transparency = 0
							ghand2.Transparency = 1	
							for i = 0.2, 1, 1/60 do 	
								hand2.Size = hand2.Size:Lerp(targerroot.CFrame, i)	
								game:GetService("RunService").Heartbeat:Wait()
							end
							hand.Transparency = 1
							ghand.Transparency = 0
							targerroot.Anchored = false	
							local weld = Instance.new("Weld",targerroot)
							weld.Part0 = targerroot		
							weld.Part1 = ghand2
							for i = 0.2, 1, 1/60 do 	
								hand2.Size = hand2.Size:Lerp(damyth.Ball.CFrame, i)	
								game:GetService("RunService").Heartbeat:Wait()
							end
							hand2.Transparency = 0
							ghand2.Transparency = 1
							local screamlol = screams[math.random(1,#screams)]
							local screamlmao = Instance.new("Sound",workspace)
							screamlmao.SoundId = "rbxassetid://"..screamlol
							screamlmao.Volume = 2
							if screamlmao.SoundId == "rbxassetid://626777433" then
								screamlmao.TimePosition = 1.5
								screamlmao.Volume = 0.5
							end
							screamlmao:Play()
							coroutine.wrap(function()
								wait(1.5)
								screamlmao:Destroy()
							end)()
							if v:FindFirstChild("Head") then
								local vheadlol = v:FindFirstChild("Head")
								if vheadlol:FindFirstChild("face") then
									vheadlol:FindFirstChild("face"):Destroy()	
								end					
							end				
							for e,g in pairs(v:GetChildren()) do
								if g:IsA("Accessory") then
									g:Destroy()		
								elseif g:IsA("Part") or g:IsA("MeshPart") then
									g.Transparency = 1						
								end
							end								
							CamShake(root,100,.5,.6)				
							v:BreakJoints()
							createsound(264486467,1,8,workspace)	
							v:Destroy()
						end	
					end
				end
			end)()

			coroutine.wrap(function()
				for i,v in pairs(workspace:GetChildren()) do
					game:GetService("RunService").Heartbeat:Wait()
					if v:IsA("Model") and v ~= ch and v:FindFirstChildOfClass("Humanoid") and v:FindFirstChild("IsRaider") == nil then
						if v:FindFirstChild("OHNOES") == nil then				
							local targerroot = nil
							if v:FindFirstChild("HumanoidRootPart") ~= nil then
								targerroot = v.HumanoidRootPart
							elseif v:FindFirstChild("Torso") then
								targerroot = v.Torso
							end
							local ohnoeslol = Instance.new("BoolValue",v)
							ohnoeslol.Name = "OHNOES"		
							targerroot.Anchored = true		
							hand3.Transparency = 0
							ghand3.Transparency = 1
							for i = 0.2, 1, 1/60 do 	
								hand3.Size = hand3.Size:Lerp(targerroot.CFrame, i)	
								game:GetService("RunService").Heartbeat:Wait()
							end
							hand3.Transparency = 1
							ghand3.Transparency = 0
							targerroot.Anchored = false	
							local weld = Instance.new("Weld",targerroot)
							weld.Part0 = targerroot		
							weld.Part1 = ghand3
							for i = 0.2, 1, 1/60 do 	
								hand3.Size = hand3.Size:Lerp(damyth.Ball.CFrame, i)	
								game:GetService("RunService").Heartbeat:Wait()
							end
							hand3.Transparency = 1
							ghand3.Transparency = 0
							local screamlol = screams[math.random(1,#screams)]
							local screamlmao = Instance.new("Sound",workspace)
							screamlmao.SoundId = "rbxassetid://"..screamlol
							screamlmao.Volume = 2
							if screamlmao.SoundId == "rbxassetid://626777433" then
								screamlmao.TimePosition = 1.5
								screamlmao.Volume = 0.5
							end
							screamlmao:Play()
							coroutine.wrap(function()
								wait(1.5)
								screamlmao:Destroy()
							end)()
							if v:FindFirstChild("Head") then
								local vheadlol = v:FindFirstChild("Head")
								if vheadlol:FindFirstChild("face") then
									vheadlol:FindFirstChild("face"):Destroy()	
								end					
							end				
							for e,g in pairs(v:GetChildren()) do
								if g:IsA("Accessory") then
									g:Destroy()		
								elseif g:IsA("Part") or g:IsA("MeshPart") then
									g.Transparency = 1						
								end
							end								
							CamShake(root,100,.5,.6)				
							v:BreakJoints()
							createsound(429400881,1,1,workspace)	
							v:Destroy()
						end	
					end
				end
			end)()

			coroutine.wrap(function()
				for i,v in pairs(workspace:GetChildren()) do
					game:GetService("RunService").Heartbeat:Wait()
					if v:IsA("Model") and v ~= ch and v:FindFirstChildOfClass("Humanoid") and v:FindFirstChild("IsRaider") == nil then
						if v:FindFirstChild("OHNOES") == nil then				
							local targerroot = nil
							if v:FindFirstChild("HumanoidRootPart") ~= nil then
								targerroot = v.HumanoidRootPart
							elseif v:FindFirstChild("Torso") then
								targerroot = v.Torso
							end
							local ohnoeslol = Instance.new("BoolValue",v)
							ohnoeslol.Name = "OHNOES"		
							targerroot.Anchored = true		
							hand4.Transparency = 0
							ghand4.Transparency = 1
							for i = 0.2, 1, 1/60 do 	
								hand4.Size = hand4.Size:Lerp(targerroot.CFrame, i)	
								game:GetService("RunService").Heartbeat:Wait()
							end
							hand4.Transparency = 1
							ghand4.Transparency = 0
							targerroot.Anchored = false	
							local weld = Instance.new("Weld",targerroot)
							weld.Part0 = targerroot		
							weld.Part1 = ghand4
							for i = 0.2, 1, 1/60 do 	
								hand4.Size = hand4.Size:Lerp(damyth.Ball.CFrame, i)	
								game:GetService("RunService").Heartbeat:Wait()
							end
							hand4.Transparency = 0
							ghand4.Transparency = 1
							local screamlol = screams[math.random(1,#screams)]
							local screamlmao = Instance.new("Sound",workspace)
							screamlmao.SoundId = "rbxassetid://"..screamlol
							screamlmao.Volume = 2
							if screamlmao.SoundId == "rbxassetid://626777433" then
								screamlmao.TimePosition = 1.5
								screamlmao.Volume = 0.5
							end
							screamlmao:Play()
							coroutine.wrap(function()
								wait(1.5)
								screamlmao:Destroy()
							end)()
							if v:FindFirstChild("Head") then
								local vheadlol = v:FindFirstChild("Head")
								if vheadlol:FindFirstChild("face") then
									vheadlol:FindFirstChild("face"):Destroy()	
								end					
							end				
							for e,g in pairs(v:GetChildren()) do
								if g:IsA("Accessory") then
									g:Destroy()		
								elseif g:IsA("Part") or g:IsA("MeshPart") then
									g.Transparency = 1						
								end
							end				
							CamShake(root,100,.5,.6)				
							v:BreakJoints()
							createsound(264486467,1,8,workspace)
							v:Destroy()	
						end	
					end
				end
			end)()

			for i,v in pairs(workspace:GetChildren()) do
				game:GetService("RunService").Heartbeat:Wait()
				if v:IsA("Model") and v ~= ch and v:FindFirstChildOfClass("Humanoid") and v:FindFirstChild("IsRaider") == nil then
					if v:FindFirstChild("OHNOES") == nil then				
						local ohnoeslol = Instance.new("BoolValue",v)
						local targerroot = nil
						if v:FindFirstChild("HumanoidRootPart") ~= nil then
							targerroot = v.HumanoidRootPart
						elseif v:FindFirstChild("Torso") then
							targerroot = v.Torso
						end
						local ohnoeslol = Instance.new("BoolValue",v)
						ohnoeslol.Name = "OHNOES"		
						targerroot.Anchored = true		
						hand5.Transparency = 0
						ghand5.Transparency = 1
						for i = 0.2, 1, 1/60 do 	
							hand5.CFrame = hand5.CFrame:Lerp(targerroot.CFrame, i)	
							game:GetService("RunService").Heartbeat:Wait()
						end
						hand5.Transparency = 1
						ghand5.Transparency = 0
						targerroot.Anchored = false	
						local weld = Instance.new("Weld",targerroot)
						weld.Part0 = targerroot		
						weld.Part1 = ghand5
						for i = 0.2, 1, 1/60 do 	
							hand5.CFrame = hand5.CFrame:Lerp(damyth.Ball.CFrame, i)	
							game:GetService("RunService").Heartbeat:Wait()
						end
						hand5.Transparency = 0
						ghand5.Transparency = 1
						local screamlol = screams[math.random(1,#screams)]
						local screamlmao = Instance.new("Sound",workspace)
						screamlmao.SoundId = "rbxassetid://"..screamlol
						screamlmao.Volume = 2
						if screamlmao.SoundId == "rbxassetid://626777433" then
							screamlmao.TimePosition = 1.5
							screamlmao.Volume = 0.5
						end
						screamlmao:Play()
						coroutine.wrap(function()
							wait(0.8)
							screamlmao:Destroy()
						end)()
						if v:FindFirstChild("Head") then
							local vheadlol = v:FindFirstChild("Head")
							if vheadlol:FindFirstChild("face") then
								vheadlol:FindFirstChild("face"):Destroy()	
							end					
						end				
						for e,g in pairs(v:GetChildren()) do
							if g:IsA("Accessory") then
								g:Destroy()		
							elseif g:IsA("Part") or g:IsA("MeshPart") then
								g.Transparency = 1						
							end
						end							
						v:BreakJoints()
						CamShake(root,100,.5,.6)
						createsound(429400881,1,1,workspace)
						v:Destroy()	
					end	
				end
			end
			wait(0.5)

			mythtime = false
		end))
	end



	function m_y_t_h()
		attack = true
		speed = 0
		jpower = 0
		damyth.Parent = ch
		local sentences = script.BillboardGui:Clone()
		sentences.Enabled = true
		sentences.Parent = ch.Head
		sentences.TextLabel.Text = "Dad never call me SUN for nothing!"
		local args = {
			[1] = "Dad never call me SUN for nothing!",
			[2] = "All"
		}

		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args))
		spawn(function()
			wait(1)
			repeat
				sentences.TextLabel.TextTransparency = sentences.TextLabel.TextTransparency+0.05
				wait(0.05)
			until sentences.TextLabel.TextTransparency >= 1
			sentences:Destroy()
		end)
		for i = 0,1,0.05 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(25),math.rad(0),math.rad(0)),0.15)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.15)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.35,0.6,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(35)),0.15)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.35,0.6,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-35)),0.15)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.18)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.18)
		end
		spawnwave(root.CFrame*CFrame.new(0,2,0),0)
		spawncircle(root.CFrame*CFrame.new(0,2,0),0)
		for i = 0,20,0.05 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(25),math.rad(0),math.rad(0)),0.15)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,50,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.05)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.35,0.6,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(35)),0.15)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.35,0.6,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-35)),0.15)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.18)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.18)
		end
		coroutine.wrap(function()
			repeat
				game:GetService("RunService").Heartbeat:Wait()
				damyth.Ball.Transparency = damyth.Ball.Transparency - 0.02
				hand.Transparency = hand.Transparency - 0.05
				hand2.Transparency = hand2.Transparency - 0.05
				hand3.Transparency = hand3.Transparency - 0.05
				hand4.Transparency = hand4.Transparency - 0.05
				hand5.Transparency = hand5.Transparency - 0.05
			until damyth.Ball.Transparency < 0
		end)
		local coloreffect = Instance.new("ColorCorrectionEffect",game.Lighting)


		for i = 0,1,0.1 do
			game:GetService("RunService").Heartbeat:Wait()	
			damyth:SetPrimaryPartCFrame(ch.Head.CFrame*CFrame.new(0,0,0))
		end
		for i = 0,6,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(25),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.35,0.6,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(35)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.35,0.6,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-35)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
		end
		local mythlol = Instance.new("Sound",ch)
		mythlol.SoundId = "rbxassetid://2736627515"
		mythlol.Volume = 2
		mythlol:Play()
		handslol()
		repeat 
			game:GetService("RunService").Heartbeat:Wait()
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,-2.5,0)*CFrame.Angles(math.rad(-90+math.random(-4,4)),math.rad(0+math.random(-4,4)),math.rad(0+math.random(-4,4))),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.1,0.5,0.5)*CFrame.Angles(math.rad(180),math.rad(0),math.rad(-25)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.1,0.5,0.5)*CFrame.Angles(math.rad(180),math.rad(0),math.rad(25)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(25)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-25)),0.3)
		until mythtime == false
		for i,v in pairs(workspace:GetChildren()) do
			game:GetService("RunService").Heartbeat:Wait()
			if v:IsA("Model") and v ~= ch and v:FindFirstChildOfClass("Humanoid") and v:FindFirstChild("HumanoidRootPart") ~= nil  then
				v:FindFirstChild("HumanoidRootPart").Anchored = false			
			end		
		end
		coroutine.wrap(function()
			repeat
				game:GetService("RunService").Heartbeat:Wait()
				damyth.OuterBall.OuterBall.Transparency = damyth.Ball.Transparency + 0.02
				damyth.Ball.Transparency = damyth.Ball.Transparency + 0.02
				hand.Transparency = hand.Transparency + 0.05
				hand2.Transparency = hand2.Transparency + 0.05
				hand3.Transparency = hand3.Transparency + 0.05
				hand4.Transparency = hand4.Transparency + 0.05
				hand5.Transparency = hand5.Transparency + 0.05
			until damyth.Ball.Transparency > 1
			damyth.Parent = nil
		end)
		damyth.Parent = nil
		coroutine.wrap(function()
			repeat 
				game:GetService("RunService").Heartbeat:Wait()
				mythlol.Volume = mythlol.Volume - 0.035
			until mythlol.Volume < 0.1
			mythlol:Destroy()
		end)()
		coroutine.wrap(function()
			coloreffect.Saturation = 0
			for i = 0,5,0.1 do
				game:GetService("RunService").Heartbeat:Wait()	
				coloreffect.TintColor = coloreffect.TintColor:Lerp(Color3.new(1,1,1),i)
			end
			coloreffect:Destroy()
		end)()

		attack = false
		speed = 75
		jpower = 75
	end

	-- Humanoid Events

	hum.Running:Connect(function(spd)
		if spd > 0.1 then
			anim = "Walk"
		elseif spd < 0.1 then
			anim = "Idle"	
		end
	end)

	hum.StateChanged:Connect(function()
		if hum:GetState() == Enum.HumanoidStateType.Freefall then
			anim = "Jump"
			wait(0.4)
			anim = "Fall"
		end
	end)

	-- UserInput Stuff

	userinput.InputBegan:Connect(function(key)
		local k = key.KeyCode
		local k2 = key.UserInputType 
		if k2 == Enum.UserInputType.MouseButton1 and attack == false then
			swing()
		end
		if k == Enum.KeyCode.F and attack == false then
			taunt()
		end
		if k == Enum.KeyCode.V and attack == false then
			Randomize()
		end
		if k == Enum.KeyCode.B and attack == false and FATHERWASUMMONDA == false then
			summonfather()
		elseif k == Enum.KeyCode.B and attack == false and FATHERWASUMMONDA == false then
			despawn()
		end
		if k == Enum.KeyCode.X and attack == false then
			flake()
		end
		if k == Enum.KeyCode.Z and attack == false then
			stomp()
		end
		if k == Enum.KeyCode.N and attack == false then
			m_y_t_h()
		end
	end)


	-- Animation

	spawn(function()
		while wait(0.4) do
			if FATHERWASUMMONDA then
				local Targets = GetPartsInArea({CFrame = ch.Torso.CFrame, Size = Vector3.new(25, 35, 25), Region = true})
				for Index, Child in next, Targets do
					local Humanoid = Child:FindFirstChildOfClass("Humanoid")
					if Humanoid then
						local CharTorso = Humanoid.Parent:FindFirstChild("Torso") or Humanoid.Parent:FindFirstChild("UpperTorso")
						if CharTorso ~= nil and Humanoid.Health > 0 and (CharTorso.Position-ch.Torso.Position).magnitude < 30 then
							FATHERDAY(CharTorso)
						end
					end
				end
			end
		end
	end)

	intro()
	while true do
		game:GetService("RunService").Heartbeat:Wait()
		sine = sine + change
		hum.WalkSpeed = speed
		hum.JumpPower = jpower
		hum.MaxHealth = math.huge
		hum.Health = math.huge
		hitbox.Position = root.Position
		if anim == "Jump" and attack == false then
			if FATHERWASUMMONDA then
				baconhair.PrimaryPart.CFrame = baconhair.PrimaryPart.CFrame:Lerp(root.CFrame * CFrame.new(-2.15, 8.3, 2.5), 0.2)
			end
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,5-1*math.cos(sine/64),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.7,0)*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.7,0)*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.4,-0.5)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-0.9,-0.15)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)	
		end
		if anim == "Fall" and attack == false then
			if FATHERWASUMMONDA then
				baconhair.PrimaryPart.CFrame = baconhair.PrimaryPart.CFrame:Lerp(root.CFrame * CFrame.new(-2.15, 8.3, 2.5), 0.2)
			end
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,2.5,0)*CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.7,0)*CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.7,0)*CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.4,-0.5)*CFrame.Angles(math.rad(25),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-0.9,-0.15)*CFrame.Angles(math.rad(25),math.rad(0),math.rad(0)),0.3)	
		end
		if anim == "Idle" and attack == false then
			if FATHERWASUMMONDA then
				baconhair.PrimaryPart.CFrame = baconhair.PrimaryPart.CFrame:Lerp(root.CFrame * CFrame.new(-2.15, 8.3, 2.5), 0.2)
			end
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,5-1*math.cos(sine/64),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.2,0.7,0.3)*CFrame.Angles(math.rad(90),math.rad(10),math.rad(90)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.2,0.7,0.3)*CFrame.Angles(math.rad(90),math.rad(-10),math.rad(-90)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.4,-0.5)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-0.9,-0.15)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)	
		end
		if anim == "Walk" and attack == false then
			if FATHERWASUMMONDA then
				baconhair.PrimaryPart.CFrame = baconhair.PrimaryPart.CFrame:Lerp(root.CFrame * CFrame.new(-2.15, 8.3, 2.5), 0.05)
			end
			neck.C0 = neck.C0:Lerp(CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
			torso.C0 = torso.C0:Lerp(CFrame.new(0,2.5-0.5*math.cos(sine/64),0)*CFrame.Angles(math.rad(-35),math.rad(0),math.rad(0)),0.3)
			rs.C0 = rs.C0:Lerp(CFrame.new(1.5,0.7,0)*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),0.3)
			ls.C0 = ls.C0:Lerp(CFrame.new(-1.5,0.7,0)*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),0.3)
			rh.C0 = rh.C0:Lerp(CFrame.new(0.5,-0.4,-0.5)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)
			lh.C0 = lh.C0:Lerp(CFrame.new(-0.5,-0.9,-0.15)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),0.3)	
		end
	end
end)

Button_14.MouseButton1Down:Connect(function()

	local script = game:GetObjects("rbxassetid://6027805918")[1]

	local AHB = Instance.new("BindableEvent")

	local FPS = 30

	local TimeFrame = 0

	local LastFrame = tick()
	local Frame = 1/FPS

	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end

	-- converter by Drahazar

	--created by helkern
	--some things might be taken from other scripts

	wait(1/60)

	Player = game:GetService("Players").LocalPlayer
	PlayerGui = Player.PlayerGui
	Cam = workspace.CurrentCamera
	Backpack = Player.Backpack
	Character = Player.Character["Dummy"]
	Humanoid = Character.Humanoid
	Mouse = Player:GetMouse()
	RootPart = Character["HumanoidRootPart"]
	Torso = Character["Torso"]
	Head = Character["Head"]
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	local sick = Instance.new("Sound",Torso)

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor


	Animation_Speed = 3
	Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
	local Speed = 60
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local neck2 = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local ANIM = "Idle"
	local ATTACK = false
	local EQUIPPED = false
	local HOLD = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local KEYHOLD = false
	local CHANGE = 2 / Animation_Speed
	local WALKINGANIM = false
	--ROBLOXIDLEANIMATION.Parent = Humanoid
	local Effects = IT("Folder", Character)
	Effects.Name = "Effects"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character.Animate
	ANIMATOR:Destroy()
	local UNANCHOR = true
	local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}	
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)


	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function Clerp(a, b, t)
		return a:lerp(b,t)
	end



	function weld(parent, part0, part1, c0, c1)
		local w = IT("Weld")
		w.Part0 = part0
		w.Part1 = part1
		w.C0 = c0
		w.C1 = c1
		w.Parent = parent
		return w
	end

	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.EmitterSize = 5*VOLUME
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

	function WACKYEFFECT2(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or VT(1,1,1))
		local ENDSIZE = (Table.Size2 or VT(0,0,0))
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local MOVEDIRECTION = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLORLOOP = (Table.ColorLoop or false)
		local COLOR = (Table.Color or C3(1,1,1))
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
		local BOOMERANG = (Table.Boomerang or 0)
		local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
			elseif TYPE == "Block" or TYPE == "Box" then
				MSH = IT("BlockMesh",EFFECT)
				MSH.Scale = SIZE
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
			end
			if MSH ~= nil then
				local BOOMR1 = 1+BOOMERANG/50
				local BOOMR2 = 1+SIZEBOOMERANG/50
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					if USEBOOMERANGMATH == true then
						MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
					else
						MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
					end
				end
				local GROWTH = nil
				if USEBOOMERANGMATH == true then
					GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
				else
					GROWTH = (SIZE - ENDSIZE)
				end
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				if USEBOOMERANGMATH == true then
					for LOOP = 1, TIME+1 do
						Swait()
						if COLORLOOP == true then
							EFFECT.Color = COLOR
						end
						MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
							EFFECT.Orientation = ORI
						end
					end
				else
					for LOOP = 1, TIME+1 do
						Swait()
						if COLORLOOP == true then
							EFFECT.Color = COLOR
						end
						MSH.Scale = MSH.Scale - GROWTH/TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
							EFFECT.Orientation = ORI
						end
					end
				end
				EFFECT.Transparency = 1
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			else
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			end
		end))
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	local HSV = Color3.fromHSV
	local Hue = 0
	local Brightness = 0.5
	local RainbowColor = HSV(0, 0, 0)
	local Increment = 2
	ArtificialHB.Event:Connect(function()
		Hue = Hue + Increment if Hue >= 360 then
			Hue = 0 
		end 
		RainbowColor = HSV(Hue / 360, Brightness, Brightness)
	end)

	Debris = game:GetService("Debris")

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end


	function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)

	end
	function attcf(wh)
		return wh.Parent.CFrame*CF(wh.Position)
	end



	--weap
	local SONG = 4447145150
	d = CF(0,0,0)
	local la = IT("Weld")
	local ra = IT("Weld")
	RightShoulder.Parent = nil
	LeftShoulder.Parent = nil
	ra.Name = "ra"
	ra.Part0 = Torso 
	ra.C0 = CF(1.5, 0.5, 0)
	ra.C1 = CF(0, 0.5, 0)
	ra.Part1 = RightArm
	ra.Parent = Torso  

	la.Name = "la"
	la.Part0 = Torso 
	la.C0 = CF(-1.5, 0.5, 0)
	la.C1 = CF(0, 0.5, 0) 
	la.Part1 = LeftArm
	la.Parent = Torso

	local lh = weld(LeftLeg,Torso,LeftLeg,CF(-.5,-1,0),d)
	lh.C1 = CF(0,1,0)
	local rh = weld(RightLeg,Torso,RightLeg,CF(.5,-1,0),d)
	rh.C1 = CF(0,1,0)

	local beat = script.beat
	local stick = beat.stick
	local weld1 = weld(Torso,beat.Main,Torso,CF(0,-1,0),d)
	local weld2 = weld(RightArm,stick.Main,RightArm,d,d)
	local stickweld = stick.stickw
	local panelweld = beat.welder.uuu
	for i,v in pairs(beat:GetDescendants()) do if v:IsA("BasePart") then v.Anchored = false end end
	beat.Parent = Character
	local letters = {}
	for f,g in pairs(beat.screen:GetChildren()) do if g:IsA("Weld") then table.insert(letters,g) end end

	local hat = game:GetService("Players").LocalPlayer.Character["Hat1"]

	hat.Handle.AccessoryWeld:Destroy()

	local function align(part0, part1)
		part1.Transparency = 1
		part0.Mesh:Destroy()
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0, 0, -0.7) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(0, 90, 0) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	align(hat.Handle, stick)





	local dead = false
	--dmg
	function DEATH(MODEL)
		MODEL:BreakJoints()
		for index, CHILD in pairs(MODEL:GetChildren()) do
			if CHILD.Name == "Torso" then
				CHILD.Name = "stuff"..MRANDOM(1,10000)..""
			end
			coroutine.resume(coroutine.create(function()
				swait(MRANDOM(8,12)/10)
				if CHILD:IsA("BasePart") and CHILD.Name ~= "HumanoidRootPart" then
					if CHILD.Name == "Head" then
						WACKYEFFECT2({Time = 120, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)*1.2), Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(0,50),MRANDOM(0,50),MRANDOM(0,50)), RotationX = MRANDOM(-4,4), RotationY = MRANDOM(-4,4), RotationZ = MRANDOM(-4,4), Material = "Neon",ColorLoop = true, Color = RainbowColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, SizeBoomerang = 0, Boomerang = 35})
					elseif CHILD.Name ~= "HumanoidRootPart" then
						WACKYEFFECT2({Time = 120, EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size*1.2, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(0,50),MRANDOM(0,50),MRANDOM(0,50)), RotationX = MRANDOM(-4,4), RotationY = MRANDOM(-4,4), RotationZ = MRANDOM(-4,4) ,Material = "Neon",ColorLoop = true, Color = RainbowColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, SizeBoomerang = 0, Boomerang = 35})
					end
					CHILD:remove()
				end
			end))
		end
		Debris:AddItem(MODEL,6)
	end
	function ApplyDamage(Humanoid,Damage)

	end

	function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
		for index, CHILD in pairs(workspace:GetDescendants()) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if INSTAKILL == true then
								--DEATH(CHILD)
							else
								local DMG = MRANDOM(MINDMG,MAXDMG)
								ApplyDamage(HUM,DMG)
							end
							if FLING > 0 then
								for _, c in pairs(CHILD:GetChildren()) do
									if c:IsA("BasePart") then
										local bv = Instance.new("BodyVelocity") 
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
										bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
										bv.Parent = c
										Debris:AddItem(bv,0.05)
									end
								end
							end
						end
					end
				end
			end
		end
	end

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	v.Anchored = false

	local Outline = Instance.new("SelectionBox", v)
	Outline.LineThickness = 0.1
	Outline.Color3 = Color3.fromRGB(195, 130, 0)
	Outline.Adornee = v

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if ATTACK == false then
				bp.Position = game.Players.LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)

	local potating = false

	--attacks
	function slamthatmfingstick()
		potating = true
		ATTACK = true
		stick.Touched:Connect(function(hit)
			if hit.Parent:FindFirstChild("Humanoid") and potating == true then
				if hit.Parent.Name == game.Players.LocalPlayer.Name then
					--print("not flinging")
				else
					if hit.Parent:FindFirstChild("UpperTorso") then
						bp.Position = hit.Parent:FindFirstChild("UpperTorso").Position
					elseif hit.Parent:FindFirstChild("Torso") then
						bp.Position = hit.Parent:FindFirstChild("Torso").Position
					end
				end
			end
		end)
		coroutine.resume(coroutine.create(function()
			for i = 1,30 do
				Swait()
				WACKYEFFECT2({Time = 20, EffectType = "Sphere", Size = VT(.5,2,.5), Size2 = VT(.5,4,1), Transparency = 0, Transparency2 = 1, CFrame = stick.CFrame*CF(2,0,0)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 25})
			end
		end))
		for i = 0,19 do
			Swait()
			local Alpha = .25
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0.2)*ANGLES(RAD(-7.3),RAD(-42.8),RAD(-5))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-16.2),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(-20.4),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,0.5,0.3)*ANGLES(RAD(5.7),RAD(32),RAD(-10.6)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.3,1.1,0.2)*ANGLES(RAD(-150.2),RAD(3.9),RAD(-9.6)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(5.3),RAD(0),RAD(43)),Alpha)
		end
		for i = 0,5 do
			local Alpha = .2
			RootJoint.C0 = RootJoint.C0:lerp(CF(0.2,0,-0.1)*ANGLES(RAD(-31.5),RAD(38.5),RAD(4.3))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-1.1,-0.4)*ANGLES(RAD(3.5),RAD(-3.1),RAD(15)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.3,0,-0.7)*ANGLES(RAD(-0.5),RAD(-4.2),RAD(14.8)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,0.5,0.3)*ANGLES(RAD(5.7),RAD(32),RAD(-10.6)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.6,0.1)*ANGLES(RAD(82.1),RAD(21),RAD(16.6)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(5.3),RAD(0),RAD(-38.7)),Alpha)
		end
		CreateSound(1577567682,stick,8,1,false)
		for i = 1,12 do
			WACKYEFFECT2({Time = 40, EffectType = "Box", Size = VT(1,1,1), Size2 = VT(7,7,7), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(2,-3,-1), MoveToPos = nil, RotationX = MRANDOM(-30,30), RotationY = MRANDOM(-30,30), RotationZ = MRANDOM(-30,30), Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		end
		for i = 1,12 do
			WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(.7,.7,.7), Size2 = VT(1.2,1.2,1.2), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(2,-3,-1), MoveToPos = RootPart.Position+VT(MRANDOM(-15,15),MRANDOM(0,15),MRANDOM(-15,15)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 35, SizeBoomerang = 0})
		end
		for i = 0,15 do
			Swait()
			local Alpha = .3
			RootJoint.C0 = RootJoint.C0:lerp(CF(0.2,0,-0.1)*ANGLES(RAD(-31.5),RAD(38.5),RAD(4.3))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-1.1,-0.4)*ANGLES(RAD(3.5),RAD(-3.1),RAD(15)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.3,0,-0.7)*ANGLES(RAD(-0.5),RAD(-4.2),RAD(14.8)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,0.5,0.3)*ANGLES(RAD(5.7),RAD(32),RAD(-10.6)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.6,0.5,-0.4)*ANGLES(RAD(-5.2),RAD(-16.8),RAD(20.8)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(5.3),RAD(0),RAD(-38.7)),Alpha)
		end	ApplyAoE(stick.Position,7,0,0,20,true)
		ATTACK = false
		potating = false
	end

	function fyoudeathray()
		ATTACK = true
		local s = CreateSound(4453403748,RootPart,8,1,false)
	--[[spawn(function()
	swait(2)	
	CreateSound(200633780,RootPart,8,1,false)
	end)]]
		local garmp = attcf(LeftArm.LeftGripAttachment)
		for i = 0,80 do
			Swait()
			local Alpha = .1
			local armp = attcf(LeftArm.LeftGripAttachment)
			if MRANDOM(1,2) == 1 then
				WACKYEFFECT2({Time = 20, EffectType = "Sphere", Size = VT(.5,.5,.5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1,0)*CF(MRANDOM(-2,2),MRANDOM(-2,2),MRANDOM(-2,2)), MoveToPos = armp.p, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			end
			if MRANDOM(1,4) == 1 then
				WACKYEFFECT2({Time = 60, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(1.3,1.3,1.3), Transparency = 0, Transparency2 = 1, CFrame = armp, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
			end
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.1+0.2*COS(SINE/5),0.5)*ANGLES(RAD(10.8),RAD(0),RAD(0))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-0.9,-0.1)*ANGLES(RAD(-32.4),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.5,-0.9)*ANGLES(RAD(-36.6),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,0.3+0.2*SIN(SINE/5),0.2)*ANGLES(RAD(43.2),RAD(11.2),RAD(-40.6)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.5+0.2*SIN(SINE/5),0.1)*ANGLES(RAD(-11.3),RAD(-9.3),RAD(4.7)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(15.5),RAD(0),RAD(0)),Alpha)
		end
		local deathlaser = CreatePart(3,Effects,"Neon",0,0,"White","DEATH LASER",VT(1,1,1),true)
		--MakeForm(deathlaser,"Cyl")
		repeat
			Swait()
			local armp = attcf(LeftArm.LeftGripAttachment)
			local h,ps = CastProperRay(armp.p,  Mouse.Hit.p, 500, Character)
			local dist = (ps - armp.p).Magnitude
			local Alpha = .2
			deathlaser.Color = RainbowColor
			deathlaser.CFrame = CF(armp.p,ps)*CF(0,0,-dist/2)
			deathlaser.Size = VT(4+.3*COS(SINE/6),4+.3*COS(SINE/6),dist)
			if h then
				ApplyAoE(ps,30,0,0,35,true)
				if MRANDOM(1,2) == 1 then
					WACKYEFFECT2({Time = 20, EffectType = "Sphere", Size = VT(2,2,2)*10, Size2 = VT(8,8,8)*10, Transparency = 0, Transparency2 = 1, CFrame = CF(ps), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
				end	
				if MRANDOM(1,2) == 1 then
					WACKYEFFECT2({Time = 20, EffectType = "Round Slash", Size = VT(.01,.01,.01)*10, Size2 = VT(.07,.01,.07)*10, Transparency = 0, Transparency2 = 1, CFrame = CF(ps)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = ps+VT(0,3,0), RotationX = 0, RotationY = MRANDOM(8,8), RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
				end 
				if MRANDOM(1,2) == 1 then
					WACKYEFFECT2({Time = 20, EffectType = "Round Slash", Size = VT(.01,.01,.01)*10, Size2 = VT(.05,.01,.05)*10, Transparency = 0, Transparency2 = 1, CFrame = armp*ANGLES(0,RAD(MRANDOM(-360,360)),0), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-5,5), RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
					WACKYEFFECT2({Time = 20, EffectType = "Sphere", Size = VT(2,2,2)*10, Size2 = VT(6,6,6)*10, Transparency = 0, Transparency2 = 1, CFrame = CF(ps), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
				end
				if MRANDOM(1,4) == 1 then
					WACKYEFFECT2({Time = 20, EffectType = "Ring", Size = VT(8,8,8), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(ps)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = MRANDOM(-1,1), RotationY = MRANDOM(-1,1), RotationZ = MRANDOM(-1,1), Material = "Neon",ColorLoop = true,Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 50})
				end
			end
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.1,0.7)*ANGLES(RAD(15.5),RAD(-45.3),RAD(11.2))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-0.9,-0.1)*ANGLES(RAD(-32.4),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.5,-0.9)*ANGLES(RAD(-36.6),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.3,0.3,-0.1)*ANGLES(RAD(83.1),RAD(-0.7),RAD(-48.3)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.4,0.1)*ANGLES(RAD(-11.3),RAD(-9.3),RAD(4.7)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(-5.6),RAD(0),RAD(46.3)),Alpha)
		until s.TimePosition == s.TimeLength
		deathlaser:Destroy()
		ATTACK = false
	end

	function milktp()
		ATTACK = true
		local milk = script.milk:Clone()
		milk.Anchored = false
		milk.Parent = Character
		local milkweld = weld(milk,milk,LeftArm,CF(0,0,1)*ANGLES(RAD(90),0,0),d)
		for i = 0,20 do
			Swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(-0.2,0,0.2)*ANGLES(RAD(-6.3),RAD(32.5),RAD(3.4))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-16.2),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(-20.4),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,1,0.2)*ANGLES(RAD(-169.2),RAD(-2.1),RAD(-24.6)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.5,0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(5.3),RAD(0),RAD(-32.7)),Alpha)
		end
		for i = 0,5 do
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,0,0.2)*ANGLES(RAD(-6.2),RAD(-30.5),RAD(-3.2))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-16.2),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(-20.4),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.3,1.1,-0.3)*ANGLES(RAD(159.9),RAD(42.7),RAD(-32.2)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.5,0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(5.3),RAD(0),RAD(30.6)),Alpha)
		end
		for i = 0,17 do
			Swait()
			local Alpha = .2
			RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,0.1,0)*ANGLES(RAD(-30.9),RAD(-30.5),RAD(-3.2))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.6,-0.9,-0.2)*ANGLES(RAD(5.4),RAD(2.4),RAD(-12.3)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(1.3),RAD(3.2),RAD(-12.1)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,0.3,-0.3)*ANGLES(RAD(48.9),RAD(7.6),RAD(18.9)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.5,0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(30.1),RAD(0),RAD(25.7)),Alpha)
		end
		milk:Destroy()
		CreateSound(200633837,RootPart,5,2,false)
		WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(11,1,11), Size2 = VT(55,0,55), Transparency = .2, Transparency2 = 1, CFrame = CF(RootPart.Position)*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(5,22,5), Size2 = VT(45,75,45), Transparency = .2, Transparency2 = 1, CFrame = CF(RootPart.Position)*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		for i = 1,5 do
			WACKYEFFECT2({Time = 40, EffectType = "Round Slash", Size = VT(.01,.01,.01), Size2 = VT(.3,.01,.3), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.9,0)*ANGLES(RAD(0),RAD(MRANDOM(-360,360)),0), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-6,6), RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 10})
		end
		for i = 1,10 do
			WACKYEFFECT2({Time = 40, EffectType = "Box", Size = VT(4,4,4), Size2 = VT(10,10,10), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = MRANDOM(-30,30), RotationY = MRANDOM(-30,30), RotationZ = MRANDOM(-30,30), Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
		end
		local hf,hp = Raycast(Mouse.Hit.p+VT(0,1,0), (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 100, Character)
		hp = hp + VT(0,3.5,0)
		local POS = RootPart.Position
		RootPart.CFrame = CF(hp,CF(POS,hp)*CF(0,0,-100000).p)
		CreateSound(200633837,RootPart,5,2,false)
		ApplyAoE(RootPart.Position,10,0,0,30,true)
		WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(11,1,11), Size2 = VT(55,0,55), Transparency = .2, Transparency2 = 1, CFrame = CF(RootPart.Position)*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(5,22,5), Size2 = VT(45,75,45), Transparency = .2, Transparency2 = 1, CFrame = CF(RootPart.Position)*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		for i = 1,5 do
			WACKYEFFECT2({Time = 40, EffectType = "Round Slash", Size = VT(.01,.01,.01), Size2 = VT(.3,.01,.3), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.9,0)*ANGLES(RAD(0),RAD(MRANDOM(-360,360)),0), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-6,6), RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 10})
		end
		for i = 1,10 do
			WACKYEFFECT2({Time = 40, EffectType = "Box", Size = VT(4,4,4), Size2 = VT(10,10,10), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = MRANDOM(-30,30), RotationY = MRANDOM(-30,30), RotationZ = MRANDOM(-30,30), Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
		end
		ATTACK = false
	end
	function beattodeath()
		ATTACK = true
		local ttors
		local beat = false
		local hum
		local hb = CreatePart(3,Effects,"Plastic",0,1,"White","hitbox",VT(2, 2, 2),false)
		local hbw = weld(LeftLeg,hb,LeftLeg,CF(0,2,0),d)
		local hitt = hb.Touched:Connect(function(h)
			if h.Parent:FindFirstChildOfClass("Humanoid") then
				if h.Parent:FindFirstChildOfClass("Humanoid").Health ~= 0 then
					hum = h.Parent:FindFirstChildOfClass("Humanoid")
					hp = hum.Health
					ttors = h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")
					ttors.CFrame = RootPart.CFrame * CF(0,-2.5,-3) * ANGLES(RAD(90), RAD(0), RAD(180))
					ttors.Anchored = true
					beat = true
				end
			end	
		end)
		for i = 0,27 do
			if beat == true then break end
			Swait()
			local Alpha = .3
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0.7)*ANGLES(RAD(16.5),RAD(0),RAD(0))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.3,-1.1,-0.3)*ANGLES(RAD(69.9),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.9,-0.3)*ANGLES(RAD(-42.2),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.4,0.5,0)*ANGLES(RAD(0.6),RAD(3.8),RAD(-9)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.5,0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(17.4),RAD(0),RAD(0)),Alpha)
		end
		hitt:Disconnect()
		local a = false
		coroutine.resume(coroutine.create(function()
			swait(3)
			a = true
		end))
		if beat == true then
			repeat
				Rooted = true
				for i = 0,5 do
					Swait()
					local Alpha = .5
					stickweld.C0 = stickweld.C0:lerp(d*ANGLES(RAD(0),RAD(0),RAD(0)),.1)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0.2)*ANGLES(RAD(8.5),RAD(0),RAD(0))*ROOTC0,Alpha)
					lh.C0 = lh.C0:lerp(CF(-0.5,-1,-0.1)*ANGLES(RAD(-8.1),RAD(7),RAD(-3.3)),Alpha)
					rh.C0 = rh.C0:lerp(CF(0.5,-1,-0.1)*ANGLES(RAD(-8),RAD(-7.5),RAD(3.8)),Alpha)
					la.C0 = la.C0:lerp(CF(-1,1,0.8)*ANGLES(RAD(-149.6),RAD(0),RAD(29.5)),Alpha)
					ra.C0 = ra.C0:lerp(CF(1,0.9,0.7)*ANGLES(RAD(-149.6),RAD(0),RAD(-22.7)),Alpha)
					Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
				end
				for i = 0,5 do
					local Alpha = .5
					stickweld.C0 = stickweld.C0:lerp(d*ANGLES(RAD(0),RAD(0),RAD(0)),.1)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.2)*ANGLES(RAD(-25.7),RAD(0),RAD(0))*ROOTC0,Alpha)
					lh.C0 = lh.C0:lerp(CF(-0.5,-0.9,-0.3)*ANGLES(RAD(26.1),RAD(7),RAD(-3.3)),Alpha)
					rh.C0 = rh.C0:lerp(CF(0.5,-0.9,-0.3)*ANGLES(RAD(26.2),RAD(-7.5),RAD(3.8)),Alpha)
					la.C0 = la.C0:lerp(CF(-1,1.1,0.1)*ANGLES(RAD(-167.4),RAD(0),RAD(29.5)),Alpha)
					ra.C0 = ra.C0:lerp(CF(1,1,0.1)*ANGLES(RAD(-167.4),RAD(0),RAD(-22.7)),Alpha)
					Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
				end
				for i = 0,7 do
					Swait()
					local Alpha = .5
					stickweld.C0 = stickweld.C0:lerp(CF(0,2,0)*ANGLES(RAD(0),RAD(0),RAD(70)),.1)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0.1,-0.6)*ANGLES(RAD(-38.3),RAD(0),RAD(0))*ROOTC0,Alpha)
					lh.C0 = lh.C0:lerp(CF(-0.5,-1.2,-0.3)*ANGLES(RAD(38.7),RAD(7),RAD(-3.3)),Alpha)
					rh.C0 = rh.C0:lerp(CF(0.5,-1.2,-0.3)*ANGLES(RAD(38.8),RAD(-7.5),RAD(3.8)),Alpha)
					la.C0 = la.C0:lerp(CF(-1,0,-1)*ANGLES(RAD(60.2),RAD(0),RAD(29.5)),Alpha)
					ra.C0 = ra.C0:lerp(CF(1,0.1,-0.9)*ANGLES(RAD(60.2),RAD(0),RAD(-22.7)),Alpha)
					Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
					if hum.Health == 0 or not hum.Parent then
						a = true
					end
				end
				local hd = hum.Parent:FindFirstChild("Head")
				if hd then
					WACKYEFFECT2({Time = 30, EffectType = "Box", Size = VT(hd.Size.Z,hd.Size.Y,hd.Size.Z), Size2 = VT(hd.Size.Z,hd.Size.Y,hd.Size.Z)*1.6, Transparency = 0, Transparency2 = 1, CFrame = hd.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = 4018616850, SoundPitch = 1, SoundVolume = 5, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
				end
			until a == true
			if hum.Parent then
				--DEATH(hum.Parent)
			end
		end
		Rooted = false
		ATTACK = false
	end

	function cs()
		if SONG == 4447145150 then
			SONG = 3252017264
		elseif SONG == 3252017264 then
			SONG = 4368711751
		elseif SONG == 4368711751 then
			SONG = 4035306718
		elseif SONG == 4035306718 then
			SONG = 3863023710
		elseif SONG == 3863023710 then
			SONG = 616388964
		elseif SONG == 616388964 then
			SONG = 1059884825
		elseif SONG == 1059884825 then
			SONG = 4447145150
		end
	end

	--keys
	function MouseDown(Mouse)
		HOLD = true
		if ATTACK == false then
			slamthatmfingstick()
		end
	end

	function MouseUp(Mouse)
		HOLD = false
	end

	function KeyDown(Key)
		KEYHOLD = true
		if Key == "z" and ATTACK == false then
			fyoudeathray()
		end
		if Key == "x" and ATTACK == false then
			milktp()
		end

		if Key == "c" and ATTACK == false then
			beattodeath()
		end

		if Key == "v" and ATTACK == false then

		end

		if Key == "b" and ATTACK == false then

		end
		if Key == "m" then
			cs()
		end

		if Key == "]" and ATTACK == false then
			if sick.Parent ~= Character then
				sick = IT("Sound",Torso)
				sick.SoundId = "rbxassetid://"..SONG
			end
		end
	end

	function KeyUp(Key)
		KEYHOLD = false
	end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

	function unanchor()
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA("BasePart") and c ~= RootPart then
				c.Anchored = false
			end
		end
		if UNANCHOR == true then
			RootPart.Anchored = false
		else
			RootPart.Anchored = true
		end
	end

	--loop stuff

	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)


	while true do
		Swait()
		ANIMATE.Parent = nil
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		SINE = SINE + CHANGE*2
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
		local TiltVelocity = CF(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity/1.6))
		local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
				ra.C0 = Clerp(ra.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))), 1 / Animation_Speed)
				la.C0 = Clerp(la.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))), 1 / Animation_Speed)
				rh.C0 = Clerp(rh.C0, CF(.5, -0.4, -0.6) * ANGLES(RAD(1), RAD(0), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				lh.C0 = Clerp(lh.C0, CF(-.5, -1, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				ra.C0 = Clerp(ra.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))), 1 / Animation_Speed)
				la.C0 = Clerp(la.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))), 1 / Animation_Speed)
				rh.C0 = Clerp(rh.C0, CF(.5, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(0), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				lh.C0 = Clerp(lh.C0, CF(-.5, -0.8, -0.3) * ANGLES(RAD(-10), RAD(10), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			local Alpha = .1
			ANIM = "Idle"
			if ATTACK == false then
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,1+0.6*COS(SINE/25),0.1)*ANGLES(RAD(-5.3+3*SIN(SINE/25)),RAD(0),RAD(0))*ROOTC0,Alpha)
				lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-16.2+5*SIN(SINE/25)),RAD(0),RAD(0)),Alpha)
				rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(-20.4+5*SIN(SINE/25)),RAD(0),RAD(0)),Alpha)
				la.C0 = la.C0:lerp(CF(-1.4,0.5+0.05*COS(SINE/25),0)*ANGLES(RAD(0.6),RAD(3.8),RAD(-9+3.6*SIN(SINE/25))),Alpha)
				ra.C0 = ra.C0:lerp(CF(1.4,0.5+0.05*COS(SINE/25),0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5-3.6*SIN(SINE/25))),Alpha)
				Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(5.3+3*SIN(SINE/25)),RAD(0),RAD(0)),Alpha)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				local Alpha = .1
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,1+0.6*COS(SINE/25),0.1)*ANGLES(RAD(-5.3+3*SIN(SINE/25)+RAD(TiltVelocity.Z*45)),RAD(0),RAD(0-RAD(TiltVelocity.X*10)))*ROOTC0,Alpha)
				lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-16.2+5*SIN(SINE/25)+RAD(TiltVelocity.Z*5)),RAD(0),RAD(0-RAD(TiltVelocity.X*19))),Alpha)
				rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(-20.4+5*SIN(SINE/25)+RAD(TiltVelocity.Z*5)),RAD(0),RAD(0-RAD(TiltVelocity.X*19))),Alpha)
				la.C0 = la.C0:lerp(CF(-1.4,0.5+0.05*COS(SINE/25),0)*ANGLES(RAD(0.6),RAD(3.8),RAD(-9+3.6*SIN(SINE/25))),Alpha)
				ra.C0 = ra.C0:lerp(CF(1.4,0.5+0.05*COS(SINE/25),0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5-3.6*SIN(SINE/25))),Alpha)
				Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(-5.3+3*SIN(SINE/25)+RAD(TiltVelocity.Z*45)),RAD(0),RAD(-2*COS(SINE/25))-RAD(TiltVelocity.X*1.5)),Alpha)
			end
		end
		stick.p1.Color = ColorSequence.new(RainbowColor)
		stick.p2.Color = ColorSequence.new(RainbowColor)
		stick.p3.Color = ColorSequence.new(RainbowColor)
		for i = 1,#letters do
			letters[i].C0 = letters[i].C0:lerp(CF(0,0+(i/80)*COS(SINE/30),0)*ANGLES(RAD(0),RAD(0),RAD(0+(i/12)*SIN(SINE/30))),.1)
		end
		panelweld.C0 = panelweld.C0:lerp(CF(0,0+.5*COS(SINE/68),0)*ANGLES(RAD(0),RAD(0),RAD(-5*SIN(SINE/68))),.1)
		if ATTACK == false then
			stickweld.C0 = stickweld.C0:lerp(CF(0,0,0),.1)
		end
		unanchor()
		Humanoid.MaxHealth = 1e4
		Humanoid.Health = 1e4
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		sick.SoundId = "rbxassetid://"..SONG
		sick.Looped = true
		sick.Pitch = 1
		sick.Volume = 3
		sick.Playing = true
	end
end)

Button_15.MouseButton1Down:Connect(function()

	local script = game:GetObjects("rbxassetid://6027805918")[1]

	local AHB = Instance.new("BindableEvent")

	local FPS = 30

	local TimeFrame = 0

	local LastFrame = tick()
	local Frame = 1/FPS

	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end

	-- converter by Drahazar

	--created by helkern
	--some things might be taken from other scripts

	wait(1/60)

	Player = game:GetService("Players").LocalPlayer
	PlayerGui = Player.PlayerGui
	Cam = workspace.CurrentCamera
	Backpack = Player.Backpack
	Character = Player.Character["Dummy"]
	Humanoid = Character.Humanoid
	Mouse = Player:GetMouse()
	RootPart = Character["HumanoidRootPart"]
	Torso = Character["Torso"]
	Head = Character["Head"]
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	local sick = Instance.new("Sound",Torso)

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor


	Animation_Speed = 3
	Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
	local Speed = 60
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local neck2 = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local ANIM = "Idle"
	local ATTACK = false
	local EQUIPPED = false
	local HOLD = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local KEYHOLD = false
	local CHANGE = 2 / Animation_Speed
	local WALKINGANIM = false
	--ROBLOXIDLEANIMATION.Parent = Humanoid
	local Effects = IT("Folder", Character)
	Effects.Name = "Effects"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character.Animate
	ANIMATOR:Destroy()
	local UNANCHOR = true
	local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}	
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)


	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function Clerp(a, b, t)
		return a:lerp(b,t)
	end



	function weld(parent, part0, part1, c0, c1)
		local w = IT("Weld")
		w.Part0 = part0
		w.Part1 = part1
		w.C0 = c0
		w.C1 = c1
		w.Parent = parent
		return w
	end

	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.EmitterSize = 5*VOLUME
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

	function WACKYEFFECT2(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or VT(1,1,1))
		local ENDSIZE = (Table.Size2 or VT(0,0,0))
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local MOVEDIRECTION = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLORLOOP = (Table.ColorLoop or false)
		local COLOR = (Table.Color or C3(1,1,1))
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
		local BOOMERANG = (Table.Boomerang or 0)
		local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
			elseif TYPE == "Block" or TYPE == "Box" then
				MSH = IT("BlockMesh",EFFECT)
				MSH.Scale = SIZE
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
			end
			if MSH ~= nil then
				local BOOMR1 = 1+BOOMERANG/50
				local BOOMR2 = 1+SIZEBOOMERANG/50
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					if USEBOOMERANGMATH == true then
						MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
					else
						MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
					end
				end
				local GROWTH = nil
				if USEBOOMERANGMATH == true then
					GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
				else
					GROWTH = (SIZE - ENDSIZE)
				end
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				if USEBOOMERANGMATH == true then
					for LOOP = 1, TIME+1 do
						Swait()
						if COLORLOOP == true then
							EFFECT.Color = COLOR
						end
						MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
							EFFECT.Orientation = ORI
						end
					end
				else
					for LOOP = 1, TIME+1 do
						Swait()
						if COLORLOOP == true then
							EFFECT.Color = COLOR
						end
						MSH.Scale = MSH.Scale - GROWTH/TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
							EFFECT.Orientation = ORI
						end
					end
				end
				EFFECT.Transparency = 1
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			else
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			end
		end))
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	local HSV = Color3.fromHSV
	local Hue = 0
	local Brightness = 0.5
	local RainbowColor = HSV(0, 0, 0)
	local Increment = 2
	ArtificialHB.Event:Connect(function()
		Hue = Hue + Increment if Hue >= 360 then
			Hue = 0 
		end 
		RainbowColor = HSV(Hue / 360, Brightness, Brightness)
	end)

	Debris = game:GetService("Debris")

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end


	function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)

	end
	function attcf(wh)
		return wh.Parent.CFrame*CF(wh.Position)
	end



	--weap
	local SONG = 4447145150
	d = CF(0,0,0)
	local la = IT("Weld")
	local ra = IT("Weld")
	RightShoulder.Parent = nil
	LeftShoulder.Parent = nil
	ra.Name = "ra"
	ra.Part0 = Torso 
	ra.C0 = CF(1.5, 0.5, 0)
	ra.C1 = CF(0, 0.5, 0)
	ra.Part1 = RightArm
	ra.Parent = Torso  

	la.Name = "la"
	la.Part0 = Torso 
	la.C0 = CF(-1.5, 0.5, 0)
	la.C1 = CF(0, 0.5, 0) 
	la.Part1 = LeftArm
	la.Parent = Torso

	local lh = weld(LeftLeg,Torso,LeftLeg,CF(-.5,-1,0),d)
	lh.C1 = CF(0,1,0)
	local rh = weld(RightLeg,Torso,RightLeg,CF(.5,-1,0),d)
	rh.C1 = CF(0,1,0)

	local beat = script.beat
	local stick = beat.stick
	local weld1 = weld(Torso,beat.Main,Torso,CF(0,-1,0),d)
	local weld2 = weld(RightArm,stick.Main,RightArm,d,d)
	local stickweld = stick.stickw
	local panelweld = beat.welder.uuu
	for i,v in pairs(beat:GetDescendants()) do if v:IsA("BasePart") then v.Anchored = false end end
	beat.Parent = Character
	local letters = {}
	for f,g in pairs(beat.screen:GetChildren()) do if g:IsA("Weld") then table.insert(letters,g) end end

	local hat = game:GetService("Players").LocalPlayer.Character["Hat1"]

	hat.Handle.AccessoryWeld:Destroy()

	local function align(part0, part1)
		part1.Transparency = 1
		part0.Mesh:Destroy()
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0, 0, -0.7) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(0, 90, 0) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	align(hat.Handle, stick)





	local dead = false
	--dmg
	function DEATH(MODEL)
		MODEL:BreakJoints()
		for index, CHILD in pairs(MODEL:GetChildren()) do
			if CHILD.Name == "Torso" then
				CHILD.Name = "stuff"..MRANDOM(1,10000)..""
			end
			coroutine.resume(coroutine.create(function()
				swait(MRANDOM(8,12)/10)
				if CHILD:IsA("BasePart") and CHILD.Name ~= "HumanoidRootPart" then
					if CHILD.Name == "Head" then
						WACKYEFFECT2({Time = 120, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)*1.2), Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(0,50),MRANDOM(0,50),MRANDOM(0,50)), RotationX = MRANDOM(-4,4), RotationY = MRANDOM(-4,4), RotationZ = MRANDOM(-4,4), Material = "Neon",ColorLoop = true, Color = RainbowColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, SizeBoomerang = 0, Boomerang = 35})
					elseif CHILD.Name ~= "HumanoidRootPart" then
						WACKYEFFECT2({Time = 120, EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size*1.2, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(0,50),MRANDOM(0,50),MRANDOM(0,50)), RotationX = MRANDOM(-4,4), RotationY = MRANDOM(-4,4), RotationZ = MRANDOM(-4,4) ,Material = "Neon",ColorLoop = true, Color = RainbowColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, SizeBoomerang = 0, Boomerang = 35})
					end
					CHILD:remove()
				end
			end))
		end
		Debris:AddItem(MODEL,6)
	end
	function ApplyDamage(Humanoid,Damage)

	end

	function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
		for index, CHILD in pairs(workspace:GetDescendants()) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if INSTAKILL == true then
								--DEATH(CHILD)
							else
								local DMG = MRANDOM(MINDMG,MAXDMG)
								ApplyDamage(HUM,DMG)
							end
							if FLING > 0 then
								for _, c in pairs(CHILD:GetChildren()) do
									if c:IsA("BasePart") then
										local bv = Instance.new("BodyVelocity") 
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
										bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
										bv.Parent = c
										Debris:AddItem(bv,0.05)
									end
								end
							end
						end
					end
				end
			end
		end
	end

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	v.Anchored = false

	local Outline = Instance.new("SelectionBox", v)
	Outline.LineThickness = 0.1
	Outline.Color3 = Color3.fromRGB(195, 130, 0)
	Outline.Adornee = v

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if ATTACK == false then
				bp.Position = game.Players.LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)

	local potating = false

	--attacks
	function slamthatmfingstick()
		potating = true
		ATTACK = true
		stick.Touched:Connect(function(hit)
			if hit.Parent:FindFirstChild("Humanoid") and potating == true then
				if hit.Parent.Name == game.Players.LocalPlayer.Name then
					--print("not flinging")
				else
					if hit.Parent:FindFirstChild("UpperTorso") then
						bp.Position = hit.Parent:FindFirstChild("UpperTorso").Position
					elseif hit.Parent:FindFirstChild("Torso") then
						bp.Position = hit.Parent:FindFirstChild("Torso").Position
					end
				end
			end
		end)
		coroutine.resume(coroutine.create(function()
			for i = 1,30 do
				Swait()
				WACKYEFFECT2({Time = 20, EffectType = "Sphere", Size = VT(.5,2,.5), Size2 = VT(.5,4,1), Transparency = 0, Transparency2 = 1, CFrame = stick.CFrame*CF(2,0,0)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 25})
			end
		end))
		for i = 0,19 do
			Swait()
			local Alpha = .25
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0.2)*ANGLES(RAD(-7.3),RAD(-42.8),RAD(-5))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-16.2),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(-20.4),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,0.5,0.3)*ANGLES(RAD(5.7),RAD(32),RAD(-10.6)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.3,1.1,0.2)*ANGLES(RAD(-150.2),RAD(3.9),RAD(-9.6)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(5.3),RAD(0),RAD(43)),Alpha)
		end
		for i = 0,5 do
			local Alpha = .2
			RootJoint.C0 = RootJoint.C0:lerp(CF(0.2,0,-0.1)*ANGLES(RAD(-31.5),RAD(38.5),RAD(4.3))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-1.1,-0.4)*ANGLES(RAD(3.5),RAD(-3.1),RAD(15)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.3,0,-0.7)*ANGLES(RAD(-0.5),RAD(-4.2),RAD(14.8)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,0.5,0.3)*ANGLES(RAD(5.7),RAD(32),RAD(-10.6)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.6,0.1)*ANGLES(RAD(82.1),RAD(21),RAD(16.6)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(5.3),RAD(0),RAD(-38.7)),Alpha)
		end
		CreateSound(1577567682,stick,8,1,false)
		for i = 1,12 do
			WACKYEFFECT2({Time = 40, EffectType = "Box", Size = VT(1,1,1), Size2 = VT(7,7,7), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(2,-3,-1), MoveToPos = nil, RotationX = MRANDOM(-30,30), RotationY = MRANDOM(-30,30), RotationZ = MRANDOM(-30,30), Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		end
		for i = 1,12 do
			WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(.7,.7,.7), Size2 = VT(1.2,1.2,1.2), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(2,-3,-1), MoveToPos = RootPart.Position+VT(MRANDOM(-15,15),MRANDOM(0,15),MRANDOM(-15,15)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 35, SizeBoomerang = 0})
		end
		for i = 0,15 do
			Swait()
			local Alpha = .3
			RootJoint.C0 = RootJoint.C0:lerp(CF(0.2,0,-0.1)*ANGLES(RAD(-31.5),RAD(38.5),RAD(4.3))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-1.1,-0.4)*ANGLES(RAD(3.5),RAD(-3.1),RAD(15)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.3,0,-0.7)*ANGLES(RAD(-0.5),RAD(-4.2),RAD(14.8)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,0.5,0.3)*ANGLES(RAD(5.7),RAD(32),RAD(-10.6)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.6,0.5,-0.4)*ANGLES(RAD(-5.2),RAD(-16.8),RAD(20.8)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(5.3),RAD(0),RAD(-38.7)),Alpha)
		end	ApplyAoE(stick.Position,7,0,0,20,true)
		ATTACK = false
		potating = false
	end

	function fyoudeathray()
		ATTACK = true
		local s = CreateSound(4453403748,RootPart,8,1,false)
	--[[spawn(function()
	swait(2)	
	CreateSound(200633780,RootPart,8,1,false)
	end)]]
		local garmp = attcf(LeftArm.LeftGripAttachment)
		for i = 0,80 do
			Swait()
			local Alpha = .1
			local armp = attcf(LeftArm.LeftGripAttachment)
			if MRANDOM(1,2) == 1 then
				WACKYEFFECT2({Time = 20, EffectType = "Sphere", Size = VT(.5,.5,.5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1,0)*CF(MRANDOM(-2,2),MRANDOM(-2,2),MRANDOM(-2,2)), MoveToPos = armp.p, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			end
			if MRANDOM(1,4) == 1 then
				WACKYEFFECT2({Time = 60, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(1.3,1.3,1.3), Transparency = 0, Transparency2 = 1, CFrame = armp, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
			end
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.1+0.2*COS(SINE/5),0.5)*ANGLES(RAD(10.8),RAD(0),RAD(0))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-0.9,-0.1)*ANGLES(RAD(-32.4),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.5,-0.9)*ANGLES(RAD(-36.6),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,0.3+0.2*SIN(SINE/5),0.2)*ANGLES(RAD(43.2),RAD(11.2),RAD(-40.6)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.5+0.2*SIN(SINE/5),0.1)*ANGLES(RAD(-11.3),RAD(-9.3),RAD(4.7)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(15.5),RAD(0),RAD(0)),Alpha)
		end
		local deathlaser = CreatePart(3,Effects,"Neon",0,0,"White","DEATH LASER",VT(1,1,1),true)
		--MakeForm(deathlaser,"Cyl")
		repeat
			Swait()
			local armp = attcf(LeftArm.LeftGripAttachment)
			local h,ps = CastProperRay(armp.p,  Mouse.Hit.p, 500, Character)
			local dist = (ps - armp.p).Magnitude
			local Alpha = .2
			deathlaser.Color = RainbowColor
			deathlaser.CFrame = CF(armp.p,ps)*CF(0,0,-dist/2)
			deathlaser.Size = VT(4+.3*COS(SINE/6),4+.3*COS(SINE/6),dist)
			if h then
				ApplyAoE(ps,30,0,0,35,true)
				if MRANDOM(1,2) == 1 then
					WACKYEFFECT2({Time = 20, EffectType = "Sphere", Size = VT(2,2,2)*10, Size2 = VT(8,8,8)*10, Transparency = 0, Transparency2 = 1, CFrame = CF(ps), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
				end	
				if MRANDOM(1,2) == 1 then
					WACKYEFFECT2({Time = 20, EffectType = "Round Slash", Size = VT(.01,.01,.01)*10, Size2 = VT(.07,.01,.07)*10, Transparency = 0, Transparency2 = 1, CFrame = CF(ps)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = ps+VT(0,3,0), RotationX = 0, RotationY = MRANDOM(8,8), RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
				end 
				if MRANDOM(1,2) == 1 then
					WACKYEFFECT2({Time = 20, EffectType = "Round Slash", Size = VT(.01,.01,.01)*10, Size2 = VT(.05,.01,.05)*10, Transparency = 0, Transparency2 = 1, CFrame = armp*ANGLES(0,RAD(MRANDOM(-360,360)),0), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-5,5), RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
					WACKYEFFECT2({Time = 20, EffectType = "Sphere", Size = VT(2,2,2)*10, Size2 = VT(6,6,6)*10, Transparency = 0, Transparency2 = 1, CFrame = CF(ps), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
				end
				if MRANDOM(1,4) == 1 then
					WACKYEFFECT2({Time = 20, EffectType = "Ring", Size = VT(8,8,8), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(ps)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = MRANDOM(-1,1), RotationY = MRANDOM(-1,1), RotationZ = MRANDOM(-1,1), Material = "Neon",ColorLoop = true,Color = RainbowColor,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 50})
				end
			end
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.1,0.7)*ANGLES(RAD(15.5),RAD(-45.3),RAD(11.2))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-0.9,-0.1)*ANGLES(RAD(-32.4),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.5,-0.9)*ANGLES(RAD(-36.6),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.3,0.3,-0.1)*ANGLES(RAD(83.1),RAD(-0.7),RAD(-48.3)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.4,0.1)*ANGLES(RAD(-11.3),RAD(-9.3),RAD(4.7)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(-5.6),RAD(0),RAD(46.3)),Alpha)
		until s.TimePosition == s.TimeLength
		deathlaser:Destroy()
		ATTACK = false
	end

	function milktp()
		ATTACK = true
		local milk = script.milk:Clone()
		milk.Anchored = false
		milk.Parent = Character
		local milkweld = weld(milk,milk,LeftArm,CF(0,0,1)*ANGLES(RAD(90),0,0),d)
		for i = 0,20 do
			Swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(-0.2,0,0.2)*ANGLES(RAD(-6.3),RAD(32.5),RAD(3.4))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-16.2),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(-20.4),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,1,0.2)*ANGLES(RAD(-169.2),RAD(-2.1),RAD(-24.6)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.5,0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(5.3),RAD(0),RAD(-32.7)),Alpha)
		end
		for i = 0,5 do
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,0,0.2)*ANGLES(RAD(-6.2),RAD(-30.5),RAD(-3.2))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-16.2),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(-20.4),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.3,1.1,-0.3)*ANGLES(RAD(159.9),RAD(42.7),RAD(-32.2)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.5,0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(5.3),RAD(0),RAD(30.6)),Alpha)
		end
		for i = 0,17 do
			Swait()
			local Alpha = .2
			RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,0.1,0)*ANGLES(RAD(-30.9),RAD(-30.5),RAD(-3.2))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.6,-0.9,-0.2)*ANGLES(RAD(5.4),RAD(2.4),RAD(-12.3)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(1.3),RAD(3.2),RAD(-12.1)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.2,0.3,-0.3)*ANGLES(RAD(48.9),RAD(7.6),RAD(18.9)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.5,0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(30.1),RAD(0),RAD(25.7)),Alpha)
		end
		milk:Destroy()
		CreateSound(200633837,RootPart,5,2,false)
		WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(11,1,11), Size2 = VT(55,0,55), Transparency = .2, Transparency2 = 1, CFrame = CF(RootPart.Position)*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(5,22,5), Size2 = VT(45,75,45), Transparency = .2, Transparency2 = 1, CFrame = CF(RootPart.Position)*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		for i = 1,5 do
			WACKYEFFECT2({Time = 40, EffectType = "Round Slash", Size = VT(.01,.01,.01), Size2 = VT(.3,.01,.3), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.9,0)*ANGLES(RAD(0),RAD(MRANDOM(-360,360)),0), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-6,6), RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 10})
		end
		for i = 1,10 do
			WACKYEFFECT2({Time = 40, EffectType = "Box", Size = VT(4,4,4), Size2 = VT(10,10,10), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = MRANDOM(-30,30), RotationY = MRANDOM(-30,30), RotationZ = MRANDOM(-30,30), Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
		end
		local hf,hp = Raycast(Mouse.Hit.p+VT(0,1,0), (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 100, Character)
		hp = hp + VT(0,3.5,0)
		local POS = RootPart.Position
		RootPart.CFrame = CF(hp,CF(POS,hp)*CF(0,0,-100000).p)
		CreateSound(200633837,RootPart,5,2,false)
		ApplyAoE(RootPart.Position,10,0,0,30,true)
		WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(11,1,11), Size2 = VT(55,0,55), Transparency = .2, Transparency2 = 1, CFrame = CF(RootPart.Position)*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(5,22,5), Size2 = VT(45,75,45), Transparency = .2, Transparency2 = 1, CFrame = CF(RootPart.Position)*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		for i = 1,5 do
			WACKYEFFECT2({Time = 40, EffectType = "Round Slash", Size = VT(.01,.01,.01), Size2 = VT(.3,.01,.3), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.9,0)*ANGLES(RAD(0),RAD(MRANDOM(-360,360)),0), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-6,6), RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 10})
		end
		for i = 1,10 do
			WACKYEFFECT2({Time = 40, EffectType = "Box", Size = VT(4,4,4), Size2 = VT(10,10,10), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = MRANDOM(-30,30), RotationY = MRANDOM(-30,30), RotationZ = MRANDOM(-30,30), Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
		end
		ATTACK = false
	end
	function beattodeath()
		ATTACK = true
		local ttors
		local beat = false
		local hum
		local hb = CreatePart(3,Effects,"Plastic",0,1,"White","hitbox",VT(2, 2, 2),false)
		local hbw = weld(LeftLeg,hb,LeftLeg,CF(0,2,0),d)
		local hitt = hb.Touched:Connect(function(h)
			if h.Parent:FindFirstChildOfClass("Humanoid") then
				if h.Parent:FindFirstChildOfClass("Humanoid").Health ~= 0 then
					hum = h.Parent:FindFirstChildOfClass("Humanoid")
					hp = hum.Health
					ttors = h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")
					ttors.CFrame = RootPart.CFrame * CF(0,-2.5,-3) * ANGLES(RAD(90), RAD(0), RAD(180))
					ttors.Anchored = true
					beat = true
				end
			end	
		end)
		for i = 0,27 do
			if beat == true then break end
			Swait()
			local Alpha = .3
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0.7)*ANGLES(RAD(16.5),RAD(0),RAD(0))*ROOTC0,Alpha)
			lh.C0 = lh.C0:lerp(CF(-0.3,-1.1,-0.3)*ANGLES(RAD(69.9),RAD(0),RAD(0)),Alpha)
			rh.C0 = rh.C0:lerp(CF(0.5,-0.9,-0.3)*ANGLES(RAD(-42.2),RAD(0),RAD(0)),Alpha)
			la.C0 = la.C0:lerp(CF(-1.4,0.5,0)*ANGLES(RAD(0.6),RAD(3.8),RAD(-9)),Alpha)
			ra.C0 = ra.C0:lerp(CF(1.4,0.5,0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5)),Alpha)
			Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*ANGLES(RAD(17.4),RAD(0),RAD(0)),Alpha)
		end
		hitt:Disconnect()
		local a = false
		coroutine.resume(coroutine.create(function()
			swait(3)
			a = true
		end))
		if beat == true then
			repeat
				Rooted = true
				for i = 0,5 do
					Swait()
					local Alpha = .5
					stickweld.C0 = stickweld.C0:lerp(d*ANGLES(RAD(0),RAD(0),RAD(0)),.1)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0.2)*ANGLES(RAD(8.5),RAD(0),RAD(0))*ROOTC0,Alpha)
					lh.C0 = lh.C0:lerp(CF(-0.5,-1,-0.1)*ANGLES(RAD(-8.1),RAD(7),RAD(-3.3)),Alpha)
					rh.C0 = rh.C0:lerp(CF(0.5,-1,-0.1)*ANGLES(RAD(-8),RAD(-7.5),RAD(3.8)),Alpha)
					la.C0 = la.C0:lerp(CF(-1,1,0.8)*ANGLES(RAD(-149.6),RAD(0),RAD(29.5)),Alpha)
					ra.C0 = ra.C0:lerp(CF(1,0.9,0.7)*ANGLES(RAD(-149.6),RAD(0),RAD(-22.7)),Alpha)
					Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
				end
				for i = 0,5 do
					local Alpha = .5
					stickweld.C0 = stickweld.C0:lerp(d*ANGLES(RAD(0),RAD(0),RAD(0)),.1)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.2)*ANGLES(RAD(-25.7),RAD(0),RAD(0))*ROOTC0,Alpha)
					lh.C0 = lh.C0:lerp(CF(-0.5,-0.9,-0.3)*ANGLES(RAD(26.1),RAD(7),RAD(-3.3)),Alpha)
					rh.C0 = rh.C0:lerp(CF(0.5,-0.9,-0.3)*ANGLES(RAD(26.2),RAD(-7.5),RAD(3.8)),Alpha)
					la.C0 = la.C0:lerp(CF(-1,1.1,0.1)*ANGLES(RAD(-167.4),RAD(0),RAD(29.5)),Alpha)
					ra.C0 = ra.C0:lerp(CF(1,1,0.1)*ANGLES(RAD(-167.4),RAD(0),RAD(-22.7)),Alpha)
					Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
				end
				for i = 0,7 do
					Swait()
					local Alpha = .5
					stickweld.C0 = stickweld.C0:lerp(CF(0,2,0)*ANGLES(RAD(0),RAD(0),RAD(70)),.1)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0.1,-0.6)*ANGLES(RAD(-38.3),RAD(0),RAD(0))*ROOTC0,Alpha)
					lh.C0 = lh.C0:lerp(CF(-0.5,-1.2,-0.3)*ANGLES(RAD(38.7),RAD(7),RAD(-3.3)),Alpha)
					rh.C0 = rh.C0:lerp(CF(0.5,-1.2,-0.3)*ANGLES(RAD(38.8),RAD(-7.5),RAD(3.8)),Alpha)
					la.C0 = la.C0:lerp(CF(-1,0,-1)*ANGLES(RAD(60.2),RAD(0),RAD(29.5)),Alpha)
					ra.C0 = ra.C0:lerp(CF(1,0.1,-0.9)*ANGLES(RAD(60.2),RAD(0),RAD(-22.7)),Alpha)
					Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
					if hum.Health == 0 or not hum.Parent then
						a = true
					end
				end
				local hd = hum.Parent:FindFirstChild("Head")
				if hd then
					WACKYEFFECT2({Time = 30, EffectType = "Box", Size = VT(hd.Size.Z,hd.Size.Y,hd.Size.Z), Size2 = VT(hd.Size.Z,hd.Size.Y,hd.Size.Z)*1.6, Transparency = 0, Transparency2 = 1, CFrame = hd.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = 4018616850, SoundPitch = 1, SoundVolume = 5, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
				end
			until a == true
			if hum.Parent then
				--DEATH(hum.Parent)
			end
		end
		Rooted = false
		ATTACK = false
	end

	function cs()
		if SONG == 4447145150 then
			SONG = 3252017264
		elseif SONG == 3252017264 then
			SONG = 4368711751
		elseif SONG == 4368711751 then
			SONG = 4035306718
		elseif SONG == 4035306718 then
			SONG = 3863023710
		elseif SONG == 3863023710 then
			SONG = 616388964
		elseif SONG == 616388964 then
			SONG = 1059884825
		elseif SONG == 1059884825 then
			SONG = 4447145150
		end
	end

	--keys
	function MouseDown(Mouse)
		HOLD = true
		if ATTACK == false then
			slamthatmfingstick()
		end
	end

	function MouseUp(Mouse)
		HOLD = false
	end

	function KeyDown(Key)
		KEYHOLD = true
		if Key == "z" and ATTACK == false then
			fyoudeathray()
		end
		if Key == "x" and ATTACK == false then
			milktp()
		end

		if Key == "c" and ATTACK == false then
			beattodeath()
		end

		if Key == "v" and ATTACK == false then

		end

		if Key == "b" and ATTACK == false then

		end
		if Key == "m" then
			cs()
		end

		if Key == "]" and ATTACK == false then
			if sick.Parent ~= Character then
				sick = IT("Sound",Torso)
				sick.SoundId = "rbxassetid://"..SONG
			end
		end
	end

	function KeyUp(Key)
		KEYHOLD = false
	end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

	function unanchor()
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA("BasePart") and c ~= RootPart then
				c.Anchored = false
			end
		end
		if UNANCHOR == true then
			RootPart.Anchored = false
		else
			RootPart.Anchored = true
		end
	end

	--loop stuff

	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)


	while true do
		Swait()
		ANIMATE.Parent = nil
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		SINE = SINE + CHANGE*2
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
		local TiltVelocity = CF(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity/1.6))
		local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
				ra.C0 = Clerp(ra.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))), 1 / Animation_Speed)
				la.C0 = Clerp(la.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))), 1 / Animation_Speed)
				rh.C0 = Clerp(rh.C0, CF(.5, -0.4, -0.6) * ANGLES(RAD(1), RAD(0), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				lh.C0 = Clerp(lh.C0, CF(-.5, -1, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				ra.C0 = Clerp(ra.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))), 1 / Animation_Speed)
				la.C0 = Clerp(la.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))), 1 / Animation_Speed)
				rh.C0 = Clerp(rh.C0, CF(.5, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(0), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				lh.C0 = Clerp(lh.C0, CF(-.5, -0.8, -0.3) * ANGLES(RAD(-10), RAD(10), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			local Alpha = .1
			ANIM = "Idle"
			if ATTACK == false then
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,1+0.6*COS(SINE/25),0.1)*ANGLES(RAD(-5.3+3*SIN(SINE/25)),RAD(0),RAD(0))*ROOTC0,Alpha)
				lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-16.2+5*SIN(SINE/25)),RAD(0),RAD(0)),Alpha)
				rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(-20.4+5*SIN(SINE/25)),RAD(0),RAD(0)),Alpha)
				la.C0 = la.C0:lerp(CF(-1.4,0.5+0.05*COS(SINE/25),0)*ANGLES(RAD(0.6),RAD(3.8),RAD(-9+3.6*SIN(SINE/25))),Alpha)
				ra.C0 = ra.C0:lerp(CF(1.4,0.5+0.05*COS(SINE/25),0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5-3.6*SIN(SINE/25))),Alpha)
				Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(5.3+3*SIN(SINE/25)),RAD(0),RAD(0)),Alpha)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				local Alpha = .1
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,1+0.6*COS(SINE/25),0.1)*ANGLES(RAD(-5.3+3*SIN(SINE/25)+RAD(TiltVelocity.Z*45)),RAD(0),RAD(0-RAD(TiltVelocity.X*10)))*ROOTC0,Alpha)
				lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-16.2+5*SIN(SINE/25)+RAD(TiltVelocity.Z*5)),RAD(0),RAD(0-RAD(TiltVelocity.X*19))),Alpha)
				rh.C0 = rh.C0:lerp(CF(0.5,-0.3,-0.6)*ANGLES(RAD(-20.4+5*SIN(SINE/25)+RAD(TiltVelocity.Z*5)),RAD(0),RAD(0-RAD(TiltVelocity.X*19))),Alpha)
				la.C0 = la.C0:lerp(CF(-1.4,0.5+0.05*COS(SINE/25),0)*ANGLES(RAD(0.6),RAD(3.8),RAD(-9+3.6*SIN(SINE/25))),Alpha)
				ra.C0 = ra.C0:lerp(CF(1.4,0.5+0.05*COS(SINE/25),0)*ANGLES(RAD(0.9),RAD(-8.1),RAD(6.5-3.6*SIN(SINE/25))),Alpha)
				Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(-5.3+3*SIN(SINE/25)+RAD(TiltVelocity.Z*45)),RAD(0),RAD(-2*COS(SINE/25))-RAD(TiltVelocity.X*1.5)),Alpha)
			end
		end
		stick.p1.Color = ColorSequence.new(RainbowColor)
		stick.p2.Color = ColorSequence.new(RainbowColor)
		stick.p3.Color = ColorSequence.new(RainbowColor)
		for i = 1,#letters do
			letters[i].C0 = letters[i].C0:lerp(CF(0,0+(i/80)*COS(SINE/30),0)*ANGLES(RAD(0),RAD(0),RAD(0+(i/12)*SIN(SINE/30))),.1)
		end
		panelweld.C0 = panelweld.C0:lerp(CF(0,0+.5*COS(SINE/68),0)*ANGLES(RAD(0),RAD(0),RAD(-5*SIN(SINE/68))),.1)
		if ATTACK == false then
			stickweld.C0 = stickweld.C0:lerp(CF(0,0,0),.1)
		end
		unanchor()
		Humanoid.MaxHealth = 1e4
		Humanoid.Health = 1e4
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		sick.SoundId = "rbxassetid://"..SONG
		sick.Looped = true
		sick.Pitch = 1
		sick.Volume = 3
		sick.Playing = true
	end
end)

Button_16.MouseButton1Down:Connect(function()
	--//====================================================\\--
	--||			   7_qz's Spellcaster.
	--\\====================================================//--

--[[
-gh 1560604139,498748537,5893937975,4903134690,5674239091,5460032471,5355316452
--]]

	local script = game:GetObjects("rbxassetid://5989999361")[1]

	plr = game:GetService("Players").LocalPlayer
	Player = plr
	char = plr.Character["Dummy"]
	hum = char.Humanoid
	mouse = plr:GetMouse()
	local cam = game.Workspace.CurrentCamera
	Camera = cam
	local CamInterrupt = false
	local TwoD = false
	local TargetInfo = {nil, nil}
	cam.CameraType = "Custom"
	t = char.Torso
	h = char.Head
	ra = char["Right Arm"]
	la = char["Left Arm"]
	rl = char["Right Leg"]
	ll = char["Left Leg"]
	tors = char.Torso
	lleg = char["Left Leg"]
	root = char.HumanoidRootPart
	hed = char.Head
	rleg = char["Right Leg"]
	rarm = char["Right Arm"]
	larm = char["Left Arm"]
	radian = math.rad
	random = math.random
	Vec3 = Vector3.new
	Inst = Instance.new
	cFrame = CFrame.new
	Euler = CFrame.fromEulerAnglesXYZ
	vt = Vector3.new
	bc = BrickColor.new
	br = BrickColor.random
	it = Instance.new
	cf = CFrame.new
	local Player_Size = 0
	cam = game.Workspace.CurrentCamera
	CF = CFrame.new
	angles = CFrame.Angles
	attack = false
	Euler = CFrame.fromEulerAnglesXYZ
	Rad = math.rad
	IT = Instance.new
	BrickC = BrickColor.new
	Cos = math.cos
	Acos = math.acos
	Sin = math.sin
	Asin = math.asin
	Abs = math.abs
	Mrandom = math.random
	Floor = math.floor
	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor
	local SINE = 0
	local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
	local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
	local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
	local ModeOfGlitch = 1
	CF = CFrame.new
	local hed = char.Head
	local root = char.HumanoidRootPart
	local rootj = root.RootJoint
	local tors = char.Torso
	local musics = script.Sounds.Song:Clone()
	musics.Parent = char
	musics.Volume = 3.5
	musics:Play()
	local Anim = "Idle"
	LeftArm=char["Left Arm"] 
	LeftLeg=char["Left Leg"] 
	RightArm=char["Right Arm"] 
	RightLeg=char["Right Leg"] 
	LS=tors["Left Shoulder"] 
	LH=tors["Left Hip"] 
	RS=tors["Right Shoulder"] 
	RH=tors["Right Hip"] 
	necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
	LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
	RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
	RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
	RootPart = char.HumanoidRootPart
	RootJoint = RootPart.RootJoint
	RootCF = EULER(-1.57, 0, 3.14)
	local Character = char
	local Torso = tors
	local book1 = script.Books.earthbook:Clone()
	book1.Parent = char
	local book2 = script.Books.firebook:Clone()
	book2.Parent = char
	local book3 = script.Books.thunderbook:Clone()
	book3.Parent = char
	local book4 = script.Books.icebook:Clone()
	book4.Parent = char
	local book5 = script.Books.darkbook:Clone()
	book5.Parent = char
	local book6 = script.Books.lightbook:Clone()
	book6.Parent = char
	local book7 = script.Books.lunarbook:Clone()
	book7.Parent = char

	local hat = game:GetService("Players").LocalPlayer.Character["jOKES"]

	local hat1 = game:GetService("Players").LocalPlayer.Character["Textbook"]

	local hat2 = game:GetService("Players").LocalPlayer.Character["Magic Spell Book - Blue"]

	local hat3 = game:GetService("Players").LocalPlayer.Character["Eggcyclopedia_WaistFront"]

	local hat4 = game:GetService("Players").LocalPlayer.Character["Waist Red Spellbook"]

	local hat5 = game:GetService("Players").LocalPlayer.Character["SpellBookAccessory"]

	local hat6 = game:GetService("Players").LocalPlayer.Character["Meshes/SpellbookBlackAccessory"]

	local function align(part0, part1)
		part1.Transparency = 1
		part0.AccessoryWeld:Destroy()
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0, 0, 0) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(0, 0, 0) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000000000000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = false
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 200000000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000000000000
	end

	align(hat.Handle, book1)
	align(hat1.Handle, book2)
	align(hat2.Handle, book3)
	align(hat3.Handle, book4)
	align(hat4.Handle, book5)
	align(hat5.Handle, book6)
	align(hat6.Handle, book7)


	selected = "fire"
	--save shoulders 
	RSH, LSH=nil, nil 
	--welds 
	RW, LW=Instance.new("Weld"), Instance.new("Weld") 
	RW.Name="Right Shoulder" LW.Name="Left Shoulder"
	LH=Torso["Left Hip"]
	RH=Torso["Right Hip"]
	TorsoColor=Torso.BrickColor
	function NoOutline(Part)
		Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
	end
	ch=Character
	RSH=ch.Torso["Right Shoulder"] 
	LSH=ch.Torso["Left Shoulder"] 
	-- 
	RSH.Parent=nil 
	LSH.Parent=nil 
	-- 
	RW.Name="Right Shoulder"
	RW.Part0=ch.Torso 
	RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
	RW.C1=cf(0, 0.5, 0) 
	RW.Part1=ch["Right Arm"] 
	RW.Parent=ch.Torso 
	-- 
	LW.Name="Left Shoulder"
	LW.Part0=ch.Torso 
	LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
	LW.C1=cf(0, 0.5, 0) 
	LW.Part1=ch["Left Arm"] 
	LW.Parent=ch.Torso 

	-------------------------------------

	if hum:findFirstChild("Animator")~=nil then
		hum:findFirstChild("Animator").Parent=nil
	end

	if char:findFirstChild("Animate")~=nil then
		char:findFirstChild("Animate").Parent=nil
	end
	-------------------------------------

	-- Needed Functions --

	------------------
	function swait(num)
		function swait(num)
			if num==0 or num==nil then
				game:service'RunService'.Stepped:wait(0)
			else
				for i=0,num do
					game:service'RunService'.Stepped:wait(0)
				end
			end
		end
	end

	so = function(id,par,vol,pit) 
		coroutine.resume(coroutine.create(function()
			local sou = Instance.new("Sound",par or workspace)
			sou.Volume=vol
			sou.Pitch=pit or 1
			sou.SoundId=id
			swait() 
			sou:play() 
			game:GetService("Debris"):AddItem(sou,6)
		end))
	end

	function clerp(a,b,t) 
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)} 
		local ax, ay, az = a.x, a.y, a.z 
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1-t
		return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
	end 

	function QuaternionFromCFrame(cf) 
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
		local trace = m00 + m11 + m22 
		if trace > 0 then 
			local s = math.sqrt(1 + trace) 
			local recip = 0.5/s 
			return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
		else 
			local i = 0 
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then 
				i = 2 
			end 
			if i == 0 then 
				local s = math.sqrt(m00-m11-m22+1) 
				local recip = 0.5/s 
				return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
			elseif i == 1 then 
				local s = math.sqrt(m11-m22-m00+1) 
				local recip = 0.5/s 
				return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
			elseif i == 2 then 
				local s = math.sqrt(m22-m00-m11+1) 
				local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
			end 
		end 
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w) 
		local xs, ys, zs = x + x, y + y, z + z 
		local wx, wy, wz = w*xs, w*ys, w*zs 
		local xx = x*xs 
		local xy = x*ys 
		local xz = x*zs 
		local yy = y*ys 
		local yz = y*zs 
		local zz = z*zs 
		return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
	end

	function QuaternionSlerp(a, b, t) 
		local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
		local startInterp, finishInterp; 
		if cosTheta >= 0.0001 then 
			if (1 - cosTheta) > 0.0001 then 
				local theta = math.acos(cosTheta) 
				local invSinTheta = 1/math.sin(theta) 
				startInterp = math.sin((1-t)*theta)*invSinTheta 
				finishInterp = math.sin(t*theta)*invSinTheta  
			else 
				startInterp = 1-t 
				finishInterp = t 
			end 
		else 
			if (1+cosTheta) > 0.0001 then 
				local theta = math.acos(-cosTheta) 
				local invSinTheta = 1/math.sin(theta) 
				startInterp = math.sin((t-1)*theta)*invSinTheta 
				finishInterp = math.sin(t*theta)*invSinTheta 
			else 
				startInterp = t-1 
				finishInterp = t 
			end 
		end 
		return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
	end

	function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
	end

	function aclerp(startCF,endCF,alpha)
		return startCF:lerp(endCF, alpha)
	end

	-- Effect Functions --

	function CreateParta(parent,transparency,reflectance,material,brickcolor)
		local p = Instance.new("Part")
		p.TopSurface = 0
		p.BottomSurface = 0
		p.Parent = parent
		p.Size = Vector3.new(0.1,0.1,0.1)
		p.Transparency = transparency
		p.Reflectance = reflectance
		p.CanCollide = false
		p.Locked = true
		p.BrickColor = brickcolor
		p.Material = material
		return p
	end

	loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()

	local Create = LoadLibrary("RbxUtility").Create

	CFuncs = {
		["Part"] = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part"){
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material,
				}
				RemoveOutlines(Part)
				return Part
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Weld"] = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld"){
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1,
				}
				return Weld
			end;
		};

		["Sound"] = {
			Create = function(id, par, vol, pit)
				local S = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				S:play()
				game:GetService("Debris"):AddItem(S, 10)
			end;
		};

		["TimeSound"] = {
			Create = function(id, par, vol, pit, timepos)
				local S = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					TimePosition = timepos,
					Parent = par or workspace,
				}
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 10)
			end;
		};
		["EchoSound"] = {
			Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl)
				local Sas = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					TimePosition = timepos,
					Parent = par or workspace,
				}
				local E = Create("EchoSoundEffect"){
					Delay = echodelay,
					Name = "Echo",
					Feedback = fedb,
					DryLevel = dryl,
					Parent = Sas,
				}
				wait()
				Sas:play()
				game:GetService("Debris"):AddItem(Sas, delays)
			end;
		};

		["LongSound"] = {
			Create = function(id, par, vol, pit)
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 60)
			end;
		};

		["ParticleEmitter"] = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter"){
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread,
				}
				return fp
			end;
		};

		CreateTemplate = {

		};
	}



	New = function(Object, Parent, Name, Data)
		local Object = Instance.new(Object)
		for Index, Value in pairs(Data or {}) do
			Object[Index] = Value
		end
		Object.Parent = Parent
		Object.Name = Name
		return Object
	end

	function ring(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
			end
			rng:Destroy()
		end))
	end


	function wave(type,pos,scale,value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function wind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end

	function groundwind(type,pos,scale,value,speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
			end
			rng:Destroy()
		end))
	end

	function CameraManager()
		if TwoD and not CamInterrupt then
			if Humanoid.Health > 0 then
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Scriptable"
				Humanoid.AutoRotate = false
				if Booleans.GyroUse then
					Directer.MaxTorque = Vec3(0, huge, 0)
				else
					Directer.MaxTorque = Vec3(0, 0, 0)
				end
				if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
					if Booleans.CamFollow then
						CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
						Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
					else
						CPart.Position = RootPart.Position
					end
				else
					local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
					CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
				end
				Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
			else
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Custom"
				Controller.Disabled = false
			end
		end
	end

	function sphere(bonuspeed,type,pos,scale,value,color,heart,invert,notaffectbychaosrainbow)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"


		if(heart)then
			rngm.MeshType = Enum.MeshType.FileMesh
			rngm.MeshId = "rbxassetid://105992239"
			rngm.Offset = Vector3.new(0,0,-.25)
		end
		rngm.Scale = scale
		if rainbowmode == true and not notaffectbychaosrainbow then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true and not notaffectbychaosrainbow then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true and not notaffectbychaosrainbow then
					rng.BrickColor = BrickColor.random()
				end
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					rng.Color = color
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				if(invert)then
					if(heart)then
						rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
					else
						rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
					end
				else
					if(heart)then
						rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
					else
						rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
					end
				end
				rng.CFrame = pos
			end
			rng:Destroy()
		end))
	end

	function newBezier(startpos, pos2, pos3, endpos, t)
		local A = clerp(startpos, pos2, t)
		local B = clerp(pos2, pos3, t)
		local C = clerp(pos3, endpos, t)
		local lerp1 = clerp(A, B, t)
		local lerp2 = clerp(B, C, t)
		local cubic = clerp(lerp1, lerp2, t)
		return cubic
	end


	function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,heart,invert)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		if(heart)then
			rngm.MeshType = Enum.MeshType.FileMesh
			rngm.MeshId = "rbxassetid://105992239"
			rngm.Offset = Vector3.new(0,0,-.25)
		end
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					rng.Color = color
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed/10
				if(invert)then rng.CFrame = rng.CFrame - rng.CFrame.lookVector*speeder*bonuspeed else rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed end
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end 

	function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,heart,invert)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		if(heart)then
			rngm.MeshType = Enum.MeshType.FileMesh
			rngm.MeshId = "rbxassetid://105992239"
			rngm.Offset = Vector3.new(0,0,-.25)
		end
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 0
		local speeder = FastSpeed/10
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					rng.Color = color
				end
				speeder = speeder + 0.01*FastSpeed*bonuspeed/10
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				if(invert)then rng.CFrame = rng.CFrame - rng.CFrame.lookVector*speeder*bonuspeed else rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed end
				--rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					rng.Color = color
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end

	function Pillar(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = script.Pillar:Clone()
		rng.Parent = workspace["xDivern"]
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(x1, y1, z1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + Vector3.new(0,0.05,0)
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
			end
			rng:Destroy()
		end))
	end

	function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = scale
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function Beamring(col,pos,bonsize,esize,fasten,textr)
		local sa = script.Objects.Ring:Clone()
		sa.Parent = char
		sa.CFrame = pos
		local bem = sa.Beam
		if textr ~= nil then
			bem.Texture = "rbxassetid://" ..textr
		end
		local at1 = sa.a1
		local at2 = sa.a2
		at1.Position = vt(0,0,0.5*esize)
		at2.Position = vt(0,0,-0.5*esize)
		bem.Width0 = 1*esize
		bem.Width1 = 1*esize
		bem.Color = ColorSequence.new(col)
		coroutine.resume(coroutine.create(function()
			local trans = 0
			for i = 0, 99/fasten do
				swait()
				trans = trans + 0.01*fasten
				bem.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,trans,0),NumberSequenceKeypoint.new(1,trans,0)})
				at1.Position = at1.Position + vt(0,0,0.5*bonsize*fasten)
				at2.Position = at2.Position - vt(0,0,0.5*bonsize*fasten)
				bem.Width0 = bem.Width0 + 1*bonsize*fasten
				bem.Width1 = bem.Width1 + 1*bonsize*fasten
			end
			sa:Destroy()
		end))
	end 

	function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 1
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1,y1,z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r/255,g/255,b/255)
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1*value
		elseif type == "Divide" then
			scaler2 = 1/value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r/255,g/255,b/255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				if glitchymode then
					local val = math.random(1,255)
					local color = Color3.fromRGB(val,val,val)
					rng.Color = color
				end
				speeder = speeder - 0.01*FastSpeed*bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end

	function dmg(dude)
		if dude.Name ~= Character then
			local bgf = Instance.new("BodyGyro",dude.Head)
			bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
			local val = Instance.new("BoolValue",dude)
			val.Name = "IsHit"
			local ds = coroutine.wrap(function()
				local torso = dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso'
				for i = 1, 10 do
					sphereMK(1.5,2,"Add",torso.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,25,-.01,BrickColor.new("White"),0,true)
				end
				dude:WaitForChild("Head"):BreakJoints()
				wait(0.5)
				targetted = nil
				CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.5, 0.3)

				coroutine.resume(coroutine.create(function()
					for i, v in pairs(dude:GetChildren()) do
						if v:IsA("Accessory") then
							v:Destroy()
						end
						if v:IsA("Humanoid") then
							v:Destroy()
						end
						if v:IsA("CharacterMesh") then
							v:Destroy()
						end
						if v:IsA("Model") then
							v:Destroy()
						end
						if v:IsA("Part") or v:IsA("MeshPart") then
							for x, o in pairs(v:GetChildren()) do
								if o:IsA("Decal") then
									o:Destroy()
								end
							end
							coroutine.resume(coroutine.create(function()
								v.Material = "Neon"
								v.CanCollide = false
								local bld = Instance.new("ParticleEmitter",v)
								bld.LightEmission = 1
								bld.Texture = "rbxassetid://284205403"
								bld.Color = ColorSequence.new(Color3.new(1,1,1))
								bld.Rate = 50
								bld.Lifetime = NumberRange.new(1)
								bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.75,0),NumberSequenceKeypoint.new(1,0,0)})
								bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
								bld.Speed = NumberRange.new(0,0)
								bld.VelocitySpread = 50000
								bld.Rotation = NumberRange.new(-500,500)
								bld.RotSpeed = NumberRange.new(-500,500)
								local sbs = Instance.new("BodyPosition", v)
								sbs.P = 3000
								sbs.D = 1000
								sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
								sbs.position = v.Position + Vector3.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))
								v.Color = Color3.new(1,1,1)
								coroutine.resume(coroutine.create(function()
									for i = 0, 49 do
										swait(1)
										v.Transparency = v.Transparency + 0.02
									end
									CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.25, 1)
									bld.Speed = NumberRange.new(1,5)
									bld.Acceleration = vt(0,10,0)
									wait(0.5)
									bld.Enabled = false
									wait(3)
									v:Destroy()
									dude:Destroy()
								end))
							end))
						end
					end
				end))
			end)
			ds()
		end
	end


	function FindNearestHead(Position, Distance, SinglePlayer)
		if SinglePlayer then
			return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
		end
		local List = {}
		for i, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") then
				if v:findFirstChild("Head") then
					if v ~= Character then
						if (v.Head.Position - Position).magnitude <= Distance then
							table.insert(List, v)
						end
					end
				end
			end
		end
		return List
	end

	function FaceMouse()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end

	function FaceMouse2()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end

	local ModeOfGlitch = 1

	function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part")({
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material
		})
		Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
		return Part
	end

	function chatfunc(text,color)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard")~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end
			local naeeym2 = Instance.new("BillboardGui",Character)
			naeeym2.Size = UDim2.new(0,100,0,40)
			naeeym2.StudsOffset = Vector3.new(0,3,0)
			naeeym2.Adornee = Character.Head
			naeeym2.Name = "TalkingBillBoard"
			local tecks2 = Instance.new("TextLabel",naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.BorderSizePixel = 0
			tecks2.Text = ""
			tecks2.Font = "SciFi"
			tecks2.TextSize = 30
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = color
			tecks2.TextStrokeColor3 = Color3.new(0,0,0)
			tecks2.Size = UDim2.new(1,0,0.5,0)
			local tecks3 = Instance.new("TextLabel",naeeym2)
			tecks3.BackgroundTransparency = 1
			tecks3.BorderSizePixel = 0
			tecks3.Text = ""
			tecks3.Font = "SciFi"
			tecks3.TextSize = 30
			tecks3.TextStrokeTransparency = 0
			tecks3.TextColor3 = Color3.new(0,0,0)
			tecks3.TextStrokeColor3 = color
			tecks3.Size = UDim2.new(1,0,0.5,0)
			coroutine.resume(coroutine.create(function()
				while true do
					swait(1)
					tecks2.Position = UDim2.new(0,math.random(-5,5),0,math.random(-5,5))
					tecks3.Position = UDim2.new(0,math.random(-5,5),0,math.random(-5,5))
					tecks2.Rotation = math.random(-5,5)
					tecks3.Rotation = math.random(-5,5)
				end
			end))
			for i = 1,string.len(text),1 do
				CFuncs["Sound"].Create("rbxassetid://274118116", char, 0.25, 0.115)
				tecks2.Text = string.sub(text,1,i)
				tecks3.Text = string.sub(text,1,i)
				swait(1)
			end
			wait(1)
			local randomrot = math.random(1,2)
			if randomrot == 1 then
				for i = 1, 50 do
					swait()
					tecks2.Rotation = tecks2.Rotation - .75
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.Rotation = tecks2.Rotation + .75
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			elseif randomrot == 2 then
				for i = 1, 50 do
					swait()
					tecks2.Rotation = tecks2.Rotation + .75
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.Rotation = tecks2.Rotation - .75
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			end
			naeeym2:Destroy()
		end)
		chat()
	end

	local NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance,parent)
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end

	FXFolder = script.Effects

	function CamShake(who,data)
		coroutine.wrap(function()
			if(FXFolder:FindFirstChild'CamShake')then
				local cam = FXFolder.CamShake:Clone()
				cam:WaitForChild'intensity'.Value = data.Intensity or 5
				cam:WaitForChild'duration'.Value = data.Duration or 5
				cam:WaitForChild'speed'.Value = data.Speed or 10;
				if(data.Origin)then NewInstance((typeof(data.Origin) == 'Instance' and "ObjectValue" or typeof(data.Origin) == 'Vector3' and 'Vector3Value' or typeof(data.Origin)=='CFrame' and 'CFrameValue'),cam,{Name='origin',Value=data.Origin}) end
				cam:WaitForChild'rot'.Value = data.Rotation or Vector3.new(1,1,5)
				cam:WaitForChild'pos'.Value = data.Position or Vector3.new(.5,.5,.5)
				cam:WaitForChild'startdist'.Value = data.DropDist or 25;
				cam:WaitForChild'enddist'.Value = data.IneffectiveDist or 150;

				cam.Parent = who
				wait()
				cam.Disabled = false
			end
		end)()
	end

	function CamShakeAll(data)
		for _,v in next, game:service'Players':players() do
			CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,data)
		end
	end

	-- Damage functions --

	DoDamage = true

	function Vanish(person)

	end

	function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)

	end

	-- Attacks --

	function volcaniceruption()
		attack = true
		hum.WalkSpeed = 2
		chatfunc("I'll make you burnt toast!",Color3.new(1,0,0))
		local volcano = script.Objects.Volcano:Clone()
		volcano.Parent = char
		volcano.Transparency = 1
		volcano.CFrame = root.CFrame + root.CFrame.lookVector*150
		for i = 1,20,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1.1,0)*angles(math.rad(0),math.rad(85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
			LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(0),math.rad(-85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,.1)*angles(math.rad(0),math.rad(0),math.rad(-25)),.01)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(0),math.rad(25)),.01)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(10)),.02)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(-10)),.02)
			volcano.Position = Vector3.new(volcano.Position.X,volcano.Position.Y + 0.1, volcano.Position.Z)
			book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book2.CFrame = hed.CFrame + root.CFrame.lookVector*4
			book2.Position = Vector3.new(book2.Position.X,book2.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book2.Position.Z)
			book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
			volcano.Transparency = 1 - (i * 5)/100
		end
		for i = 1,100 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1.1,0)*angles(math.rad(0),math.rad(85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
			LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(0),math.rad(-85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,.1)*angles(math.rad(0),math.rad(0),math.rad(-25)),.01)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(0),math.rad(25)),.01)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(10)),.02)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(-10)),.02)
			book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book2.CFrame = hed.CFrame + root.CFrame.lookVector*4
			book2.Position = Vector3.new(book2.Position.X,book2.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book2.Position.Z)
			book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
			coroutine.resume(coroutine.create(function()
				local magma = Instance.new("Part",char)
				magma.Position = Vector3.new(volcano.Position.X,volcano.Position.Y + 150, volcano.Position.Z)
				magma.Size = Vector3.new(10,10,10)
				magma.BrickColor = BrickColor.Red()
				magma.Velocity = Vector3.new(math.random(-300,300),math.random(-300,300),math.random(-300,300))
				swait(50)
				for i = 1,100 do
					swait(1)
					--MagniDamage(magma, 40, 3,5, 0, "Burn")
				end
				magma:Destroy()
			end))
		end
		volcano:Destroy()
		hum.WalkSpeed = 16
		attack = false
	end

	local Alpha = .1

	function LithosphereSpikes()
		local distlook = 0
		attack = true
		hum.WalkSpeed = 0
		chatfunc("Have fun flopping like a fish.",Color3.new(0.5,0.5,0))
		for i = 1,10 do
			swait()
			RootJoint.C0 = RootJoint.C0:lerp(cf(-0.2,-1.4,-0.5)*angles(math.rad(-36),math.rad(-16.3),math.rad(0))*RootCF,Alpha)
			LH.C0 = LH.C0:lerp(cf(-0.9,0.3,-0.1)*angles(math.rad(17.7),math.rad(15.6),math.rad(-4.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
			RH.C0 = RH.C0:lerp(cf(1.2,-1.2,-0.3)*angles(math.rad(-32.5),math.rad(13.9),math.rad(8.7))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
			LW.C0 = LW.C0:lerp(cf(-1.5,0.3,-0.4)*angles(math.rad(43.5),math.rad(12),math.rad(-11.1)),Alpha)
			RW.C0 = RW.C0:lerp(cf(0.9,0.2,-0.4)*angles(math.rad(41.2),math.rad(0),math.rad(-63.3)),Alpha)
			Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0.1,0.2,0.4)*angles(math.rad(-29.6),math.rad(16.9),math.rad(9.4))*necko,Alpha)
			book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book1.CFrame = hed.CFrame + root.CFrame.lookVector*4
			book1.Position = Vector3.new(book1.Position.X,book1.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book1.Position.Z)
			book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
			coroutine.resume(coroutine.create(function()
				local hite = script.Objects.Spike:Clone()
				hite.Parent = char
				hite.Transparency = 0
				hite.Anchored = true
				hite.CanCollide = false
				hite.CFrame = root.CFrame + root.CFrame.lookVector*(distlook + 10)
				distlook = distlook + 10
				--MagniDamage(hite, 10, 30,50, 0, "UpKnock")
				swait(100)
				for i = 1,30 do
					swait()
					hite.Position = hite.Position - Vector3.new(0,0.5,0)
					hite.Transparency = i/30
				end
				hite:Destroy()
			end))
		end
		attack = false
		hum.WalkSpeed = 16
	end

	function Mountain()
		attack = true
		hum.WalkSpeed = 0	
		local a = Instance.new("Part",workspace)
		a.Position = Torso.Position - Vector3.new(0,4,0)
		a.Material = "Grass"
		a.BrickColor = BrickColor.new("Earth green")
		a.Anchored = true
		a.Size = Vector3.new(10,1,10)
		CamShakeAll({
			Duration=0.5; 
			Intensity=5;
			Position=Vector3.new(2,2,2);
			Rotation=Vector3.new(2,2,6);
			DropDist=1000;
			IneffectiveDist=1000;
			Origin=tors.Position;
		})
		for i = 1,50 do
			swait()
			RootJoint.C0 = RootJoint.C0:lerp(cf(-0.2,-1.4,-0.5)*angles(math.rad(-36),math.rad(-16.3),math.rad(0))*RootCF,Alpha)
			LH.C0 = LH.C0:lerp(cf(-0.9,0.3,-0.1)*angles(math.rad(17.7),math.rad(15.6),math.rad(-4.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
			RH.C0 = RH.C0:lerp(cf(1.2,-1.2,-0.3)*angles(math.rad(-32.5),math.rad(13.9),math.rad(8.7))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
			LW.C0 = LW.C0:lerp(cf(-1.5,0.3,-0.4)*angles(math.rad(43.5),math.rad(12),math.rad(-11.1)),Alpha)
			RW.C0 = RW.C0:lerp(cf(0.9,0.2,-0.4)*angles(math.rad(41.2),math.rad(0),math.rad(-63.3)),Alpha)
			Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0.1,0.2,0.4)*angles(math.rad(-29.6),math.rad(16.9),math.rad(9.4))*necko,Alpha)
			book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book1.CFrame = hed.CFrame + root.CFrame.lookVector*4
			book1.Position = Vector3.new(book1.Position.X,book1.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book1.Position.Z)
			book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)		
			a.Size = a.Size + Vector3.new(0,2,0)
		end
		attack = false
		hum.WalkSpeed = 16
	end

	function LightningStrike()
		chatfunc("Take it!",Color3.new(1,1,0))
		CFuncs["EchoSound"].Create("rbxassetid://1625448638", root, 4, 1,0,10,0.15,0.5,1)
		swait(30)
		local a = Instance.new("Part",char)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = BrickColor.new("New Yeller")
		a.Material = "Neon"
		a.Transparency = 1
		a.Shape = "Cylinder"
		local ray = Ray.new(
			root.CFrame.p,                           -- origin
			(mouse.Hit.p - root.CFrame.p).unit * 500 -- direction
		) 
		local ignore = char
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (root.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance,1,1)
		a.CFrame = CFrame.new(root.CFrame.p, position) * CFrame.new(1, 1, -distance)
		local ht = Instance.new("Part",char)
		ht.Name = "Hit"	
		ht.Anchored = true
		--MagniDamage(ht, 20, 10,15, 0, "Burn")
		ht.CanCollide = false
		ht.Transparency = 1
		ht.Size = vt(0.1,0.1,0.1)
		CFuncs["Sound"].Create("rbxassetid://782353443", char, 3, 1)
		CFuncs["Sound"].Create("rbxassetid://763717897", char, 1, 1.35)
		a.CanCollide = false
		ht.Position = a.Position
		sphere2(2,"Add",ht.CFrame,vt(24,24,24),2,2,2,BrickColor.new("New Yeller"))
		sphere2(1,"Add",ht.CFrame,vt(1,100000,1),0.25,0.25,0.25,BrickColor.new("New Yeller"))
		sphere2(1,"Add",ht.CFrame,vt(24,24,24),1,1,1,BrickColor.new("New Yeller"))
		for i = 0, 9 do
			Beamring(Color3.new(1,1,1),ht.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),math.random(10,100)/10,0,math.random(1,5),348103573)
		end
		for i, v in pairs(FindNearestHead(ht.CFrame.p, 80)) do
			if v:FindFirstChild('Head') then
				--MagniDamage(v.Head, 5, 10,15, 0, "Burn")
			end
		end
		coroutine.resume(coroutine.create(function()
			game:GetService("Debris"):AddItem(a,5)
			game:GetService("Debris"):AddItem(ht,5)
		end))
	end

	function DryFreeze()
		attack = true
		hum.WalkSpeed = 0
		CFuncs["EchoSound"].Create("rbxassetid://1690476035", root, 10, 1,0.1,10,0.15,0.5,1)
		for i = 1,100 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1.1,0)*angles(math.rad(0),math.rad(85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
			LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(0),math.rad(-85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,.1)*angles(math.rad(0),math.rad(0),math.rad(-25)),.01)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(0),math.rad(25)),.01)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(10)),.02)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(-10)),.02)
			book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book4.CFrame = hed.CFrame + root.CFrame.lookVector*4
			book4.Position = Vector3.new(book4.Position.X,book4.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book4.Position.Z)
			book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
			coroutine.resume(coroutine.create(function()
				local icespike = script.Objects.IceSpike:Clone()
				icespike.Parent = char
				icespike.Transparency = 0.1
				icespike.CFrame = root.CFrame * CFrame.new((i-50)/5,-2,0)
				icespike.CFrame = icespike.CFrame + root.CFrame.lookVector*10
				icespike.Orientation = Vector3.new(math.random(-35,35),math.random(85,95),math.random(-35,35))
				--MagniDamage(icespike, 5, 10,15, 0, "Freeze")
				swait(100)
				for i = 1,30 do
					swait()
					icespike.Position = icespike.Position - Vector3.new(0,0.5,0)
					icespike.Transparency = i/30
				end
				icespike:Destroy()
			end))
		end
		attack = false
		hum.WalkSpeed = 16
	end

	function DarkPillar() -- some things here are from Spectrum v7.
		chatfunc("The end times are upon us.",Color3.new(0,0,0))
		attack = true
		hum.WalkSpeed = 0
		for i = 1,10,0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1,-1.1,0)*angles(math.rad(0),math.rad(85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
			LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(0),math.rad(-85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,.1)*angles(math.rad(0),math.rad(0),math.rad(-25)),.01)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(0),math.rad(25)),.01)
			RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(10)),.02)
			LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(-10)),.02)
			book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book5.CFrame = hed.CFrame + root.CFrame.lookVector*4
			book5.Position = Vector3.new(book5.Position.X,book5.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book5.Position.Z)
			book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
		end
		local keptcolor = BrickColor.Black()
		local pil = script.Objects.Pillar:Clone()
		pil.Parent = char
		pil.CFrame = root.CFrame + root.CFrame.lookVector*15
		pil.Position = pil.Position + Vector3.new(0,3,0)
		pil.Transparency = 0
		--MagniDamage(pil, 30, 10,15, 0, "UpKnock")
		local locat = Instance.new("Part", char)
		locat.CanCollide = false
		locat.FormFactor = 3
		locat.Name = "Ring"
		locat.Material = "Neon"
		locat.Size = Vector3.new(1, 1, 1)
		locat.Transparency = 1
		locat.TopSurface = 0
		locat.BottomSurface = 0
		locat.Anchored = true
		locat.CFrame = pil.CFrame*CFrame.new(0,-3,0)
		local poste = 0
		local rotation = 0
		local upperpos = 0
		local rate = 0
		local x = locat


		CFuncs["Sound"].Create("rbxassetid://763717897", char, 1.2, 1)
		CFuncs["Sound"].Create("rbxassetid://1192402877", char, 0.5, 0.75)
		CFuncs["Sound"].Create("rbxassetid://1664711478", char, 1.2, 0.95)
		sphere2(1,"Add",x.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.Black())
		sphere2(2,"Add",x.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.Black())
		sphere2(4,"Add",x.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.Black())
		for i = 0, 99 do
			local dis = CreateParta(char,1,1,"Neon",BrickColor.Black())
			dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-25000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(25000,0,0)
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 10)
		end
		coroutine.resume(coroutine.create(function()
			coroutine.resume(coroutine.create(function()
				local eff = Instance.new("ParticleEmitter",x)
				eff.Texture = "rbxassetid://2273224484"
				eff.LightEmission = 1
				eff.Color = ColorSequence.new(BrickColor.Black().Color)
				eff.Rate = 90000
				eff.Lifetime = NumberRange.new(3,8)
				eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,120,0),NumberSequenceKeypoint.new(0.2,25,0),NumberSequenceKeypoint.new(1,0.1,0)})
				eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
				eff.Speed = NumberRange.new(250,1500)
				eff.Drag = 5
				eff.Rotation = NumberRange.new(-500,500)
				eff.VelocitySpread = 9000
				eff.RotSpeed = NumberRange.new(-100,100)
				wait(0.7)
				eff.Enabled = false
			end))

			for i = 0, 154 do
				swait()
				rotation = rotation + 5
				poste = poste + 1
				upperpos = upperpos + rate
				rate = rate + 0.2
				sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,upperpos,poste),vt(2.5+upperpos/5,2.5+upperpos/5,2.5+upperpos/5),-0.05,-0.05,-0.05,BrickColor.Black())
				sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(90+rotation),0)*CFrame.new(0,upperpos,poste),vt(2.5+upperpos/5,2.5+upperpos/5,2.5+upperpos/5),-0.05,-0.05,-0.05,BrickColor.Black())
				sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(180+rotation),0)*CFrame.new(0,upperpos,poste),vt(2.5+upperpos/5,2.5+upperpos/5,2.5+upperpos/5),-0.05,-0.05,-0.05,BrickColor.Black())
				sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(270+rotation),0)*CFrame.new(0,upperpos,poste),vt(2.5+upperpos/5,2.5+upperpos/5,2.5+upperpos/5),-0.05,-0.05,-0.05,BrickColor.Black())
				sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(2.5+upperpos/10,2.5+upperpos/10,2.5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
				sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(90-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(3.5+upperpos/10,3.5+upperpos/10,3.5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
				sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(180-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(3.5+upperpos/10,3.5+upperpos/10,3.5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
				sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(270-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(3.5+upperpos/10,3.5+upperpos/10,3.5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
			end
			wait(6)
			x:Destroy()
		end))
		attack = false
		hum.WalkSpeed = 16
		swait(30)
		for i = 1,30 do
			swait()
			pil.Position = pil.Position - Vector3.new(0,0.5,0)
			pil.Transparency = i/30
		end
		pil:Destroy()
	end

	function Torpefy(plr)
		coroutine.resume(coroutine.create(function()
			tree(plr)	
		end))	
	end

	function tree(who)
		pcall(function()
			local ded = who
			ded.Humanoid:Remove()
			for i,v in pairs(ded:GetDescendants()) do
				if v:IsA("Part") then
					v.Material = "Grass"
					v.BrickColor = BrickColor.new("Forest green")
				elseif v:IsA("MeshPart") and v.Name ~= "treemesh" then
					v:Remove()
				elseif 	v:IsA("SpecialMesh") then
					v:Destroy()
				end
			end
			local h1 = ded:FindFirstChild("Head")
			local t1 = ded:FindFirstChild("Torso")
			local ff = ded:FindFirstChildOfClass("ForceField")
			if ff ~= nil then
				ff:Destroy()
			end
			local ra1 = ded:FindFirstChild("Right Arm")
			local la1 = ded:FindFirstChild("Left Arm")
			local rl1 = ded:FindFirstChild("Right Leg")
			local ll1 = ded:FindFirstChild("Left Leg")
			local acc = ded:FindFirstChild("xdded")
			if acc == nil then 
				local ac = Instance.new("Glue",ded) ac.Name = "xdded"
				local rut1 = ded:FindFirstChild("HumanoidRootPart")
				if rut1 ~= nil then
					rut1.Parent = nil
				end
				pcall(function()
					for i,v in pairs(who:GetChildren()) do
						if v:IsA("Accessory") or v:IsA("Hat") then
							v:Destroy()
						end
					end
					for i,v in pairs(who:GetChildren()) do
						if v:IsA("Script") or v:IsA("LocalScript") then
							if v.Name == "Health" then
								v.Parent = nil
							end
						end
					end
				end)
				t1:BreakJoints()
				ra1:BreakJoints()
				la1:BreakJoints()
				rl1:BreakJoints()
				ll1:BreakJoints()

				--//Joints~//--
				--Neck--
				if h1 ~= nil then
					local neca = Instance.new("Glue",t1) neca.Part0 = t1 neca.Part1 = h1 neca.C0 = CFrame.new(0,t1.Size.y/2,0) neca.C1 = CFrame.new(0,-h1.Size.y/2,0) neca.Name = "yo"
					local ch = Instance.new("Part",t1) ch.Name = "yo" ch.Size = Vector3.new(h1.Size.x/2,h1.Size.y/2,h1.Size.z/2 + h1.Size.z/4) ch.TopSurface = "Smooth" ch.BottomSurface = "Smooth" ch.Transparency = 1
					local wh = Instance.new("Weld",ch) wh.Part0 = h1 wh.Part1 = ch
				end
				--Right Arm--
				if ra1 ~= nil then
					local rsa = Instance.new("Glue",t1) rsa.Part0 = t1 rsa.Part1 = ra1 rsa.C0 = CFrame.new(t1.Size.x/2 + t1.Size.x/4,t1.Size.y/4,0) rsa.C1 = CFrame.new(0,ra1.Size.y/4,0) rsa.Name = "yo"
					local cra = Instance.new("Part",t1) cra.Name = "yo" cra.Size = Vector3.new(ra1.Size.y/2 + ra1.Size.y/4,ra1.Size.y/2,ra1.Size.z) cra.TopSurface = "Smooth" cra.BottomSurface = "Smooth" cra.Transparency = 1
					local wra = Instance.new("Weld",cra) wra.Part0 = ra1 wra.Part1 = cra wra.C0 = CFrame.new(0,-ra1.Size.y/8,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
				end
				--Left Arm--
				if la1 ~= nil then
					local lsa = Instance.new("Glue",t1) lsa.Part0 = t1 lsa.Part1 = la1 lsa.C0 = CFrame.new(-t1.Size.x/2 - t1.Size.x/4,t1.Size.y/4,0) lsa.C1 = CFrame.new(0,la1.Size.y/4,0) lsa.Name = "yo"
					local cla = Instance.new("Part",t1) cla.Name = "yo" cla.Size = Vector3.new(la1.Size.y/2 + la1.Size.y/4,la1.Size.y/2,la1.Size.z) cla.TopSurface = "Smooth" cla.BottomSurface = "Smooth" cla.Transparency = 1
					local wla = Instance.new("Weld",cla) wla.Part0 = la1 wla.Part1 = cla wla.C0 = CFrame.new(0,-la1.Size.y/8,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
				end
				--Right Leg--
				if rl1 ~= nil then
					local rha = Instance.new("Glue",t1) rha.Part0 = t1 rha.Part1 = rl1 rha.C0 = CFrame.new(t1.Size.x/4,-t1.Size.y/2,0) rha.C1 = CFrame.new(0,rl1.Size.y/2,0) rha.Name = "yo"
					local crl = Instance.new("Part",t1) crl.Name = "yo" crl.Size = Vector3.new(rl1.Size.y/2 + rl1.Size.y/4,rl1.Size.y/2,rl1.Size.z) crl.TopSurface = "Smooth" crl.BottomSurface = "Smooth" crl.Transparency = 1
					local wrl = Instance.new("Weld",crl) wrl.Part0 = rl1 wrl.Part1 = crl wrl.C0 = CFrame.new(0,-rl1.Size.y/8,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
				end
				--Left Leg--
				if ll1 ~= nil then
					local lha = Instance.new("Glue",t1) lha.Part0 = t1 lha.Part1 = ll1 lha.C0 = CFrame.new(-t1.Size.x/4,-t1.Size.y/2,0) lha.C1 = CFrame.new(0,ll1.Size.y/2,0) lha.Name = "yo"
					local cll = Instance.new("Part",t1) cll.Name = "yo" cll.Size = Vector3.new(ll1.Size.y/2 + ll1.Size.y/4,ll1.Size.y/2,ll1.Size.z) cll.TopSurface = "Smooth" cll.BottomSurface = "Smooth" cll.Transparency = 1
					local wll = Instance.new("Weld",cll) wll.Part0 = ll1 wll.Part1 = cll wll.C0 = CFrame.new(0,-ll1.Size.y/8,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
				end
				--//End of Joints~//--
				swait(50)
				local nou = who
				swait(300)
				local BRUTAL = Instance.new("Sound",nou)
				BRUTAL.SoundId = "rbxassetid://256509968"
				BRUTAL.Volume = 7
				BRUTAL:Play()
				coroutine.resume(coroutine.create(function()
					for i,v in pairs(nou:GetChildren()) do
						if v:IsA("Part") then
							v.Anchored = true
						end
					end
				end))
				local trae = script.Objects.treemesh:Clone()
				trae.Parent = nou
				trae.Transparency = 0
				trae.Position = nou.Torso.Position
				wait(7)
				BRUTAL:Destroy()
				local BRUTAL = Instance.new("Sound",nou)
				BRUTAL.SoundId = "rbxassetid://256509968"
				BRUTAL.Volume = 7
				BRUTAL:Play()
				trae.Size = Vector3.new(14,40,14)
				wait(7)
				BRUTAL:Destroy()
			end
		end)
	end

	function TreeReduce()
		attack = true
		hum.WalkSpeed = 0
		for i = 1,100,0.75 do
			swait()
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 1 * math.cos(0)),math.rad(0 + 2 * math.cos(SINE / 32)),math.rad(1 + 2 * math.cos(SINE / 32))),.6)
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*CFrame.new(0,-.3,-1.6) * CFrame.Angles(math.rad(20),math.rad(0 + 1.5 * math.sin(SINE / 2)),math.rad(0)),.25)
			LW.C0 = aclerp(LW.C0,CFrame.new(-0.80868268, 0.497842163, -0.14479053, 0.744864702, -0.66721499, -0.00102781132, -0.0409338176, -0.0441599488, -0.998185575, 0.665959001, 0.743555188, -0.0602048337)*angles(0,math.rad(0+2*math.cos(SINE/0.134561367)),math.rad(0+5*math.cos(SINE/0.127347))),0.3)
			RW.C0 = clerp(RW.C0, cf(1.5* Player_Size, 0.5 + 0.06 * math.sin(SINE / 20)* Player_Size, 0* Player_Size) * angles(math.rad(145), math.rad(0), math.rad(15 + 2.5 * math.sin(SINE / 20))), 0.12)
			RH.C0 = clerp(RH.C0,CFrame.new(-0.5, 0.4 + 0.01 * math.sin(SINE / 12), -0.05 + 0.001 * math.sin(SINE / 12)) * CFrame.Angles(math.rad(-10), math.rad(0 + 0.05 * math.cos(SINE / 12)), math.rad(0 + 0.05 * math.cos(SINE / 12))), 0.25)
			LH.C0 = clerp(LH.C0,CFrame.new(0.5, 0.4 + 0.01 * math.sin(SINE / 12), -0.05 + 0.001 * math.sin(SINE / 12)) * CFrame.Angles(math.rad(-10), math.rad(0 + 0.05 * math.cos(SINE / 12)), math.rad(0 + 0.05 * math.cos(SINE / 12))), 0.25)		
			book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book6.CFrame = hed.CFrame + root.CFrame.lookVector*4
			book6.Position = Vector3.new(book6.Position.X,book6.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book6.Position.Z)
			book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
		end
		CFuncs["Sound"].Create("rbxassetid://438666141", root, 7.5,1)
		CFuncs["Sound"].Create("rbxassetid://1208650519", root, 7.5, 1)
		CamShakeAll({
			Duration=0.4; 
			Intensity=3;
			Position=Vector3.new(2,2,2);
			Rotation=Vector3.new(2,2,6);
			DropDist=1000;
			IneffectiveDist=1000;
			Origin=tors.Position;
		})
		--MagniDamage(tors, 50, 1,2, 0, "Tree")
		chatfunc("Leave the dead where they fall.",Color3.new(1,1,1))
		CFuncs["Sound"].Create("rbxassetid://907329669", root, 10, 1)
		attack = false
		hum.WalkSpeed = 16
	end

	-- transparent objects --
	for i,v in pairs(script.Objects:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
		end
	end

	-- Keystrokes --

--[[z,x,c,v,b,n and m select spell books
	q,e,r,t,y, and u are attacks 
--]]

	mouse.KeyDown:connect(function(k)
		if attack == false then
			if k == "z" then
				selected = "fire"
			elseif k == "x" then
				selected = "earth"
			elseif k == "c" then
				selected = "thunder"
			elseif k == "v" then
				selected = "ice"
			elseif k == "b" then
				selected = "dark"
			elseif k == "n" then
				selected = "light"
			elseif k == "m" then
				selected = "lunar"
			end
			if selected == "fire" then
				if k == "q" then
					volcaniceruption()
				end
			elseif selected == "earth" then
				if k == "q" then
					LithosphereSpikes()
				elseif k == "e" then
					Mountain()
				end
			elseif selected == "thunder" then
				if k == "q" then
					LightningStrike()
				end
			elseif selected == "ice" then
				if k == "q" then
					DryFreeze()
				end
			elseif selected == "dark" then
				if k == "q" then
					DarkPillar()
				end
			elseif selected == "light" then
				if k == "q" then
					TreeReduce()
				end
			end
		end
	end)
	-- Final loop--

--[[

--]]

	local idle = 0

	hum.Name = "Humanoid"
	hum.MaxHealth = math.huge
	hum.Health = math.huge
	hum.BreakJointsOnDeath = false
	Instance.new("ForceField",char).Visible = false

	while true do
		swait()
		hum.MaxHealth = math.huge
		hum.Health = math.huge
		hum.BreakJointsOnDeath = false
		SINE = SINE + 1
		if attack ~= true then
			book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
			book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
			book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
			book6.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.sin(SINE / 25 + 150), RootPart.Position.Z  - math.sin(SINE/14) * 6)
			book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
		end
		if selected == "fire" then
			book2.Material = "Neon"
			book1.Material = "Plastic"
			book3.Material = "Plastic"
			book4.Material = "Plastic"
			book5.Material = "Plastic"
			book6.Material = "Plastic"
			book7.Material = "Plastic"
		elseif selected == "earth" then
			book2.Material = "Plastic"
			book1.Material = "Neon"
			book3.Material = "Plastic"		
			book4.Material = "Plastic"
			book5.Material = "Plastic"
			book6.Material = "Plastic"
			book7.Material = "Plastic"
		elseif selected == "thunder" then
			book2.Material = "Plastic"
			book1.Material = "Plastic"
			book3.Material = "Neon" 
			book4.Material = "Plastic"
			book5.Material = "Plastic"
			book6.Material = "Plastic"
			book7.Material = "Plastic"
		elseif selected == "ice" then
			book2.Material = "Plastic"
			book1.Material = "Plastic"
			book3.Material = "Plastic" 
			book4.Material = "Neon"
			book5.Material = "Plastic"	
			book6.Material = "Plastic"
			book7.Material = "Plastic"
		elseif selected == "dark" then
			book2.Material = "Plastic"
			book1.Material = "Plastic"
			book3.Material = "Plastic" 
			book4.Material = "Plastic"
			book5.Material = "Neon"
			book6.Material = "Plastic"
			book7.Material = "Plastic"
		elseif selected == "light" then
			book2.Material = "Plastic"
			book1.Material = "Plastic"
			book3.Material = "Plastic" 
			book4.Material = "Plastic"
			book5.Material = "Plastic"
			book6.Material = "Neon"
			book7.Material = "Plastic"
		elseif selected == "lunar" then
			book2.Material = "Plastic"
			book1.Material = "Plastic"
			book3.Material = "Plastic" 
			book4.Material = "Plastic"
			book5.Material = "Plastic"
			book6.Material = "Plastic"
			book7.Material = "Neon"
		end
		local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
		local velderp = RootPart.Velocity.y
		hf, pf = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
		hitfloor, posfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if not (idle >= 500) or attack == false then
		end
		if 1 < RootPart.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(SINE / 25), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(-20)), 0.1)
				LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(SINE / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(20)), 0.1)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.05 * math.cos(SINE / 25)) * angles(math.rad(-10), math.rad(0), math.rad(0)), 0.1)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-2.5), math.rad(0), math.rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, cf(1.45, 0.5 + 0.1 * math.cos(SINE / 25), 0) * angles(math.rad(-5), math.rad(0), math.rad(25)), 0.1)
				LW.C0 = clerp(LW.C0, cf(-1.45, 0.5 + 0.1 * math.cos(SINE / 25), 0) * angles(math.rad(-5), math.rad(0), math.rad(-25)), 0.1)
			end
		elseif -1 > RootPart.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(SINE / 25), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(-20)), 0.1)
				LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(SINE / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(20)), 0.1)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.05 * math.cos(SINE / 25)) * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, cf(1.45, 0.5 + 0.1 * math.cos(SINE / 25), 0) * angles(math.rad(-20), math.rad(0), math.rad(50)), 0.1)
				LW.C0 = clerp(LW.C0, cf(-1.45, 0.5 + 0.1 * math.cos(SINE / 25), 0) * angles(math.rad(-20), math.rad(0), math.rad(-50)), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			if attack == false then
				RH.C0=clerp(RH.C0,cf(1,-0.7,-0.5)*angles(math.rad(0),math.rad(80),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(10)),.15)
				LH.C0=clerp(LH.C0,cf(-1,-0.8,0)*angles(math.rad(0),math.rad(-80),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),.15)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.25)*angles(math.rad(0),math.rad(0),math.rad(-30)),.15)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(30)),.15)
				RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(SINE / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(SINE / 72)),math.rad(3 - 2 * math.cos(SINE / 58)),math.rad(-82 + 2 * math.cos(SINE / 45))),.1)
				LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(SINE / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(SINE / 66)),math.rad(4 - 3 * math.cos(SINE / 59)),math.rad(67 - 4 * math.cos(SINE / 45))),.1)
			end
		elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
			Anim = "Walk"
			if attack == false then
				RH.C0 = clerp(RH.C0, cf(1, -0.85 - 0.15 * math.cos(SINE / 3), -0.15 - 0.15 * math.cos(SINE / 3)) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 55 * math.cos(SINE / 6))), 0.1)
				LH.C0 = clerp(LH.C0, cf(-1, -0.85 + 0.15 * math.cos(SINE / 3), -0.15 + 0.15 * math.cos(SINE / 3)) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 55 * math.cos(SINE / 6))), 0.1)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.15 - 0.1 * math.cos(SINE / 3)) * angles(math.rad(5), math.rad(0), math.rad(0 - 5 * math.cos(SINE / 6))), 0.1)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(10 + 2.5 * math.cos(SINE / 100)), math.rad(0), math.rad(0 + 5 * math.cos(SINE / 6))), 0.1)
				RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0 - 75 * math.cos(SINE / 6)), math.rad(0), math.rad(10 - 10 * math.cos(SINE / 3))), 0.1)
				LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0 + 75 * math.cos(SINE / 6)), math.rad(0), math.rad(-10 + 10 * math.cos(SINE / 3))), 0.1)
			end
		elseif torvel >= 22 and hitfloor ~= nil then
			Anim = "Run"
			if attack == false then
				RH.C0 = clerp(RH.C0, cf(1, -0.75 - 0.25 * math.cos(SINE / 3), -0.25 - 0.25 * math.cos(SINE / 3)) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 95 * math.cos(SINE / 6))), 0.1)
				LH.C0 = clerp(LH.C0, cf(-1, -0.75 + 0.25 * math.cos(SINE / 3), -0.25 + 0.25 * math.cos(SINE / 3)) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 95 * math.cos(SINE / 6))), 0.1)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.125 + 0.125 * math.cos(SINE / 3)) * angles(math.rad(20), math.rad(0), math.rad(0 - 15 * math.cos(SINE / 6))), 0.1)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-10 + 2.5 * math.cos(SINE / 100)), math.rad(0), math.rad(0 + 15 * math.cos(SINE / 6))), 0.1)
				RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0 - 125 * math.cos(SINE / 6)), math.rad(0), math.rad(5 - 10 * math.cos(SINE / 3))), 0.1)
				LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0 + 125 * math.cos(SINE / 6)), math.rad(0), math.rad(-5 + 10 * math.cos(SINE / 3))), 0.1)
			end
		end
	end
end)

Button_17.MouseButton1Down:Connect(function()

	--//====================================================\\--
	--||			   CREATED BY SHACKLUSTER
	--\\====================================================//--
	--repeat wait() until script:WaitForChild'Owner'.Value

	local script = game:GetObjects("rbxassetid://6029686719")[1]

	local Player = game.Players.LocalPlayer


	local AHB = Instance.new("BindableEvent")

	local FPS = 80

	local TimeFrame = 0

	local LastFrame = tick()
	local Frame = 1/FPS

	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end

	wait(0.2)
	Player = game:GetService("Players").LocalPlayer
	PlayerGui = Player.PlayerGui
	Cam = workspace.CurrentCamera
	Backpack = Player.Backpack
	Character = Player.Character["Dummy"]
	Humanoid = Character.Humanoid
	Mouse = Player:GetMouse()
	RootPart = Character.HumanoidRootPart
	Torso = Character.Torso
	Head = Character.Head
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart.RootJoint
	Neck = Torso.Neck
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	local MOUSEPOS = RootPart.Position
	local TIME = 0
	local sick = Instance.new("Sound",Torso)
	local Firing = false

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if Firing == false then
				bp.Position = game:GetService("Players").LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor
	--//=================================\\
	--|| 	      USEFUL VALUES
	--\\=================================//

	Animation_Speed = 3
	Frame_Speed = 0.016666666666666666
	local FORCERESET = false
	Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
	local Speed = 25
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local DAMAGEMULTIPLIER = 1
	local ANIM = "Idle"
	local ATTACK = false
	local EQUIPPED = false
	local HOLD = false
	local COMBO = 1
	local Type = "Ban"
	local reason = "Ur damn skids nigga"
	local Rooted = false
	local SINE = 0
	local SIZE = 1
	local KEYHOLD = false
	local CHANGE = 2 / Animation_Speed
	local WALKINGANIM = false
	local VALUE1 = false
	local VALUE2 = false
	local ROBLOXIDLEANIMATION = IT("Animation")
	ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
	ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
	--ROBLOXIDLEANIMATION.Parent = Humanoid
	local WEAPONGUI = IT("ScreenGui", PlayerGui)
	WEAPONGUI.Name = "BanishV3Gui"
	local Characterb = IT("Model")
	Characterb.Name = "shackisgaylol"
	local CharacterA = IT("Model")
	CharacterA.Name = "shackismegagaylol"
	local Effects = IT("Folder", CharacterA)
	Effects.Name = "Effects"
	local Effects2 = IT("Folder", Characterb)
	Effects.Name = "Effects"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character:FindFirstChild("Animate")
	local UNANCHOR = true
	local TOBANISH = {}
	script.Parent = PlayerGui

	--//=================================\\
	--\\=================================//


	--//=================================\\
	--|| SAZERENOS' ARTIFICIAL HEARTBEAT
	--\\=================================//

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	--//=================================\\
	--\\=================================//

	--//=================================\\
	--|| 	      SOME FUNCTIONS
	--\\=================================//

	local BODY = {}
	for _, c in pairs(Character:GetDescendants()) do
		if c:IsA("BasePart") and c.Name ~= "Handle" then
			if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
				c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
			end
			table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
		elseif c:IsA("JointInstance") then
			table.insert(BODY,{c,c.Parent,nil,nil,nil})
		end
	end
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART.ClassName == "Part" and PART ~= RootPart then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY
			end
			PART.AncestryChanged:Connect(function()
				PART.Parent = PARENT
			end)
		end
	end

	function refit()
		Character.Parent = workspace
		for e = 1, #BODY do
			if BODY[e] ~= nil then
				local STUFF = BODY[e]
				local PART = STUFF[1]
				local PARENT = STUFF[2]
				local MATERIAL = STUFF[3]
				local COLOR = STUFF[4]
				local TRANSPARENCY = STUFF[5]
				if PART:IsA("BasePart") and PART ~= RootPart then
					PART.Material = MATERIAL
					PART.Color = COLOR
					PART.Transparency = TRANSPARENCY+EXTRATRANS
				end
				if PART.Parent ~= PARENT then
					Humanoid:remove()
					PART.Parent = PARENT
					Humanoid = IT("Humanoid",Character)
				end
			end
		end
	end

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then 
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
		local frame = IT("Frame")
		frame.BackgroundTransparency = TRANSPARENCY
		frame.BorderSizePixel = BORDERSIZEPIXEL
		frame.Position = POSITION
		frame.Size = SIZE
		frame.BackgroundColor3 = COLOR
		frame.BorderColor3 = BORDERCOLOR
		frame.Name = NAME
		frame.Parent = PARENT
		return frame
	end

	function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
		local label = IT("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UD2(1, 0, 1, 0)
		label.Position = UD2(0, 0, 0, 0)
		label.TextColor3 = TEXTCOLOR
		label.TextStrokeTransparency = STROKETRANSPARENCY
		label.TextTransparency = TRANSPARENCY
		label.FontSize = TEXTFONTSIZE
		label.Font = TEXTFONT
		label.BorderSizePixel = BORDERSIZEPIXEL
		label.TextScaled = false
		label.Text = TEXT
		label.Name = NAME
		label.Parent = PARENT
		return label
	end


	function NoOutlines(PART)
		PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
	end

	function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
		local weld = Instance.new("Weld")
		weld.Parent = parent
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
		weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
		return weld
	end

	function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
		local NEWWELD = IT(TYPE)
		NEWWELD.Part0 = PART0
		NEWWELD.Part1 = PART1
		NEWWELD.C0 = C0
		NEWWELD.C1 = C1
		NEWWELD.Parent = PARENT
		return NEWWELD
	end

	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
	end

	--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	function WACKYEFFECT(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or VT(1,1,1))
		local ENDSIZE = (Table.Size2 or VT(0,0,0))
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local MOVEDIRECTION = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLOR = (Table.Color or C3(1,1,1))
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
			elseif TYPE == "Block" then
				MSH = IT("BlockMesh",EFFECT)
				MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
			end
			if MSH ~= nil then
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
				end
				local GROWTH = SIZE - ENDSIZE
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.X/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					SOUND.Stopped:Connect(function()
						EFFECT:remove()
					end)
				end
			else
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until SOUND.Playing == false
					EFFECT:remove()
				end
			end
		end))
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	function SpawnTrail(FROM,TO,BIG)
		local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "White", "Trail", VT(0,0,0))
		MakeForm(TRAIL,"Cyl")
		local DIST = (FROM - TO).Magnitude
		if BIG == true then
			TRAIL.Size = VT(0.5,DIST,0.5)
		else
			TRAIL.Size = VT(0.25,DIST,0.25)
		end
		TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
		coroutine.resume(coroutine.create(function()
			for i = 1, 5 do
				Swait()
				TRAIL.Transparency = TRAIL.Transparency + 0.1
			end
			TRAIL:remove()
		end))
	end

	function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
		local mesh = IT("SpecialMesh",wave)
		mesh.MeshType = "Sphere"
		mesh.Scale = SIZE
		mesh.Offset = VT(0,0,0)
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				wave.Transparency = wave.Transparency + (1/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function MagicSphereCo(SIZE,WAIT,CFRAME,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
		local mesh = IT("SpecialMesh",wave)
		mesh.MeshType = "Sphere"
		mesh.Scale = SIZE
		mesh.Offset = VT(0,0,0)
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				wave.Transparency = wave.Transparency + (1/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function MagicBlock(SIZE,WAIT,CFRAME,COLOR,GROW)
		local wave = CreatePart(3, Effects, "ForceField", 0, 0.5, BRICKC(COLOR), "Effect", VT(SIZE,SIZE,SIZE), true)
		local mesh = IT("BlockMesh",wave)
		wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
				wave.Transparency = wave.Transparency + (0.5/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
		local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "559831844", "", SIZE, VT(0, 0, 0))
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				if DOESROT == true then
					wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
				end
				wave.Transparency = wave.Transparency + 0.5 / WAIT
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	local DECAL = IT("Decal")
	function MagicRing()
		local RING = CreatePart(3, Effects, "Granite", 0, 1, "Maroon", "MagicRing", VT(0,0,0),true)
		local MESH = IT("BlockMesh",RING)
		local BOTTOMTEXTURE = DECAL:Clone()
		BOTTOMTEXTURE.Parent = RING
		BOTTOMTEXTURE.Face = "Bottom"
		BOTTOMTEXTURE.Name = "BottomTexture"
		local TOPTEXTURE = DECAL:Clone()
		TOPTEXTURE.Parent = RING
		TOPTEXTURE.Face = "Top"
		TOPTEXTURE.Name = "TopTexture"
		BOTTOMTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
		TOPTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
		BOTTOMTEXTURE.Color3 = C3(0,0,0)
		TOPTEXTURE.Color3 = C3(1,1,1)
		return RING,MESH,TOPTEXTURE,BOTTOMTEXTURE
	end

	Debris = game:GetService("Debris")

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end

	function turnto(position)
		RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
	end

	function SHAKECAM(POSITION, RANGE, INTENSITY, TIME)

	end

	--//=================================\\
	--||	     WEAPON CREATION
	--\\=================================//

	local Shotgun = script.Shotgun:Clone()
	Shotgun.Parent = RightArm
	CreateWeld(Shotgun.Handle,RightArm,Shotgun.Handle,0.2,-0.1,0.5,math.rad(90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
	local Hole = Shotgun.Flash

	local hat = game:GetService("Players").LocalPlayer.Character["Type-12Accessory"]

	hat.Handle.AccessoryWeld:Destroy()

	local function align(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0.1, 1.4, -0.6) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(-85, 180, 0) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	align(hat.Handle, Shotgun.Handle)

	local Particle = IT("ParticleEmitter",nil)
	Particle.Enabled = false
	Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
	Particle.LightEmission = 0.5
	Particle.Rate = 150
	Particle.ZOffset = 0.2
	Particle.Rotation = NumberRange.new(-180, 180)
	Particle.RotSpeed = NumberRange.new(-180, 180)
	Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
	Particle.Color = ColorSequence.new(C3(0,1,0),C3(0,1.1,0))

	--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
	function ParticleEmitter(Table)
		local PRTCL = Particle:Clone()
		local Speed = Table.Speed or 5
		local Drag = Table.Drag or 0
		local Size1 = Table.Size1 or 1
		local Size2 = Table.Size2 or 5
		local Lifetime1 = Table.Lifetime1 or 1
		local Lifetime2 = Table.Lifetime2 or 1.5
		local Parent = Table.Parent or Torso
		local Emit = Table.Emit or 100
		local Offset = Table.Offset or 360
		local Acel = Table.Acel or VT(0,0,0)
		local Enabled = Table.Enabled or false
		PRTCL.Parent = Parent
		PRTCL.Size = NumberSequence.new(Size1,Size2)
		PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
		PRTCL.Speed = NumberRange.new(Speed)
		PRTCL.VelocitySpread = Offset
		PRTCL.Drag = Drag
		PRTCL.Acceleration = Acel
		if Enabled == false then
			PRTCL:Emit(Emit)
			Debris:AddItem(PRTCL,Lifetime2)
		else
			PRTCL.Enabled = true
		end
		return PRTCL
	end

	for _, c in pairs(CharacterA:GetChildren()) do
		if c.ClassName == "Part" then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
	end

	CharacterA.Parent = Character

	Characterb.Parent = Character


	local SKILLTEXTCOLOR = C3(1,1,1)
	local SKILLFONT = ""
	local SKILLTEXTSIZE = 7

	Humanoid.Died:connect(function()
		ATTACK = true
	end)

--[[local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.1, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.63, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.215, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.525, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")
]]
--[[local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Banish Bullet", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Ability 2", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Ability 3", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 3")
local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Ability 4", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 4")
local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[X] Mercy", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 5")
]]

	function chatfunc(text)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard")~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end
			local Bill = Instance.new("BillboardGui",Character)
			Bill.Size = UDim2.new(0,100,0,40)
			Bill.StudsOffset = Vector3.new(0,3,0)
			Bill.Adornee = Character.Head
			Bill.Name = "TalkingBillBoard"
			local Hehe = Instance.new("TextLabel",Bill)
			Hehe.BackgroundTransparency = 1
			Hehe.BorderSizePixel = 0
			Hehe.Text = ""
			Hehe.Font = "SourceSansItalic"
			Hehe.TextSize = 40
			Hehe.TextStrokeTransparency = 0
			Hehe.Size = UDim2.new(1,0,0.5,0)
			coroutine.resume(coroutine.create(function()
				while Hehe ~= nil do
					Swait()	
					Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
					Hehe.Rotation = math.random(-5,5)
					Hehe.TextColor3 = Color3.new(0,0,0)
					Hehe.TextStrokeColor3 = Color3.new(1,1,1)
				end
			end))
			for i = 1,string.len(text),1 do
				Swait()
				Hehe.Text = string.sub(text,1,i)
			end
			Swait(90)--Re[math.random(1, 93)]
			for i = 0, 1, .025 do
				Swait()
				Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
				Hehe.TextStrokeTransparency = i
				Hehe.TextTransparency = i
			end
			Bill:Destroy()
		end)
		chat()
	end

	function onChatted(msg)
		chatfunc(msg)
	end

	Player.Chatted:connect(onChatted)

	function printbye(Name)
		local MESSAGES = {"You cannot struggle, ","Your existance is an insult, ","Fade, ","Your existance is not desired, ","You are not permitted here, ","You are not to decide your fate, ","Be gone, ","You are already dead, ","Your live is an anomaly, ","Don't dare to return, ","Why are you resisting, ","You cannot exist here, ","Why are you struggling, ","Your fate was already decided, ","Goodbye, ","You cannot ignore my command, ","You cannot resist my command, ","You already died, "}
		chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
	end



	--//=================================\\
	--||			DAMAGING
	--\\=================================//

	function Banish(Foe)

	end

	function ApplyAoE(POSITION,RANGE,ISBANISH)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if ISBANISH == true then
								Banish(CHILD)
							else
								if ISBANISH == "Gravity" then
									HUM.PlatformStand = true
									if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
										local grav = Instance.new("BodyPosition",TORSO)
										grav.D = 15
										grav.P = 20000
										grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
										grav.position = TORSO.Position
										grav.Name = "V3BanishForce"..Player.Name
									else
										TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
										TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
									end
								else
									HUM.PlatformStand = false
								end
							end
						elseif ISBANISH == "Gravity" then
							if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
								TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
								HUM.PlatformStand = false
							end
						end
					end
				end
			end
		end
	end


	function ManualDamage(Humanoid,Damage,TorsoPart)

	end

	local asd = Instance.new("ParticleEmitter")
	asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.3, 0, 0))
	asd.LightEmission = .1
	asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
	aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6),NumberSequenceKeypoint.new(1, 2)})
	bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
	asd.Transparency = bbb
	asd.Size = aaa
	asd.ZOffset = .9
	asd.Acceleration = Vector3.new(0, -15, 0)
	asd.LockedToPart = false
	asd.EmissionDirection = "Back"
	asd.Lifetime = NumberRange.new(1, 2)
	asd.Rotation = NumberRange.new(-100, 100)
	asd.RotSpeed = NumberRange.new(-100, 100)
	asd.Speed = NumberRange.new(10)
	asd.Enabled = false
	asd.VelocitySpread = 999

	function getbloody(victim,amount)
		local PART = CreatePart(3, Effects, "Metal", 0, 1, "Mid gray", "Blood", victim.Size)
		PART.CFrame = victim.CFrame
		local HITPLAYERSOUNDS = {"356551938","264486467"}
		Debris:AddItem(PART,5)
		CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
		CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
		CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
		local prtcl = asd:Clone()
		prtcl.Parent = PART
		prtcl:Emit(amount*10)
	end

	function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if INSTAKILL == true then
								--CHILD:BreakJoints()
							else
								local DMG = MRANDOM(MINDMG,MAXDMG)
								ManualDamage(HUM,DMG,TORSO)
							end
							if FLING > 0 then
								for _, c in pairs(CHILD:GetChildren()) do
									if c:IsA("BasePart") then
										local bv = Instance.new("BodyVelocity") 
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
										bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
										bv.Parent = c
										Debris:AddItem(bv,0.05)
									end
								end
							end
						end
					end
				end
			end
		end
	end

	function KickThatNigga(CHARACTER)
		g = game.Players:GetPlayers()
		local kickfolder = IT("Folder",Effects)
		local naeeym2 = Instance.new("BillboardGui",kickfolder)
		naeeym2.AlwaysOnTop = false
		naeeym2.Size = UDim2.new(5,35,2,35)
		naeeym2.StudsOffset = Vector3.new(0,1,0)
		naeeym2.Name = "Mark"
		local tecks2 = Instance.new("TextLabel",naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.TextScaled = true
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 1
		tecks2.TextColor3 = Color3.new(1,0,0)
		tecks2.TextStrokeColor3 = Color3.new(1,0,0)
		tecks2.Size = UDim2.new(1,0,0.5,0)
		tecks2.Parent = naeeym2
		CreateSound("527749592", CHARACTER, 600, 1, false)
		for i,v in ipairs(CHARACTER:GetChildren()) do
			if v.ClassName == "Part" or v.ClassName == "MeshPart" then
				if v.Name ~= "HumanoidRootPart" then
					local BOD = v:Clone()
					BOD.CanCollide = false
					BOD.Anchored = true
					BOD.CFrame = v.CFrame
					BOD.Parent = kickfolder
					BOD.Material = "Granite"
					BOD.Color = C3(.3,0,0)
					if BOD:FindFirstChildOfClass("Decal") then
						BOD:FindFirstChildOfClass("Decal"):remove()
					end
					if BOD.Name == "Head" then
						naeeym2.Adornee = BOD
					end
					if BOD.ClassName == "MeshPart" then
						BOD.TextureID = ""
					end
				end
			end
		end
		for i,v in pairs(g) do
			v:remove()
		end 
		if CHARACTER ~= Character then
			CHARACTER:remove()
		end
		if CHARACTER.Name == "Helkern" then
			--Character:BreakJoints()
		end
		coroutine.resume(coroutine.create(function()
			for i = 1, 50 do
				Swait()
				for i,v in ipairs(kickfolder:GetChildren()) do
					if v.ClassName == "Part" or v.ClassName == "MeshPart" then
						v.Transparency = 1
					end
					naeeym2.Enabled = false
				end
				Swait()
				for i,v in ipairs(kickfolder:GetChildren()) do
					if v.ClassName == "Part" or v.ClassName == "MeshPart" then
						v.Transparency = 0
					end
					naeeym2.Enabled = true
				end
			end
			kickfolder:remove()
		end))
	end

	function ApplyAoE(POSITION,RANGE,ISKICKED)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if ISKICKED == true then
								KickThatNigga(CHILD)
							else
								if ISKICKED == "Gravity" then
									HUM.PlatformStand = true
									if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
										local grav = Instance.new("BodyPosition",TORSO)
										grav.D = 15
										grav.P = 20000
										grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
										grav.position = TORSO.Position
										grav.Name = "V3BanishForce"..Player.Name
									else
										TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
										TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
									end
								else
									HUM.PlatformStand = false
								end
							end
						elseif ISKICKED == "Gravity" then
							if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
								TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
								HUM.PlatformStand = false
							end
						end
					end
				end
			end
		end
	end

	local BEANED = {}

	function Ban(bitch)	
		if bitch then	
			g = game.Players:GetPlayers()
			local kickfolder = IT("Folder",Effects)
			local naeeym2 = Instance.new("BillboardGui",kickfolder)
			naeeym2.AlwaysOnTop = false
			naeeym2.Size = UDim2.new(5,35,2,35)
			naeeym2.StudsOffset = Vector3.new(0,1,0)
			naeeym2.Name = "Mark"
			local tecks2 = Instance.new("TextLabel",naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.TextScaled = true
			tecks2.BorderSizePixel = 0
			tecks2.Text = ""
			tecks2.Font = "SciFi"
			tecks2.TextSize = 30
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = Color3.new(1,0,0)
			tecks2.TextStrokeColor3 = Color3.new(1,0,0)
			tecks2.Size = UDim2.new(1,0,0.5,0)
			tecks2.Parent = naeeym2
			-- CreateSound("2570187601", bitch, 600, 1, false)
			local Players = game:GetService("Players")
			local fag = Players:FindFirstChild(bitch.Name)
			--faggut:Kick()
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick(reason)
			end
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick(reason)
			end
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick(reason)
			end
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick(reason)
			end
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick(reason)
			end
			if Players:FindFirstChild(bitch.Name) then
				fag:Kick(reason)
			end
			if Players:FindFirstChild("Drago_TH") then
			end
			table.insert(BEANED,bitch.name)
			--]]
			--CreateSound("527749592", game.Workspace, 700, 1, false)
			--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
			coroutine.resume(coroutine.create(function()
				for i = 1, 50 do
					Swait()
					for i,v in ipairs(kickfolder:GetChildren()) do
						if v.ClassName == "Part" or v.ClassName == "MeshPart" then
							v.Transparency = 1
						end
						naeeym2.Enabled = false
					end
					Swait()
					for i,v in ipairs(kickfolder:GetChildren()) do
						if v.ClassName == "Part" or v.ClassName == "MeshPart" then
							v.Transparency = 0
						end
						naeeym2.Enabled = true
					end
				end
				kickfolder:remove()
			end))
			--wait(6)
			--bitch:Remove()
		end
	end

	local function CheckForBan(player)
		for i = 1, #BEANED do
			if player.Name == BEANED[i] then
				player:Kick("Ur mom gay skids") --Ban Reason Change between the '' to change the reason!
			end
		end
	end


	game.Players.PlayerAdded:connect(function()
		for i,v in pairs(game.Players:GetPlayers())do
			CheckForBan(v)
		end  
	end)


	function Kick(bitch)
		g = game.Players:GetPlayers()
		local kickfolder = IT("Folder",Effects)
		local naeeym2 = Instance.new("BillboardGui",kickfolder)
		naeeym2.AlwaysOnTop = false
		naeeym2.Size = UDim2.new(5,35,2,35)
		naeeym2.StudsOffset = Vector3.new(0,1,0)
		naeeym2.Name = "Mark"
		local tecks2 = Instance.new("TextLabel",naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.TextScaled = true
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = Color3.new(1,0,0)
		tecks2.TextStrokeColor3 = Color3.new(1,0,0)
		tecks2.Size = UDim2.new(1,0,0.5,0)
		tecks2.Parent = naeeym2
		-- CreateSound("2570187601", bitch, 600, 1, false)
		local Players = game:GetService("Players")
		local fag = Players:FindFirstChild(bitch.Name)
		--faggut:Kick()
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick(reason)
		end
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick(reason)
		end
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick(reason)
		end
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick(reason)
		end
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick(reason)
		end
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick(reason)
		end
	--[[
		for i,v in pairs(fag.Name) do
		if (v:lower() == newPlayer.Name:lower()) then
			newPlayer:Remove()
		end
	end]]--
		--CreateSound("527749592", game.Workspace, 700, 1, false)
		--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
		coroutine.resume(coroutine.create(function()
			for i = 1, 50 do
				Swait()
				for i,v in ipairs(kickfolder:GetChildren()) do
					if v.ClassName == "Part" or v.ClassName == "MeshPart" then
						v.Transparency = 1
					end
					naeeym2.Enabled = false
				end
				Swait()
				for i,v in ipairs(kickfolder:GetChildren()) do
					if v.ClassName == "Part" or v.ClassName == "MeshPart" then
						v.Transparency = 0
					end
					naeeym2.Enabled = true
				end
			end
			kickfolder:remove()
		end))
		--wait(6)
		--bitch:Remove()
	end


	function ApplyAoE(POSITION,RANGE,ISBANISH)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if ISBANISH == true then
								--Banish(CHILD)
							else
								if ISBANISH == "Gravity" then
									HUM.PlatformStand = true
									if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
										local grav = Instance.new("BodyPosition",TORSO)
										grav.D = 15
										grav.P = 20000
										grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
										grav.position = TORSO.Position
										grav.Name = "V3BanishForce"..Player.Name
									else
										TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
										TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
									end
								else
									HUM.PlatformStand = false
								end
							end
						elseif ISBANISH == "Gravity" then
							if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
								TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
								HUM.PlatformStand = false
							end
						end
					end
				end
			end
		end
	end

	function KickAoE(POSITION,RANGE,BRUTAL)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if BRUTAL == true then
								if Type == "Banish" then
									KickThatNigger(CHILD)
								elseif Type == "Ban" then
									Ban(CHILD)
								elseif Type == "Kick" then
									Kick(CHILD)
									--elseif Type == "Tangle" then
									--Entangle(CHILD)
								end
							else
								--CHILD:BreakJoints()
							end
						end
					end
				end
			end
		end
	end

	local PE=Instance.new("ParticleEmitter",art)
	PE.LightEmission=.8
	PE.Color = ColorSequence.new(BRICKC("Really red").Color)
	PE.Lifetime=NumberRange.new(0.35,1.5)
	PE.Rotation=NumberRange.new(0,360)
	PE.Rate=999
	PE.VelocitySpread = 10000
	PE.Acceleration = Vector3.new(0,0,0)
	PE.Drag = 5
	PE.Speed = NumberRange.new(0,0,0)
	PE.Texture="http://www.roblox.com/asset/?id=833874434"
	PE.ZOffset = -1.5
	PE.Name = "PE"
	PE.Enabled = false

	function particles(art)
		local PARTICLES = PE:Clone()
		PARTICLES.Parent = art
	end

	function KillChildren(v)
		--v:BreakJoints()
		for _, c in pairs(v:GetChildren()) do
			if c.ClassName == "Part" or c.ClassName == "MesPart" then
				if c.Transparency < 1 then
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end
					particles(c)
					c.PE.Enabled = true
					c.Parent = Effects
					c.CanCollide = false
					c.Material = "Neon"
					c.Color = C3(1,0,0)
					c.Transparency = 0.5
					local grav = Instance.new("BodyPosition",c)
					grav.P = 20000
					grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
					grav.position = c.Position + VT(MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1))
					grav.Name = "GravityForce"
					coroutine.resume(coroutine.create(function()
						for i = 1, 50 do
							Swait()
							c.Transparency = c.Transparency + 0.01
						end
						c.PE.Enabled = false
						Debris:AddItem(c,2)
					end))
				end
			end
		end
	end

	function killnearest(position,range)

	end

	function Dismember(MAN,DOWHAT)
		for index, CHILD in pairs(MAN:GetDescendants()) do
			if CHILD:IsA("Script") or CHILD:IsA("LocalScript") then
				CHILD:Destroy()
			end
		end
		if DOWHAT == "Ragdoll" then
			local HUM = MAN:FindFirstChildOfClass("Humanoid")
			if HUM then
				HUM.Health = 0
			end
			if MAN:FindFirstChild("UpperTorso") then
				local SCRIPT = script.R15Ragdoll:Clone()
				SCRIPT.Parent = MAN
				SCRIPT.Disabled = false
			else
				local SCRIPT = script.R6Ragdoll:Clone()
				SCRIPT.Parent = MAN
				SCRIPT.Disabled = false
			end
			--MAN:BreakJoints()
		else
			local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
			local HED = MAN:FindFirstChild("Head")
			if TORSO and HED then
				if DOWHAT == "Head" then
					if TORSO:FindFirstChild("TorsoA4") then
						TORSO:FindFirstChild("TorsoA4"):Remove()
					elseif MAN:FindFirstChild("RagdollConstraintHead") then
						MAN:FindFirstChild("RagdollConstraintHead"):Remove()
					end
					--HED:BreakJoints()
				elseif DOWHAT == "RightArm" then
					if TORSO:FindFirstChild("TorsoA3") then
						TORSO:FindFirstChild("TorsoA3"):Remove()
					elseif MAN:FindFirstChild("RagdollConstraintRightUpperArm") then
						MAN:FindFirstChild("RagdollConstraintRightUpperArm"):Remove()
					end
				elseif DOWHAT == "LeftArm" then
					if TORSO:FindFirstChild("TorsoA2") then
						TORSO:FindFirstChild("TorsoA2")
					elseif MAN:FindFirstChild("RagdollConstraintLeftUpperArm") then
						MAN:FindFirstChild("RagdollConstraintLeftUpperArm"):Remove()
					end
				elseif DOWHAT == "Legs" then
					if TORSO.Name == "Torso" then
						if TORSO:FindFirstChild("TorsoA") then
							TORSO:FindFirstChild("TorsoA"):Remove()
						end
						if TORSO:FindFirstChild("TorsoA1") then
							TORSO:FindFirstChild("TorsoA1"):Remove()
						end
					elseif MAN:FindFirstChild("RagdollConstraintUpperTorso") then
						MAN:FindFirstChild("RagdollConstraintUpperTorso"):Remove()
					end
				end
			end
		end
	end

	function OofOuchBlood(LOCATION,TO,AMOUNT)
		local P = CreatePart(3, Effects, "Granite", 0, 1, BRICKC("Pearl"), "Blood", VT(0,0,0), true)
		P.CFrame = CF(LOCATION,TO)
		local BLOOD = script.Blood:Clone()
		BLOOD.Parent = P
		BLOOD:Emit(AMOUNT)
		Debris:AddItem(P,2)
	end

	local DETECTKILL = function(HIT,POS,FORCE)
		if HIT.Parent:FindFirstChildOfClass("Humanoid") then
			if HIT.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
				local BV = IT("BodyVelocity")
				BV.MaxForce = BV.MaxForce * 500
				BV.Velocity = CF(RootPart.Position,HIT.Position+VT(0,5,0)).lookVector*(FORCE or 25)
				BV.Parent = HIT
				Debris:AddItem(BV,0.05)
				OofOuchBlood(POS,RootPart.Position,150)
			else
				OofOuchBlood(POS,RootPart.Position,2)
			end
		end
	end

	--//=================================\\
	--||	ATTACK FUNCTIONS AND STUFF
	--\\=================================//

	function Zone()
		ATTACK = true
		Rooted = true
		for i=0, 5, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(-18)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(12), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
		ATTACK = false
		Rooted = false
	end

	function meme()
		local TARGET = Mouse.Target
		if TARGET ~= nil then
			if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
				local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
				local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
				if ROOT and HUM.Health > 0 then
					local FOE = Mouse.Target.Parent
					RootPart.CFrame = ROOT.CFrame*CF(0.3,0,6)
					ROOT.Anchored = true
					local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
					if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
						local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
						local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
						if TORSO and HUM.Health > 0 then
							Firing = true
							ATTACK = true
							Rooted = false
							CreateSound(429459101, TORSO, 0.5, 1, false)
							for i=0, 2, 0.1 / Animation_Speed do
								Swait()
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							end
							for i=0, 1, 0.1 / Animation_Speed do
								Swait()
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(85), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(90), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							end
							WACKYEFFECT({Time = 18, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(Hole.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = 136523485, SoundPitch = 1, SoundVolume = 5})
							for i=0, 0.5, 0.1 / Animation_Speed do
								Swait()
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.5, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(-6), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.2, -0.8) * ANGLES(RAD(85), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.4, -0.3) * ANGLES(RAD(90), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-25)), 0.5 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							end
							Firing = false
							getbloody(TORSO,1)
							SHAKECAM(HITPOS, 15, 2, 130)
							killnearest(TORSO.Position, 5, 5)
							WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(10,10,10), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = MRANDOM(13,15)/10, SoundVolume = 3})
							WACKYEFFECT({EffectType = "Sphere", Size = VT(6,6,6), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							ATTACK = false
							Rooted = false
							repeat wait() until Firing == true
							repeat
								game:GetService("RunService").Heartbeat:Wait()
								if Firing == true then
									bp.Position = TORSO.Position
								end
							until Firing == false
						end
					end
				end
			end
		end
	end

	function Dance()
		ATTACK = true
		Rooted = true
		local LOOP = true
		KEY = Mouse.KeyDown:connect(function(NEWKEY)
			if NEWKEY == "t" then
				KEY:Disconnect()
				LOOP = false
			end
		end)
		repeat
			for i = 0, 0.4, 0.1 / Animation_Speed do
				Swait()
				if LOOP == false then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0.1 + ((1) - 1)) * ANGLES(RAD(-8), RAD(0), RAD(60)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.2, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(15)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(15)), 1 / Animation_Speed)
			end
			for i = 0, 1, 0.1 / Animation_Speed do
				Swait()
				if LOOP == false then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(26)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(26)), 1 / Animation_Speed)
			end
			for i = 0, 0.4, 0.1 / Animation_Speed do
				Swait()
				if LOOP == false then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0.1 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(60)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.2, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 1 / Animation_Speed)
			end
			for i = 0, 1, 0.1 / Animation_Speed do
				Swait()
				if LOOP == false then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-26)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-26)), 1 / Animation_Speed)
			end
		until LOOP == false
		ATTACK = false
		Rooted = false
	end


	--//=================================\\
	--||	  ASSIGN THINGS TO KEYS
	--\\=================================//

	-------------------------------------

	Humanoid.Animator.Parent = nil

	-------------------------------------


	function MouseDown(Mouse)
		if ATTACK == false then
		end
	end


	function MouseUp(Mouse)
		HOLD = false
	end

	function KeyDown(Key)
		KEYHOLD = true
		if Key == "v" and ATTACK == false then
			meme()
		end

		if Key == "t" and ATTACK == false then
			Dance()
		end
	end

	function KeyUp(Key)
		KEYHOLD = false
	end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

	--//=================================\\
	--\\=================================//


	function unanchor()
		if UNANCHOR == true then
			g = CharacterA:GetChildren()
			for i = 1, #g do
				if g[i].ClassName == "Part" then
					g[i].Anchored = false
				end
			end
		end
	end


	--//=================================\\
	--||	WRAP THE WHOLE SCRIPT UP
	--\\=================================//

	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)

	local CONNECT = nil

	while true do
		Swait()
		ANIMATE.Parent = nil
		if Character:FindFirstChildOfClass("Humanoid") == nil then
			Humanoid = IT("Humanoid",Character)
		end
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local NameClan = 0
		local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
		SINE = SINE + CHANGE
		if ANIM == "Walk" and TORSOVELOCITY > 1 then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.2 * COS(SINE / (WALKSPEEDVALUE))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 100, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1 - 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1 + 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		end
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(15)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			ANIM = "Idle"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(45)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.15 / Animation_Speed)
				if MRANDOM(1,50) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-10,10)), RAD(MRANDOM(-10,10)), RAD(MRANDOM(-10,10))), 1 / Animation_Speed)
				end	
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.3, 0) * ANGLES(RAD(15 - 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.8, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(86), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-86), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		end
		unanchor()
		Humanoid.MaxHealth = "inf"
		Humanoid.Health = "inf"
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		if sick.Parent ~= Torso then
			sick = IT("Sound", Torso)
		end
		sick.Parent = Torso
		sick.Playing = true
		sick.Looped = true
		sick.Volume = 2
		sick.Pitch = 1
		sick.SoundId = "rbxassetid://549162782"
		sick.Name = "Dead"
	end

	--//=================================\\
	--\\=================================//





	--//====================================================\\--
	--||			  		 END OF SCRIPT
	--\\====================================================//--

end)

Button_18.MouseButton1Down:Connect(function()
	local script = game:GetObjects("rbxassetid://6027975138")[1]

	local AHB = Instance.new("BindableEvent")

	local FPS = 30

	local TimeFrame = 0

	local LastFrame = tick()
	local Frame = 1/FPS

	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end

	-- converter by Drahazar

	--created by helkern
	--some things might be taken from other scripts

	wait(1/60)

	Player = game:GetService("Players").LocalPlayer
	PlayerGui = Player.PlayerGui
	Cam = workspace.CurrentCamera
	Backpack = Player.Backpack
	Character = Player.Character["Dummy"]
	Humanoid = Character.Humanoid
	Mouse = Player:GetMouse()
	RootPart = Character["HumanoidRootPart"]
	Torso = Character["Torso"]
	Head = Character["Head"]
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	local sick = Instance.new("Sound",Torso)

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor


	Animation_Speed = 3
	Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
	local Speed = 40
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local ANIM = "Idle"
	local ATTACK = false
	local EQUIPPED = false
	local HOLD = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local KEYHOLD = false
	local CHANGE = 2 / Animation_Speed
	local WALKINGANIM = false
	--ROBLOXIDLEANIMATION.Parent = Humanoid
	local Effects = IT("Folder", Character)
	Effects.Name = "Effects"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character.Animate
	ANIMATOR:Destroy()
	local UNANCHOR = true
	local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}	
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)


	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function Clerp(a, b, t)
		return a:lerp(b,t)
	end



	function weld(parent, part0, part1, c0, c1)
		local w = IT("Weld")
		w.Part0 = part0
		w.Part1 = part1
		w.C0 = c0
		w.C1 = c1
		w.Parent = parent
		return w
	end

	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.EmitterSize = 5*VOLUME
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

	function WACKYEFFECT2(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or VT(1,1,1))
		local ENDSIZE = (Table.Size2 or VT(0,0,0))
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local MOVEDIRECTION = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLOR = (Table.Color or C3(1,1,1))
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
		local BOOMERANG = (Table.Boomerang or 0)
		local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
			elseif TYPE == "Block" or TYPE == "Box" then
				MSH = IT("BlockMesh",EFFECT)
				MSH.Scale = SIZE
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
			end
			if MSH ~= nil then
				local BOOMR1 = 1+BOOMERANG/50
				local BOOMR2 = 1+SIZEBOOMERANG/50
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					if USEBOOMERANGMATH == true then
						MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
					else
						MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
					end
				end
				local GROWTH = nil
				if USEBOOMERANGMATH == true then
					GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
				else
					GROWTH = (SIZE - ENDSIZE)
				end
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				if USEBOOMERANGMATH == true then
					for LOOP = 1, TIME+1 do
						Swait()
						MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
							EFFECT.Orientation = ORI
						end
					end
				else
					for LOOP = 1, TIME+1 do
						Swait()
						MSH.Scale = MSH.Scale - GROWTH/TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
							EFFECT.Orientation = ORI
						end
					end
				end
				EFFECT.Transparency = 1
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			else
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			end
		end))
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	Debris = game:GetService("Debris")

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end


	function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)

	end


	local asd = Instance.new("ParticleEmitter")
	asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.3, 0, 0))
	asd.LightEmission = .1
	asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
	aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6),NumberSequenceKeypoint.new(1, 2)})
	bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
	asd.Transparency = bbb
	asd.Size = aaa
	asd.ZOffset = .9
	asd.Acceleration = Vector3.new(0, -15, 0)
	asd.LockedToPart = false
	asd.EmissionDirection = "Back"
	asd.Lifetime = NumberRange.new(1, 2)
	asd.Rotation = NumberRange.new(-100, 100)
	asd.RotSpeed = NumberRange.new(-100, 100)
	asd.Speed = NumberRange.new(10)
	asd.Enabled = false
	asd.VelocitySpread = 999

	function getbloody(victim,amount)
		local PART = CreatePart(3, Effects, "Metal", 0, 1, "Mid gray", "Blood", victim.Size)
		PART.CFrame = victim.CFrame
		local HITPLAYERSOUNDS = {"356551938","264486467"}
		Debris:AddItem(PART,5)
		CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
		CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
		CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
		local prtcl = asd:Clone()
		prtcl.Parent = PART
		prtcl:Emit(amount*10)
	end



	--weap
	local SONG = 1251094537
	d = CF(0,0,0)
	local gu = script.g
	local w = weld(RightArm,gu.Main,RightArm,CF(0,-.3,0)*ANGLES(RAD(180),RAD(180),RAD(180)),d)
	for i,v in pairs(gu:GetChildren()) do
		v.Anchored = false	
	end
	gu.Parent = Character
	gu.Gun.Transparency = 1

	-- local script = game:GetObjects("rbxassetid://id")[1]

	local hat = game:GetService("Players").LocalPlayer.Character["Sniper"]

	hat.Handle.AccessoryWeld:Destroy()

	local function align(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(-2.8,-0.3, 0) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(80, -180, -90) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 20000
		weldpos.MaxVelocity = math.huge
		weldpos.Responsiveness = 200000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 20000
		weldrot.MaxAngularVelocity = math.huge
		weldrot.Responsiveness = 200000
	end

	align(hat.Handle, gu.Main)

	local naeeym2 = IT("BillboardGui",Character)
	naeeym2.AlwaysOnTop = true
	naeeym2.Size = UDim2.new(5,35,2,15)
	naeeym2.StudsOffset = Vector3.new(0,2,0)
	naeeym2.MaxDistance = 75
	naeeym2.Adornee = Character.Head
	naeeym2.Name = "a"
	local t = IT("TextLabel",naeeym2)
	t.BackgroundTransparency = 1
	t.TextScaled = true
	t.BorderSizePixel = 0
	t.Text = "The Hotline"
	t.Font = "Arial"
	t.TextSize = 45
	t.TextStrokeTransparency = 0
	t.TextColor3 = C3(1,1,1)
	t.TextStrokeColor3 = C3(0,0,0)
	t.Size = UDim2.new(1,0,0.5,0)
	t.Parent = naeeym2
	Hole = gu.Hole
	gre = script.gre
	gre.Parent = nil

	--uhhh

	function chatfunc(text,timeex)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard")~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end
			local naeey2 = Instance.new("BillboardGui",Character)
			naeey2.AlwaysOnTop = true
			naeey2.Size = UDim2.new(5,35,2,15)
			naeey2.StudsOffset = Vector3.new(0,2,0)
			naeey2.MaxDistance = 75
			naeey2.Adornee = Character.Head
			local tecks2 = t:Clone()
			tecks2.Parent = naeey2
			local tecks3 = t:Clone()
			t.TextTransparency = t.TextTransparency  + 1
			t.TextStrokeTransparency = t.TextStrokeTransparency + 1
			for i = 0, 74*timeex do
				swait()
				t.TextTransparency = 1
				t.TextStrokeTransparency = 1
				tecks2.Text = text
				tecks3.Text = text
			end
			local randomrot = math.random(1,2)
			if randomrot == 1 then
				for i = 1, 50 do
					swait()
					tecks2.Text = text
					tecks3.Text = text
					t.TextTransparency = t.TextTransparency - .02
					t.TextStrokeTransparency = t.TextStrokeTransparency - .02
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			elseif randomrot == 2 then
				for i = 1, 50 do
					swait()
					tecks2.Text = text
					tecks3.Text = text
					t.TextTransparency = t.TextTransparency - .02
					t.TextStrokeTransparency = t.TextStrokeTransparency - .02
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks2.TextTransparency = tecks2.TextTransparency + .04
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
					tecks3.TextTransparency = tecks2.TextTransparency + .04
				end
			end
			t.TextTransparency = 0
			t.TextStrokeTransparency = 0
			naeey2:Destroy()
		end)
		chat()
	end
	---

	--dmg

	function kill(MODEL)

	end

	function ManSlaughter(MAN)

	end

	function ApplyDamage(Humanoid,Damage)

	end

	function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
		for index, CHILD in pairs(workspace:GetDescendants()) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if INSTAKILL == true then
								ManSlaughter(CHILD)
							else
								local DMG = MRANDOM(MINDMG,MAXDMG)
								ApplyDamage(HUM,DMG)
							end
							if FLING > 0 then
								for _, c in pairs(CHILD:GetChildren()) do
									if c:IsA("BasePart") then
										local bv = Instance.new("BodyVelocity") 
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
										bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
										bv.Parent = c
										Debris:AddItem(bv,0.05)
									end
								end
							end
						end
					end
				end
			end
		end
	end

	--attacks
	function cs()
		if SONG == 1251094537 then
			SONG = 150486020
		elseif SONG == 150486020 then
			SONG = 143364907
		elseif SONG == 143364907 then
			SONG = 729655571
		elseif SONG == 729655571 then
			SONG = 234176878
		elseif SONG == 234176878 then
			SONG = 1338971957
		elseif SONG == 1338971957 then
			SONG = 4361463193
		elseif SONG == 4361463193 then
			SONG = 1251094537	
		end
	end

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	v.Anchored = false

	local Outline = Instance.new("SelectionBox", v)
	Outline.LineThickness = 0.1
	Outline.Color3 = Color3.fromRGB(195, 130, 0)
	Outline.Adornee = v

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if ATTACK == false then
				bp.Position = game.Players.LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)

	function shoot()
		ATTACK = true
		for i = 1,15 do
			Swait()
			local Alpha = .15
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.1)*ANGLES(RAD(-90),RAD(0),RAD(-155.3)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.1,0.6,-0.4)*ANGLES(RAD(170.2),RAD(-6),RAD(95.9)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.1,0.1,-0.1)*ANGLES(RAD(-72.1),RAD(71.7),RAD(152.2)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(-0,1,0)*ANGLES(RAD(-90),RAD(0),RAD(132.1)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(-5.5),RAD(-51.6),RAD(-7.9)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1.1,-0.9,0)*ANGLES(RAD(-45.9),RAD(76.5),RAD(45.8)),Alpha)	
		end	
		CreateSound(3617692930,gu.Gun,5,1,false)
		for i = 1,10 do
			Swait()
			local Alpha = .15
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.1)*ANGLES(RAD(-90),RAD(0),RAD(-155.3)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.6,0.6,-0.9)*ANGLES(RAD(164.8),RAD(39.6),RAD(97.6)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.1,0.1,-0.1)*ANGLES(RAD(-72.1),RAD(71.7),RAD(152.2)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(-0,1,0.1)*ANGLES(RAD(-97.3),RAD(1.8),RAD(166.5)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(-5.5),RAD(-51.6),RAD(-7.9)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1.1,-0.9,0)*ANGLES(RAD(-45.9),RAD(76.5),RAD(45.8)),Alpha)	
		end
		for i = 0,30 do
			Swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.1)*ANGLES(RAD(-90),RAD(0),RAD(-155.3)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.2,0.8,-1)*ANGLES(RAD(93.7),RAD(-0.8),RAD(73.2)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5,-0.2)*ANGLES(RAD(8.3),RAD(68.5),RAD(88.8)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(-0,1,0)*ANGLES(RAD(-90),RAD(0),RAD(153.1)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(-5.5),RAD(-51.6),RAD(-7.9)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1.1,-0.9,0)*ANGLES(RAD(-45.9),RAD(76.5),RAD(45.8)),Alpha)
		end	
		repeat
			for i = 0,2 do
				Swait()
				local Alpha = .1
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.1)*ANGLES(RAD(-90),RAD(0),RAD(-155.3)),Alpha)
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.2,0.8,-1)*ANGLES(RAD(93.7),RAD(-0.8),RAD(73.2)),Alpha)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5,-0.2)*ANGLES(RAD(8.3),RAD(68.5),RAD(88.8)),Alpha)
				Neck.C0 =Neck.C0:lerp(CF(-0,1,0)*ANGLES(RAD(-90),RAD(0),RAD(153.1)),Alpha)
				LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(-5.5),RAD(-51.6),RAD(-7.9)),Alpha)
				RightHip.C0 = RightHip.C0:lerp(CF(1.1,-0.9,0)*ANGLES(RAD(-45.9),RAD(76.5),RAD(45.8)),Alpha)
			end
			local HIT,POS = CastProperRay(Hole.Position,  Mouse.Hit.p, 500, Character)
			local DISTANCE = (POS - Hole.Position).Magnitude
			if HIT then
				if HIT.Parent:FindFirstChildOfClass("Humanoid") then
					ManSlaughter(HIT.Parent)
				elseif HIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
					ManSlaughter(HIT.Parent.Parent)
				end
			end
			WACKYEFFECT2({Time = 12, EffectType = "Box", Size = VT(.01,.01,.01), Size2 = VT(.7,.7,.7), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = nil, RotationX = MRANDOM(-20,20), RotationY = MRANDOM(-20,20), RotationZ = MRANDOM(-20,20), Material = "Neon", Color = C3(1,1,0),SoundID = 529312443, SoundPitch = 1, SoundVolume = 10, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			WACKYEFFECT2({Time = 8, EffectType = "Box", Size = Vector3.new(0,0,DISTANCE), Size2 = Vector3.new(0.1,0.1,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(Hole.Position,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT2({Time = 20, EffectType = "Round Slash", Size = VT(.01,.01,.01), Size2 = VT(.025,.01,.025), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})

			for i = 0,0.10,0.2 do
				Swait()
				local Alpha = .6
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,0+0.08*COS(SINE/27),-0.1)*ANGLES(RAD(-90),RAD(0),RAD(-155.3)),Alpha)
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.2,0.8,-.5)*ANGLES(RAD(93.7),RAD(-0.8),RAD(73.2)),Alpha)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.5,0)*ANGLES(RAD(8.3),RAD(68.5),RAD(88.8)),Alpha)
				Neck.C0 =Neck.C0:lerp(CF(-0,1,0)*ANGLES(RAD(-90),RAD(0),RAD(153.1)),Alpha)
				LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1-0.08*COS(SINE/27),0.1)*ANGLES(RAD(-5.5),RAD(-51.6),RAD(-7.9)),Alpha)
				RightHip.C0 = RightHip.C0:lerp(CF(1.1,-0.9-0.08*COS(SINE/27),0)*ANGLES(RAD(-45.9),RAD(76.5),RAD(45.8)),Alpha)	
			end
		until HOLD == false
		ATTACK = false
		repeat wait() until ATTACK == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if ATTACK == true then
				bp.Position = Mouse.Hit.p
			end
		until ATTACK == false
	end

	function taunt()
		ATTACK = true
		chatfunc("Such a waste.",.8)
		local args = {
			[1] = "Such a waste.",
			[2] = "All"
		}

		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args))
		CreateSound(4148542202,RootPart,6,1,false)
		for i = 0,85 do
			local Alpha = .1
			Swait()
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.1)*ANGLES(RAD(-90),RAD(0),RAD(-155.3)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.7,0.3,-0.9)*ANGLES(RAD(-36),RAD(-68.6),RAD(143.6)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.5,0.3,0)*ANGLES(RAD(-9.8),RAD(14.7),RAD(-109.1)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.6),RAD(-4.8),RAD(-155.8 - 20 * COS(SINE/8))),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(-5.5),RAD(-51.6),RAD(-7.9)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1,-0.9,0)*ANGLES(RAD(-45.9),RAD(76.5),RAD(45.8)),Alpha)
		end
		ATTACK = false
	end

	function grenade()
		ATTACK = true
		for i = 0,20 do
			Swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.1)*ANGLES(RAD(-90),RAD(0),RAD(-155.3)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.9,0.4,0)*ANGLES(RAD(24.5),RAD(-38.2),RAD(62.8)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.5,0.3,0)*ANGLES(RAD(-9.8),RAD(14.7),RAD(-109.1)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-99.3),RAD(-11),RAD(-130.6)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(-5.5),RAD(-51.6),RAD(-7.9)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1.1,-0.9,0)*ANGLES(RAD(-45.9),RAD(76.5),RAD(45.8)),Alpha)
		end
		local grec = gre:Clone()
		grec.Parent = Character
		grec.Anchored = false
		for i,v in pairs(grec:GetChildren()) do
			if v:IsA("BasePart") then v.Anchored = false end
		end
		local gw = weld(LeftArm,grec,LeftArm,CF(0.4,0,1)*ANGLES(RAD(90),0,0),d)
		CreateSound(326088041,grec,8,1,false)
		for i = 0,24 do
			Swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0.1,0.2)*ANGLES(RAD(-76.8),RAD(0),RAD(-155.3)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.7,0.7,0.1)*ANGLES(RAD(68),RAD(-67),RAD(-128.6)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.5,0.3,0)*ANGLES(RAD(-9.8),RAD(14.7),RAD(-109.1)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-92.1),RAD(-4.7),RAD(175)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-0.9,-1,0.1)*ANGLES(RAD(-24.1),RAD(-50.1),RAD(-16.4)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1.1,-1.1,0)*ANGLES(RAD(-38),RAD(80.2),RAD(25.4)),Alpha)
		end
		gw:Destroy()
		for i,v in pairs(grec:GetChildren()) do
			if v:IsA("BasePart") then
				v.CanCollide = true
			end
		end
		grec.CanCollide = true
		grec.Parent = workspace
		local br = CF(grec.Position,Mouse.Hit.p)
		local mmm = IT("BodyVelocity")
		mmm.Parent = grec
		mmm.Velocity = br.lookVector*125
		mmm.MaxForce = VT(50000,50000,50000)
		Debris:AddItem(mmm,.19)
		Debris:AddItem(grec,3)
		coroutine.resume(coroutine.create(function()
			local h = false
			swait(1.2)
			local hi = grec.Touched:Connect(function(hit)
				if h == false and hit.Parent ~= Character then
					h = true
					grec:BreakJoints()
					ApplyAoE(grec.Position,33,0,0,100,true)
					CreateSound(142070127,grec,10,1,false)
					for i = 1,4 do
						WACKYEFFECT2({Time = 80, EffectType = "Sphere", Size = VT(40,40,40), Size2 = VT(55,55,55), Transparency = 0, Transparency2 = 1, CFrame = grec.CFrame, MoveToPos = grec.Position + VT(MRANDOM(-25,25),0,MRANDOM(-25,25)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(255,MRANDOM(30,150),0),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
					end
					for i = 1,25 do
						WACKYEFFECT2({Time = 80, EffectType = "Sphere", Size = VT(1.3,1.3,1.3), Size2 = VT(.3,.3,.3), Transparency = 0, Transparency2 = 1, CFrame = grec.CFrame*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = grec.Position+VT(MRANDOM(-40,40),MRANDOM(-40,40),MRANDOM(-40,40)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(255,MRANDOM(30,150),0),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})

					end
				end	
			end)
		end))
		for i = 0,15 do
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.1)*ANGLES(RAD(-99.7),RAD(0),RAD(-155.3)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.9,-0.1)*ANGLES(RAD(105.8),RAD(-53.2),RAD(-39)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.5,0.3,0)*ANGLES(RAD(-9.8),RAD(14.7),RAD(-109.1)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,-0.1)*ANGLES(RAD(-76.3),RAD(-5.8),RAD(158.8)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-0.9,-1,0)*ANGLES(RAD(8.4),RAD(-51.4),RAD(-1.4)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1.1,-0.8,-0.1)*ANGLES(RAD(-47.5),RAD(73.5),RAD(56.6)),Alpha)	
		end

		for i = 0,20 do
			Swait()
			local Alpha = .25
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.4)*ANGLES(RAD(-136.9),RAD(0),RAD(-155.3)),Alpha)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.6,-0.9)*ANGLES(RAD(111.5),RAD(-33.8),RAD(79.8)),Alpha)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.5,0.3,0)*ANGLES(RAD(-9.8),RAD(14.7),RAD(-109.1)),Alpha)
			Neck.C0 =Neck.C0:lerp(CF(0,1,-0.1)*ANGLES(RAD(-76.3),RAD(-5.8),RAD(158.8)),Alpha)
			LeftHip.C0 = LeftHip.C0:lerp(CF(-0.7,-1,-0.9)*ANGLES(RAD(-134.4),RAD(-73.1),RAD(-61.8)),Alpha)
			RightHip.C0 = RightHip.C0:lerp(CF(1.2,-0.5,-0.2)*ANGLES(RAD(-41),RAD(62.5),RAD(86.1)),Alpha)
		end
		ATTACK = false	
		repeat wait() until ATTACK == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if ATTACK == true then
				bp.Position = Mouse.Hit.p
			end
		until ATTACK == false
	end
	--keys
	function MouseDown(Mouse)
		HOLD = true
		if ATTACK == false then
			shoot()
		end
	end

	function MouseUp(Mouse)
		HOLD = false
	end

	function KeyDown(Key)
		KEYHOLD = true
		if Key == "z" and ATTACK == false then
			grenade()	
		end
		if Key == "x" and ATTACK == false then

		end

		if Key == "c" and ATTACK == false then

		end

		if Key == "v" and ATTACK == false then

		end

		if Key == "b" and ATTACK == false then

		end

		if Key == "t" and ATTACK == false then
			taunt()
		end

		if Key == "m" then
			cs()
		end

		if Key == "]" and ATTACK == false then
			if sick.Parent ~= Character then
				sick = IT("Sound",Torso)
				sick.SoundId = "rbxassetid://"..SONG
			end
		end
	end

	function KeyUp(Key)
		KEYHOLD = false
	end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

	function unanchor()
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA("BasePart") and c ~= RootPart then
				c.Anchored = false
			end
		end
		if UNANCHOR == true then
			RootPart.Anchored = false
		else
			RootPart.Anchored = true
		end
	end

	--loop stuff

	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)


	while true do
		Swait()
		ANIMATE.Parent = nil
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		SINE = SINE + CHANGE*2
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
		local TiltVelocity = CF(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity/1.6))
		local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
		t.Rotation = 4*SIN(SINE/30)
		t.TextColor3 = Color3.fromRGB(127.5 + 127.5 * COS(SINE/35),127.5 + 127.5 * COS(SINE/35),127.5 + 127.5 * COS(SINE/35))
		t.TextStrokeColor3 = Color3.fromRGB(127.5 - 127.5 * COS(SINE/35),127.5 - 127.5 * COS(SINE/35),127.5 - 127.5 * COS(SINE/35))
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.5,0.3,0)*ANGLES(RAD(-9.8),RAD(14.7),RAD(-109.1)),1/Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.5,0.3,0)*ANGLES(RAD(-9.8),RAD(14.7),RAD(-109.1)),1/Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			local Alpha = .1
			ANIM = "Idle"
			if ATTACK == false then
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 + 0.08 * COS(SINE/27),-0.1)*ANGLES(RAD(-90),RAD(0),RAD(-155.3)),Alpha)
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.9,0.4,-0.1)*ANGLES(RAD(-36),RAD(-68.6 + 3 * SIN(SINE/27)),RAD(-38)),Alpha)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.5,0.3,0)*ANGLES(RAD(-9.8 +2.5*COS(SINE/27)),RAD(14.7),RAD(-109.1)),Alpha)
				Neck.C0 =Neck.C0:lerp(CF(-0,1,0)*ANGLES(RAD(-90 + 2 * SIN(SINE/27)),RAD(0),RAD(132.1)),Alpha)
				LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1- 0.08 * COS(SINE/27),0.1)*ANGLES(RAD(-5.5),RAD(-51.6),RAD(-7.9)),Alpha)
				RightHip.C0 = RightHip.C0:lerp(CF(1,-0.9- 0.08 * COS(SINE/27),0)*ANGLES(RAD(-45.9),RAD(76.5),RAD(45.8)),Alpha)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				local Alpha = .1
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 + .1 * SIN(SINE/WALKSPEEDVALUE*2),0 - 0.10 * COS(SINE/(WALKSPEEDVALUE/2)))*ANGLES(RAD(-92+3*SIN(SINE/(WALKSPEEDVALUE/2)))+RAD(TiltVelocity.z),RAD(0),RAD(-180+10*COS(SINE/WALKSPEEDVALUE))),Alpha)
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,0)*ANGLES(RAD(-55*COS(SINE/WALKSPEEDVALUE))+SIN(SINE/WALKSPEEDVALUE)/2.5,RAD(-90)-RAD(TiltVelocity.X)*0.5,RAD(0)),Alpha)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.5,0.3,0)*ANGLES(RAD(-9.8),RAD(14.7),RAD(-109.1)),Alpha)
				Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-80+1.5*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(-180-10*COS(SINE/WALKSPEEDVALUE)-RAD(TiltVelocity.z)*1)-RAD(TiltVelocity.x)*3),Alpha)
				LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1+1.85*COS(SINE/WALKSPEEDVALUE)/2,0-0.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5+65*COS(SINE/WALKSPEEDVALUE))+RootPart.RotVelocity.Y/75+SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.z)*10,RAD(-90-25*COS(SINE/WALKSPEEDVALUE)*RAD(TiltVelocity.X)*4.5),RAD(0))*ANGLES(RAD(0-2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)
				RightHip.C0 = RightHip.C0:lerp(CF(1,-1-1.85*COS(SINE/WALKSPEEDVALUE)/2,0+0.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5-65*COS(SINE/WALKSPEEDVALUE))-RootPart.RotVelocity.Y/-75+-SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.z)*10,RAD(90+25*COS(SINE/WALKSPEEDVALUE)*RAD(TiltVelocity.X)*4.5),RAD(0))* ANGLES(RAD(0+2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)	
			end
		end
		unanchor()
		Humanoid.MaxHealth = 1e4
		Humanoid.Health = 1e4
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		sick.SoundId = "rbxassetid://"..SONG
		sick.Looped = true
		sick.Pitch = 1
		sick.Volume = 3
		sick.Playing = true
	end
end)

Button_19.MouseButton1Down:Connect(function()
	workspace.FallenPartsDestroyHeight = -1000

	local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
	local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
	local C3 = {N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
	local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
	local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
	local R3 = {N=Region3.new}
	local De = S.Debris
	local WS = workspace
	local Lght = S.Lighting
	local RepS = S.ReplicatedStorage
	local IN = Instance.new
	local Plrs = S.Players

	Player = game.Players.LocalPlayer
	Character = Player.Character["Dummy"]
	PlayerGui = Player.PlayerGui
	Backpack = Player.Backpack
	Humanoid = Character.Humanoid
	RootPart = Character["HumanoidRootPart"]
	Torso = Character["Torso"]
	Torso.Transparency = 1
	Head = Character["Head"]
	Head.Transparency = 1
	RightArm = Character["Right Arm"]
	RightArm.Transparency = 1
	LeftArm = Character["Left Arm"]
	LeftArm.Transparency = 1
	RightLeg = Character["Right Leg"]
	RightLeg.Transparency = 1
	LeftLeg = Character["Left Leg"]
	LeftLeg.Transparency = 1
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]

	IT = Instance.new
	it = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor
	vt = Vector3.new
	cf = CFrame.new


	--//=================================\\
	--|| 	      USEFUL VALUES
	--\\=================================//
	local SONG1 = 1416035124
	local SONG2 = 1416035124
	local BanishMode = 555
	local KeepPlayersOutfit = false
	local SIZE = 1
	local Player_Size = 1
	local Jump = 50
	local Animation_Speed = 3
	local lastbeat = 0
	local lastloud = 0
	local AntiBullet = true
	local PlaybackSound = 0
	local Speed = 45
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local faceShadingFolder = IT("Model", Character)
	faceShadingFolder.Name = "Face Shading Folder"
	local Weapon = IT("Model")
	Weapon.Name = "Finding Lost"
	local Karma = IT("Model")
	Weapon.Name = "Finding Lost"
	local KarmaWeapon = IT("Model")
	Weapon.Name = "Finding Lost"
	local KarmaWeapon2 = IT("Model")
	Weapon.Name = "Finding Lost"
	local HornFolder = IT("Model", Character)
	HornFolder.Name = "Horns"
	local BannedSkids = {}
	local TOBANISH = {}
	local TAIL = {}
	local qui = Enum.EasingStyle.Quint
	local io = Enum.EasingDirection.InOut
	local char = Player.Character["Dummy"]
	local t = char:FindFirstChild("Torso")
	local ls = t:FindFirstChild("Left Shoulder")
	local rh = t:FindFirstChild("Right Hip")
	local lh = t:FindFirstChild("Left Hip")
	local hum = char:FindFirstChildOfClass("Humanoid")
	local tweens = game:GetService("TweenService")
	local rs = t:FindFirstChild("Right Shoulder")
	local rut = char.HumanoidRootPart
	local rutj = rut.RootJoint
	local t = char:FindFirstChild("Torso")
	local nec = t.Neck
	local MAINRUINCOLOR = BrickColor.Black()
	local DAMAGEMULTIPLIER = 1
	local ANIM = "Idle"
	local ATTACK = false
	local targetted = nil
	local EQUIPPED = false
	local HOLD = false
	local furmode = false
	local sitting = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local rad = math.rad
	local KEYHOLD = false
	local CHANGE = 2 / Animation_Speed
	local WALKINGANIM = false
	local VALUE1 = false
	local VALUE2 = false
	local NICE = false
	local RunService = game:GetService("RunService")
	local ROBLOXIDLEANIMATION = IT("Animation")
	ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
	ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
	--ROBLOXIDLEANIMATION.Parent = Humanoid
	local Effects = IT("Folder", Character)
	Effects.Name = "Effects"
	pcall(function()
		Character.Animate.Parent = nil
	end)
	local UNANCHOR = true

	function Rainbowify(name)
		while RunService.Stepped:Wait() do
			for a = 1,360,1 do wait(.0000000000000000000000001)
				name.Color = Color3.fromHSV(a/360,1,1)
			end
		end
	end

	function RainbowifyText(name)
		while RunService.Stepped:Wait() do
			for a = 1,360,1 do wait(.0000000000000000000000001)
				name.TextColor3 = Color3.fromHSV(a/360,1,1) 			
				name.TextStrokeColor3 = Color3.fromHSV(a/360,1,1)
			end
		end
	end

	local FONTS = {
		Enum.Font.Antique,
		Enum.Font.Arcade,
		Enum.Font.Arial,
		Enum.Font.ArialBold,
		Enum.Font.Bodoni,
		Enum.Font.Cartoon,
		Enum.Font.Code,
		Enum.Font.Fantasy,
		Enum.Font.Garamond,
		Enum.Font.Highway,
		Enum.Font.Legacy,
		Enum.Font.SciFi,
		Enum.Font.SourceSans,
		Enum.Font.SourceSansBold,
		Enum.Font.SourceSansItalic,
		Enum.Font.SourceSansLight,
		Enum.Font.SourceSansSemibold
	}

	local PlayerSize = 1
	local FT,FRA,FLA,FRL,FLL = Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh")
	FT.MeshId,FT.Scale = "rbxasset://fonts/torso.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
	FRA.MeshId,FRA.Scale = "rbxasset://fonts/rightarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
	FLA.MeshId,FLA.Scale = "rbxasset://fonts/leftarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
	FRL.MeshId,FRL.Scale = "rbxasset://fonts/rightleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
	FLL.MeshId,FLL.Scale = "rbxasset://fonts/leftleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)

	local naeeym2 = Instance.new("BillboardGui",Character)
	naeeym2.AlwaysOnTop = true
	naeeym2.Size = UDim2.new(7,35,3,15)
	naeeym2.StudsOffset = Vector3.new(0,2,0)
	naeeym2.MaxDistance = 10000
	naeeym2.Adornee = Head
	naeeym2.Name = "Name2"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = "Broken"
	tecks2.Font = "Arcade"
	tecks2.TextSize = 35
	tecks2.TextStrokeTransparency = 0
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
	tecks2.TextColor3 = Color3.fromRGB()
	coroutine.resume(coroutine.create(function()
		while true do
			Swait()
			tecks2.Font = FONTS[MRANDOM(1, #FONTS)]
			tecks2.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
		end
	end))
	spawn(function() RainbowifyText(tecks2) end)

	--//=================================\\
	--\\=================================//

	--//=================================\\
	--|| SAZERENOS' ARTIFICIAL HEARTBEAT
	--\\=================================//
	Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	--//=================================\\
	--\\=================================//


	--//=================================\\
	--|| 	      SOME FUNCTIONS
	--\\=================================//
	NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance,parent)
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end

	local tlerp = function(part,tablee,leinght,easingstyle,easingdirec)
		pcall(function()
			local info = TweenInfo.new(
				leinght,
				easingstyle,
				easingdirec,
				0,
				false,
				0
			)
			local lerp = tweens:Create(part,info,tablee)
			lerp:Play()
		end)
	end

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function hasarrived(whom)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
					v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
				end
				local droppingFrame = false
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				scrg.Name = "ARRIVAL"
				local mainFrame = Instance.new("Frame", scrg)
				mainFrame.Name = "MainFrame"
				mainFrame.BackgroundTransparency = 0
				mainFrame.BorderSizePixel = 5
				mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
				mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
				local TextFrame = Instance.new("TextLabel",mainFrame)
				TextFrame.Name = "TextFrame"
				TextFrame.Font = "Arcade"
				TextFrame.Text = ""
				TextFrame.TextScaled = true
				TextFrame.TextSize = 14
				TextFrame.TextStrokeTransparency = 0
				TextFrame.BackgroundTransparency = 1
				TextFrame.Size = UDim2.new(1, 0, 0, 92)
				TextFrame.Position = UDim2.new(0, 0, 0, 0)
				local fvalen = 0.55
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						Swait()
						mainFrame.BackgroundColor3 = C3(0,0,0)
						mainFrame.BorderColor3 = C3(1, 1, 1)
						if(not droppingFrame)then
							mainFrame.Rotation = 0 - 2 * COS(SINE / 24)
						end
						TextFrame.TextColor3 = C3(0,0,0)
						TextFrame.Font = FONTS[MRANDOM(1, #FONTS)]
						TextFrame.TextStrokeColor3 = C3(1, 1, 1)
						TextFrame.TextStrokeTransparency = 0
					end
				end))
				for i = 1,string.len(whom),1 do
					TextFrame.Text = string.sub(whom,1,i)
					wait(0.2)
				end
				wait(2)
				droppingFrame = true
				mainFrame.Rotation = 0
				local vinc2 = 1
				for i = 0, 99 do
					Swait()
					vinc2 = vinc2 + 0.25
					mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
				end
				scrg:Destroy()
			end))
		end
	end

	function hasarrivedB(whom)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
					v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
				end
				local droppingFrame = false
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				scrg.Name = "ARRIVAL"
				local mainFrame = Instance.new("Frame", scrg)
				mainFrame.Name = "MainFrame"
				mainFrame.BackgroundTransparency = 1
				mainFrame.BorderSizePixel = 0
				mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
				mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
				local TextFrame = Instance.new("TextLabel",mainFrame)
				TextFrame.Name = "TextFrame"
				TextFrame.Font = "Arcade"
				TextFrame.Text = ""
				TextFrame.TextScaled = true
				TextFrame.TextSize = 9
				TextFrame.TextStrokeTransparency = 1
				TextFrame.BackgroundTransparency = 1
				TextFrame.TextColor3 = C3(1,1,1)
				TextFrame.TextStrokeColor3 = C3(0, 0, 0)
				TextFrame.Size = UDim2.new(1, 0, 0, 92)
				TextFrame.Position = UDim2.new(0, 0, 0, 0)
				spawn(function() RainbowifyText(TextFrame) end)
				local fvalen = 0.55
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						Swait()
						mainFrame.BackgroundColor3 = C3(0,0,0)
						mainFrame.BorderColor3 = C3(0, 0, 0)
						if(not droppingFrame)then
							mainFrame.Rotation = 0 - 2 * COS(SINE / 24)
						end
						TextFrame.TextStrokeTransparency = 0
					end
				end))
				for i = 1,string.len(whom),1 do
					TextFrame.Text = string.sub(whom,1,i)
					wait(0.2)
				end
				wait(2)
				droppingFrame = true
				mainFrame.Rotation = 0
				local vinc2 = 1
				for i = 0, 99 do
					Swait()
					vinc2 = vinc2 + 0.25
					mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
				end
				scrg:Destroy()
			end))
		end
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then 
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	function turnto(position)
		RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
	end

	function CreateWave(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(0,0,0))
		local mesh = IT("SpecialMesh",wave)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
		mesh.Scale = SIZE
		mesh.Offset = VT(0,0,-SIZE.X/8)
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
				wave.Color = C3(0,0,0)
				if DOESROT == true then
					wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
				end
				wave.Transparency = wave.Transparency + (0.5/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function CreateSwirl(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(0,0,0))
		local mesh = IT("SpecialMesh",wave)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = "http://www.roblox.com/asset/?id=1051557"
		mesh.Scale = SIZE
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
				wave.Color = C3(0,0,0)
				if DOESROT == true then
					wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
				end
				wave.Transparency = wave.Transparency + (0.5/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function killnearest(position,range,maxstrength,direction)

	end


	function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0, COLOR, "Effect", VT(1,1,1), true)
		local mesh = IT("SpecialMesh",wave)
		mesh.MeshType = "Sphere"
		mesh.Scale = SIZE
		mesh.Offset = VT(0,0,0)
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				wave.Color = C3(0,0,0)
				wave.Transparency = wave.Transparency + (1/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function SpliceSlice(KIND, SIZE, WAIT, CFRAME, COLOR, GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(1, 1, 1), true)
		local mesh
		if KIND == "Base" then
			mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0, SIZE / 10, SIZE / 10), VT(0, 0, 0))
		elseif KIND == "Thin" then
			mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662586858", "", VT(SIZE / 10, 0, SIZE / 10), VT(0, 0, 0))
		elseif KIND == "Round" then
			mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662585058", "", VT(SIZE / 10, 0, SIZE / 10), VT(0, 0, 0))
		end
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW / 10
				wave.Color = C3(0,0,0)
				wave.Transparency = wave.Transparency + 0.5 / WAIT
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function AddChildrenToTable(FROM, PARENT, DIST, TABLE)
		for _, c in pairs(PARENT:GetChildren()) do
			if c.ClassName == "Model" then
				if c ~= Character and c:FindFirstChildOfClass("Humanoid") and (c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")) then
					local HUMANOID = c:FindFirstChildOfClass("Humanoid")
					local TORSO = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
					if DIST > (TORSO.Position - FROM).Magnitude then
						table.insert(TABLE, c)
					end
					AddChildrenToTable(FROM, c, DIST, TABLE)
				elseif c.ClassName == "Folder" then
					AddChildrenToTable(FROM, c, DIST, TABLE)
				end
			end
		end
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	function Slice(SIZE,WAIT,CFRAME,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(1,1,1), true)
		local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0,SIZE/10,SIZE/10), VT(0,0,0))
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale * GROW
				wave.Color = C3(0,0,0)
				wave.Transparency = wave.Transparency + (0.5/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function CreateWave2(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
		local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(0,0,0))
		local mesh = IT("SpecialMesh",wave)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
		mesh.Scale = SIZE
		wave.CFrame = CFRAME
		coroutine.resume(coroutine.create(function(PART)
			for i = 1, WAIT do
				Swait()
				mesh.Scale = mesh.Scale + GROW
				wave.Color = C3(0,0,0)
				if DOESROT == true then
					wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
				end
				wave.Transparency = wave.Transparency + (0.5/WAIT)
				if wave.Transparency > 0.99 then
					wave:remove()
				end
			end
		end))
	end

	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
		local frame = IT("Frame")
		frame.BackgroundTransparency = TRANSPARENCY
		frame.BorderSizePixel = BORDERSIZEPIXEL
		frame.Position = POSITION
		frame.Size = SIZE
		frame.BackgroundColor3 = COLOR
		frame.BorderColor3 = BORDERCOLOR
		frame.Name = NAME
		frame.Parent = PARENT
		return frame
	end

	function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
		local label = IT("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UD2(1, 0, 1, 0)
		label.Position = UD2(0, 0, 0, 0)
		label.TextColor3 = TEXTCOLOR
		label.TextStrokeTransparency = STROKETRANSPARENCY
		label.TextTransparency = TRANSPARENCY
		label.FontSize = TEXTFONTSIZE
		label.Font = TEXTFONT
		label.BorderSizePixel = BORDERSIZEPIXEL
		label.TextScaled = false
		label.Text = TEXT
		label.Name = NAME
		label.Parent = PARENT
		return label
	end

	function NoOutlines(PART)
		PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
	end

	function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
		local NEWWELD = IT(TYPE)
		NEWWELD.Part0 = PART0
		NEWWELD.Part1 = PART1
		NEWWELD.C0 = C0
		NEWWELD.C1 = C1
		NEWWELD.Parent = PARENT
		return NEWWELD
	end

	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
	end

	--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	function WACKYEFFECT(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or VT(1,1,1))
		local ENDSIZE = (Table.Size2 or VT(0,0,0))
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local MOVEDIRECTION = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLOR = (Table.Color or C3(1,1,1))
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
			elseif TYPE == "Block" or TYPE == "Box" then
				MSH = IT("BlockMesh",EFFECT)
				MSH.Scale = SIZE
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
			end
			if MSH ~= nil then
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
				end
				local GROWTH = SIZE - ENDSIZE
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.X/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			else
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			end
		end))
	end

	Debris = game:GetService("Debris")

	function CharacterFade(COLOR,TIMER)

	end

	function Chunks(PART)
		for i = 1, MRANDOM(3,5) do
			coroutine.resume(coroutine.create(function()
				local CHUNK = CreatePart(3, workspace, PART.Material, 0, PART.Transparency, PART.BrickColor, "Chunk", VT(0.3,0.3,0.3)*MRANDOM(7,13)/10, false)
				CHUNK.CFrame = PART.CFrame*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				local CFRAME = PART.CFrame*CF(MRANDOM(-4,4)/2,MRANDOM(-4,4)/2,-6)
				CHUNK.Velocity = CF(PART.Position,CFRAME.p).lookVector*MRANDOM(15,65)
				wait(0.1)
				CHUNK.CanCollide = true
				wait(MRANDOM(15,25)/5)
				for i = 1, 25 do
					Swait()
					CHUNK.Transparency = CHUNK.Transparency + 1/25
				end
				CHUNK:remove()
			end))
		end
	end

	New = function(Object, Parent, Name, Data)
		local Object = Instance.new(Object)
		for Index, Value in pairs(Data or {}) do
			Object[Index] = Value
		end
		Object.Parent = Parent
		Object.Name = Name
		return Object
	end

	NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance,parent)
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end

	local function ToMesh(Part)
		local Mesh=Instance.new("SpecialMesh",Part)
		if Part.Shape==Enum.PartType.Block then Mesh.MeshType="Brick"elseif Part.Shape==Enum.PartType.Ball then Mesh.MeshType="Sphere"elseif Part.Shape==Enum.PartType.Cylinder then Mesh.MeshType="Cylinder"end
		Mesh.Scale=Part.Size*20 Part.Size=Vector3.new()
		return Mesh
	end
	local function GHK(char)
		local Players=game:service("Players")
		local soidk=Players:FindFirstChild(tostring(char))
		if soidk~=nil then if soidk.Character and soidk~=Player and tostring(soidk)~="CKBackup"then-- print("hit : "..tostring(soidk))
				soidk.Character.Parent=workspace soidk.Character:BreakJoints()--soidk.Character:Destroy()
				if soidk.Character:FindFirstChild("HumanoidRootPart")then
					local p=Instance.new("Part")p.Size=Vector3.new(8,8,8)p.Material="Neon"p.Color=Color3.new(1)local m=ToMesh(p)p.Anchored=true p.CanCollide=false p.CFrame=soidk.Character.HumanoidRootPart.CFrame p.Parent=workspace m.MeshType="Sphere"
					p.CFrame=p.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),0)spawn(function()for i=0,1,.05 do if p.Parent then m.Scale=m.Scale+Vector3.new(25,25,25)p.Transparency=i swait()end end p:Destroy()end)
					for i=1,3 do local p=Instance.new("Part")p.Size=Vector3.new(8,8,8)p.Material="Neon"p.Color=Color3.new(1)local m=ToMesh(p)p.Anchored=true p.CanCollide=false p.CFrame=soidk.Character.HumanoidRootPart.CFrame p.Parent=workspace m.MeshType="Sphere"
						p.CFrame=p.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),0)spawn(function()for i=0,1,.01 do if p.Parent then m.Scale=m.Scale+Vector3.new(25,-1,-1)p.Transparency=i swait()end end p:Destroy()end)	
					end
				end spawn(function()swait(20)soidk.Character:Destroy()end)
			end
		end return soidk end

	function dmg(dude,bloods,isfal)--(Position, Direction, Range, Ignore)

	end

	function mdmg(Part, Magnitude,Spread)--, MinimumDamage, MaximumDamage, KnockBack, Type, HitSound, HitPitch)
		--local buddy
		for _, c in pairs(workspace:children()) do
			local hum = c:FindFirstChildOfClass("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("HumanoidRootPart")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if mag <= Magnitude and c.Name ~= Player.Name then 
						if c.Name ~= Character then
							if c.Name ~= "tomonaoboys" then
								local asd = Instance.new("ParticleEmitter",c.HumanoidRootPart)
								asd.Color = ColorSequence.new(Color3.new(1, 0, 0), Color3.new(.5, 0, 0))
								asd.LightEmission = .1
								asd.Size = NumberSequence.new(0.2)
								asd.Texture = "http://www.roblox.com/asset/?ID=771221224"
								asd.ZOffset = .9
								asd.Acceleration = Vector3.new(0, -5, 0)
								asd.LockedToPart = false
								asd.EmissionDirection = "Back"
								asd.Lifetime = NumberRange.new(1, 2)
								asd.Rate = 1000
								asd.Rotation = NumberRange.new(-10000, 10000)
								asd.RotSpeed = NumberRange.new(-100, 100)
								asd.Speed = NumberRange.new(6)
								asd.VelocitySpread = 1000000
								asd.Enabled=true
								--Damage(head, head, MinimumDamage, MaximumDamage, KnockBack, Type, RootPart, .1, "rbxassetid://" .. HitSound, HitPitch)
								if Spread==nil then Spread=1 end
								dmg(c,Spread)
								coroutine.wrap(function()
									wait(.2)
									asd.Enabled = false
									wait(2)
									asd:Remove()
								end)()
							else		
								Effects.Sphere.Create(BrickColor.new("Bright red"), c.HumanoidRootPart.CFrame, 30, 30, 30, .5, .5, .5, 0.04)

							end
						end
					end
				end
			end
			if c:FindFirstChild("Torso")then
				if (Part.Position-c.Torso.Position).magnitude<=Magnitude then
					GHK(c)
				end
			end
		end
	end

	function sphereMK(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos)
		local chaosmode = true
		hum = char.Humanoid
		local storehumanoidWS = 16
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1, y1, z1)
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10 / bonuspeed, 0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value / bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value * bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.Black()
				end
				speeder = speeder - 0.01 * FastSpeed * bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
				rng.Transparency = rng.Transparency + 0.01 * bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end

	function sphere(bonuspeed, type, pos, scale, value, color)
		local chaosmode = true
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10 / bonuspeed, 0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value / bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value * bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.Black()
				end
				rng.Transparency = rng.Transparency + 0.01 * bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
			end
			rng:Destroy()
		end))
	end

	local function Create(Type)
		local NewInstance = Instance.new(Type)
		return function(Properties)
			for i,v in pairs(Properties) do
				NewInstance[i] = v
			end
			return NewInstance
		end
	end

	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end

	CFuncs = {	
		["Part"] = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part"){
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material,
				}
				RemoveOutlines(Part)
				return Part
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Mesh"] = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh){
					Parent = Part,
					Offset = OffSet,
					Scale = Scale,
				}
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end;
		};

		["Weld"] = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld"){
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1,
				}
				return Weld
			end;
		};

		["Sound"] = {
			Create = function(id, par, vol, pit) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 10)
				end))
			end;
		};

		["TimeSound"] = {
			Create = function(id, par, vol, pit, timepos) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						TimePosition = timepos,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 10)
				end))
			end;
		};
		["EchoSound"] = {
			Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
				coroutine.resume(coroutine.create(function()
					local Sas = Create("Sound"){
						Volume = vol,
						Name = "EffectSoundo",
						Pitch = pit or 1,
						SoundId = id,
						TimePosition = timepos,
						Parent = par or workspace,
					}
					local E = Create("EchoSoundEffect"){
						Delay = echodelay,
						Name = "Echo",
						Feedback = fedb,
						DryLevel = dryl,
						Parent = Sas,
					}
					wait() 
					Sas:play() 
					game:GetService("Debris"):AddItem(Sas, delays)
				end))
			end;
		};

		["LongSound"] = {
			Create = function(id, par, vol, pit) 
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound"){
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace,
					}
					wait() 
					S:play() 
					game:GetService("Debris"):AddItem(S, 60)
				end))
			end;
		};

		["ParticleEmitter"] = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter"){
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread,
				}
				return fp
			end;
		};

		CreateTemplate = {

		};
	}

	function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
		local type = type
		local rotenable = rotatingop
		local rng = Instance.new("Part", Effects)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		if typeoftrans == "In" then
			rng.Transparency = 1
		end
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "FileMesh"
		if typeofshape == "Normal" then
			rngm.MeshId = "rbxassetid://662586858"
		elseif typeofshape == "Round" then
			rngm.MeshId = "rbxassetid://662585058"
		end
		rngm.Scale = scale
		local scaler2 = 1/10
		if type == "Add" then
			scaler2 = 1*value/10
		elseif type == "Divide" then
			scaler2 = 1/value/10
		end
		local randomrot = MRANDOM(1,2)
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				Swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed/10
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed/10
				end
				if rotenable == true then
					if randomrot == 1 then
						rng.CFrame = rng.CFrame*CFrame.Angles(0,RAD(rotspeed*bonuspeed/2),0)
					elseif randomrot == 2 then
						rng.CFrame = rng.CFrame*CFrame.Angles(0,RAD(-rotspeed*bonuspeed/2),0)
					end
				end
				if typeoftrans == "Out" then
					rng.Transparency = rng.Transparency + 0.01*bonuspeed
				elseif typeoftrans == "In" then
					rng.Transparency = rng.Transparency - 0.01*bonuspeed
				end
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
			end
			rng:Destroy()
		end))
	end

	function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
		local type = type
		local rng = Instance.new("Part", Effects)
		rng.Anchored = true
		rng.BrickColor = color
		rng.Color = color3
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Brick"
		rngm.Scale = scale
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				Swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.CFrame = rng.CFrame*CFrame.Angles(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
		local type = type
		local rng = Instance.new("Part", Effects)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = scale
		local scaler2 = 1
		local scaler2b = 1
		local scaler2c = 1
		if type == "Add" then
			scaler2 = 1*value
			scaler2b = 1*value2
			scaler2c = 1*value3
		elseif type == "Divide" then
			scaler2 = 1/value
			scaler2b = 1/value2
			scaler2c = 1/value3
		end
		coroutine.resume(coroutine.create(function()
			for i = 0,10/bonuspeed,0.1 do
				Swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01*value/bonuspeed
					scaler2b = scaler2b - 0.01*value/bonuspeed
					scaler2c = scaler2c - 0.01*value/bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01/value*bonuspeed
					scaler2b = scaler2b - 0.01/value*bonuspeed
					scaler2c = scaler2c - 0.01/value*bonuspeed
				end
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
			end
			rng:Destroy()
		end))
	end

	function ManualDamage(Humanoid,Damage,TorsoPart)
		local defence = Instance.new("BoolValue",Humanoid.Parent)
		defence.Name = ("HitBy"..Player.Name)
		game:GetService("Debris"):AddItem(defence, 0.001)
		Damage = Damage * DAMAGEMULTIPLIER
		if Humanoid.Health ~= 0 then
			local CritChance = MRANDOM(1,100)
			if Damage > Humanoid.Health then
				Damage = math.ceil(Humanoid.Health)
				if Damage == 0 then
					Damage = 0.1
				end
			end
			Humanoid.Health = Humanoid.Health - Damage
		end
	end

	function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if INSTAKILL == true then
								CHILD:BreakJoints()
							else
								local DMG = MRANDOM(MINDMG,MAXDMG)
								ManualDamage(HUM,DMG,TORSO)
							end
							if FLING > 0 then
								for _, c in pairs(CHILD:GetChildren()) do
									if c:IsA("BasePart") then
										local bv = Instance.new("BodyVelocity") 
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
										bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
										bv.Parent = c
										Debris:AddItem(bv,0.05)
									end
								end
							end
						end
					end
				end
			end
		end
	end

	function dmj(dude)
		local targetted
		if dude.Name ~= Character then
			local bgf = Instance.new("BodyGyro",dude.Head)
			bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
--[[local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"]]--
			local ds = coroutine.wrap(function()
				dude:WaitForChild("Head"):BreakJoints()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Part") or v:IsA("MeshPart") then
						v.Name = "DEMINISHED"
						CFuncs["Sound"].Create("rbxassetid://763718160", v, 0.75, 0.6)
						CFuncs["Sound"].Create("rbxassetid://782353443", v, 1, 0.5)
						for i = 0, 1 do
							sphere2(1,"Add",v.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,10,-0.01,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
						end
					end
				end
				wait(0.5)
				targetted = nil
				CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.25, 0.215)
				coroutine.resume(coroutine.create(function()
					for i, v in pairs(dude:GetChildren()) do
						if v:IsA("Accessory") then
							v:Destroy()
						end
						if v:IsA("Humanoid") then
							v:Destroy()
						end
						if v:IsA("CharacterMesh") then
							v:Destroy()
						end
						if v:IsA("Model") then
							v:Destroy()
						end
						if v:IsA("Part") or v:IsA("MeshPart") then
							for x, o in pairs(v:GetChildren()) do
								if o:IsA("Decal") then
									o:Destroy()
								end
							end
							coroutine.resume(coroutine.create(function()
								v.Material = "Neon"
								v.CanCollide = false
								v.Anchored = false
								local bld = Instance.new("ParticleEmitter",v)
								bld.LightEmission = 1
								bld.Texture = "rbxassetid://363275192" ---284205403
								bld.Color = ColorSequence.new(BrickColor.new("Really black").Color)
								bld.Rate = 500
								bld.Lifetime = NumberRange.new(1)
								bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0,0)})
								bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
								bld.Speed = NumberRange.new(2,5)
								bld.VelocitySpread = 50000
								bld.Rotation = NumberRange.new(-500,500)
								bld.RotSpeed = NumberRange.new(-500,500)
								local sbs = Instance.new("BodyPosition", v)
								sbs.P = 3000
								sbs.D = 1000
								sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
								sbs.position = v.Position + Vector3.new(math.random(-2,2),10 + math.random(-2,2),math.random(-2,2))
								v.Color = BrickColor.new("Really black").Color
								coroutine.resume(coroutine.create(function()
									for i = 0, 49 do
										swait(1)
										v:BreakJoints()
										v.Transparency = v.Transparency + 0.02
									end
									v:BreakJoints()
									for i = 0, 4 do
										slash(math.random(10,50)/10,3,true,"Round","Add","Out",v.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.0025,0.01),math.random(10,100)/2500,BrickColor.new("White"))
									end
									block(1,"Add",v.CFrame,vt(0,0,0),0.1,0.1,0.1,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
									CFuncs["Sound"].Create("rbxassetid://782353117", v, 0.25, 0.7)
									CFuncs["Sound"].Create("rbxassetid://1192402877", workspace, 3, 0.25)
									bld.Speed = NumberRange.new(10,25)
									bld.Drag = 5
									bld.Acceleration = vt(0,2,0)
									wait(0.5)
									bld.Enabled = false
									wait(4)
									coroutine.resume(coroutine.create(function()
										for i = 0, 99 do
											swait()
											v:Destroy()
											dude:Destroy()
										end
									end))
								end))
							end))
						end
					end
				end))
			end)
			ds()
		end
	end


	local function FindHumanoid(Part)local humanoid=nil if Part.Parent then if Part.Parent~=Player.Character and Part.Parent:FindFirstChildOfClass("Humanoid")~=nil then humanoid=Part.Parent:FindFirstChildOfClass("Humanoid")else if Part.Parent.Parent then if Part.Parent.Parent:FindFirstChildOfClass("Humanoid")and Part.Parent.Parent~=Player.Character then humanoid=Part.Parent.Parent:FindFirstChildOfClass("Humanoid")end end end end if humanoid==Humanoid then humanoid=nil end return humanoid end  
	function CreateBeam(Parent,isReversed)local p=Instance.new("Beam",Parent)local a0=Instance.new("Attachment",Parent)local a1=Instance.new("Attachment",Parent)if isReversed then p.Attachment0=a1 p.Attachment1=a0 else p.Attachment0=a0 p.Attachment1=a1 end return a0,a1,p end
	function CTE(Part)Part.Size=Vector3.new()Part.Transparency=1 Part.CanCollide=false Part.Anchored=true local j=Instance.new("BodyVelocity",Part)j.MaxForce=Vector3.new(1/0,1/0,1/0)j.Velocity=Vector3.new(0,0,0)end
	function RingE(pos,siz,tim,dsiz,seg,wid,z,col,w)local IDK=.7
		local p=Instance.new("Part",workspace)if col==nil then col=ColorSequence.new(Color3.new())end if z==nil then z=0 end
		CTE(p)p.CFrame=pos
		local a0,a1,b=CreateBeam(p)a0.Position=Vector3.new(0,0,-dsiz)a1.Position=-a0.Position b.Texture="rbxassetid://1251856844"b.Color=col
		local b2=Instance.new("Beam",b.Parent)b2.Attachment0=a1 b2.Attachment1=a0 b2.Texture="rbxassetid://1251856844"b2.Color=col
		b.CurveSize0=math.abs(a0.Position.Z)*2 *IDK b.CurveSize1=math.abs(a0.Position.Z)*2 *IDK b2.CurveSize0=-math.abs(a0.Position.Z)*2 *IDK b2.CurveSize1=math.abs(a0.Position.Z)*2 *IDK
		b.Segments=seg b2.Segments=seg b.ZOffset=z b2.ZOffset=z b.Width0=wid b.Width1=wid b2.Width0=wid b2.Width1=wid spawn(function()
			for i=1,tim do if p.Parent then
					a0.Position=a0.Position-Vector3.new(0,0,siz)a1.Position=a1.Position+Vector3.new(0,0,siz)b.CurveSize0=(a1.Position.Z*2)*IDK b.CurveSize1=-(a1.Position.Z*2)*IDK
					b2.CurveSize0=-(a1.Position.Z*2)*IDK b2.CurveSize1=(a1.Position.Z*2)*IDK
					if w~=nil then b.Width0=b.Width0+w b.Width1=b.Width0 b2.Width0=b.Width0 b2.Width1=b.Width0 end b.Transparency=NumberSequence.new(i/tim)b2.Transparency=NumberSequence.new(i/tim)swait()
				end end p:Destroy()
		end)
	end

	function CreateFlyingDebree(FLOOR,POSITION,AMOUNT,BLOCKSIZE,SWAIT,STRENGTH)
		if FLOOR ~= nil then
			for i = 1, AMOUNT do
				local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, FLOOR.Transparency, "Peal", "Debree", BLOCKSIZE, false)
				DEBREE.Material = FLOOR.Material
				DEBREE.Color = FLOOR.Color
				DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
				DEBREE.Velocity = VT(MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH))
				coroutine.resume(coroutine.create(function()
					Swait(15)
					DEBREE.Parent = workspace
					DEBREE.CanCollide = true
					Debris:AddItem(DEBREE,SWAIT)
				end))
			end
		end
	end

	--//=================================\\
	--||	    GUIS AND MISC
	--\\=================================//

	local SKILLTEXTCOLOR = C3(1,0,0)
	local SKILLFONT = "Antique"
	local SKILLTEXTSIZE = 7

	local ATTACKS = {"Z - Neckless","C - Brave Speed","G - Slashed","V - Dirtface"}

	local GUIS = {}
	local WEAPONGUI = IT("ScreenGui")
	WEAPONGUI.Name = "[M U R D E R]"
	for i = 1, #ATTACKS do
		local SKILLFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.74, 0, 0.97-(0.02*i), 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill Frame")
		local SKILLTEXT = CreateLabel(SKILLFRAME, "["..ATTACKS[i].."]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Skill text")
		SKILLTEXT.TextXAlignment = "Right"
		table.insert(GUIS,SKILLTEXT)
	end

	local sick = IT("Sound", Torso)
	sick.SoundId = "rbxassetid://"..SONG1
	sick.TimePosition = 0
	sick.Looped = true
	sick.Pitch = 1
	sick.Volume = 10
	sick:Play()

	local BODY = {}
	for _, c in pairs(Character:GetDescendants()) do
		if c:IsA("BasePart") and c.Name ~= "Handle" then
			if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
				c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
			end
			table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
		elseif c:IsA("JointInstance") then
			table.insert(BODY,{c,c.Parent,nil,nil,nil})
		end
	end
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART.ClassName == "Part" and PART ~= RootPart then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY
			end
			PART.AncestryChanged:Connect(function()
				PART.Parent = PARENT
			end)
		end
	end

	warn("All your friends are dead.")
	warn("You're the only one left...")
	warn("YOU NEED TO AVENGE THEM =)")

	--//=================================\\
	--||			DAMAGING
	--\\=================================//

	function ApplyDamage(Humanoid,Damage,OneShot)
		Damage = Damage * DAMAGEMULTIPLIER
		local DEAD = false
		if Humanoid.Health < 2000 and OneShot == false then
			if Humanoid.Health - Damage > 0 then
				Humanoid.Health = Humanoid.Health - Damage
			else
				if lplr == Player then
					DamageRemote:FireServer("BreakJoints", Humanoid.Parent)
				end
				DEAD = true
			end
		else
			DEAD = true
			if lplr == Player then
				DamageRemote:FireServer("BreakJoints", Humanoid.Parent)
			end
		end
		if DEAD == true then
			local PARTS = {}
			for index, CHILD in pairs(Humanoid.Parent:GetChildren()) do
				if CHILD:IsA("BasePart") then
					table.insert(PARTS,CHILD)
				end
			end
			coroutine.resume(coroutine.create(function()
				wait(2)
				repeat
					Swait()
					local PIECE = nil
					if MRANDOM(1,5) == 1 then
						for E = 1, #PARTS do
							if MRANDOM(1,5) == 1 then
								PIECE = PARTS[E]
								table.remove(PARTS,E)
								break
							end
						end
					end
					if PIECE ~= nil then
						if PIECE.Name == "Head" then
							WACKYEFFECT({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(PIECE.Size.Z,PIECE.Size.Y,PIECE.Size.Z), Size2 = (VT(PIECE.Size.Z,PIECE.Size.Y,PIECE.Size.Z))*MRANDOM(7,14)/10, Transparency = PIECE.Transparency, Transparency2 = 1, CFrame = PIECE.CFrame, MoveToPos = PIECE.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = C3(0.4,0,0), SoundID = 3264923, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2})
						else
							WACKYEFFECT({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = PIECE.Size, Size2 = PIECE.Size*MRANDOM(7,14)/10, Transparency = PIECE.Transparency, Transparency2 = 1, CFrame = PIECE.CFrame, MoveToPos = PIECE.Position+VT(0,MRANDOM(5,8)/1.5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = C3(0.4,0,0), SoundID = 3264923, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2})
						end
						if lplr == Player then
							DamageRemote:FireServer("Remove", PIECE)
						end
						PIECE:Remove()
					end
				until #PARTS == 0
			end))
		end
	end

	--//=================================\\
	--||         WEAPON CREATION
	--\\=================================//


	coroutine.resume(coroutine.create(function()
		while wait() do
			if BanishMode == 555 then
				if VALUE1 == true then
					if NICE == true then 
					elseif NICE == false then
						CreateSound(155202884,Torso,2, 1.4,false)
					end
				end
			end
		end
	end))
	--glitch
	coroutine.resume(coroutine.create(function()
		while wait() do
			if BanishMode == 555 and ATTACK == false then
				if VALUE1 == false and math.random(1,55) == 1 then
					coroutine.resume(coroutine.create(function()
						VALUE1 = true
						for i=1,25 do
							Swait()
							if NICE == true then 
								CreateSound(152624155,Head,1,MRANDOM(11,13)/13,false)
							end
							FT.Parent = Torso
							FRA.Parent = RightArm
							FLA.Parent = LeftArm
							FRL.Parent = RightLeg
							FLL.Parent = LeftLeg
							for _,v in next, Character:GetDescendants() do
								if(v:IsA'DataModelMesh')then
									v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
								end
							end		
						end
						VALUE1 = false
						FT.Parent = nil
						FRA.Parent = nil
						FLA.Parent = nil
						FRL.Parent = nil
						FLL.Parent = nil
						if NICE == true then 
						elseif NICE == false then
						end
						sick.PlaybackSpeed = 1
						for _,v in next, Character:GetDescendants() do
							if(v:IsA'DataModelMesh')then
								v.Offset = VT(0,0,0)
							end
						end	
					end))
				end
			end
		end
	end))

	local Shield = IT("MeshPart", workspace)
	Shield.Name = Player.Name.."'s Shield Anti Bullets"
	Shield.CanCollide = false
	Shield.Transparency = 1
	Shield.Material = "Neon"
	Shield.BrickColor = BrickColor.new("fat")
	Shield.Size = Vector3.new(5.3,6.3,5.3)
	Shield.CFrame = Torso.CFrame
	local Wed = Instance.new("Weld", Shield)
	Wed.Part0 = Shield
	Wed.Part1 = Torso

	local outer = Instance.new("Part")
	outer.Locked = true
	outer.CanCollide = false
	outer.Shape = Enum.PartType.Cylinder
	outer.Size = Vector3.new(0.05, 1, 1)
	outer.Material = Enum.Material.Neon
	outer.Color = Color3.new(0, 0, 0)
	outer.Parent = Character
	spawn(function() Rainbowify(outer) end)

	local outerm = Instance.new("SpecialMesh")
	outerm.MeshType = Enum.MeshType.Cylinder
	outerm.Parent = outer

	local weld1 = Instance.new("Weld")
	weld1.Part0 = outer
	weld1.Part1 = Character["HumanoidRootPart"]
	weld1.Parent = outer
	weld1.C0 = CFrame.new(-2.95, 0, 0) * CFrame.Angles(0, 0, 1.571)
	coroutine.resume(coroutine.create(function()
		while true do
			Swait()
			outerm.Scale = Vector3.new(0, sick.PlaybackLoudness / 25, sick.PlaybackLoudness / 25)
		end
	end))



	function Weld(part0,part1,c0,c1)
		local weld = IT("Weld")
		weld.Parent = part0
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C0 = c0 or CF()
		weld.C1 = c1 or CF()
		return weld
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	if Head:FindFirstChildOfClass("Decal") then
		Head:FindFirstChildOfClass("Decal").Texture = "rbxassetid://176217464"
	else
		local newFace = Instance.new("Decal", Head)
		newFace.Parent = Head
		newFace.Face = "Front"
		newFace.Texture = "rbxassetid://176217464"
	end 

	New = function(Object, Parent, Name, Data)
		local Object = Instance.new(Object)
		for Index, Value in pairs(Data or {}) do
			Object[Index] = Value
		end
		Object.Parent = Parent
		Object.Name = Name
		return Object
	end

	local all, last = {}, nil
	ArmourParts = {}
	NeonParts = {}
	function scan(p)
		for _, v in pairs(p:GetChildren()) do
			if v:IsA("BasePart") then
				if v.BrickColor == BrickColor.new("Black") then
					table.insert(ArmourParts, v)
				end
				if v.BrickColor == BrickColor.new("Institutional white") then
					table.insert(NeonParts, v)
				end
				if last then
					local w = Instance.new("Weld")
					w.Part0, w.Part1 = last, v
					w.C0 = v.CFrame:toObjectSpace(last.CFrame):inverse()
					w.Parent = last
				end
				table.insert(all, v)
				last = v
			end
			scan(v)
		end
	end

	for i, v in pairs(ArmourParts) do
		v.BrickColor = BrickColor.new("Black")
		v.Material = Enum.Material.Neon
	end
	for i, v in pairs(NeonParts) do
		v.BrickColor = BrickColor.Black()
	end

	local FaceGradient = IT("Folder", Character)
	FaceGradient.Name = "FaceGradient"
	local Eyes = IT("Folder", Character)
	Eyes.Name = "Eyes"

	for i = 1, 10 do
		local FACE = CreatePart(3, faceShadingFolder, "Neon", 0, 0+(i-1)/10.2, "Dark stone grey", "FaceGradient", VT(1.01,0.65,1.01),false)
		FACE.Color = C3(0,0,0)
		Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
		CreateWeldOrSnapOrMotor("Weld", FACE, Head, FACE, CF(0,0.28-(i-1)/30,0), CF(0, 0, 0))
	end

	local Eye = CreatePart(3, Eyes, "Neon", 0, 0, "Institutional white", "Eye", VT(0.1,1,1)/2,false)
	MakeForm(Eye,"Ball")
	CreateWeldOrSnapOrMotor("Weld", Eye, Head, Eye, CF(0,0.15,0) * ANGLES(RAD(0), RAD(-18), RAD(0)), CF(0, 0, 0.4))
	local Eye = CreatePart(3, Eyes, "Neon", 0, 0, "Forest green", "Eye", VT(0.1,1,1)/2,false)
	MakeForm(Eye,"Ball")
	CreateWeldOrSnapOrMotor("Weld", Eye, Head, Eye, CF(0,0.15,0) * ANGLES(RAD(0), RAD(18), RAD(0)), CF(0, 0, 0.4))

	local Particle = IT("ParticleEmitter",nil)
	Particle.Enabled = false
	Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
	Particle.LightEmission = 0.5
	Particle.Rate = 150
	Particle.ZOffset = 0.2
	Particle.Rotation = NumberRange.new(-180, 180)
	Particle.RotSpeed = NumberRange.new(-180, 180)
	Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
	Particle.Color = ColorSequence.new(C3(1,0,0),C3(0.4,0,0))

	--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
	function ParticleEmitter(Table)
		local PRTCL = Particle:Clone()
		local Speed = Table.Speed or 5
		local Drag = Table.Drag or 0
		local Size1 = Table.Size1 or 1
		local Size2 = Table.Size2 or 5
		local Lifetime1 = Table.Lifetime1 or 1
		local Lifetime2 = Table.Lifetime2 or 1.5
		local Parent = Table.Parent or Torso
		local Emit = Table.Emit or 100
		local Offset = Table.Offset or 360
		local Acel = Table.Acel or VT(0,0,0)
		local Enabled = Table.Enabled or false
		PRTCL.Parent = Parent
		PRTCL.Size = NumberSequence.new(Size1,Size2)
		PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
		PRTCL.Speed = NumberRange.new(Speed)
		PRTCL.VelocitySpread = Offset
		PRTCL.Drag = Drag
		PRTCL.Acceleration = Acel
		if Enabled == false then
			PRTCL:Emit(Emit)
			Debris:AddItem(PRTCL,Lifetime2)
		else
			PRTCL.Enabled = true
		end
		return PRTCL
	end

	-- IdleWeapon(Karma) --

	local Handle = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.2,0.6,0.2),false)
	spawn(function() Rainbowify(Handle) end)
	local RightArmGrasp = CreateWeldOrSnapOrMotor("Weld", Handle, RightArm, Handle, CF(0,-1, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0.21, 0))
	--spawn(function() Rainbowify(RightArmGrasp) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.3, 0.2) * ANGLES(RAD(0), RAD(180), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.2,0.3,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.4, 0) * ANGLES(RAD(0), RAD(0), RAD(180)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.3,0.3,0.3),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.5, 0.2) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.3,0.5,0.5),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.4,0.4,0.4),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	for i = 1, 8 do
		local Piece = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Eye", VT(0,0.35,0.41),false)
		CreateWeldOrSnapOrMotor("Weld", Handle, Part, Piece, CF(0, 0, 0) * ANGLES(RAD(0), RAD((360/8)*i), RAD(0)), CF(0, 0, 0))
	end
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Eye", VT(0.38,0.41,0.38),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.37,0.5,0.37),false)
	MakeForm(Part,"Ball")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.3) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.2,0.7,0.4),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.7, 0.5) * ANGLES(RAD(90), RAD(180), RAD(180)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.3,0.4,0.2),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.35,0.35,0.35),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.5),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.45),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1.1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.55, 0.2) * ANGLES(RAD(-135), RAD(0), RAD(0)), CF(0, -0.3, 0))
	spawn(function() Rainbowify(Part) end)
	local LASTPART = Handle
	for i = 1, 10 do
		if LASTPART == Handle then
			local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.1,0.2,0),false)
			LASTPART = Part
			CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.1, 0.2) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
			spawn(function() Rainbowify(Part) end)
		else
			local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.1,0.05,0),false)
			CreateWeldOrSnapOrMotor("Weld", Handle, LASTPART, Part, CF(0, 0.025, 0) * ANGLES(RAD(8), RAD(0), RAD(0)), CF(0, -0.025, 0))
			LASTPART = Part
			spawn(function() Rainbowify(Part) end)
		end
	end

	local hat = game:GetService("Players").LocalPlayer.Character["Type-49 Abomindation Back Accessory"]

	hat.Handle.AccessoryWeld:Destroy()

	local function align(part0, part1)
		local attachment0 = Instance.new("Attachment", part0)
		attachment0.Position = Vector3.new(0.6, -0.2, -0.3) --Custom Positioning Values Here
		attachment0.Orientation = Vector3.new(50, -80, 180) --Custom Rotationing Values here
		local attachment1 = Instance.new("Attachment", part1)
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 10000
		weldpos.MaxVelocity = 10000
		weldpos.Responsiveness = 10000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 10000
		weldrot.MaxAngularVelocity = 10000
		weldrot.Responsiveness = 10000
	end

	local function invweld(part0)
		local attachment0 = Instance.new("Attachment", part0)
		local attachment1 = InvAtt
		local weldpos = Instance.new("AlignPosition", part0)
		weldpos.Enabled = false
		weldpos.Name = "InvPos"
		weldpos.Attachment0 = attachment0
		weldpos.Attachment1 = attachment1
		weldpos.RigidityEnabled = false
		weldpos.ReactionForceEnabled = false
		weldpos.ApplyAtCenterOfMass = false
		weldpos.MaxForce = 10000
		weldpos.MaxVelocity = 10000
		weldpos.Responsiveness = 10000
		local weldrot = Instance.new("AlignOrientation", part0)
		weldrot.Enabled = false
		weldrot.Name = "InvRot"
		weldrot.Attachment0 = attachment0
		weldrot.Attachment1 = attachment1
		weldrot.ReactionTorqueEnabled = true
		weldrot.PrimaryAxisOnly = false
		weldrot.MaxTorque = 10000
		weldrot.MaxAngularVelocity = 10000
		weldrot.Responsiveness = 10000
	end

	align(hat.Handle, Handle)
	invweld(hat.Handle)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if not Handle then
				hat.Handle.AlignOrientation.Enabled = false
				hat.Handle.AlignPosition.Enabled = false
				hat.Handle.InvPos.Enabled = true
				hat.Handle.InvRot.Enabled = true
			else
				hat.Handle.AlignOrientation.Enabled = true
				hat.Handle.AlignPosition.Enabled = true
				hat.Handle.InvPos.Enabled = false
				hat.Handle.InvRot.Enabled = false
			end
		end
	end)



	local Barrel = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.15,4,0.15),false)
	MakeForm(Barrel,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Barrel, CF(0, -0.6, 1.85) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Barrel) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.25,2,0.25),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, -0.2, 0), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0,0.1,0.2),false)
	MakeForm(Part,"Wedge")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, 0.945, 0.1) * ANGLES(RAD(180), RAD(0), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Part) end)
	local Hole = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Eye", VT(0.125,0,0.125),false)
	MakeForm(Hole,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Hole, CF(0, 2, 0), CF(0, 0, 0))
	spawn(function() Rainbowify(Hole) end)
	local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0,0,0),false)
	spawn(function() Rainbowify(Part) end)
	local GEARWELD = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
	CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.8,0.8,1.5), VT(0,0,0.2))

	local Part = CreatePart(3, Weapon, "ForceField", 0, 0.5, "Mid gray", "Eye", VT(0,0,0),false)
	spawn(function() Rainbowify(Part) end)
	local GEARWELD2 = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
	CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.9,0.9,0.3), VT(0,0,0.2))

	coroutine.resume(coroutine.create(function()
		while wait() do
			GEARWELD.C0 = GEARWELD.C0 * ANGLES(RAD(0), RAD(0), RAD(sick.PlaybackLoudness/60 + 0.05))
			GEARWELD2.C0 = GEARWELD2.C0 * ANGLES(RAD(0), RAD(0), RAD(-sick.PlaybackLoudness/60 - 0.05))
		end
	end))

	ParticleEmitter({Speed = 0.2, Drag = 0, Size1 = 0.1, Size2 = 0, Lifetime1 = 0.3, Lifetime2 = 0.5, Parent = Hole, Emit = 100, Offset = 360, Enabled = true, Acel = VT(0,5,0)})

	local LASTPART = Head
	for i = 1, 20 do
		local MATH = (1-(i/25))
		if LASTPART == Head then
			local Horn = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(15), RAD(-15)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i*3-3)/.5,0,.5)
			spawn(function() Rainbowify(Horn) end)
		else
			local Horn = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(-0.3), RAD(0)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i*3-3)/.5,0,.5)
			spawn(function() Rainbowify(Horn) end)
		end
	end
	local LASTPART = Head
	for i = 1, 20 do
		local MATH = (1-(i/25))
		if LASTPART == Head then
			local Horn = CreatePart(3, Character, "ForceField", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(-0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(-15), RAD(15)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i*3-3)/.5,0,.5)
			spawn(function() Rainbowify(Horn) end)
		else
			local Horn = CreatePart(3, Character, "ForceField", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(0.3), RAD(0)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i*3-3)/.5,0,.5)
			spawn(function() Rainbowify(Horn) end)
		end
	end

	local LASTPART = Torso
	for i = 1, 45 do
		local MATH = 1 - i / 60
		if LASTPART == Torso then
			local Tail = CreatePart(3, Character, "Neon", 0, 0, "New Yeller", "Tail", VT(0.25 * MATH, 0.25, 0.25 * MATH), false)
			local WLD = CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Tail, CF(0, -0.75, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
			LASTPART = Tail
			coroutine.resume(coroutine.create(function()
			end))
			table.insert(TAIL, WLD)
			spawn(function() Rainbowify(Tail) end)
		else
			local Tail = CreatePart(3, Character, "Neon", 0, 0, "New Yeller", "Tail", VT(0.25 * MATH, 0.25, 0.25 * MATH), false)
			local WLD = CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Tail, CF(0, Tail.Size.Y / 2, 0) * ANGLES(RAD(-1.2), RAD(0), RAD(0)), CF(0, 0, 0))
			LASTPART = Tail
			spawn(function() Rainbowify(Tail) end)
			table.insert(TAIL, WLD)
		end
	end

	for _, b in pairs(Karma:GetChildren()) do
		if b.ClassName == "Part" then
			b.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
	end

	for _, b in pairs(Weapon:GetChildren()) do
		if b.ClassName == "Part" then
			b.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
	end

	coroutine.resume(coroutine.create(function()
		while true do
			Swait()
			for _, c in pairs(KarmaWeapon2:GetDescendants()) do
				if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
					c.Material = "Glass"
					c.Color = BrickColor.Black().Color
				elseif c.ClassName == "Part" and c.Name == "Eye" then
					c.Material = "Neon"
					c.Color = C3(0,0,0)
					spawn(function() Rainbowify(c) end)
				end
			end
			for _, c in pairs(KarmaWeapon:GetDescendants()) do
				if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
					c.Material = "Glass"
					c.Color = BrickColor.Black().Color
				elseif c.ClassName == "Part" and c.Name == "Eye" then
					c.Material = "Neon"
					c.Color = C3(0,0,0)
					spawn(function() Rainbowify(c) end)
				end
			end
		end
	end))

	Weapon.Parent = Character


	--//=================================\\
	--||	ATTACK FUNCTIONS AND STUFF
	--\\=================================//
	function antideath()
		Head.Parent = Character
		Torso.Parent = Character
		RightArm.Parent = Character
		LeftArm.Parent = Character
		LeftLeg.Parent = Character
		RightLeg.Parent = Character
		Head.Locked = true
		Torso.Locked = true
		RightArm.Locked = true
		LeftArm.Locked = true
		LeftLeg.Locked = true
		RightLeg.Locked = true
		Shield.Locked = true
		Humanoid.Parent = Character
	end

	abss = Instance.new("BillboardGui",Character)
	abss.Size = UDim2.new(10,0,10,0)
	abss.Enabled = false
	imgl = Instance.new("ImageLabel",abss)
	imgl.Position = UDim2.new(0,0,0,0)
	imgl.Size = UDim2.new(1,0,1,0)
	imgl.Image = "rbxassetid://342199418"
	imgl.BackgroundTransparency = 1
	imgl.ImageColor3 = Color3.new(.9,0,0)
	img2 = Instance.new("ImageLabel",abss)
	img2.Position = UDim2.new(0,0,0,0)
	img2.Size = UDim2.new(1,0,1,0)
	img2.Image = "rbxassetid://342199418"
	img2.BackgroundTransparency = 1
	img2.ImageColor3 = Color3.new(.9,0,0)

	function CreatePartC(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, COLOR3, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.Color = COLOR3
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end


	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end

	function SpawnTrail(FROM,TO,BIG)
		local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "Really red", "Trail", VT(0,0,0))
		spawn(function() Rainbowify(TRAIL) end)
		MakeForm(TRAIL,"Cyl")
		local DIST = (FROM - TO).Magnitude
		if BIG == true then
			TRAIL.Size = VT(0.5,DIST,0.5)
		else
			TRAIL.Size = VT(0.25,DIST,0.25)
		end
		TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
		coroutine.resume(coroutine.create(function()
			for i = 1, 5 do
				Swait()
				TRAIL.Transparency = TRAIL.Transparency + 0.01
			end
			wait(4.2)
			TRAIL:remove()
		end))
	end



	function printbye(Name)
		local MESSAGES = {"You re a bad boi, ", "Go away, ", "YO GO AWAY PLS, ", "Chill, ", "BEGONE, ", "STAAAAAAAAAAFFFFFFFFFFF, ", "Try it again, ", "Welcome to my special hecc, ", "Dont come back please, ", "You are bad ","Don't try that ever again, "}
		chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
	end

	Player.Chatted:connect(function(msg)
		if BanishMode == 324 then
			if msg:sub(1, 5):lower()=='play/' then
				sick:Stop()
				SONG1 = msg:sub(6)
				sick:Play()
				sick.Looped = true
				chatfunc("Now playing "..msg:sub(6))
			elseif msg:sub(1, 6):lower()=='pitch/' then
				local Pitch = msg:sub(7)
				sick.Pitch = Pitch
				chatfunc("Now pitch is "..msg:sub(7))
			elseif msg:sub(1, 4):lower()=='vol/' then
				local Volume = msg:sub(5)
				sick.Volume = Volume
				chatfunc("Now volume is "..msg:sub(5))
			elseif msg:sub(1, 5):lower()=='stop/' then
				sick:Stop()
				chatfunc("Music Stopped")
			elseif msg:sub(1, 7):lower()=='parent/' then
				local Parent = msg:sub(7)
				sick.Parent = Parent
				chatfunc("Music Parent Changed to "..msg:sub(7))
			end
		end
	end)

	function Kick(Foe)

	end


	function Respawn(Foe)

	end

	function Banish(Foe)

	end


	function ApplyAoE(POSITION,RANGE,ISBANISH)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if ISBANISH == true then
								Banish(CHILD)
							else
								if ISBANISH == "Gravity" then
									HUM.PlatformStand = true
									if TORSO:FindFirstChild("BanishForceV5"..Player.Name) then
										local grav = Instance.new("BodyPosition",TORSO)
										grav.D = 15
										grav.P = 20000
										grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
										grav.position = TORSO.Position
										grav.Name = "BanishForceV5"..Player.Name
									else
										TORSO:FindFirstChild("BanishForceV5"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
										TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
									end
								else
									HUM.PlatformStand = false
								end
							end
						elseif ISBANISH == "Gravity" then
							if TORSO:FindFirstChild("BanishForceV5"..Player.Name) then
								TORSO:FindFirstChild("BanishForceV5"..Player.Name):remove()
								HUM.PlatformStand = false
							end
						end
					end
				end
			end
		end
	end



	Mouse = Player:GetMouse()

	game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy()

	game.Players.LocalPlayer.Character["RunningBull"].Parent = workspace

	game:GetService("RunService").Stepped:wait()

	v = game.Workspace["RunningBull"].Handle

	v.Transparency = 0.5

	v.Anchored = false

	local Outline = Instance.new("SelectionBox", v)
	Outline.LineThickness = 0.1
	Outline.Color3 = Color3.fromRGB(195, 130, 0)
	Outline.Adornee = v

	local bp = Instance.new("BodyPosition", v)

	bp.P = 100000

	bp.D = 1250

	bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)

	local bav = Instance.new("BodyAngularVelocity", v)

	bav.P = 1250

	bav.AngularVelocity = Vector3.new(99999999,99999999,99999999)

	bav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)

	local plr = game.Players.LocalPlayer

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			if ATTACK == false then
				bp.Position = game.Players.LocalPlayer.Character["Dummy"].Torso.Position + Vector3.new(0,500,0)
			end
		end
	end)

	spawn(function()
		while game:GetService("RunService").Heartbeat:Wait() do
			v.CanCollide = false
		end
	end)

	function BanishBullet()
		if Weapon.Parent == Character then
			ATTACK = true
			Rooted = false
			for i=0, 0.01, 0.1 / Animation_Speed do
				Swait()
				turnto(Mouse.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
			repeat
				for i=0, 0.01, 0.1 / Animation_Speed do
					Swait()
					turnto(Mouse.Hit.p)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				end
				local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
				SpawnTrail(Hole.Position,POS)
				CreateSound(904440937, Character, 10, 1, false)
				if HIT ~= nil then
					if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
						Banish(HIT.Parent)
					end
				end
				for i=0, 0.01, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				end
			until KEYHOLD == false
			ATTACK = false
			Rooted = false
		end
		repeat wait() until ATTACK == true
		repeat
			game:GetService("RunService").Heartbeat:Wait()
			if ATTACK == true then
				bp.Position = Mouse.Hit.p
			end
		until ATTACK == false
	end

	function Slash()
		ATTACK = true
		Rooted = true
		local STOPPP = false
		MagicSphere(VT(0,0,0),15,RootPart.CFrame,"Really black",VT(2,2,2))
		coroutine.wrap(function()
			while wait() do
				WACKYEFFECT({Time = 15, EffectType = "Crystal", Size = VT(1,5,1), Size2 = VT(1,25,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,0,0)*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				if STOPPP == true then
					break
				end
			end
		end)()
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, -0.5*SIZE) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(-45), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.2*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.5*SIZE, -0.5*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(-45), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		for i=0,0.1, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(-45), RAD(0)) * RIGHTSHOULDERC0, 0.5)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 0.5)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
		end
		local SOUND = CreateSound("rbxasset://sounds/swordlunge.wav", Torso, 5, 0.6)
		SOUND.SoundId = "rbxasset://sounds/swordlunge.wav"
		CreateSound(62339698, Torso, 10, 0.4)
		WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(5,5,5), Size2 = VT(100,100,100)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MRANDOM(1,1.1), SoundVolume = 10})
		WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		STOPPP = true
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			Humanoid.CameraOffset = VT(MRANDOM(-500,500)/2.5,MRANDOM(-50,50)/2.5,MRANDOM(-500,500)/2.5)/30
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(-75)) * RIGHTSHOULDERC0, 0.5)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 0.5)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
		end
		Humanoid.CameraOffset = VT(0,0,0)
		ATTACK = false
		Rooted = false
	end

	function BanBullet()
		if Weapon.Parent == Character then
			ATTACK = true
			Rooted = false
			for i=0, 0.01, 0.1 / Animation_Speed do
				Swait()
				turnto(Mouse.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
			repeat
				for i=0, 0.01, 0.1 / Animation_Speed do
					Swait()
					turnto(Mouse.Hit.p)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				end
				local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
				SpawnTrail(Hole.Position,POS)
				CreateSound(904440937, Character, 10, 1, false)
				if HIT ~= nil then
					if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
						table.insert(BannedSkids, HIT.Parent.Name)
						Kick(HIT.Parent)
					end
				end
				for i=0, 0.01, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				end
			until KEYHOLD == false
			ATTACK = false
			Rooted = false
			repeat wait() until ATTACK == true
			repeat
				game:GetService("RunService").Heartbeat:Wait()
				if ATTACK == true then
					bp.Position = Mouse.Hit.p
				end
			until ATTACK == false
		end
	end

	function RespawnBullet()
		if Weapon.Parent == Character then
			ATTACK = true
			Rooted = false
			for i=0, 0.01, 0.1 / Animation_Speed do
				Swait()
				turnto(Mouse.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
			repeat
				for i=0, 0.01, 0.1 / Animation_Speed do
					Swait()
					turnto(Mouse.Hit.p)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				end
				local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
				SpawnTrail(Hole.Position,POS)
				CreateSound(664046210, Character, 10, 1, false)
				if HIT ~= nil then
					if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
						Respawn(HIT.Parent)
					end
				end
				for i=0, 0.01, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				end
			until KEYHOLD == false
			ATTACK = false
			Rooted = false
			repeat wait() until ATTACK == true
			repeat
				game:GetService("RunService").Heartbeat:Wait()
				if ATTACK == true then
					bp.Position = Mouse.Hit.p
				end
			until ATTACK == false
		end
	end


	function Rush()
		local ORIGIN = RootPart.Position
		CreateWave2(VT(1,1,1),65,CF(RootPart.Position)*CF(0,-3,0),false,2,"Pearl",VT(0.2,1,0.2))
		CreateWave2(VT(1,1,1),65,CF(RootPart.Position)*CF(0,-3,0),false,2,"Pearl",VT(0.2,1,0.2))
		spawn(function() Rainbowify(ORIGIN) end)
		local SOUNDPART = CreatePart(3, Effects, "Neon", 0, 1, "Pearl", "Sound", VT(0,0,0))
		SOUNDPART.CFrame = RootPart.CFrame
		Debris:AddItem(SOUNDPART,5)
		CreateSound("1295446488", SOUNDPART, 2, 1)
		RootPart.CFrame = CF(Mouse.Hit.p+VT(0,3,0),VT(ORIGIN.X,Mouse.Hit.p.Y,ORIGIN.Z))
		Swait()
		CreateWave2(VT(1,1,1),65,CF(RootPart.Position)*CF(0,-3,0),false,2,"Pearl",VT(0.2,1,0.2))
		CreateWave2(VT(1,1,1),65,CF(RootPart.Position)*CF(0,-3,0),false,2,"Pearl",VT(0.2,1,0.2))
		spawn(function() Rainbowify(SOUNDPART) end)
		local SOUNDPART = CreatePart(3, Effects, "Neon", 0, 1, "Pearl", "Sound", VT(0,0,0))
		SOUNDPART.CFrame = RootPart.CFrame
		Debris:AddItem(SOUNDPART,5)
		CreateSound("1295446488", SOUNDPART, 2, 1)
		if MRANDOM(1,8) == 1 then
			ATTACK = true
			Rooted = true
			local FRUITSTABLE = {
				{MeshId = "16190555", TextureId = "16190577", Color = BrickColor.Black()},
				{MeshId = "119574562", TextureId = "64374853", Color = BrickColor.Black()},
				{MeshId = "24394186", TextureId = "24394178", Color = BrickColor.Black()}
			}
			local FRUIT = FRUITSTABLE[MRANDOM(1, #FRUITSTABLE)]
			local FRUITMODEL = CreatePart(3, Effects, "Neon", 0, 0, FRUIT.Color, "Fruit", VT(0,0,0),false)
			CreateMesh("SpecialMesh", FRUITMODEL, "FileMesh", FRUIT.MeshId, FRUIT.TextureId, VT(2,2,2), VT(0,0,0))
			FRUITMODEL.CFrame = RightArm.CFrame * CF(0,-1.5,0)
			weldBetween(RightArm,FRUITMODEL)
			for i=0, 4, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(190), RAD(-145)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			CreateSound("414517163", RightArm, 10, MRANDOM(7, 12) / 10)
			FRUITMODEL:remove()
			for i = 1, 15 do
				Slice(0.1,15,RightArm.CFrame*CF(0,-1,0) * ANGLES(RAD(MRANDOM(-180,180)), RAD(MRANDOM(-180,180)), RAD(MRANDOM(-180,180))),FRUIT.Color, 1 + MRANDOM(1,10)/15)
			end
			for i=0, 0.5, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(190), RAD(-175)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			ATTACK = false
			Rooted = false
		end
	end

	function CreateParta(parent,transparency,reflectance,material,brickcolor)
		local p = Instance.new("Part")
		p.TopSurface = 0
		p.BottomSurface = 0
		p.Parent = parent
		p.Size = Vector3.new(0.1,0.1,0.1)
		p.Transparency = transparency
		p.Reflectance = reflectance
		p.CanCollide = false
		p.Locked = true
		p.BrickColor = brickcolor
		p.Material = material
		return p
	end

	function FireArc(Part, ToLocation, AmountOfTime, Height, DoesCourontine)
		if DoesCourontine == false then
			local Direction = CF(Part.Position, ToLocation)
			local Distance = (Part.Position - ToLocation).magnitude
			for i = 1, AmountOfTime do
				Swait()
				Part.CFrame = Direction * CF(0, AmountOfTime / 200 + (AmountOfTime / Height - i * 2 / Height), -Distance / AmountOfTime)
				Direction = Part.CFrame
			end
			Part:remove()
		elseif DoesCourontine == true then
			coroutine.resume(coroutine.create(function()
				local Direction = CF(Part.Position, ToLocation)
				local Distance = (Part.Position - ToLocation).magnitude
				for i = 1, AmountOfTime do
					Swait()
					Part.CFrame = Direction * CF(0, AmountOfTime / 200 + (AmountOfTime / Height - i * 2 / Height), -Distance / AmountOfTime)
					Direction = Part.CFrame
				end
				Part:remove()
			end))
		end
	end

	function chatfunc(text)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard")~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end
			local Bill = Instance.new("BillboardGui",Character)
			Bill.Size = UDim2.new(0,35,0,18)
			Bill.StudsOffset = Vector3.new(0,4.5,0)
			Bill.Adornee = Character.Head
			Bill.Name = "TalkingBillBoard"
			local Hehe = Instance.new("TextLabel",Bill)
			Hehe.BackgroundTransparency = 1
			Hehe.BorderSizePixel = 0
			Hehe.Text = ""
			Hehe.Font = "Arcade"
			Hehe.TextSize = 45
			Hehe.TextStrokeTransparency = 0
			Hehe.Size = UDim2.new(1,0,0.5,0)
			coroutine.resume(coroutine.create(function()
				while Hehe ~= nil do
					wait()	
					Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
				end
			end))
			spawn(function() RainbowifyText(Hehe) end)
			for i = 1,string.len(text),1 do
				wait()
				Hehe.Text = string.sub(text,1,i)
			end
			wait(3)
			for i = 0, 5, .025 do
				wait()
				Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
				Hehe.TextStrokeTransparency = i
				Hehe.TextTransparency = i
			end
			Bill:Destroy()
		end)
		chat()
	end


	function warnedpeople(text)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("Spinny")~= nil then
					v.PlayerGui:FindFirstChild("Spinny"):destroy()
				end
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				scrg.Name = "Spinny"
				local wobble = Instance.new("Frame",scrg)
				wobble.Name = "Wobble"
				wobble.BackgroundTransparency = 0.5
				wobble.Size = UDim2.new(1.1,0,1.1,0)
				wobble.Position = UDim2.new(-0.08,0,0.943,0)
				local wobble2 = Instance.new("Frame",scrg)
				wobble2.Name = "wobble2"
				wobble2.BackgroundTransparency = 0.5
				wobble2.Size = UDim2.new(1.1,0,0.09,0)
				wobble2.Position = UDim2.new(-0.08,0,0.878,0)
				local Visuals = Instance.new("Frame",scrg)
				Visuals.Name = "Visuals"
				Visuals.BackgroundTransparency = 0.3
				Visuals.Size = UDim2.new(0,100,0,100)
				Visuals.Position = UDim2.new(0.462,0,0.826,0)
				local glow = Instance.new("ImageLabel",scrg)
				glow.Name = "glow"
				glow.BackgroundTransparency = 1
				glow.ImageTransparency = 0
				glow.Image = "rbxassetid://2344870656"
				glow.Size = UDim2.new(0,0,0,0)
				glow.Position = UDim2.new(0.026,0,-0.235,0)
				local Visuals2 = Instance.new("Frame",scrg)
				Visuals2.Name = "Visuals2"
				Visuals2.BackgroundTransparency = 0.3
				Visuals2.Size = UDim2.new(0,50,0,50)
				Visuals2.Position = UDim2.new(0.48,0,0.867,0)
				local TextFrame = Instance.new("TextLabel",scrg)
				TextFrame.Name = "Farmer"
				TextFrame.Font = "Arcade"
				TextFrame.Text = text
				TextFrame.TextScaled = true
				TextFrame.TextSize = 60
				TextFrame.TextColor3 = C3(1,1,1)
				TextFrame.TextStrokeColor3 = C3(0, 0, 0)
				TextFrame.BackgroundTransparency = 1
				TextFrame.Size = UDim2.new(0.8,0,0,42)
				TextFrame.Position = UDim2.new(0.11,0,0.867,0)
				spawn(function() RainbowifyText(TextFrame) end)
				local fvalen = 0.55
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						Swait()
						TextFrame.TextStrokeTransparency = 0
						TextFrame.Rotation = 0 + MRANDOM(-3, 3)
						TextFrame.Position = UDim2.new(0.11, 0 + MRANDOM(-3, 3), 0.867, 0 + MRANDOM(-3, 3))
						TextFrame.Font = Enum.Font.Arcade
						glow.ImageColor3 = C3(0, 0, 0)
						wobble.Rotation = 0 - 2 * COS(SINE / 24)
						wobble2.Rotation = 0 - 2 * COS(SINE / 30)
						wobble2.BackgroundColor3 = C3(0,0,0)
						wobble2.BorderColor3 = C3(0,0,0)
						wobble2.BorderSizePixel = 4
						Visuals.Rotation = Visuals.Rotation + MRANDOM(-5, 5)
						Visuals2.Rotation = Visuals2.Rotation + MRANDOM(-10, 10)
						Visuals.BackgroundColor3 = C3(0,0,0)
						Visuals.BorderColor3 = C3(0,0,0)
						Visuals2.BackgroundColor3 = C3(0,0,0)
						Visuals2.BorderColor3 = C3(0,0,0)
						wobble.BackgroundColor3 = C3(0,0,0)
						wobble.BorderColor3 = C3(0,0,0)
						wobble.BorderSizePixel = 5
					end
				end))
				coroutine.resume(coroutine.create(function()
					for i = 0, 205 do
						Swait()
					end
					scrg:Destroy()
				end))
			end))
		end
	end

	function warnedpeople2(text)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("Spinny")~= nil then
					v.PlayerGui:FindFirstChild("Spinny"):destroy()
				end
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				scrg.Name = "Spinny"
				local wobble = Instance.new("Frame",scrg)
				wobble.Name = "Wobble"
				wobble.BackgroundTransparency = 0.5
				wobble.Size = UDim2.new(1.1,0,1.1,0)
				wobble.Position = UDim2.new(-0.08,0,0.943,0)
				local wobble2 = Instance.new("Frame",scrg)
				wobble2.Name = "wobble2"
				wobble2.BackgroundTransparency = 0.5
				wobble2.Size = UDim2.new(1.1,0,0.09,0)
				wobble2.Position = UDim2.new(-0.08,0,0.878,0)
				local Visuals = Instance.new("Frame",scrg)
				Visuals.Name = "Visuals"
				Visuals.BackgroundTransparency = 0.3
				Visuals.Size = UDim2.new(0,100,0,100)
				Visuals.Position = UDim2.new(0.462,0,0.826,0)
				local glow = Instance.new("ImageLabel",scrg)
				glow.Name = "glow"
				glow.BackgroundTransparency = 1
				glow.ImageTransparency = 0
				glow.Image = "rbxassetid://2344870656"
				glow.Size = UDim2.new(0,0,0,0)
				glow.Position = UDim2.new(0.026,0,-0.235,0)
				local Visuals2 = Instance.new("Frame",scrg)
				Visuals2.Name = "Visuals2"
				Visuals2.BackgroundTransparency = 0.3
				Visuals2.Size = UDim2.new(0,50,0,50)
				Visuals2.Position = UDim2.new(0.48,0,0.867,0)
				local TextFrame = Instance.new("TextLabel",scrg)
				TextFrame.Name = "Farmer"
				TextFrame.Font = "Arcade"
				TextFrame.Text = text
				TextFrame.TextScaled = true
				TextFrame.TextSize = 60
				TextFrame.BackgroundTransparency = 1
				TextFrame.Size = UDim2.new(0.8,0,0,42)
				TextFrame.Position = UDim2.new(0.11,0,0.867,0)
				local fvalen = 0.55
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						Swait()
						TextFrame.TextColor3 = C3(1,0,0)
						TextFrame.TextStrokeColor3 = C3(0, 0, 0)
						TextFrame.TextStrokeTransparency = 0
						TextFrame.Rotation = 0 + MRANDOM(-3, 3)
						TextFrame.Position = UDim2.new(0.11, 0 + MRANDOM(-3, 3), 0.867, 0 + MRANDOM(-3, 3))
						TextFrame.Font = Enum.Font.Fantasy
						glow.ImageColor3 = C3(0, 0, 0)
						wobble.Rotation = 0 - 2 * COS(SINE / 24)
						wobble2.Rotation = 0 - 2 * COS(SINE / 30)
						wobble2.BackgroundColor3 = C3(0,0,0)
						wobble2.BorderColor3 = C3(1,0,0)
						wobble2.BorderSizePixel = 5
						Visuals.Rotation = Visuals.Rotation + MRANDOM(-5, 5)
						Visuals2.Rotation = Visuals2.Rotation + MRANDOM(-10, 10)
						Visuals.BackgroundColor3 = C3(0,0,0)
						Visuals.BorderColor3 = C3(1,0,0)
						Visuals2.BackgroundColor3 = C3(0,0,0)
						Visuals2.BorderColor3 = C3(1,0,0)
						wobble.BackgroundColor3 = C3(0,0,0)
						wobble.BorderColor3 = C3(1,0,0)
						wobble.BorderSizePixel = 5
					end
				end))
				coroutine.resume(coroutine.create(function()
					for i = 0, 205 do
						Swait()
					end
					scrg:Destroy()
				end))
			end))
		end
	end

	function warnedpeopleB(text)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("Spinny")~= nil then
					v.PlayerGui:FindFirstChild("Spinny"):destroy()
				end
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				scrg.Name = "Spinny"
				local wobble = Instance.new("Frame",scrg)
				wobble.Name = "Wobble"
				wobble.BackgroundTransparency = 1
				wobble.Size = UDim2.new(1.1,0,1.1,0)
				wobble.Position = UDim2.new(-0.08,0,0.943,0)
				local wobble2 = Instance.new("Frame",scrg)
				wobble2.Name = "wobble2"
				wobble2.BackgroundTransparency = 1
				wobble2.Size = UDim2.new(1.1,0,0.09,0)
				wobble2.Position = UDim2.new(-0.08,0,0.878,0)
				local Visuals = Instance.new("Frame",scrg)
				Visuals.Name = "Visuals"
				Visuals.BackgroundTransparency = 1
				Visuals.Size = UDim2.new(0,100,0,100)
				Visuals.Position = UDim2.new(0.462,0,0.826,0)
				local glow = Instance.new("ImageLabel",scrg)
				glow.Name = "glow"
				glow.BackgroundTransparency = 1
				glow.ImageTransparency = 0
				glow.Image = "rbxassetid://2344870656"
				glow.Size = UDim2.new(0,0,0,0)
				glow.Position = UDim2.new(0.026,0,-0.235,0)
				local Visuals2 = Instance.new("Frame",scrg)
				Visuals2.Name = "Visuals2"
				Visuals2.BackgroundTransparency = 1
				Visuals2.Size = UDim2.new(0,50,0,50)
				Visuals2.Position = UDim2.new(0.48,0,0.867,0)
				local TextFrame = Instance.new("TextLabel",scrg)
				TextFrame.Name = "Farmer"
				TextFrame.Font = "Arcade"
				TextFrame.Text = text
				TextFrame.TextScaled = true
				TextFrame.TextSize = 60
				TextFrame.BackgroundTransparency = 1
				TextFrame.Size = UDim2.new(0.8,0,0,42)
				TextFrame.Position = UDim2.new(0.11,0,0.867,0)
				local fvalen = 0.55
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						Swait()
						TextFrame.TextColor3 = C3(1,1,1)
						TextFrame.TextStrokeColor3 = C3(0, 0, 0)
						TextFrame.TextStrokeTransparency = 0
						TextFrame.Rotation = 0 + MRANDOM(-3, 3)
						TextFrame.Position = UDim2.new(0.11, 0 + MRANDOM(-3, 3), 0.867, 0 + MRANDOM(-3, 3))
						TextFrame.Font = Enum.Font.Arcade
						glow.ImageColor3 = C3(0, 0, 0)
						wobble.Rotation = 0 - 2 * COS(SINE / 24)
						wobble2.Rotation = 0 - 2 * COS(SINE / 30)
						wobble2.BackgroundColor3 = C3(0,0,0)
						wobble2.BorderColor3 = C3(0,0,0)
						wobble2.BorderSizePixel = 0
						Visuals.Rotation = Visuals.Rotation + MRANDOM(-5, 5)
						Visuals2.Rotation = Visuals2.Rotation + MRANDOM(-10, 10)
						Visuals.BackgroundColor3 = C3(0,0,0)
						Visuals.BorderColor3 = C3(0,0,0)
						Visuals2.BackgroundColor3 = C3(0,0,0)
						Visuals2.BorderColor3 = C3(0,0,0)
						wobble.BackgroundColor3 = C3(0,0,0)
						wobble.BorderColor3 = C3(0,0,0)
						wobble.BorderSizePixel = 0
					end
				end))
				coroutine.resume(coroutine.create(function()
					for i = 0, 205 do
						Swait()
					end
					scrg:Destroy()
				end))
			end))
		end
	end


	--//=================================\\
	--||	  ASSIGN THINGS TO KEYS
	--\\=================================//

	function KeyDown(Key)
		KEYHOLD = true
		if Key == "f" and ATTACK == false then
			TOBANISH = {}
			BannedSkids = {}
			warnedpeople("In my opinion, you are free")
		end

		if Key == "e" and ATTACK == false then
			BanishBullet()
		end

		if Key == "x" and ATTACK == false then
			Slash()
		end

		if Key == "r" and ATTACK == false then
			BanBullet()
		end

		if Key == "t" and ATTACK == false then
			RespawnBullet()
		end

		if Key == "y" and ATTACK == false then
			sick.Pitch = 1
			SONG1 = 1007132288
			sick.TimePosition = 0
			Speed = 16
			Weapon.Parent = Character
			BanishMode = 666
			Jump = 50
			tecks2.Text = "Lost Friend"
		end

		if Key == "j" and ATTACK == false then
			sick.Pitch = 1
			SONG1 = 1416035124
			sick.TimePosition = 0
			Speed = 16
			Weapon.Parent = Character
			BanishMode = 555
			Jump = 50
			tecks2.Text = "Broken.."
		end

		if Key == "p" and ATTACK == false then

		end

		if Key == "u" and ATTACK == false then
			sick.Pitch = 1.25
			SONG1 = 614734751
			sick.TimePosition = 0
			Speed = 45
			Weapon.Parent = Character
			BanishMode = 3
			Jump = 50
			tecks2.Text = "C00L BANISHER"
		end

		if Key == "m" and ATTACK == false and BanishMode == 3 then
			SONG1 = 381664493
			BanishMode = 1444
			Weapon.Parent = nil
			Speed = 0
			Jump = 0
			sick.TimePosition = 0
			tecks2.Text = "Cringe"
			chatfunc("hell lol")
			wait(3)
			SONG1 = 1033438052
			BanishMode = 555
			Speed = 30
			Weapon.Parent = Character
			BanishMode = 900
			Jump = 100
			tecks2.Text = "Super meme"
		end

		if Key == "h" and ATTACK == false then
			chatfunc("Gonna relax :)")
			SONG1 = 2619399246
			sick.TimePosition = 0
			Speed = 27
			Weapon.Parent = Character
			BanishMode = 2
			Jump = 50
			tecks2.Text = "Relaxing"
		end

		if Key == "m" and ATTACK == false then
			SONG1 = 644312180
			BanishMode = 1444
			Speed = 0
			Jump = 0
			wait(1)
			chatfunc(".....")
			wait(1)
			chatfunc("Weak........")
			wait(2)
			chatfunc("Hopeless.....")
			wait(3)
			chatfunc("Broken  heart.......")
			wait(2)
			chatfunc("Hate......")
			wait(2.5)
			chatfunc("Pain....")
			wait(3)
			warnedpeople(":(")
			tecks2.Text = "g l a d u r h e r e "
			SONG1 = 1563962343
			sick.TimePosition = 0
			Speed = 27
			Jump = 150
			Weapon.Parent = Character
			BanishMode = 1555
		end

		if Key == "1" and ATTACK == false then
			SONG1 = 5347040507
			Speed = 0
			Jump = 0
			Weapon.Parent = nil
			BanishMode = nil
			game.Lighting.FogColor = Color3.fromRGB(0,0,0)
			game.Lighting.FogEnd = 0
			game.Lighting.TimeOfDay = 0
			warnedpeople("...")
			wait(4.5)
			game.Lighting.FogEnd = 100000
			game.Lighting.TimeOfDay = "14:00:00"
			SONG1 = 482886779
			BanishMode = 777
			Weapon.Parent = Character
			Speed = 25
			Jump = 75
			tecks2.Text = "go to hell skids"
		end

		if Key == "q" and ATTACK == false then
			Rush()
		end
	end

	function KeyUp(Key)
		KEYHOLD = false
	end
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

	--//=================================\\
	--\\=================================//

	function unanchor()
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA("BasePart") and c ~= RootPart then
				c.Anchored = false
			end
		end
		if UNANCHOR == true then
			RootPart.Anchored = false
		else
			RootPart.Anchored = true
		end
	end

	--//=================================\\
	--||	WRAP THE WHOLE SCRIPT UP
	--\\=================================//

	--//=================================\\
	--||          Compatibility
	--\\=================================//

	local sine = SINE
	local Sine = SINE
	local angles = ANGLES
	local RH = RightHip
	local LH = LeftHip
	local LW = LeftShoulder
	local RW = RightShoulder
	local head = Head
	local RootCF = ROOTC0
	local necko = NECKC0
	local NK = Neck
	local RJ = RootJoint
	local LS = LeftShoulder
	local RS = RightShoulder
	local clerp = Clerp
	local LSC0 = LS.C0
	local RSC0 = RS.C0
	local NKC0 = NK.C0
	local LHC0 = LH.C0
	local RHC0 = RH.C0
	local RJC0 = RJ.C0
	local CFA = CFrame.Angles
	local CFN = CFrame.new

	--//=================================\\
	--\\=================================//

	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)

	local clerp = Clerp

	while true do
		Swait()
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		if Character:FindFirstChild("Safety") == nil then
			local Safety = IT("Script")
			Safety.Name = "Safety"
			Safety.Parent = Character
		end
		for T = 1, #TAIL do
			if TAIL[T] ~= nil then
				TAIL[T].C1 = Clerp(TAIL[T].C1, CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(3.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			end
		end
		SINE = SINE + CHANGE
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		if lplr == Player then
			TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
			TORSOVERTICALVELOCITY = RootPart.Velocity.y
		end
		Player_Size = 1
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
		if ANIM == "Walk" and TORSOVELOCITY > 1 then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		end
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 * Player_Size, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			ANIM = "Idle"
			if ATTACK == false and BanishMode == 1 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(45)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(3), RAD(0)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-50), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 3 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.15 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(45)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-45)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0+ 0.15 * COS(SINE / 12), -0.2) * ANGLES(RAD(150), RAD(35), RAD(-5)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0 + 0.15 * COS(SINE / 12), -0.2) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.15 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-76), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 2 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0+0.5*COS(SINE / 15) , 0+0.5*COS(SINE / 14) , 0+0.5*COS(SINE / 16)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.35 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.35 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.6, 0.5, -0.3) * ANGLES(RAD(120), RAD(0), RAD(-70))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.6, 0.5, -0.3) * ANGLES(RAD(60), RAD(0), RAD(70)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -1) * ANGLES(RAD(90), RAD(-20), RAD(-70)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 666 then
				RightHip.C0=Clerp(RightHip.C0,cf(1,-1 - 0.1 * math.cos(SINE / 32),0)*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(-10 - 2.5 * math.cos(SINE / 32)),math.rad(-20),math.rad(0)),.1)
				LeftHip.C0=Clerp(LeftHip.C0,cf(-1,-1 - 0.1 * math.cos(SINE / 32),0)*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(0),math.rad(0),math.rad(-10 + 2.5 * math.cos(SINE / 32))),.1)
				RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*cf(0,0,0 + 0.1 * math.cos(SINE / 32))*ANGLES(math.rad(10 - 2 * math.cos(SINE / 32)),math.rad(0),math.rad(20)),.1)
				Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*ANGLES(math.rad(55),math.rad(0),math.rad(0)),.1)
				RightShoulder.C0=Clerp(RightShoulder.C0,cf(0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(SINE / 28))),.1)
				LeftShoulder.C0=Clerp(LeftShoulder.C0,cf(-0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(SINE / 28))),.1)
			elseif ATTACK == false and BanishMode == 777 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(0), RAD(-100)) * ANGLES(RAD(20), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 555 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.1, 1 + 0.5 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(2.5), RAD(0), RAD(21 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed) 
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(100 + 2 * COS(SINE / 12)), RAD(0), RAD(15 + 3 * COS(SINE / 12) - 3 * SIN(SINE / 12))) *               ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(-3.5), RAD(-25 + 5 * COS(SINE / 12))) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(-20 + 1 * COS(SINE / 18)), RAD(0), RAD(-80)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.7) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(-35 + 1 * COS(SINE / 18)), RAD(0), RAD(80)), 1 / Animation_Speed)
				if MRANDOM(1,32) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000,100000)), RAD(MRANDOM(-99999,99999)), RAD(MRANDOM(-200,48375935))), 1 / Animation_Speed) 
				end
				if MRANDOM(1,20) == 1 then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90,90)), RAD(MRANDOM(-30,30)), RAD(MRANDOM(-50,50)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-900,900)), RAD(MRANDOM(-20,20)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end
			elseif ATTACK == false and BanishMode == 1444 then
				RightHip.C0= Clerp(RightHip.C0,CF(1,0.35 - 0.05 * math.cos(SINE / 32),-0.7)*ANGLES(math.rad(-20),math.rad(75),math.rad(0))*ANGLES(math.rad(-3),math.rad(0 - 1 * math.cos(SINE / 56)),math.rad(25 - 2 * math.cos(SINE / 32))),.1)
				LeftHip.C0= Clerp(LeftHip.C0,CF(-1,-1.125 - 0.05 * math.cos(SINE / 32),-0.6)*ANGLES(math.rad(-105),math.rad(-75),math.rad(0))*ANGLES(math.rad(-3),math.rad(0 - 1 * math.cos(SINE / 56)),math.rad(-25 + 2 * math.cos(SINE / 32))),.1)
				RootJoint.C0= Clerp(RootJoint.C0,ROOTC0*CF(0,0,-1.3 + 0.05 * math.cos(SINE / 32))*ANGLES(math.rad(7.5 - 2 * math.cos(SINE / 32)),math.rad(0),math.rad(0)),.1)
				Neck.C0= Clerp(Neck.C0,NECKC0*ANGLES(math.rad(25 - 2 * math.cos(SINE / 37)),math.rad(0 + 1 * math.cos(SINE / 58)),math.rad(0 + 2 * math.cos(SINE / 53))),.1)
				RightShoulder.C0= Clerp(RightShoulder.C0,CF(1.35,0.5 + 0.025 * math.cos(SINE / 45),0)*ANGLES(math.rad(165 + 5 * math.cos(SINE / 74)),math.rad(1 - 3 * math.cos(SINE / 53)),math.rad(-15 + 3 * math.cos(SINE / 45))),.1)
				LeftShoulder.C0= Clerp(LeftShoulder.C0,CF(-1.35,0.5 + 0.025 * math.cos(SINE / 45),0)*ANGLES(math.rad(165 - 3 * math.cos(SINE / 73)),math.rad(2 - 1 * math.cos(SINE / 55)),math.rad(15 - 3 * math.cos(SINE / 45))),.1)
			elseif ATTACK == false and BanishMode == 1555 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5 - 2.5 * COS(SINE / 12)), RAD(0), RAD(-45)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.5 + 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(100), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(15), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-50), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 900 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(1,360)), RAD(MRANDOM(1,360)), RAD(MRANDOM(1,360))), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-899 * COS(SINE / WALKSPEEDVALUE)), RAD(-899 * COS(SINE / WALKSPEEDVALUE)), RAD(-899 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -0.5) * ANGLES(RAD(-891231239 * COS(SINE / WALKSPEEDVALUE)), RAD(-89123129 * COS(SINE / WALKSPEEDVALUE)), RAD(-891232139 * COS(SINE / WALKSPEEDVALUE)))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-891232139 * COS(SINE / WALKSPEEDVALUE)), RAD(-891231239 * COS(SINE / WALKSPEEDVALUE)), RAD(-81232199 * COS(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-899 * COS(SINE / WALKSPEEDVALUE)), RAD(-89123129 * COS(SINE / WALKSPEEDVALUE)), RAD(-891239 * COS(SINE / WALKSPEEDVALUE))) * ANGLES(RAD(-13221899 * COS(SINE / WALKSPEEDVALUE)), RAD(-89132319 * COS(SINE / WALKSPEEDVALUE)), RAD(-8912329 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-899 * COS(SINE / WALKSPEEDVALUE)), RAD(-89123129 * COS(SINE / WALKSPEEDVALUE)), RAD(-8312399 * COS(SINE / WALKSPEEDVALUE))) * ANGLES(RAD(-891239 * COS(SINE / WALKSPEEDVALUE)), RAD(-891239 * COS(SINE / WALKSPEEDVALUE)), RAD(-812399 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 324 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil and Rooted == false then
			ANIM = "Walk"
			if ATTACK == false and BanishMode == 1 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 3 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5 + 2.5 * COS(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(-15)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(-15 + 3 * COS(SINE / (WALKSPEEDVALUE / 2))), RAD(15)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, -0.25, 0.2) * ANGLES(RAD(170), RAD(15), RAD(5)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 - 0.15 * COS(SINE / (WALKSPEEDVALUE / 2)), 0 + 0.1 * COS(SINE / (WALKSPEEDVALUE))) * ANGLES(RAD(-5 * SIN(SINE / 12)), RAD(15 * SIN(SINE / (WALKSPEEDVALUE))), RAD(-25 - 5.5 * SIN(SINE / (WALKSPEEDVALUE)))) * LEFTSHOULDERC0, 2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(95), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-74), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 2 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(0), RAD(0), RAD(-15 * COS(SINE / (WALKSPEEDVALUE)))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(10 * COS(SINE / (WALKSPEEDVALUE)))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(100 + 2 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(70 * SIN(SINE / WALKSPEEDVALUE)), RAD(5), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 2 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 666 then
				RightHip.C0=Clerp(RightHip.C0,cf(1,-0.85,-0.15 - 0.15 * math.cos(SINE / 8))*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(0),math.rad(0 + 5 * math.cos(SINE / 12)),math.rad(5 + 25 * math.cos(SINE / 12))),.1)
				LeftHip.C0=Clerp(LeftHip.C0,cf(-1,-0.85,-0.15 + 0.15 * math.cos(SINE / 8))*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(0),math.rad(0 + 5 * math.cos(SINE / 12)),math.rad(-5 + 25 * math.cos(SINE / 12))),.1)
				RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*cf(0,0,-0.15 - 0.1 * math.cos(SINE / 8))*ANGLES(math.rad(12.5),math.rad(0),math.rad(0 - 5 * math.cos(SINE / 12))),.1)
				Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*ANGLES(math.rad(30 - 5 * math.cos(SINE / 0.5265)),math.rad(0 - 5 * math.cos(SINE / 0.25)),math.rad(0 - 5 * math.cos(SINE / 0.465))),.1)
				RightShoulder.C0=Clerp(RightShoulder.C0,cf(0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(SINE / 28))),.1)
				LeftShoulder.C0=Clerp(LeftShoulder.C0,cf(-0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(SINE / 28))),.1)
			elseif ATTACK == false and BanishMode == 777 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 555 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.15 * COS(SINE / 47), -0.5, 0.5 + 0.1 * COS(SINE / 28)) * ANGLES(RAD(70), RAD(0 - RootPart.RotVelocity.Y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), .2 / 3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-17 - 5 * COS(SINE / 52)), RAD(0 - 3 * COS(SINE / 37)), RAD(0 + 2 * COS(SINE / 78))), .2 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 4 * COS(SINE / 59)), RAD(-20 + 7 * COS(SINE / 62)), RAD(20 + 5 * COS(SINE / 50)))* RIGHTSHOULDERC0, .2 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.1 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 3 * COS(SINE / 55)), RAD(20 + 8 * COS(SINE / 67)), RAD(-20 - 4 * COS(SINE / 29))) * LEFTSHOULDERC0, .2 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -0.5, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(1.5), RAD(0), RAD(-20 - 5 * COS(SINE / 34))), .2 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(1), RAD(0), RAD(20 + 2 * COS(SINE / 38))), .2 / 3)
			elseif ATTACK == false and BanishMode == 1555 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE))), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 - 0.1 * COS(SINE / 3) + ((1) - 1)) * ANGLES(RAD(30 - 2.5 * SIN(SINE / 12)), RAD(7 * COS(SINE / 24)), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.5 + 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(100), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5 * SIN(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 900 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(1,360)), RAD(MRANDOM(1,360)), RAD(MRANDOM(1,360))), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-899 * COS(SINE / WALKSPEEDVALUE)), RAD(-899 * COS(SINE / WALKSPEEDVALUE)), RAD(-899 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -0.5) * ANGLES(RAD(-891231239 * COS(SINE / WALKSPEEDVALUE)), RAD(-89123129 * COS(SINE / WALKSPEEDVALUE)), RAD(-891232139 * COS(SINE / WALKSPEEDVALUE)))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-891232139 * COS(SINE / WALKSPEEDVALUE)), RAD(-891231239 * COS(SINE / WALKSPEEDVALUE)), RAD(-81232199 * COS(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-899 * COS(SINE / WALKSPEEDVALUE)), RAD(-89123129 * COS(SINE / WALKSPEEDVALUE)), RAD(-891239 * COS(SINE / WALKSPEEDVALUE))) * ANGLES(RAD(-13221899 * COS(SINE / WALKSPEEDVALUE)), RAD(-89132319 * COS(SINE / WALKSPEEDVALUE)), RAD(-8912329 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-899 * COS(SINE / WALKSPEEDVALUE)), RAD(-89123129 * COS(SINE / WALKSPEEDVALUE)), RAD(-8312399 * COS(SINE / WALKSPEEDVALUE))) * ANGLES(RAD(-891239 * COS(SINE / WALKSPEEDVALUE)), RAD(-891239 * COS(SINE / WALKSPEEDVALUE)), RAD(-812399 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
			elseif ATTACK == false and BanishMode == 324 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, -0.1*SIZE) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(15 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 1/ Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / WALKSPEEDVALUE)), RAD(-55 + 2.5 * SIN(SINE / WALKSPEEDVALUE))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / WALKSPEEDVALUE)), RAD(55 - 2.5 * SIN(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
			end
		end
		unanchor()
		for _, c in pairs(HornFolder:GetChildren()) do
			c.Color = C3(0,0,0)
		end
		for _, c in pairs(faceShadingFolder:GetChildren()) do
			c.Color = C3(0,0,0)
			c.Transparency = 1
		end
		for i, v in pairs(NeonParts) do
			v.Color = BrickColor.Black().Color
		end
		for i, v in pairs(ArmourParts) do
			v.Color = C3(0,0,0)
		end
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA('CharacterMesh') then
				c:Destroy()
			end
		end
		Humanoid.MaxHealth = math.huge
		Humanoid.Health = math.huge
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		sick.SoundId = "rbxassetid://"..SONG1
		sick.Looped = true
		Humanoid.Name = "Humanoid"
		Humanoid.JumpPower = Jump
		Humanoid.UseJumpPower = true
		Head.Parent = Character
		Torso.Parent = Character
		RightArm.Parent = Character
		LeftArm.Parent = Character
		LeftLeg.Parent = Character
		RightLeg.Parent = Character
		Head.Locked = true
		Torso.Locked = true
		RightArm.Locked = true
		LeftArm.Locked = true
		LeftLeg.Locked = true
		RightLeg.Locked = true
		Shield.Locked = true
	end

	local function CheckForBan(player)
		for i = 1, #BannedSkids do
			if player.Name == BannedSkids[i] then
				player:Kick()
			end
		end
	end

	game.Players.PlayerAdded:connect(function()
		for i,v in pairs(game.Players:GetPlayers())do
			CheckForBan(v)
		end  
	end)


	--//=================================\\
	--\\=================================//



	BrickColor.new("Green")

	--//====================================================\\--
	--||			  		 END OF SCRIPT
	--\\====================================================//--

end)

UnderlineButton_19.Name = "UnderlineButton"
UnderlineButton_19.Parent = Button_19
UnderlineButton_19.BackgroundColor3 = Color3.fromRGB(255, 170, 127)
UnderlineButton_19.BorderSizePixel = 0
UnderlineButton_19.Position = UDim2.new(0, 0, 1, 0)
UnderlineButton_19.Size = UDim2.new(1, 0, 0, 1)

Home.Name = "Home"
Home.Parent = FrameHolder
Home.Active = true
Home.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
Home.BackgroundTransparency = 1.000
Home.BorderSizePixel = 0
Home.Size = UDim2.new(0, 400, 0, 220)
Home.ZIndex = 2

Title2.Name = "Title2"
Title2.Parent = Home
Title2.AnchorPoint = Vector2.new(0.5, 0.5)
Title2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title2.BackgroundTransparency = 1.000
Title2.Position = UDim2.new(0.5, 0, 0.322727263, 0)
Title2.Size = UDim2.new(0, 147, 0, 50)
Title2.Font = Enum.Font.GothamSemibold
Title2.Text = "       SEX"
Title2.TextColor3 = Color3.fromRGB(255, 255, 255)
Title2.TextSize = 18.000
Title2.TextXAlignment = Enum.TextXAlignment.Left

HUB2.Name = "HUB2"
HUB2.Parent = Title2
HUB2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
HUB2.BackgroundTransparency = 1.000
HUB2.Position = UDim2.new(0.389635593, 0, 0.239999995, 0)
HUB2.Selectable = true
HUB2.Size = UDim2.new(0, 78, 0, 26)
HUB2.Font = Enum.Font.GothamSemibold
HUB2.Text = "HUB"
HUB2.TextColor3 = Color3.fromRGB(255, 170, 127)
HUB2.TextSize = 18.000

FEVer1.Name = "FEVer1"
FEVer1.Parent = Title2
FEVer1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
FEVer1.BackgroundTransparency = 1.000
FEVer1.Position = UDim2.new(0, 0, 0.884616077, 0)
FEVer1.Size = UDim2.new(0, 148, 0, 48)
FEVer1.Font = Enum.Font.Gotham
FEVer1.Text = "FE Version"
FEVer1.TextColor3 = Color3.fromRGB(255, 255, 255)
FEVer1.TextSize = 14.000

FEVer1_2.Name = "FEVer1"
FEVer1_2.Parent = Title2
FEVer1_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
FEVer1_2.BackgroundTransparency = 1.000
FEVer1_2.Position = UDim2.new(-0.860544205, 0, 2.84461641, 0)
FEVer1_2.Size = UDim2.new(0, 245, 0, 31)
FEVer1_2.Font = Enum.Font.Gotham
FEVer1_2.Text = "  Welcome, "..game.Players.LocalPlayer.Name
FEVer1_2.TextColor3 = Color3.fromRGB(255, 255, 255)
FEVer1_2.TextSize = 14.000
FEVer1_2.TextXAlignment = Enum.TextXAlignment.Left

Credits_2.Name = "Credits"
Credits_2.Parent = FrameHolder
Credits_2.Active = true
Credits_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Credits_2.BackgroundTransparency = 1.000
Credits_2.BorderSizePixel = 0
Credits_2.ClipsDescendants = true
Credits_2.Position = UDim2.new(-0, 0, -1, 0)
Credits_2.Selectable = true
Credits_2.Size = UDim2.new(0, 400, 0, 220)

TextLabel.Parent = Credits_2
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.Position = UDim2.new(0.195718661, 0, 0.098825179, 0)
TextLabel.Size = UDim2.new(0, 200, 0, 13)
TextLabel.Font = Enum.Font.Gotham
TextLabel.Text = "CREDITS"
TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.TextSize = 20.000

TextLabel_2.Parent = Credits_2
TextLabel_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_2.BackgroundTransparency = 1.000
TextLabel_2.Position = UDim2.new(0.195718661, 0, 0.22758621, 0)
TextLabel_2.Size = UDim2.new(0, 200, 0, 33)
TextLabel_2.Font = Enum.Font.Gotham
TextLabel_2.Text = "Blurry : Founder of Sex Hub"
TextLabel_2.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_2.TextSize = 15.000

TextLabel_3.Parent = Credits_2
TextLabel_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_3.BackgroundTransparency = 1.000
TextLabel_3.Position = UDim2.new(0.195718661, 0, 0.395455509, 0)
TextLabel_3.Size = UDim2.new(0, 200, 0, 33)
TextLabel_3.Font = Enum.Font.Gotham
TextLabel_3.Text = "Destroid : Co-founder of Sex Hub"
TextLabel_3.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_3.TextSize = 15.000

TextLabel_4.Parent = Credits_2
TextLabel_4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_4.BackgroundTransparency = 1.000
TextLabel_4.Position = UDim2.new(0.195718661, 0, 0.56332463, 0)
TextLabel_4.Size = UDim2.new(0, 200, 0, 33)
TextLabel_4.Font = Enum.Font.Gotham
TextLabel_4.Text = "Comic : Epic Helper"
TextLabel_4.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_4.TextSize = 15.000

TextLabel_5.Parent = Credits_2
TextLabel_5.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_5.BackgroundTransparency = 1.000
TextLabel_5.Position = UDim2.new(0.195718661, 0, 0.720002294, 0)
TextLabel_5.Size = UDim2.new(0, 200, 0, 33)
TextLabel_5.Font = Enum.Font.Gotham
TextLabel_5.Text = "Typical : Cool guy"
TextLabel_5.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_5.TextSize = 15.000

-- Scripts:

local function BWEJUSN_fake_script() -- Main.Dragify 
	local script = Instance.new('LocalScript', Main)

	local UIS = game:GetService("UserInputService")
	function dragify(Frame)
		dragToggle = nil
		local dragSpeed = 0
		dragInput = nil
		dragStart = nil
		local dragPos = nil
		function updateInput(input)
			local Delta = input.Position - dragStart
			local Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
			game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.25), {Position = Position}):Play()
		end
		Frame.InputBegan:Connect(function(input)
			if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then
				dragToggle = true
				dragStart = input.Position
				startPos = Frame.Position
				input.Changed:Connect(function()
					if input.UserInputState == Enum.UserInputState.End then
						dragToggle = false
					end
				end)
			end
		end)
		Frame.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
				dragInput = input
			end
		end)
		game:GetService("UserInputService").InputChanged:Connect(function(input)
			if input == dragInput and dragToggle then
				updateInput(input)
			end
		end)
	end

	dragify(script.Parent)
end
coroutine.wrap(BWEJUSN_fake_script)()
